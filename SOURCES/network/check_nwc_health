#! /usr/bin/perl -w
# nagios: -epn

package Monitoring::GLPlugin::Commandline::Extraopts;
use strict;
use File::Basename;
use strict;

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    file => $params{file},
    commandline => $params{commandline},
    config => {},
    section => 'default_no_section',
  };
  bless $self, $class;
  $self->prepare_file_and_section();
  $self->init();
  return $self;
}

sub prepare_file_and_section {
  my $self = shift;
  if (! defined $self->{file}) {
    # ./check_stuff --extra-opts
    $self->{section} = basename($0);
    $self->{file} = $self->get_default_file();
  } elsif ($self->{file} =~ /^[^@]+$/) {
    # ./check_stuff --extra-opts=special_opts
    $self->{section} = $self->{file};
    $self->{file} = $self->get_default_file();
  } elsif ($self->{file} =~ /^@(.*)/) {
    # ./check_stuff --extra-opts=@/etc/myconfig.ini
    $self->{section} = basename($0);
    $self->{file} = $1;
  } elsif ($self->{file} =~ /^(.*?)@(.*)/) {
    # ./check_stuff --extra-opts=special_opts@/etc/myconfig.ini
    $self->{section} = $1;
    $self->{file} = $2;
  }
}

sub get_default_file {
  my $self = shift;
  foreach my $default (qw(/etc/nagios/plugins.ini
      /usr/local/nagios/etc/plugins.ini
      /usr/local/etc/nagios/plugins.ini
      /etc/opt/nagios/plugins.ini
      /etc/nagios-plugins.ini
      /usr/local/etc/nagios-plugins.ini
      /etc/opt/nagios-plugins.ini)) {
    if (-f $default) {
      return $default;
    }
  }
  return undef;
}

sub init {
  my $self = shift;
  if (! defined $self->{file}) {
    $self->{errors} = sprintf 'no extra-opts file specified and no default file found';
  } elsif (! -f $self->{file}) {
    $self->{errors} = sprintf 'could not open %s', $self->{file};
  } else {
    my $data = do { local (@ARGV, $/) = $self->{file}; <> };
    my $in_section = 'default_no_section';
    foreach my $line (split(/\n/, $data)) {
      if ($line =~ /\[(.*)\]/) {
        $in_section = $1;
      } elsif ($line =~ /(.*?)\s*=\s*(.*)/) {
        $self->{config}->{$in_section}->{$1} = $2;
      }
    }
  }
}

sub is_valid {
  my $self = shift;
  return ! exists $self->{errors};
}

sub overwrite {
  my $self = shift;
  if (scalar(keys %{$self->{config}->{default_no_section}}) > 0) {
    foreach (keys %{$self->{config}->{default_no_section}}) {
      $self->{commandline}->{$_} = $self->{config}->{default_no_section}->{$_};
    }
  }
  if (exists $self->{config}->{$self->{section}}) {
    foreach (keys %{$self->{config}->{$self->{section}}}) {
      $self->{commandline}->{$_} = $self->{config}->{$self->{section}}->{$_};
    }
  }
}

sub errors {
  my $self = shift;
  return $self->{errors} || "";
}



package Monitoring::GLPlugin::Commandline::Getopt;
use strict;
use File::Basename;
use Getopt::Long qw(:config no_ignore_case bundling);

# Standard defaults
my %DEFAULT = (
  timeout => 15,
  verbose => 0,
  license =>
"This monitoring plugin is free software, and comes with ABSOLUTELY NO WARRANTY.
It may be used, redistributed and/or modified under the terms of the GNU
General Public Licence (see http://www.fsf.org/licensing/licenses/gpl.txt).",
);
# Standard arguments
my @ARGS = ({
    spec => 'usage|?',
    help => "-?, --usage\n   Print usage information",
  }, {
    spec => 'help|h',
    help => "-h, --help\n   Print detailed help screen",
  }, {
    spec => 'version|V',
    help => "-V, --version\n   Print version information",
  }, {
    #spec => 'extra-opts:s@',
    #help => "--extra-opts=[<section>[@<config_file>]]\n   Section and/or config_file from which to load extra options (may repeat)",
  }, {
    spec => 'timeout|t=i',
    help => sprintf("-t, --timeout=INTEGER\n   Seconds before plugin times out (default: %s)", $DEFAULT{timeout}),
    default => $DEFAULT{timeout},
  }, {
    spec => 'verbose|v+',
    help => "-v, --verbose\n   Show details for command-line debugging (can repeat up to 3 times)",
    default => $DEFAULT{verbose},
  },
);
# Standard arguments we traditionally display last in the help output
my %DEFER_ARGS = map { $_ => 1 } qw(timeout verbose);

sub _init {
  my ($self, %params) = @_;
  # Check params
  my %attr = (
    usage => 1,
    version => 0,
    url => 0,
    plugin => { default => $Monitoring::GLPlugin::pluginname },
    blurb => 0,
    extra => 0,
    'extra-opts' => 0,
    license => { default => $DEFAULT{license} },
    timeout => { default => $DEFAULT{timeout} },
  );

  # Add attr to private _attr hash (except timeout)
  $self->{timeout} = delete $attr{timeout};
  $self->{_attr} = { %attr };
  foreach (keys %{$self->{_attr}}) {
    if (exists $params{$_}) {
      $self->{_attr}->{$_} = $params{$_};
    } else {
      $self->{_attr}->{$_} = $self->{_attr}->{$_}->{default}
          if ref ($self->{_attr}->{$_}) eq 'HASH' &&
              exists $self->{_attr}->{$_}->{default};
    }
  }
  # Chomp _attr values
  chomp foreach values %{$self->{_attr}};

  # Setup initial args list
  $self->{_args} = [ grep { exists $_->{spec} } @ARGS ];

  $self
}

sub new {
  my ($class, @params) = @_;
  require Monitoring::GLPlugin::Commandline::Extraopts
      if ! grep /BEGIN/, keys %Monitoring::GLPlugin::Commandline::Extraopts::;
  my $self = bless {}, $class;
  $self->_init(@params);
}

sub add_arg {
  my ($self, %arg) = @_;
  push (@{$self->{_args}}, \%arg);
}

sub mod_arg {
  my ($self, $argname, %arg) = @_;
  foreach my $old_arg (@{$self->{_args}}) {
    next unless $old_arg->{spec} =~ /(\w+).*/ && $argname eq $1;
    foreach my $key (keys %arg) {
      $old_arg->{$key} = $arg{$key};
    }
  }
}

sub getopts {
  my ($self) = @_;
  my %commandline = ();
  $self->{opts}->{all_my_opts} = {};
  my @params = map { $_->{spec} } @{$self->{_args}};
  if (! GetOptions(\%commandline, @params)) {
    $self->print_help();
    exit 3;
  } else {
    no strict 'refs';
    no warnings 'redefine';
    if (exists $commandline{'extra-opts'}) {
      # read the extra file and overwrite other parameters
      my $extras = Monitoring::GLPlugin::Commandline::Extraopts->new(
          file => $commandline{'extra-opts'},
          commandline => \%commandline
      );
      if (! $extras->is_valid()) {
        printf "UNKNOWN - extra-opts are not valid: %s\n", $extras->errors();
        exit 3;
      } else {
        $extras->overwrite();
      }
    }
    do { $self->print_help(); exit 0; } if $commandline{help};
    do { $self->print_version(); exit 0 } if $commandline{version};
    do { $self->print_usage(); exit 3 } if $commandline{usage};
    foreach (map { $_->{spec} =~ /^([\w\-]+)/; $1; } @{$self->{_args}}) {
      my $field = $_;
      *{"$field"} = sub {
        return $self->{opts}->{$field};
      };
    }
    *{"all_my_opts"} = sub {
      return $self->{opts}->{all_my_opts};
    };
    foreach (map { $_->{spec} =~ /^([\w\-]+)/; $1; }
        grep { exists $_->{required} && $_->{required} } @{$self->{_args}}) {
      do { $self->print_usage(); exit 3 } if ! exists $commandline{$_};
    }
    foreach (grep { exists $_->{default} } @{$self->{_args}}) {
      $_->{spec} =~ /^([\w\-]+)/;
      my $spec = $1;
      $self->{opts}->{$spec} = $_->{default};
    }
    foreach (keys %commandline) {
      $self->{opts}->{$_} = $commandline{$_};
      $self->{opts}->{all_my_opts}->{$_} = $commandline{$_};
    }
    foreach (grep { exists $_->{env} } @{$self->{_args}}) {
      $_->{spec} =~ /^([\w\-]+)/;
      my $spec = $1;
      if (exists $ENV{'NAGIOS__HOST'.$_->{env}}) {
        $self->{opts}->{$spec} = $ENV{'NAGIOS__HOST'.$_->{env}};
      }
      if (exists $ENV{'NAGIOS__SERVICE'.$_->{env}}) {
        $self->{opts}->{$spec} = $ENV{'NAGIOS__SERVICE'.$_->{env}};
      }
    }
    foreach (grep { exists $_->{aliasfor} } @{$self->{_args}}) {
      my $field = $_->{aliasfor};
      $_->{spec} =~ /^([\w\-]+)/;
      my $aliasfield = $1;
      next if $self->{opts}->{$field};
      *{"$field"} = sub {
        return $self->{opts}->{$aliasfield};
      };
    }
  }
}

sub create_opt {
  my ($self, $key) = @_;
  no strict 'refs';
  *{"$key"} = sub {
      return $self->{opts}->{$key};
  };
}

sub override_opt {
  my ($self, $key, $value) = @_;
  $self->{opts}->{$key} = $value;
}

sub get {
  my ($self, $opt) = @_;
  return $self->{opts}->{$opt};
}

sub print_help {
  my ($self) = @_;
  $self->print_version();
  printf "\n%s\n", $self->{_attr}->{license};
  printf "\n%s\n\n", $self->{_attr}->{blurb};
  $self->print_usage();
  foreach (grep {
      ! (exists $_->{hidden} && $_->{hidden}) 
  } @{$self->{_args}}) {
    printf " %s\n", $_->{help};
  }
}

sub print_usage {
  my ($self) = @_;
  printf $self->{_attr}->{usage}, $self->{_attr}->{plugin};
  print "\n";
}

sub print_version {
  my ($self) = @_;
  printf "%s %s", $self->{_attr}->{plugin}, $self->{_attr}->{version};
  printf " [%s]", $self->{_attr}->{url} if $self->{_attr}->{url};
  print "\n";
}

sub print_license {
  my ($self) = @_;
  printf "%s\n", $self->{_attr}->{license};
  print "\n";
}



package Monitoring::GLPlugin::Commandline;
use strict;
use IO::File;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3, DEPENDENT => 4 };
our %ERRORS = (
    'OK'        => OK,
    'WARNING'   => WARNING,
    'CRITICAL'  => CRITICAL,
    'UNKNOWN'   => UNKNOWN,
    'DEPENDENT' => DEPENDENT,
);

our %STATUS_TEXT = reverse %ERRORS;
our $AUTOLOAD;


sub new {
  my ($class, %params) = @_;
  require Monitoring::GLPlugin::Commandline::Getopt
      if ! grep /BEGIN/, keys %Monitoring::GLPlugin::Commandline::Getopt::;
  my $self = {
       perfdata => [],
       messages => {
         ok => [],
         warning => [],
         critical => [],
         unknown => [],
       },
       args => [],
       opts => Monitoring::GLPlugin::Commandline::Getopt->new(%params),
       modes => [],
       statefilesdir => undef,
  };
  foreach (qw(shortname usage version url plugin blurb extra
      license timeout)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  $self->{plugin} ||= $Monitoring::GLPlugin::pluginname;
  $self->{name} = $self->{plugin};
  $Monitoring::GLPlugin::plugin = $self;
}

sub AUTOLOAD {
  my ($self, @params) = @_;
  return if ($AUTOLOAD =~ /DESTROY/);
  $self->debug("AUTOLOAD %s\n", $AUTOLOAD)
        if $self->{opts}->verbose >= 2;
  if ($AUTOLOAD =~ /^.*::(add_arg|override_opt|create_opt)$/) {
    $self->{opts}->$1(@params);
  }
}

sub DESTROY {
  my ($self) = @_;
  # ohne dieses DESTROY rennt nagios_exit in obiges AUTOLOAD rein
  # und fliegt aufs Maul, weil {opts} bereits nicht mehr existiert.
  # Unerklaerliches Verhalten.
}

sub debug {
  my ($self, $format, @message) = @_;
  my $tracefile = "/tmp/".$Monitoring::GLPlugin::pluginname.".trace";
  $self->{trace} = -f $tracefile ? 1 : 0;
  if ($self->opts->verbose && $self->opts->verbose > 10) {
    printf("%s: ", scalar localtime);
    printf($format, @message);
    printf "\n";
  }
  if ($self->{trace}) {
    my $logfh = IO::File->new();
    $logfh->autoflush(1);
    if ($logfh->open($tracefile, "a")) {
      $logfh->printf("%s: ", scalar localtime);
      $logfh->printf($format, @message);
      $logfh->printf("\n");
      $logfh->close();
    }
  }
}

sub opts {
  my ($self) = @_;
  return $self->{opts};
}

sub getopts {
  my ($self) = @_;
  $self->opts->getopts();
}

sub add_message {
  my ($self, $code, @messages) = @_;
  $code = (qw(ok warning critical unknown))[$code] if $code =~ /^\d+$/;
  $code = lc $code;
  push @{$self->{messages}->{$code}}, @messages;
}

sub selected_perfdata {
  my ($self, $label) = @_;
  if ($self->opts->can("selectedperfdata") && $self->opts->selectedperfdata) {
    my $pattern = $self->opts->selectedperfdata;
    return ($label =~ /$pattern/i) ? 1 : 0;
  } else {
    return 1;
  }
}

sub add_perfdata {
  my ($self, %args) = @_;
#printf "add_perfdata %s\n", Data::Dumper::Dumper(\%args);
#printf "add_perfdata %s\n", Data::Dumper::Dumper($self->{thresholds});
#
# wenn warning, critical, dann wird von oben ein expliziter wert mitgegeben
# wenn thresholds
#  wenn label in 
#    warningx $self->{thresholds}->{$label}->{warning} existiert
#  dann nimm $self->{thresholds}->{$label}->{warning}
#  ansonsten thresholds->default->warning
#

  my $label = $args{label};
  my $value = $args{value};
  my $uom = $args{uom} || "";
  my $format = '%d';

  if ($self->opts->can("morphperfdata") && $self->opts->morphperfdata) {
    # 'Intel [R] Interface (\d+) usage'='nic$1'
    foreach my $key (keys %{$self->opts->morphperfdata}) {
      if ($label =~ /$key/) {
        my $replacement = '"'.$self->opts->morphperfdata->{$key}.'"';
        my $oldlabel = $label;
        $label =~ s/$key/$replacement/ee;
        if (exists $self->{thresholds}->{$oldlabel}) {
          %{$self->{thresholds}->{$label}} = %{$self->{thresholds}->{$oldlabel}};
        }
      }
    }
  }
  if ($value =~ /\./) {
    if (defined $args{places}) {
      $value = sprintf '%.'.$args{places}.'f', $value;
    } else {
      $value = sprintf "%.2f", $value;
    }
  } else {
    $value = sprintf "%d", $value;
  }
  my $warn = "";
  my $crit = "";
  my $min = defined $args{min} ? $args{min} : "";
  my $max = defined $args{max} ? $args{max} : "";
  if ($args{thresholds} || (! exists $args{warning} && ! exists $args{critical})) {
    if (exists $self->{thresholds}->{$label}->{warning}) {
      $warn = $self->{thresholds}->{$label}->{warning};
    } elsif (exists $self->{thresholds}->{default}->{warning}) {
      $warn = $self->{thresholds}->{default}->{warning};
    }
    if (exists $self->{thresholds}->{$label}->{critical}) {
      $crit = $self->{thresholds}->{$label}->{critical};
    } elsif (exists $self->{thresholds}->{default}->{critical}) {
      $crit = $self->{thresholds}->{default}->{critical};
    }
  } else {
    if ($args{warning}) {
      $warn = $args{warning};
    }
    if ($args{critical}) {
      $crit = $args{critical};
    }
  }
  if ($uom eq "%") {
    $min = 0;
    $max = 100;
  }
  if (defined $args{places}) {
    # cut off excessive decimals which may be the result of a division
    # length = places*2, no trailing zeroes
    if ($warn ne "") {
      $warn = join("", map {
          s/\.0+$//; $_
      } map {
          s/(\.[1-9]+)0+$/$1/; $_
      } map {
          /[\+\-\d\.]+/ ? sprintf '%.'.2*$args{places}.'f', $_ : $_;
      } split(/([\+\-\d\.]+)/, $warn));
    }
    if ($crit ne "") {
      $crit = join("", map {
          s/\.0+$//; $_
      } map {
          s/(\.[1-9]+)0+$/$1/; $_
      } map {
          /[\+\-\d\.]+/ ? sprintf '%.'.2*$args{places}.'f', $_ : $_;
      } split(/([\+\-\d\.]+)/, $crit));
    }
    if ($min ne "") {
      $min = join("", map {
          s/\.0+$//; $_
      } map {
          s/(\.[1-9]+)0+$/$1/; $_
      } map {
          /[\+\-\d\.]+/ ? sprintf '%.'.2*$args{places}.'f', $_ : $_;
      } split(/([\+\-\d\.]+)/, $min));
    }
    if ($max ne "") {
      $max = join("", map {
          s/\.0+$//; $_
      } map {
          s/(\.[1-9]+)0+$/$1/; $_
      } map {
          /[\+\-\d\.]+/ ? sprintf '%.'.2*$args{places}.'f', $_ : $_;
      } split(/([\+\-\d\.]+)/, $max));
    }
  }
  push @{$self->{perfdata}}, sprintf("'%s'=%s%s;%s;%s;%s;%s",
      $label, $value, $uom, $warn, $crit, $min, $max)
      if $self->selected_perfdata($label);
}

sub add_pandora {
  my ($self, %args) = @_;
  my $label = $args{label};
  my $value = $args{value};

  if ($args{help}) {
    push @{$self->{pandora}}, sprintf("# HELP %s %s", $label, $args{help});
  }
  if ($args{type}) {
    push @{$self->{pandora}}, sprintf("# TYPE %s %s", $label, $args{type});
  }
  if ($args{labels}) {
    push @{$self->{pandora}}, sprintf("%s{%s} %s", $label,
        join(",", map {
            sprintf '%s="%s"', $_, $args{labels}->{$_};
        } keys %{$args{labels}}),
        $value);
  } else {
    push @{$self->{pandora}}, sprintf("%s %s", $label, $value);
  }
}

sub add_html {
  my ($self, $line) = @_;
  push @{$self->{html}}, $line;
}

sub suppress_messages {
  my ($self) = @_;
  $self->{suppress_messages} = 1;
}

sub clear_messages {
  my ($self, $code) = @_;
  $code = (qw(ok warning critical unknown))[$code] if $code =~ /^\d+$/;
  $code = lc $code;
  $self->{messages}->{$code} = [];
}

sub reduce_messages_short {
  my ($self, $message) = @_;
  $message ||= "no problems";
  if ($self->opts->report && $self->opts->report eq "short") {
    $self->clear_messages(OK);
    $self->add_message(OK, $message) if ! $self->check_messages();
  }
}

sub reduce_messages {
  my ($self, $message) = @_;
  $message ||= "no problems";
  $self->clear_messages(OK);
  $self->add_message(OK, $message) if ! $self->check_messages();
}

sub check_messages {
  my ($self, %args) = @_;

  # Add object messages to any passed in as args
  for my $code (qw(critical warning unknown ok)) {
    my $messages = $self->{messages}->{$code} || [];
    if ($args{$code}) {
      unless (ref $args{$code} eq 'ARRAY') {
        if ($code eq 'ok') {
          $args{$code} = [ $args{$code} ];
        }
      }
      push @{$args{$code}}, @$messages;
    } else {
      $args{$code} = $messages;
    }
  }
  my %arg = %args;
  $arg{join} = ' ' unless defined $arg{join};

  # Decide $code
  my $code = OK;
  $code ||= CRITICAL  if @{$arg{critical}};
  $code ||= WARNING   if @{$arg{warning}};
  $code ||= UNKNOWN   if @{$arg{unknown}};
  return $code unless wantarray;

  # Compose message
  my $message = '';
  if ($arg{join_all}) {
      $message = join( $arg{join_all},
          map { @$_ ? join( $arg{'join'}, @$_) : () }
              $arg{critical},
              $arg{warning},
              $arg{unknown},
              $arg{ok} ? (ref $arg{ok} ? $arg{ok} : [ $arg{ok} ]) : []
      );
  }

  else {
      $message ||= join( $arg{'join'}, @{$arg{critical}} )
          if $code == CRITICAL;
      $message ||= join( $arg{'join'}, @{$arg{warning}} )
          if $code == WARNING;
      $message ||= join( $arg{'join'}, @{$arg{unknown}} )
          if $code == UNKNOWN;
      $message ||= ref $arg{ok} ? join( $arg{'join'}, @{$arg{ok}} ) : $arg{ok}
          if $arg{ok};
  }

  return ($code, $message);
}

sub status_code {
  my ($self, $code) = @_;
  $code = (qw(ok warning critical unknown))[$code] if $code =~ /^\d+$/;
  $code = uc $code;
  $code = $ERRORS{$code} if defined $code && exists $ERRORS{$code};
  $code = UNKNOWN unless defined $code && exists $STATUS_TEXT{$code};
  return "$STATUS_TEXT{$code}";
}

sub perfdata_string {
  my ($self) = @_;
  if (scalar (@{$self->{perfdata}})) {
    return join(" ", @{$self->{perfdata}});
  } else {
    return "";
  }
}

sub metrics_string {
  my ($self) = @_;
  if (scalar (@{$self->{metrics}})) {
    return join("\n", @{$self->{metrics}});
  } else {
    return "";
  }
}

sub html_string {
  my ($self) = @_;
  if (scalar (@{$self->{html}})) {
    return join(" ", @{$self->{html}});
  } else {
    return "";
  }
}

sub nagios_exit {
  my ($self, $code, $message, $arg) = @_;
  $code = $ERRORS{$code} if defined $code && exists $ERRORS{$code};
  $code = UNKNOWN unless defined $code && exists $STATUS_TEXT{$code};
  $message = '' unless defined $message;
  if (ref $message && ref $message eq 'ARRAY') {
      $message = join(' ', map { chomp; $_ } @$message);
  } else {
      chomp $message;
  }
  if ($self->opts->negate) {
    my $original_code = $code;
    foreach my $from (keys %{$self->opts->negate}) {
      if ((uc $from) =~ /^(OK|WARNING|CRITICAL|UNKNOWN)$/ &&
          (uc $self->opts->negate->{$from}) =~ /^(OK|WARNING|CRITICAL|UNKNOWN)$/) {
        if ($original_code == $ERRORS{uc $from}) {
          $code = $ERRORS{uc $self->opts->negate->{$from}};
        }
      }
    }
  }
  my $output = "$STATUS_TEXT{$code}";
  $output .= " - $message" if defined $message && $message ne '';
  if ($self->opts->can("morphmessage") && $self->opts->morphmessage) {
    # 'Intel [R] Interface (\d+) usage'='nic$1'
    # '^OK.*'="alles klar"   '^CRITICAL.*'="alles hi"
    foreach my $key (keys %{$self->opts->morphmessage}) {
      if ($output =~ /$key/) {
        my $replacement = '"'.$self->opts->morphmessage->{$key}.'"';
        $output =~ s/$key/$replacement/ee;
      }
    }
  }
  $output =~ s/\|/!/g if $output;
  if (scalar (@{$self->{perfdata}})) {
    $output .= " | ".$self->perfdata_string();
  }
  $output .= "\n";
  if ($self->opts->can("isvalidtime") && ! $self->opts->isvalidtime) {
    $code = OK;
    $output = "OK - outside valid timerange. check results are not relevant now. original message was: ".
        $output;
  }
  if (! exists $self->{suppress_messages}) {
    print $output;
  }
  exit $code;
}

sub set_thresholds {
  my ($self, %params) = @_;
  if (exists $params{metric}) {
    my $metric = $params{metric};
    # erst die hartcodierten defaultschwellwerte
    $self->{thresholds}->{$metric}->{warning} = $params{warning};
    $self->{thresholds}->{$metric}->{critical} = $params{critical};
    # dann die defaultschwellwerte von der kommandozeile
    if (defined $self->opts->warning) {
      $self->{thresholds}->{$metric}->{warning} = $self->opts->warning;
    }
    if (defined $self->opts->critical) {
      $self->{thresholds}->{$metric}->{critical} = $self->opts->critical;
    }
    # dann die ganz spezifischen schwellwerte von der kommandozeile
    if ($self->opts->warningx) { # muss nicht auf defined geprueft werden, weils ein hash ist
      # Erst schauen, ob einer * beinhaltet. Von denen wird vom Laengsten
      # bis zum Kuerzesten probiert, ob die matchen. Der laengste Match
      # gewinnt.
      my @keys = keys %{$self->opts->warningx};
      my @stringkeys = ();
      my @regexkeys = ();
      foreach my $key (sort { length($b) > length($a) } @keys) {
        if ($key =~ /\*/) {
          push(@regexkeys, $key);
        } else {
          push(@stringkeys, $key);
        }
      }
      foreach my $key (@regexkeys) {
        next if $metric !~ /$key/;
        $self->{thresholds}->{$metric}->{warning} = $self->opts->warningx->{$key};
        last;
      }
      # Anschliessend nochmal schauen, ob es einen nicht-Regex-Volltreffer gibt
      foreach my $key (@stringkeys) {
        next if $key ne $metric;
        $self->{thresholds}->{$metric}->{warning} = $self->opts->warningx->{$key};
        last;
      }
    }
    if ($self->opts->criticalx) {
      my @keys = keys %{$self->opts->criticalx};
      my @stringkeys = ();
      my @regexkeys = ();
      foreach my $key (sort { length($b) > length($a) } @keys) {
        if ($key =~ /\*/) {
          push(@regexkeys, $key);
        } else {
          push(@stringkeys, $key);
        }
      }
      foreach my $key (@regexkeys) {
        next if $metric !~ /$key/;
        $self->{thresholds}->{$metric}->{critical} = $self->opts->criticalx->{$key};
        last;
      }
      # Anschliessend nochmal schauen, ob es einen nicht-Regex-Volltreffer gibt
      foreach my $key (@stringkeys) {
        next if $key ne $metric;
        $self->{thresholds}->{$metric}->{critical} = $self->opts->criticalx->{$key};
        last;
      }
    }
  } else {
    $self->{thresholds}->{default}->{warning} =
        defined $self->opts->warning ? $self->opts->warning : defined $params{warning} ? $params{warning} : 0;
    $self->{thresholds}->{default}->{critical} =
        defined $self->opts->critical ? $self->opts->critical : defined $params{critical} ? $params{critical} : 0;
  }
}

sub force_thresholds {
  my ($self, %params) = @_;
  if (exists $params{metric}) {
    my $metric = $params{metric};
    $self->{thresholds}->{$metric}->{warning} = $params{warning} || 0;
    $self->{thresholds}->{$metric}->{critical} = $params{critical} || 0;
  } else {
    $self->{thresholds}->{default}->{warning} = $params{warning} || 0;
    $self->{thresholds}->{default}->{critical} = $params{critical} || 0;
  }
}

sub get_thresholds {
  my ($self, @params) = @_;
  if (scalar(@params) > 1) {
    my %params = @params;
    my $metric = $params{metric};
    return ($self->{thresholds}->{$metric}->{warning},
        $self->{thresholds}->{$metric}->{critical});
  } else {
    return ($self->{thresholds}->{default}->{warning},
        $self->{thresholds}->{default}->{critical});
  }
}

sub check_thresholds {
  my ($self, @params) = @_;
  my $level = $ERRORS{OK};
  my $warningrange;
  my $criticalrange;
  my $value;
  if (scalar(@params) > 1) {
    my %params = @params;
    $value = $params{value};
    my $metric = $params{metric};
    if ($metric ne 'default') {
      $warningrange = exists $self->{thresholds}->{$metric}->{warning} ?
          $self->{thresholds}->{$metric}->{warning} :
          $self->{thresholds}->{default}->{warning};
      $criticalrange = exists $self->{thresholds}->{$metric}->{critical} ?
          $self->{thresholds}->{$metric}->{critical} :
          $self->{thresholds}->{default}->{critical};
    } else {
      $warningrange = (defined $params{warning}) ?
          $params{warning} : $self->{thresholds}->{default}->{warning};
      $criticalrange = (defined $params{critical}) ?
          $params{critical} : $self->{thresholds}->{default}->{critical};
    }
  } else {
    $value = $params[0];
    $warningrange = $self->{thresholds}->{default}->{warning};
    $criticalrange = $self->{thresholds}->{default}->{critical};
  }
  if (! defined $warningrange) {
    # there was no set_thresholds for defaults, no --warning, no --warningx
  } elsif ($warningrange =~ /^([-+]?[0-9]*\.?[0-9]+)$/) {
    # warning = 10, warn if > 10 or < 0
    $level = $ERRORS{WARNING}
        if ($value > $1 || $value < 0);
  } elsif ($warningrange =~ /^([-+]?[0-9]*\.?[0-9]+):$/) {
    # warning = 10:, warn if < 10
    $level = $ERRORS{WARNING}
        if ($value < $1);
  } elsif ($warningrange =~ /^~:([-+]?[0-9]*\.?[0-9]+)$/) {
    # warning = ~:10, warn if > 10
    $level = $ERRORS{WARNING}
        if ($value > $1);
  } elsif ($warningrange =~ /^([-+]?[0-9]*\.?[0-9]+):([-+]?[0-9]*\.?[0-9]+)$/) {
    # warning = 10:20, warn if < 10 or > 20
    $level = $ERRORS{WARNING}
        if ($value < $1 || $value > $2);
  } elsif ($warningrange =~ /^@([-+]?[0-9]*\.?[0-9]+):([-+]?[0-9]*\.?[0-9]+)$/) {
    # warning = @10:20, warn if >= 10 and <= 20
    $level = $ERRORS{WARNING}
        if ($value >= $1 && $value <= $2);
  }
  if (! defined $criticalrange) {
    # there was no set_thresholds for defaults, no --critical, no --criticalx
  } elsif ($criticalrange =~ /^([-+]?[0-9]*\.?[0-9]+)$/) {
    # critical = 10, crit if > 10 or < 0
    $level = $ERRORS{CRITICAL}
        if ($value > $1 || $value < 0);
  } elsif ($criticalrange =~ /^([-+]?[0-9]*\.?[0-9]+):$/) {
    # critical = 10:, crit if < 10
    $level = $ERRORS{CRITICAL}
        if ($value < $1);
  } elsif ($criticalrange =~ /^~:([-+]?[0-9]*\.?[0-9]+)$/) {
    # critical = ~:10, crit if > 10
    $level = $ERRORS{CRITICAL}
        if ($value > $1);
  } elsif ($criticalrange =~ /^([-+]?[0-9]*\.?[0-9]+):([-+]?[0-9]*\.?[0-9]+)$/) {
    # critical = 10:20, crit if < 10 or > 20
    $level = $ERRORS{CRITICAL}
        if ($value < $1 || $value > $2);
  } elsif ($criticalrange =~ /^@([-+]?[0-9]*\.?[0-9]+):([-+]?[0-9]*\.?[0-9]+)$/) {
    # critical = @10:20, crit if >= 10 and <= 20
    $level = $ERRORS{CRITICAL}
        if ($value >= $1 && $value <= $2);
  }
  return $level;
}



package Monitoring::GLPlugin;

=head1 Monitoring::GLPlugin

Monitoring::GLPlugin - infrastructure functions to build a monitoring plugin

=cut

use strict;
use IO::File;
use File::Basename;
use Digest::MD5 qw(md5_hex);
use Errno;
use Data::Dumper;
our $AUTOLOAD;
*VERSION = \'2.3.8.1';

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

{
  our $mode = undef;
  our $plugin = undef;
  our $pluginname = basename($ENV{'NAGIOS_PLUGIN'} || $0);
  our $blacklist = undef;
  our $info = [];
  our $extendedinfo = [];
  our $summary = [];
  our $variables = {};
  our $survive_sudo_env = ["LD_LIBRARY_PATH", "SHLIB_PATH"];
}

sub new {
  my ($class, %params) = @_;
  my $self = {};
  bless $self, $class;
  require Monitoring::GLPlugin::Commandline
      if ! grep /BEGIN/, keys %Monitoring::GLPlugin::Commandline::;
  require Monitoring::GLPlugin::Item
      if ! grep /BEGIN/, keys %Monitoring::GLPlugin::Item::;
  require Monitoring::GLPlugin::TableItem
      if ! grep /BEGIN/, keys %Monitoring::GLPlugin::TableItem::;
  $Monitoring::GLPlugin::plugin = Monitoring::GLPlugin::Commandline->new(%params);
  return $self;
}

sub init {
  my ($self) = @_;
  if ($self->opts->can("blacklist") && $self->opts->blacklist &&
      -f $self->opts->blacklist) {
    $self->opts->blacklist = do {
        local (@ARGV, $/) = $self->opts->blacklist; <> };
  }
}

sub dumper {
  my ($self, $object) = @_;
  my $run = $object->{runtime};
  delete $object->{runtime};
  printf STDERR "%s\n", Data::Dumper::Dumper($object);
  $object->{runtime} = $run;
}

sub no_such_mode {
  my ($self) = @_;
  printf "Mode %s is not implemented for this type of device\n",
      $self->opts->mode;
  exit 3;
}

#########################################################
# framework-related. setup, options
#
sub add_default_args {
  my ($self) = @_;
  $self->add_arg(
      spec => 'mode=s',
      help => "--mode
   A keyword which tells the plugin what to do",
      required => 1,
  );
  $self->add_arg(
      spec => 'regexp',
      help => "--regexp
   Parameter name/name2/name3 will be interpreted as (perl) regular expression",
      required => 0,);
  $self->add_arg(
      spec => 'warning=s',
      help => "--warning
   The warning threshold",
      required => 0,);
  $self->add_arg(
      spec => 'critical=s',
      help => "--critical
   The critical threshold",
      required => 0,);
  $self->add_arg(
      spec => 'warningx=s%',
      help => '--warningx
   The extended warning thresholds
   e.g. --warningx db_msdb_free_pct=6: to override the threshold for a
   specific item ',
      required => 0,
  );
  $self->add_arg(
      spec => 'criticalx=s%',
      help => '--criticalx
   The extended critical thresholds',
      required => 0,
  );
  $self->add_arg(
      spec => 'units=s',
      help => "--units
   One of %, B, KB, MB, GB, Bit, KBi, MBi, GBi. (used for e.g. mode interface-usage)",
      required => 0,
  );
  $self->add_arg(
      spec => 'name=s',
      help => "--name
   The name of a specific component to check",
      required => 0,
  );
  $self->add_arg(
      spec => 'name2=s',
      help => "--name2
   The secondary name of a component",
      required => 0,
  );
  $self->add_arg(
      spec => 'name3=s',
      help => "--name3
   The tertiary name of a component",
      required => 0,
  );
  $self->add_arg(
      spec => 'extra-opts=s',
      help => "--extra-opts
   read command line arguments from an external file",
      required => 0,
  );
  $self->add_arg(
      spec => 'blacklist|b=s',
      help => '--blacklist
   Blacklist some (missing/failed) components',
      required => 0,
      default => '',
  );
  $self->add_arg(
      spec => 'mitigation=s',
      help => "--mitigation
   The parameter allows you to change a critical error to a warning.",
      required => 0,
  );
  $self->add_arg(
      spec => 'lookback=s',
      help => "--lookback
   The amount of time you want to look back when calculating average rates.
   Use it for mode interface-errors or interface-usage. Without --lookback
   the time between two runs of check_nwc_health is the base for calculations.
   If you want your checkresult to be based for example on the past hour,
   use --lookback 3600. ",
      required => 0,
  );
  $self->add_arg(
      spec => 'environment|e=s%',
      help => "--environment
   Add a variable to the plugin's environment",
      required => 0,
  );
  $self->add_arg(
      spec => 'negate=s%',
      help => "--negate
   Emulate the negate plugin. --negate warning=critical --negate unknown=critical",
      required => 0,
  );
  $self->add_arg(
      spec => 'morphmessage=s%',
      help => '--morphmessage
   Modify the final output message',
      required => 0,
  );
  $self->add_arg(
      spec => 'morphperfdata=s%',
      help => "--morphperfdata
   The parameter allows you to change performance data labels.
   It's a perl regexp and a substitution.
   Example: --morphperfdata '(.*)ISATAP(.*)'='\$1patasi\$2'",
      required => 0,
  );
  $self->add_arg(
      spec => 'selectedperfdata=s',
      help => "--selectedperfdata
   The parameter allows you to limit the list of performance data. It's a perl regexp.
   Only matching perfdata show up in the output",
      required => 0,
  );
  $self->add_arg(
      spec => 'report=s',
      help => "--report
   Can be used to shorten the output",
      required => 0,
      default => 'long',
  );
  $self->add_arg(
      spec => 'multiline',
      help => '--multiline
   Multiline output',
      required => 0,
  );
  $self->add_arg(
      spec => 'with-mymodules-dyn-dir=s',
      help => "--with-mymodules-dyn-dir
   Add-on modules for the my-modes will be searched in this directory",
      required => 0,
  );
  $self->add_arg(
      spec => 'statefilesdir=s',
      help => '--statefilesdir
   An alternate directory where the plugin can save files',
      required => 0,
      env => 'STATEFILESDIR',
  );
  $self->add_arg(
      spec => 'isvalidtime=i',
      help => '--isvalidtime
   Signals the plugin to return OK if now is not a valid check time',
      required => 0,
      default => 1,
  );
  $self->add_arg(
      spec => 'reset',
      help => "--reset
   remove the state file",
      required => 0,
      hidden => 1,
  );
  $self->add_arg(
      spec => 'runas=s',
      help => "--runas
   run as a different user",
      required => 0,
      hidden => 1,
  );
  $self->add_arg(
      spec => 'shell',
      help => "--shell
   forget what you see",
      required => 0,
      hidden => 1,
  );
  $self->add_arg(
      spec => 'drecksptkdb=s',
      help => "--drecksptkdb
   This parameter must be used instead of --name, because Devel::ptkdb is stealing the latter from the command line",
      aliasfor => "name",
      required => 0,
      hidden => 1,
  );
}

sub add_modes {
  my ($self, $modes) = @_;
  my $modestring = "";
  my @modes = @{$modes};
  my $longest = length ((reverse sort {length $a <=> length $b} map { $_->[1] } @modes)[0]);
  my $format = "       %-".
      (length ((reverse sort {length $a <=> length $b} map { $_->[1] } @modes)[0])).
      "s\t(%s)\n";
  foreach (@modes) {
    $modestring .= sprintf $format, $_->[1], $_->[3];
  }
  $modestring .= sprintf "\n";
  $Monitoring::GLPlugin::plugin->{modestring} = $modestring;
}

sub add_arg {
  my ($self, %args) = @_;
  if ($args{help} =~ /^--mode/) {
    $args{help} .= "\n".$Monitoring::GLPlugin::plugin->{modestring};
  }
  $Monitoring::GLPlugin::plugin->{opts}->add_arg(%args);
}

sub mod_arg {
  my ($self, @arg) = @_;
  $Monitoring::GLPlugin::plugin->{opts}->mod_arg(@arg);
}

sub add_mode {
  my ($self, %args) = @_;
  push(@{$Monitoring::GLPlugin::plugin->{modes}}, \%args);
  my $longest = length ((reverse sort {length $a <=> length $b} map { $_->{spec} } @{$Monitoring::GLPlugin::plugin->{modes}})[0]);
  my $format = "       %-".
      (length ((reverse sort {length $a <=> length $b} map { $_->{spec} } @{$Monitoring::GLPlugin::plugin->{modes}})[0])).
      "s\t(%s)\n";
  $Monitoring::GLPlugin::plugin->{modestring} = "";
  foreach (@{$Monitoring::GLPlugin::plugin->{modes}}) {
    $Monitoring::GLPlugin::plugin->{modestring} .= sprintf $format, $_->{spec}, $_->{help};
  }
  $Monitoring::GLPlugin::plugin->{modestring} .= "\n";
}

sub validate_args {
  my ($self) = @_;
  if ($self->opts->mode =~ /^my-([^\-.]+)/) {
    my $param = $self->opts->mode;
    $param =~ s/\-/::/g;
    $self->add_mode(
        internal => $param,
        spec => $self->opts->mode,
        alias => undef,
        help => 'my extension',
    );
  } elsif ($self->opts->mode eq 'encode') {
    my $input = <>;
    chomp $input;
    $input =~ s/([^A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg;
    printf "%s\n", $input;
    exit 0;
  } elsif ($self->opts->mode eq 'decode') {
    if (! -t STDIN) {
      my $input = <>;
      chomp $input;
      $input =~ s/%([A-Za-z0-9]{2})/chr(hex($1))/seg;
      printf "%s\n", $input;
      exit OK;
    } else {
      if ($self->opts->name) {
        my $input = $self->opts->name;
        $input =~ s/%([A-Za-z0-9]{2})/chr(hex($1))/seg;
        printf "%s\n", $input;
        exit OK;
      } else {
        printf "i can't find your encoded statement. use --name or pipe it in my stdin\n";
        exit UNKNOWN;
      }
    }
  } elsif ((! grep { $self->opts->mode eq $_ } map { $_->{spec} } @{$Monitoring::GLPlugin::plugin->{modes}}) &&
      (! grep { $self->opts->mode eq $_ } map { defined $_->{alias} ? @{$_->{alias}} : () } @{$Monitoring::GLPlugin::plugin->{modes}})) {
    printf "UNKNOWN - mode %s\n", $self->opts->mode;
    $self->opts->print_help();
    exit 3;
  }
  if ($self->opts->name && $self->opts->name =~ /(%22)|(%27)/) {
    my $name = $self->opts->name;
    $name =~ s/\%([A-Fa-f0-9]{2})/pack('C', hex($1))/seg;
    $self->override_opt('name', $name);
  }
  $Monitoring::GLPlugin::mode = (
      map { $_->{internal} }
      grep {
         ($self->opts->mode eq $_->{spec}) ||
         ( defined $_->{alias} && grep { $self->opts->mode eq $_ } @{$_->{alias}})
      } @{$Monitoring::GLPlugin::plugin->{modes}}
  )[0];
  if ($self->opts->multiline) {
    $ENV{NRPE_MULTILINESUPPORT} = 1;
  } else {
    $ENV{NRPE_MULTILINESUPPORT} = 0;
  }
  if ($self->opts->can("statefilesdir") && ! $self->opts->statefilesdir) {
    if ($^O =~ /MSWin/) {
      if (defined $ENV{TEMP}) {
        $self->override_opt('statefilesdir', $ENV{TEMP}."/".$Monitoring::GLPlugin::plugin->{name});
      } elsif (defined $ENV{TMP}) {
        $self->override_opt('statefilesdir', $ENV{TMP}."/".$Monitoring::GLPlugin::plugin->{name});
      } elsif (defined $ENV{windir}) {
        $self->override_opt('statefilesdir', File::Spec->catfile($ENV{windir}, 'Temp')."/".$Monitoring::GLPlugin::plugin->{name});
      } else {
        $self->override_opt('statefilesdir', "C:/".$Monitoring::GLPlugin::plugin->{name});
      }
    } elsif (exists $ENV{OMD_ROOT}) {
      $self->override_opt('statefilesdir', $ENV{OMD_ROOT}."/var/tmp/".$Monitoring::GLPlugin::plugin->{name});
    } else {
      $self->override_opt('statefilesdir', "/var/tmp/".$Monitoring::GLPlugin::plugin->{name});
    }
  }
  $Monitoring::GLPlugin::plugin->{statefilesdir} = $self->opts->statefilesdir
      if $self->opts->can("statefilesdir");
  if ($self->opts->can("warningx") && $self->opts->warningx) {
    foreach my $key (keys %{$self->opts->warningx}) {
      $self->set_thresholds(metric => $key,
          warning => $self->opts->warningx->{$key});
    }
  }
  if ($self->opts->can("criticalx") && $self->opts->criticalx) {
    foreach my $key (keys %{$self->opts->criticalx}) {
      $self->set_thresholds(metric => $key,
          critical => $self->opts->criticalx->{$key});
    }
  }
  $self->set_timeout_alarm() if ! $SIG{'ALRM'};
}

sub set_timeout_alarm {
  my ($self, $timeout, $handler) = @_;
  $timeout ||= $self->opts->timeout;
  $handler ||= sub {
    printf "UNKNOWN - %s timed out after %d seconds\n",
        $Monitoring::GLPlugin::plugin->{name}, $self->opts->timeout;
    exit 3;
  };
  use POSIX ':signal_h';
  if ($^O =~ /MSWin/) {
    local $SIG{'ALRM'} = $handler;
  } else {
    my $mask = POSIX::SigSet->new( SIGALRM );
    my $action = POSIX::SigAction->new(
        $handler, $mask
    );   
    my $oldaction = POSIX::SigAction->new();
    sigaction(SIGALRM ,$action ,$oldaction );
  }    
  alarm(int($timeout)); # 1 second before the global unknown timeout
}

#########################################################
# global helpers
#
sub set_variable {
  my ($self, $key, $value) = @_;
  $Monitoring::GLPlugin::variables->{$key} = $value;
}

sub get_variable {
  my ($self, $key, $fallback) = @_;
  return exists $Monitoring::GLPlugin::variables->{$key} ?
      $Monitoring::GLPlugin::variables->{$key} : $fallback;
}

sub debug {
  my ($self, $format, @message) = @_;
  my $tracefile = "/tmp/".$Monitoring::GLPlugin::pluginname.".trace";
  $self->{trace} = -f $tracefile ? 1 : 0;
  if ($self->get_variable("verbose") &&
      $self->get_variable("verbose") > $self->get_variable("verbosity", 10)) {
    printf("%s: ", scalar localtime);
    printf($format, @message);
    printf "\n";
  }
  if ($self->{trace}) {
    my $logfh = IO::File->new();
    $logfh->autoflush(1);
    if ($logfh->open($tracefile, "a")) {
      $logfh->printf("%s: ", scalar localtime);
      $logfh->printf($format, @message);
      $logfh->printf("\n");
      $logfh->close();
    }
  }
}

sub filter_namex {
  my ($self, $opt, $name) = @_;
  if ($opt) {
    if ($self->opts->regexp) {
      if ($name =~ /$opt/i) {
        return 1;
      }
    } else {
      if (lc $opt eq lc $name) {
        return 1;
      }
    }
  } else {
    return 1;
  }
  return 0;
}

sub filter_name {
  my ($self, $name) = @_;
  return $self->filter_namex($self->opts->name, $name);
}

sub filter_name2 {
  my ($self, $name) = @_;
  return $self->filter_namex($self->opts->name2, $name);
}

sub filter_name3 {
  my ($self, $name) = @_;
  return $self->filter_namex($self->opts->name3, $name);
}

sub version_is_minimum {
  my ($self, $version) = @_;
  my $installed_version;
  my $newer = 1;
  if ($self->get_variable("version")) {
    $installed_version = $self->get_variable("version");
  } elsif (exists $self->{version}) {
    $installed_version = $self->{version};
  } else {
    return 0;
  }
  my @v1 = map { $_ eq "x" ? 0 : $_ } split(/\./, $version);
  my @v2 = split(/\./, $installed_version);
  if (scalar(@v1) > scalar(@v2)) {
    push(@v2, (0) x (scalar(@v1) - scalar(@v2)));
  } elsif (scalar(@v2) > scalar(@v1)) {
    push(@v1, (0) x (scalar(@v2) - scalar(@v1)));
  }
  foreach my $pos (0..$#v1) {
    if ($v2[$pos] > $v1[$pos]) {
      $newer = 1;
      last;
    } elsif ($v2[$pos] < $v1[$pos]) {
      $newer = 0;
      last;
    }
  }
  return $newer;
}

sub accentfree {
  my ($self, $text) = @_;
  # thanks mycoyne who posted this accent-remove-algorithm
  # http://www.experts-exchange.com/Programming/Languages/Scripting/Perl/Q_23275533.html#a21234612
  my @transformed;
  my %replace = (
    '9a' => 's', '9c' => 'oe', '9e' => 'z', '9f' => 'Y', 'c0' => 'A', 'c1' => 'A',
    'c2' => 'A', 'c3' => 'A', 'c4' => 'A', 'c5' => 'A', 'c6' => 'AE', 'c7' => 'C',
    'c8' => 'E', 'c9' => 'E', 'ca' => 'E', 'cb' => 'E', 'cc' => 'I', 'cd' => 'I',
    'ce' => 'I', 'cf' => 'I', 'd0' => 'D', 'd1' => 'N', 'd2' => 'O', 'd3' => 'O',
    'd4' => 'O', 'd5' => 'O', 'd6' => 'O', 'd8' => 'O', 'd9' => 'U', 'da' => 'U',
    'db' => 'U', 'dc' => 'U', 'dd' => 'Y', 'e0' => 'a', 'e1' => 'a', 'e2' => 'a',
    'e3' => 'a', 'e4' => 'a', 'e5' => 'a', 'e6' => 'ae', 'e7' => 'c', 'e8' => 'e',
    'e9' => 'e', 'ea' => 'e', 'eb' => 'e', 'ec' => 'i', 'ed' => 'i', 'ee' => 'i',
    'ef' => 'i', 'f0' => 'o', 'f1' => 'n', 'f2' => 'o', 'f3' => 'o', 'f4' => 'o',
    'f5' => 'o', 'f6' => 'o', 'f8' => 'o', 'f9' => 'u', 'fa' => 'u', 'fb' => 'u',
    'fc' => 'u', 'fd' => 'y', 'ff' => 'y',
  );
  my @letters = split //, $text;;
  for (my $i = 0; $i <= $#letters; $i++) {
    my $hex = sprintf "%x", ord($letters[$i]);
    $letters[$i] = $replace{$hex} if (exists $replace{$hex});
  }
  push @transformed, @letters;
  return join '', @transformed;
}

sub dump {
  my ($self) = @_;
  my $class = ref($self);
  $class =~ s/^.*:://;
  if (exists $self->{flat_indices}) {
    printf "[%s_%s]\n", uc $class, $self->{flat_indices};
  } else {
    printf "[%s]\n", uc $class;
  }
  foreach (grep !/^(info|trace|warning|critical|blacklisted|extendedinfo|flat_indices|indices)$/, sort keys %{$self}) {
    printf "%s: %s\n", $_, $self->{$_} if defined $self->{$_} && ref($self->{$_}) ne "ARRAY";
  }
  if ($self->{info}) {
    printf "info: %s\n", $self->{info};
  }
  printf "\n";
  foreach (grep !/^(info|trace|warning|critical|blacklisted|extendedinfo|flat_indices|indices)$/, sort keys %{$self}) {
    if (defined $self->{$_} && ref($self->{$_}) eq "ARRAY") {
      my $have_flat_indices = 1;
      foreach my $obj (@{$self->{$_}}) {
        $have_flat_indices = 0 if (ref($obj) ne "HASH" || ! exists $obj->{flat_indices});
      }
      if ($have_flat_indices) {
        foreach my $obj (sort {
            join('', map { sprintf("%30d",$_) } split( /\./, $a->{flat_indices})) cmp
            join('', map { sprintf("%30d",$_) } split( /\./, $b->{flat_indices}))
        } @{$self->{$_}}) {
          $obj->dump();
        }
      } else {
        foreach my $obj (@{$self->{$_}}) {
          $obj->dump() if UNIVERSAL::can($obj, "isa") && $obj->can("dump");
        }
      }
    }
  }
}

sub table_ascii {
  my ($self, $table, $titles) = @_;
  my $text = "";
  my $column_length = {};
  my $column = 0;
  foreach (@{$titles}) {
    $column_length->{$column++} = length($_);
  }
  foreach my $tr (@{$table}) {
    @{$tr} = map { ref($_) eq "ARRAY" ? $_->[0] : $_; } @{$tr};
    $column = 0;
    foreach my $td (@{$tr}) {
      if (length($td) > $column_length->{$column}) {
        $column_length->{$column} = length($td);
      }
      $column++;
    }
  }
  $column = 0;
  foreach (@{$titles}) {
    $column_length->{$column} = "%".($column_length->{$column} + 3)."s";
    $column++;
  }
  $column = 0;
  foreach (@{$titles}) {
    $text .= sprintf $column_length->{$column++}, $_;
  }
  $text .= "\n";
  foreach my $tr (@{$table}) {
    $column = 0;
    foreach my $td (@{$tr}) {
      $text .= sprintf $column_length->{$column++}, $td;
    }
    $text .= "\n";
  }
  return $text;
}

sub table_html {
  my ($self, $table, $titles) = @_;
  my $text = "";
  $text .= "<table style=\"border-collapse:collapse; border: 1px solid black;\">";
  $text .= "<tr>";
  foreach (@{$titles}) {
    $text .= sprintf "<th style=\"text-align: left; padding-left: 4px; padding-right: 6px;\">%s</th>", $_;
  }
  $text .= "</tr>";
  foreach my $tr (@{$table}) {
    $text .= "<tr>";
    foreach my $td (@{$tr}) {
      my $class = "statusOK";
      if (ref($td) eq "ARRAY") {
        $class = {
          0 => "statusOK",
          1 => "statusWARNING",
          2 => "statusCRITICAL",
          3 => "statusUNKNOWN",
        }->{$td->[1]};
        $td = $td->[0];
      }
      $text .= sprintf "<td style=\"text-align: left; padding-left: 4px; padding-right: 6px;\" class=\"%s\">%s</td>", $class, $td;
    }
    $text .= "</tr>";
  }
  $text .= "</table>";
  return $text;
}

sub load_my_extension {
  my ($self) = @_;
  if ($self->opts->mode =~ /^my-([^-.]+)/) {
    my $class = $1;
    my $loaderror = undef;
    substr($class, 0, 1) = uc substr($class, 0, 1);
    if (! $self->opts->get("with-mymodules-dyn-dir")) {
      $self->override_opt("with-mymodules-dyn-dir", "");
    }
    my $plugin_name = $Monitoring::GLPlugin::pluginname;
    $plugin_name =~ /check_(.*?)_health/;
    my $deprecated_class = "DBD::".(uc $1)."::Server";
    $plugin_name = "Check".uc(substr($1, 0, 1)).substr($1, 1)."Health";
    foreach my $libpath (split(":", $self->opts->get("with-mymodules-dyn-dir"))) {
      foreach my $extmod (glob $libpath."/".$plugin_name."*.pm") {
        my $stderrvar;
        *SAVEERR = *STDERR;
        open OUT ,'>',\$stderrvar;
        *STDERR = *OUT;
        eval {
          $self->debug(sprintf "loading module %s", $extmod);
          require $extmod;
        };
        *STDERR = *SAVEERR;
        if ($@) {
          $loaderror = $extmod;
          $self->debug(sprintf "failed loading module %s: %s", $extmod, $@);
        }
      }
    }
    my $original_class = ref($self);
    my $original_init = $self->can("init");
    $self->compatibility_class() if $self->can('compatibility_class');
    bless $self, "My$class";
    $self->compatibility_methods() if $self->can('compatibility_methods') &&
        $self->isa($deprecated_class);
    if ($self->isa("Monitoring::GLPlugin")) {
      my $new_init = $self->can("init");
      if ($new_init == $original_init) {
          $self->add_unknown(
              sprintf "Class %s needs an init() method", ref($self));
      } else {
        # now go back to check_*_health.pl where init() will be called
      }
    } else {
      bless $self, $original_class;
      $self->add_unknown(
          sprintf "Class %s is not a subclass of Monitoring::GLPlugin%s",
              "My$class",
              $loaderror ? sprintf " (syntax error in %s?)", $loaderror : "" );
      my ($code, $message) = $self->check_messages(join => ', ', join_all => ', ');
      $self->nagios_exit($code, $message);
    }
  }
}

sub decode_password {
  my ($self, $password) = @_;
  if ($password && $password =~ /^rfc3986:\/\/(.*)/) {
    $password = $1;
    $password =~ s/%([A-Za-z0-9]{2})/chr(hex($1))/seg;
  }
  return $password;
}

sub number_of_bits {
  my ($self, $unit) = @_;
  # https://en.wikipedia.org/wiki/Data_rate_units
  my $bits = {
    'bit' => 1,			# Bit per second
    'B' => 8,			# Byte per second, 8 bits per second
    'kbit' => 1000,		# Kilobit per second, 1,000 bits per second
    'kb' => 1000,		# Kilobit per second, 1,000 bits per second
    'Kibit' => 1024,		# Kibibit per second, 1,024 bits per second
    'kB' => 8000,		# Kilobyte per second, 8,000 bits per second
    'KiB' => 8192,		# Kibibyte per second, 1,024 bytes per second
    'Mbit' => 1000000,		# Megabit per second, 1,000,000 bits per second
    'Mb' => 1000000,		# Megabit per second, 1,000,000 bits per second
    'Mibit' => 1048576,		# Mebibit per second, 1,024 kibibits per second
    'MB' => 8000000,		# Megabyte per second, 1,000 kilobytes per second
    'MiB' => 8388608,		# Mebibyte per second, 1,024 kibibytes per second
    'Gbit' => 1000000000,	# Gigabit per second, 1,000 megabits per second
    'Gb' => 1000000000,		# Gigabit per second, 1,000 megabits per second
    'Gibit' => 1073741824,	# Gibibit per second, 1,024 mebibits per second
    'GB' => 8000000000,		# Gigabyte per second, 1,000 megabytes per second
    'GiB' => 8589934592,	# Gibibyte per second, 8192 mebibits per second
    'Tbit' => 1000000000000,	# Terabit per second, 1,000 gigabits per second
    'Tb' => 1000000000000,	# Terabit per second, 1,000 gigabits per second
    'Tibit' => 1099511627776,	# Tebibit per second, 1,024 gibibits per second
    'TB' => 8000000000000,	# Terabyte per second, 1,000 gigabytes per second
    # eigene kreationen
    'Bits' => 1,
    'Bit' => 1,			# Bit per second
    'KB' => 1024,		# Kilobyte (like disk kilobyte)
    'KBi' => 1024,		# -"-
    'MBi' => 1024 * 1024,	# Megabyte (like disk megabyte)
    'GBi' => 1024 * 1024 * 1024, # Gigybate (like disk gigybyte)
  };
  if (exists $bits->{$unit}) {
    return $bits->{$unit};
  } else {
    return 0;
  }
}


#########################################################
# runtime methods
#
sub mode : lvalue {
  my ($self) = @_;
  $Monitoring::GLPlugin::mode;
}

sub statefilesdir {
  my ($self) = @_;
  return $Monitoring::GLPlugin::plugin->{statefilesdir};
}

sub opts { # die beiden _nicht_ in AUTOLOAD schieben, das kracht!
  my ($self) = @_;
  return $Monitoring::GLPlugin::plugin->opts();
}

sub getopts {
  my ($self, $envparams) = @_;
  $envparams ||= [];
  my $needs_restart = 0;
  my @restart_opts = ();
  $Monitoring::GLPlugin::plugin->getopts();
  # es kann sein, dass beim aufraeumen zum schluss als erstes objekt
  # das $Monitoring::GLPlugin::plugin geloescht wird. in anderen destruktoren
  # (insb. fuer dbi disconnect) steht dann $self->opts->verbose
  # nicht mehr zur verfuegung bzw. $Monitoring::GLPlugin::plugin->opts ist undef.
  $self->set_variable("verbose", $self->opts->verbose);
  #
  # die gueltigkeit von modes wird bereits hier geprueft und nicht danach
  # in validate_args. (zwischen getopts und validate_args wird
  # normalerweise classify aufgerufen, welches bereits eine verbindung
  # zum endgeraet herstellt. bei falschem mode waere das eine verschwendung
  # bzw. durch den exit3 ein evt. unsauberes beenden der verbindung.
  if ((! grep { $self->opts->mode eq $_ } map { $_->{spec} } @{$Monitoring::GLPlugin::plugin->{modes}}) &&
      (! grep { $self->opts->mode eq $_ } map { defined $_->{alias} ? @{$_->{alias}} : () } @{$Monitoring::GLPlugin::plugin->{modes}})) {
    if ($self->opts->mode !~ /^my-/) {
      printf "UNKNOWN - mode %s\n", $self->opts->mode;
      $self->opts->print_help();
      exit 3;
    }
  }
  if ($self->opts->environment) {
    # wenn die gewuenschten Environmentvariablen sich von den derzeit
    # gesetzten unterscheiden, dann restart. Denn $ENV aendert
    # _nicht_ das Environment des laufenden Prozesses. 
    # $ENV{ZEUGS} = 1 bedeutet lediglich, dass $ENV{ZEUGS} bei weiterer
    # Verwendung 1 ist, bedeutet aber _nicht_, dass diese Variable 
    # im Environment des laufenden Prozesses existiert.
    foreach (keys %{$self->opts->environment}) {
      if ((! $ENV{$_}) || ($ENV{$_} ne $self->opts->environment->{$_})) {
        $needs_restart = 1;
        $ENV{$_} = $self->opts->environment->{$_};
        $self->debug(sprintf "new %s=%s forces restart\n", $_, $ENV{$_});
      }
    }
  }
  if ($self->opts->runas) {
    # exec sudo $0 ... und dann ohne --runas
    $needs_restart = 1;
    # wenn wir environmentvariablen haben, die laut survive_sudo_env als
    # wichtig erachtet werden, dann muessen wir die ueber einen moeglichen
    # sudo-aufruf rueberretten, also in zusaetzliche --environment umwandenln.
    # sudo putzt das Environment naemlich aus.
    foreach my $survive_env (@{$Monitoring::GLPlugin::survive_sudo_env}) {
      if ($ENV{$survive_env} && ! scalar(grep { /^$survive_env=/ }
          keys %{$self->opts->environment})) {
        $self->opts->environment->{$survive_env} = $ENV{$survive_env};
        printf STDERR "add important --environment %s=%s\n",
            $survive_env, $ENV{$survive_env} if $self->opts->verbose >= 2;
        push(@restart_opts, '--environment');
        push(@restart_opts, sprintf '%s=%s',
            $survive_env, $ENV{$survive_env});
      }
    }
  }
  if ($needs_restart) {
    foreach my $option (keys %{$self->opts->all_my_opts}) {
      # der fliegt raus, sonst gehts gleich wieder in needs_restart rein
      next if $option eq "runas";
      foreach my $spec (map { $_->{spec} } @{$Monitoring::GLPlugin::plugin->opts->{_args}}) {
        if ($spec =~ /^(\w+)=(.*)/) {
          if ($1 eq $option && $2 =~ /s%/) {
            foreach (keys %{$self->opts->$option()}) {
              push(@restart_opts, sprintf "--%s", $option);
              push(@restart_opts, sprintf "%s=%s", $_, $self->opts->$option()->{$_});
            }
          } elsif ($1 eq $option) {
            push(@restart_opts, sprintf "--%s", $option);
            push(@restart_opts, sprintf "%s", $self->opts->$option());
          }
        } elsif ($spec eq $option) {
          push(@restart_opts, sprintf "--%s", $option);
        }
      }
    }
    if ($self->opts->runas && ($> == 0)) {
      # Ja, es gibt so Narrische, die gehen mit check_by_ssh als root
      # auf Datenbankmaschinen drauf und lassen dann dort check_oracle_health
      # laufen. Damit OPS$-Anmeldung dann funktioniert, wird mit --runas
      # auf eine andere Kennung umgeschwenkt. Diese Kennung gleich fuer
      # ssh zu verwenden geht aus Sicherheitsgruenden nicht. Narrische halt.
      exec "su", "-c", sprintf("%s %s", $0, join(" ", @restart_opts)), "-", $self->opts->runas;
    } elsif ($self->opts->runas) {
      exec "sudo", "-S", "-u", $self->opts->runas, $0, @restart_opts;
    } else {
      exec $0, @restart_opts;
      # dadurch werden SHLIB oder LD_LIBRARY_PATH sauber gesetzt, damit beim
      # erneuten Start libclntsh.so etc. gefunden werden.
    }
    exit;
  }
  if ($self->opts->shell) {
    # So komme ich bei den Narrischen zu einer root-Shell.
    system("/bin/sh");
  }
}


sub add_ok {
  my ($self, $message) = @_;
  $message ||= $self->{info};
  $self->add_message(OK, $message);
}

sub add_warning {
  my ($self, $message) = @_;
  $message ||= $self->{info};
  $self->add_message(WARNING, $message);
}

sub add_critical {
  my ($self, $message) = @_;
  $message ||= $self->{info};
  $self->add_message(CRITICAL, $message);
}

sub add_unknown {
  my ($self, $message) = @_;
  $message ||= $self->{info};
  $self->add_message(UNKNOWN, $message);
}

sub add_ok_mitigation {
  my ($self, $message) = @_;
  if (defined $self->opts->mitigation()) {
    $self->add_message($self->opts->mitigation(), $message);
  } else {
    $self->add_ok($message);
  }
}

sub add_warning_mitigation {
  my ($self, $message) = @_;
  if (defined $self->opts->mitigation()) {
    $self->add_message($self->opts->mitigation(), $message);
  } else {
    $self->add_warning($message);
  }
}

sub add_critical_mitigation {
  my ($self, $message) = @_;
  if (defined $self->opts->mitigation()) {
    $self->add_message($self->opts->mitigation(), $message);
  } else {
    $self->add_critical($message);
  }
}

sub add_unknown_mitigation {
  my ($self, $message) = @_;
  if (defined $self->opts->mitigation()) {
    $self->add_message($self->opts->mitigation(), $message);
  } else {
    $self->add_unknown($message);
  }
}

sub add_message {
  my ($self, $level, $message) = @_;
  $message ||= $self->{info};
  $Monitoring::GLPlugin::plugin->add_message($level, $message)
      unless $self->is_blacklisted();
  if (exists $self->{failed}) {
    if ($level == UNKNOWN && $self->{failed} == OK) {
      $self->{failed} = $level;
    } elsif ($level > $self->{failed}) {
      $self->{failed} = $level;
    }
  }
}

sub clear_ok {
  my ($self) = @_;
  $self->clear_messages(OK);
}

sub clear_warning {
  my ($self) = @_;
  $self->clear_messages(WARNING);
}

sub clear_critical {
  my ($self) = @_;
  $self->clear_messages(CRITICAL);
}

sub clear_unknown {
  my ($self) = @_;
  $self->clear_messages(UNKNOWN);
}

sub clear_all { # deprecated, use clear_messages
  my ($self) = @_;
  $self->clear_ok();
  $self->clear_warning();
  $self->clear_critical();
  $self->clear_unknown();
}

sub set_level {
  my ($self, $code) = @_;
  $code = (qw(ok warning critical unknown))[$code] if $code =~ /^\d+$/;
  $code = lc $code;
  if (! exists $self->{tmp_level}) {
    $self->{tmp_level} = {
      ok => 0,
      warning => 0,
      critical => 0,
      unknown => 0,
    };
  }
  $self->{tmp_level}->{$code}++;
}

sub get_level {
  my ($self) = @_;
  return OK if ! exists $self->{tmp_level};
  my $code = OK;
  $code ||= CRITICAL if $self->{tmp_level}->{critical};
  $code ||= WARNING  if $self->{tmp_level}->{warning};
  $code ||= UNKNOWN  if $self->{tmp_level}->{unknown};
  return $code;
}

#########################################################
# blacklisting
#
sub blacklist {
  my ($self) = @_;
  $self->{blacklisted} = 1;
}

sub add_blacklist {
  my ($self, $list) = @_;
  $Monitoring::GLPlugin::blacklist = join('/',
      (split('/', $self->opts->blacklist), $list));
}

sub is_blacklisted {
  my ($self) = @_;
  if (! $self->opts->can("blacklist")) {
    return 0;
  }
  if (! exists $self->{blacklisted}) {
    $self->{blacklisted} = 0;
  }
  if (exists $self->{blacklisted} && $self->{blacklisted}) {
    return $self->{blacklisted};
  }
  # FAN:459,203/TEMP:102229/ENVSUBSYSTEM
  # FAN_459,FAN_203,TEMP_102229,ENVSUBSYSTEM
  if ($self->opts->blacklist =~ /_/) {
    foreach my $bl_item (split(/,/, $self->opts->blacklist)) {
      if ($bl_item eq $self->internal_name()) {
        $self->{blacklisted} = 1;
      }
    }
  } else {
    foreach my $bl_items (split(/\//, $self->opts->blacklist)) {
      if ($bl_items =~ /^(\w+):([\:\d\-,]+)$/) {
        my $bl_type = $1;
        my $bl_names = $2;
        foreach my $bl_name (split(/,/, $bl_names)) {
          if ($bl_type."_".$bl_name eq $self->internal_name()) {
            $self->{blacklisted} = 1;
          }
        }
      } elsif ($bl_items =~ /^(\w+)$/) {
        if ($bl_items eq $self->internal_name()) {
          $self->{blacklisted} = 1;
        }
      }
    }
  }
  return $self->{blacklisted};
}

#########################################################
# additional info
#
sub add_info {
  my ($self, $info) = @_;
  $info = $self->is_blacklisted() ? $info.' (blacklisted)' : $info;
  $self->{info} = $info;
  push(@{$Monitoring::GLPlugin::info}, $info);
}

sub annotate_info {
  my ($self, $annotation) = @_;
  my $lastinfo = pop(@{$Monitoring::GLPlugin::info});
  $lastinfo .= sprintf ' (%s)', $annotation;
  $self->{info} = $lastinfo;
  push(@{$Monitoring::GLPlugin::info}, $lastinfo);
}

sub add_extendedinfo {  # deprecated
  my ($self, $info) = @_;
  $self->{extendedinfo} = $info;
  return if ! $self->opts->extendedinfo;
  push(@{$Monitoring::GLPlugin::extendedinfo}, $info);
}

sub get_info {
  my ($self, $separator) = @_;
  $separator ||= ' ';
  return join($separator , @{$Monitoring::GLPlugin::info});
}

sub get_last_info {
  my ($self) = @_;
  return pop(@{$Monitoring::GLPlugin::info});
}

sub get_extendedinfo {
  my ($self, $separator) = @_;
  $separator ||= ' ';
  return join($separator, @{$Monitoring::GLPlugin::extendedinfo});
}

sub add_summary {  # deprecated
  my ($self, $summary) = @_;
  push(@{$Monitoring::GLPlugin::summary}, $summary);
}

sub get_summary {
  my ($self) = @_;
  return join(', ', @{$Monitoring::GLPlugin::summary});
}

#########################################################
# persistency
#
sub valdiff {
  my ($self, $pparams, @keys) = @_;
  my %params = %{$pparams};
  my $now = time;
  my $newest_history_set = {};
  $params{freeze} = 0 if ! $params{freeze};
  my $mode = "normal";
  if ($self->opts->lookback && $self->opts->lookback == 99999 && $params{freeze} == 0) {
    $mode = "lookback_freeze_chill";
  } elsif ($self->opts->lookback && $self->opts->lookback == 99999 && $params{freeze} == 1) {
    $mode = "lookback_freeze_shockfrost";
  } elsif ($self->opts->lookback && $self->opts->lookback == 99999 && $params{freeze} == 2) {
    $mode = "lookback_freeze_defrost";
  } elsif ($self->opts->lookback) {
    $mode = "lookback";
  }
  # lookback=99999, freeze=0(default)
  #  nimm den letzten lauf und schreib ihn nach {cold}
  #  vergleich dann
  #    wenn es frozen gibt, vergleich frozen und den letzten lauf
  #    sonst den letzten lauf und den aktuellen lauf
  # lookback=99999, freeze=1
  #  wird dann aufgerufen,wenn nach dem freeze=0 ein problem festgestellt wurde
  #     (also als 2.valdiff hinterher)
  #  schreib cold nach frozen
  # lookback=99999, freeze=2
  #  wird dann aufgerufen,wenn nach dem freeze=0 wieder alles ok ist
  #     (also als 2.valdiff hinterher)
  #  loescht frozen
  #
  my $last_values = $self->load_state(%params) || eval {
    my $empty_events = {};
    foreach (@keys) {
      if (ref($self->{$_}) eq "ARRAY") {
        $empty_events->{$_} = [];
      } else {
        $empty_events->{$_} = 0;
      }
    }
    $empty_events->{timestamp} = 0;
    if ($mode eq "lookback") {
      $empty_events->{lookback_history} = {};
    } elsif ($mode eq "lookback_freeze_chill") {
      $empty_events->{cold} = {};
      $empty_events->{frozen} = {};
    }
    $empty_events;
  };
  $self->{'delta_timestamp'} = $now - $last_values->{timestamp};
  foreach (@keys) {
    if ($mode eq "lookback_freeze_chill") {
      # die werte vom letzten lauf wegsichern.
      # vielleicht gibts gleich einen freeze=1, dann muessen die eingefroren werden
      if (exists $last_values->{$_}) {
        if (ref($self->{$_}) eq "ARRAY") {
          $last_values->{cold}->{$_} = [];
          foreach my $value (@{$last_values->{$_}}) {
            push(@{$last_values->{cold}->{$_}}, $value);
          }
        } else {
          $last_values->{cold}->{$_} = $last_values->{$_};
        }
      } else {
        if (ref($self->{$_}) eq "ARRAY") {
          $last_values->{cold}->{$_} = [];
        } else {
          $last_values->{cold}->{$_} = 0;
        }
      }
      # es wird so getan, als sei der frozen wert vom letzten lauf
      if (exists $last_values->{frozen}->{$_}) {
        if (ref($self->{$_}) eq "ARRAY") {
          $last_values->{$_} = [];
          foreach my $value (@{$last_values->{frozen}->{$_}}) {
            push(@{$last_values->{$_}}, $value);
          }
        } else {
          $last_values->{$_} = $last_values->{frozen}->{$_};
        }
      }
    } elsif ($mode eq "lookback") {
      # find a last_value in the history which fits lookback best
      # and overwrite $last_values->{$_} with historic data
      if (exists $last_values->{lookback_history}->{$_}) {
        foreach my $date (sort {$a <=> $b} keys %{$last_values->{lookback_history}->{$_}}) {
            $newest_history_set->{$_} = $last_values->{lookback_history}->{$_}->{$date};
            $newest_history_set->{timestamp} = $date;
        }
        foreach my $date (sort {$a <=> $b} keys %{$last_values->{lookback_history}->{$_}}) {
          if ($date >= ($now - $self->opts->lookback)) {
            $last_values->{$_} = $last_values->{lookback_history}->{$_}->{$date};
            $last_values->{timestamp} = $date;
            $self->{'delta_timestamp'} = $now - $last_values->{timestamp};
            if (ref($last_values->{$_}) eq "ARRAY") {
              $self->debug(sprintf "oldest value of %s within lookback is size %s (age %d)",
                  $_, scalar(@{$last_values->{$_}}), $now - $date);
            } else {
              $self->debug(sprintf "oldest value of %s within lookback is %s (age %d)",
                  $_, $last_values->{$_}, $now - $date);
            }
            last;
          } else {
            $self->debug(sprintf "deprecate %s of age %d", $_, time - $date);
            delete $last_values->{lookback_history}->{$_}->{$date};
          }
        }
      }
    }
    if ($mode eq "normal" || $mode eq "lookback" || $mode eq "lookback_freeze_chill") {
      if ($self->{$_} =~ /^\d+\.*\d*$/) {
        $last_values->{$_} = 0 if ! exists $last_values->{$_};
        if ($self->{$_} >= $last_values->{$_}) {
          $self->{'delta_'.$_} = $self->{$_} - $last_values->{$_};
        } elsif ($self->{$_} eq $last_values->{$_}) {
          # dawischt! in einem fall wurde 131071.999023438 >= 131071.999023438 da oben nicht erkannt
          # subtrahieren ging auch daneben, weil ein winziger negativer wert rauskam.
          $self->{'delta_'.$_} = 0;
        } else {
          if ($mode =~ /lookback_freeze/) {
            # hier koennen delta-werte auch negativ sein, wenn z.b. peers verschwinden
            $self->{'delta_'.$_} = $self->{$_} - $last_values->{$_};
          } elsif (exists $params{lastarray}) {
            $self->{'delta_'.$_} = $self->{$_} - $last_values->{$_};
          } else {
            # vermutlich db restart und zaehler alle auf null
            $self->{'delta_'.$_} = $self->{$_};
          }
        }
        $self->debug(sprintf "delta_%s %f", $_, $self->{'delta_'.$_});
        $self->{$_.'_per_sec'} = $self->{'delta_timestamp'} ?
            $self->{'delta_'.$_} / $self->{'delta_timestamp'} : 0;
      } elsif (ref($self->{$_}) eq "ARRAY") {
        if ((! exists $last_values->{$_} || ! defined $last_values->{$_}) && exists $params{lastarray}) {
          # innerhalb der lookback-zeit wurde nichts in der lookback_history
          # gefunden. allenfalls irgendwas aelteres. normalerweise
          # wuerde jetzt das array als [] initialisiert.
          # d.h. es wuerde ein delta geben, @found s.u.
          # wenn man das nicht will, sondern einfach aktuelles array mit
          # dem array des letzten laufs vergleichen will, setzt man lastarray
          $last_values->{$_} = %{$newest_history_set} ?
              $newest_history_set->{$_} : []
        } elsif ((! exists $last_values->{$_} || ! defined $last_values->{$_}) && ! exists $params{lastarray}) {
          $last_values->{$_} = [] if ! exists $last_values->{$_};
        } elsif (exists $last_values->{$_} && ! defined $last_values->{$_}) {
          # $_ kann es auch ausserhalb des lookback_history-keys als normalen
          # key geben. der zeigt normalerweise auf den entspr. letzten
          # lookback_history eintrag. wurde der wegen ueberalterung abgeschnitten
          # ist der hier auch undef.
          $last_values->{$_} = %{$newest_history_set} ?
              $newest_history_set->{$_} : []
        }
        my %saved = map { $_ => 1 } @{$last_values->{$_}};
        my %current = map { $_ => 1 } @{$self->{$_}};
        my @found = grep(!defined $saved{$_}, @{$self->{$_}});
        my @lost = grep(!defined $current{$_}, @{$last_values->{$_}});
        $self->{'delta_found_'.$_} = \@found;
        $self->{'delta_lost_'.$_} = \@lost;
      }
    }
  }
  $params{save} = eval {
    my $empty_events = {};
    foreach (@keys) {
      $empty_events->{$_} = $self->{$_};
      if ($mode =~ /lookback_freeze/) {
        if (exists $last_values->{frozen}->{$_}) {
          if (ref($last_values->{frozen}->{$_}) eq "ARRAY") {
            @{$empty_events->{cold}->{$_}} = @{$last_values->{frozen}->{$_}};
          } else {
            $empty_events->{cold}->{$_} = $last_values->{frozen}->{$_};
          }
        } else {
          if (ref($last_values->{cold}->{$_}) eq "ARRAY") {
            @{$empty_events->{cold}->{$_}} = @{$last_values->{cold}->{$_}};
          } else {
            $empty_events->{cold}->{$_} = $last_values->{cold}->{$_};
          }
        }
        $empty_events->{cold}->{timestamp} = $last_values->{cold}->{timestamp};
      }
      if ($mode eq "lookback_freeze_shockfrost") {
        if (ref($empty_events->{cold}->{$_}) eq "ARRAY") {
          @{$empty_events->{frozen}->{$_}} = @{$empty_events->{cold}->{$_}};
        } else {
          $empty_events->{frozen}->{$_} = $empty_events->{cold}->{$_};
        }
        $empty_events->{frozen}->{timestamp} = $now;
      }
    }
    $empty_events->{timestamp} = $now;
    if ($mode eq "lookback") {
      $empty_events->{lookback_history} = $last_values->{lookback_history};
      foreach (@keys) {
        if (ref($self->{$_}) eq "ARRAY") {
          @{$empty_events->{lookback_history}->{$_}->{$now}} = @{$self->{$_}};
        } else {
          $empty_events->{lookback_history}->{$_}->{$now} = $self->{$_};
        }
      }
    }
    if ($mode eq "lookback_freeze_defrost") {
      delete $empty_events->{freeze};
    }
    $empty_events;
  };
  $self->save_state(%params);
}

sub create_statefilesdir {
  my ($self) = @_;
  if (! -d $self->statefilesdir()) {
    eval {
      use File::Path;
      mkpath $self->statefilesdir();
    };
    if ($@ || ! -w $self->statefilesdir()) {
      $self->add_message(UNKNOWN,
        sprintf "cannot create status dir %s! check your filesystem (permissions/usage/integrity) and disk devices", $self->statefilesdir());
    }
  } elsif (! -w $self->statefilesdir()) {
    $self->add_message(UNKNOWN,
        sprintf "cannot write status dir %s! check your filesystem (permissions/usage/integrity) and disk devices", $self->statefilesdir());
  }
}

sub create_statefile {
  my ($self, %params) = @_;
  my $extension = "";
  $extension .= $params{name} ? '_'.$params{name} : '';
  $extension =~ s/\//_/g;
  $extension =~ s/\(/_/g;
  $extension =~ s/\)/_/g;
  $extension =~ s/\*/_/g;
  $extension =~ s/\s/_/g;
  return sprintf "%s/%s%s", $self->statefilesdir(),
      $self->clean_path($self->mode), $self->clean_path(lc $extension);
}

sub clean_path {
  my ($self, $path) = @_;
  if ($^O =~ /MSWin/) {
    $path =~ s/:/_/g;
  }
  return $path;
}

sub schimpf {
  my ($self) = @_;
  printf "statefilesdir %s is not writable.\nYou didn't run this plugin as root, didn't you?\n", $self->statefilesdir();
}

# $self->protect_value('1.1-flat_index', 'cpu_busy', 'percent');
sub protect_value {
  my ($self, $ident, $key, $validfunc) = @_;
  if (ref($validfunc) ne "CODE" && $validfunc eq "percent") {
    $validfunc = sub {
      my $value = shift;
      return 0 if $value !~ /^[-+]?([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
      return ($value < 0 || $value > 100) ? 0 : 1;
    };
  } elsif (ref($validfunc) ne "CODE" && $validfunc eq "positive") {
    $validfunc = sub {
      my $value = shift;
      return 0 if $value !~ /^[-+]?([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
      return ($value < 0) ? 0 : 1;
    };
  }
  if (&$validfunc($self->{$key})) {
    $self->save_state(name => 'protect_'.$ident.'_'.$key, save => {
        $key => $self->{$key},
        exception => 0,
    });
  } else {
    # if the device gives us an clearly wrong value, simply use the last value.
    my $laststate = $self->load_state(name => 'protect_'.$ident.'_'.$key);
    $self->debug(sprintf "self->{%s} is %s and invalid for the %dth time",
        $key, $self->{$key}, $laststate->{exception} + 1);
    if ($laststate->{exception} <= 5) {
      # but only 5 times.
      # if the error persists, somebody has to check the device.
      $self->{$key} = $laststate->{$key};
    }
    $self->save_state(name => 'protect_'.$ident.'_'.$key, save => {
        $key => $laststate->{$key},
        exception => ++$laststate->{exception},
    });
  }
}

sub save_state {
  my ($self, %params) = @_;
  $self->create_statefilesdir();
  my $statefile = $self->create_statefile(%params);
  my $tmpfile = $self->statefilesdir().'/check__health_tmp_'.$$;
  if ((ref($params{save}) eq "HASH") && exists $params{save}->{timestamp}) {
    $params{save}->{localtime} = scalar localtime $params{save}->{timestamp};
  }
  my $seekfh = IO::File->new();
  if ($seekfh->open($tmpfile, "w")) {
    $seekfh->printf("%s", Data::Dumper::Dumper($params{save}));
    $seekfh->flush();
    $seekfh->close();
    $self->debug(sprintf "saved %s to %s",
        Data::Dumper::Dumper($params{save}), $statefile);
  }
  if (! rename $tmpfile, $statefile) {
    $self->add_message(UNKNOWN,
        sprintf "cannot write status file %s! check your filesystem (permissions/usage/integrity) and disk devices", $statefile);
  }
}

sub load_state {
  my ($self, %params) = @_;
  my $statefile = $self->create_statefile(%params);
  if ( -f $statefile) {
    our $VAR1;
    eval {
      delete $INC{$statefile} if exists $INC{$statefile}; # else unit tests fail
      require $statefile;
    };
    if($@) {
      printf "rumms\n";
    }
    $self->debug(sprintf "load %s from %s", Data::Dumper::Dumper($VAR1), $statefile);
    return $VAR1;
  } else {
    return undef;
  }
}

#########################################################
# daemon mode
#
sub check_pidfile {
  my ($self) = @_;
  my $fh = IO::File->new();
  if ($fh->open($self->{pidfile}, "r")) {
    my $pid = $fh->getline();
    $fh->close();
    if (! $pid) {
      $self->debug("Found pidfile %s with no valid pid. Exiting.",
          $self->{pidfile});
      return 0;
    } else {
      $self->debug("Found pidfile %s with pid %d", $self->{pidfile}, $pid);
      kill 0, $pid;
      if ($! == Errno::ESRCH) {
        $self->debug("This pidfile is stale. Writing a new one");
        $self->write_pidfile();
        return 1;
      } else {
        $self->debug("This pidfile is held by a running process. Exiting");
        return 0;
      }
    }
  } else {
    $self->debug("Found no pidfile. Writing a new one");
    $self->write_pidfile();
    return 1;
  }
}

sub write_pidfile {
  my ($self) = @_;
  if (! -d dirname($self->{pidfile})) {
    eval "require File::Path;";
    if (defined(&File::Path::mkpath)) {
      import File::Path;
      eval { mkpath(dirname($self->{pidfile})); };
    } else {
      my @dirs = ();
      map {
          push @dirs, $_;
          mkdir(join('/', @dirs))
              if join('/', @dirs) && ! -d join('/', @dirs);
      } split(/\//, dirname($self->{pidfile}));
    }
  }
  my $fh = IO::File->new();
  $fh->autoflush(1);
  if ($fh->open($self->{pidfile}, "w")) {
    $fh->printf("%s", $$);
    $fh->close();
  } else {
    $self->debug("Could not write pidfile %s", $self->{pidfile});
    die "pid file could not be written";
  }
}

sub system_vartmpdir {
  my ($self) = @_;
  if ($^O =~ /MSWin/) {
    return $self->system_tmpdir();
  } else {
    return "/var/tmp/".$Monitoring::GLPlugin::pluginname;
  }
}

sub system_tmpdir {
  my ($self) = @_;
  if ($^O =~ /MSWin/) {
    return $ENV{TEMP} if defined $ENV{TEMP};
    return $ENV{TMP} if defined $ENV{TMP};
    return File::Spec->catfile($ENV{windir}, 'Temp')
        if defined $ENV{windir};
    return 'C:\Temp';
  } else {
    return "/tmp";
  }
}

sub convert_scientific_numbers {
  my ($self, $n) = @_;
  # mostly used to convert numbers in scientific notation
  if ($n =~ /^\s*\d+\s*$/) {
    return $n;
  } elsif ($n =~ /^\s*([-+]?)(\d*[\.,]*\d*)[eE]{1}([-+]?)(\d+)\s*$/) {
    my ($vor, $num, $sign, $exp) = ($1, $2, $3, $4);
    $n =~ s/E/e/g;
    $n =~ s/,/\./g;
    $num =~ s/,/\./g;
    my $sig = $sign eq '-' ? "." . ($exp - 1 + length $num) : '';
    my $dec = sprintf "%${sig}f", $n;
    $dec =~ s/\.[0]+$//g;
    return $dec;
  } elsif ($n =~ /^\s*([-+]?)(\d+)[\.,]*(\d*)\s*$/) {
    return $1.$2.".".$3;
  } elsif ($n =~ /^\s*(.*?)\s*$/) {
    return $1;
  } else {
    return $n;
  }
}

sub compatibility_methods {
  my ($self) = @_;
  # add_perfdata
  # add_message
  # nagios_exit
  # ->{warningrange}
  # ->{criticalrange}
  # ...
  $self->{warningrange} = ($self->get_thresholds())[0];
  $self->{criticalrange} = ($self->get_thresholds())[1];
  my $old_init = $self->can('init');
  my %params = (
    'mode' => join('::', split(/-/, $self->opts->mode)),
    'name' => $self->opts->name,
    'name2' => $self->opts->name2,
  );
  {
    no strict 'refs';
    no warnings 'redefine';
    *{ref($self).'::init'} = sub {
      $self->$old_init(%params);
      $self->nagios(%params);
    };
    *{ref($self).'::add_nagios'} = \&{"Monitoring::GLPlugin::add_message"};
    *{ref($self).'::add_nagios_ok'} = \&{"Monitoring::GLPlugin::add_ok"};
    *{ref($self).'::add_nagios_warning'} = \&{"Monitoring::GLPlugin::add_warning"};
    *{ref($self).'::add_nagios_critical'} = \&{"Monitoring::GLPlugin::add_critical"};
    *{ref($self).'::add_nagios_unknown'} = \&{"Monitoring::GLPlugin::add_unknown"};
    *{ref($self).'::add_perfdata'} = sub {
      my $self = shift;
      my $message = shift;
      foreach my $perfdata (split(/\s+/, $message)) {
      my ($label, $perfstr) = split(/=/, $perfdata);
      my ($value, $warn, $crit, $min, $max) = split(/;/, $perfstr);
      $value =~ /^([\d\.\-\+]+)(.*)$/;
      $value = $1;
      my $uom = $2;
      $Monitoring::GLPlugin::plugin->add_perfdata(
        label => $label,
        value => $value,
        uom => $uom,
        warn => $warn,
        crit => $crit,
        min => $min,
        max => $max,
      );
      }
    };
    *{ref($self).'::check_thresholds'} = sub {
      my $self = shift;
      my $value = shift;
      my $defaultwarningrange = shift;
      my $defaultcriticalrange = shift;
      $Monitoring::GLPlugin::plugin->set_thresholds(
          metric => 'default',
          warning => $defaultwarningrange,
          critical => $defaultcriticalrange,
      );
      $self->{warningrange} = ($self->get_thresholds())[0];
      $self->{criticalrange} = ($self->get_thresholds())[1];
      return $Monitoring::GLPlugin::plugin->check_thresholds(
          metric => 'default',
          value => $value,
          warning => $defaultwarningrange,
          critical => $defaultcriticalrange,
      );
    };
  }
}


sub AUTOLOAD {
  my ($self, @params) = @_;
  return if ($AUTOLOAD =~ /DESTROY/);
  $self->debug("AUTOLOAD %s\n", $AUTOLOAD)
        if $self->opts->verbose >= 2;
  if ($AUTOLOAD =~ /^(.*)::analyze_and_check_(.*)_subsystem$/) {
    my $class = $1;
    my $subsystem = $2;
    my $analyze = sprintf "analyze_%s_subsystem", $subsystem;
    my $check = sprintf "check_%s_subsystem", $subsystem;
    if (@params) {
      # analyzer class
      my $subsystem_class = shift @params;
      $self->{components}->{$subsystem.'_subsystem'} = $subsystem_class->new();
      $self->debug(sprintf "\$self->{components}->{%s_subsystem} = %s->new()",
          $subsystem, $subsystem_class);
    } else {
      $self->$analyze();
      $self->debug("call %s()", $analyze);
    }
    $self->$check();
  } elsif ($AUTOLOAD =~ /^(.*)::check_(.*)_subsystem$/) {
    my $class = $1;
    my $subsystem = sprintf "%s_subsystem", $2;
    $self->{components}->{$subsystem}->check();
    $self->{components}->{$subsystem}->dump()
        if $self->opts->verbose >= 2;
  } elsif ($AUTOLOAD =~ /^.*::(status_code|check_messages|nagios_exit|html_string|perfdata_string|selected_perfdata|check_thresholds|get_thresholds|opts|pandora_string)$/) {
    return $Monitoring::GLPlugin::plugin->$1(@params);
  } elsif ($AUTOLOAD =~ /^.*::(reduce_messages|reduce_messages_short|clear_messages|suppress_messages|add_html|add_perfdata|override_opt|create_opt|set_thresholds|force_thresholds|add_pandora)$/) {
    $Monitoring::GLPlugin::plugin->$1(@params);
  } elsif ($AUTOLOAD =~ /^.*::mod_arg_(.*)$/) {
    return $Monitoring::GLPlugin::plugin->mod_arg($1, @params);
  } else {
    $self->debug("AUTOLOAD: class %s has no method %s\n",
        ref($self), $AUTOLOAD);
  }
}



package Monitoring::GLPlugin::Item;
our @ISA = qw(Monitoring::GLPlugin);

use strict;

sub new {
  my ($class, %params) = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub check {
  my ($self, $lists) = @_;
  my @lists = $lists ? @{$lists} : grep { ref($self->{$_}) eq "ARRAY" } keys %{$self};
  foreach my $list (@lists) {
    $self->add_info('checking '.$list);
    foreach my $element (@{$self->{$list}}) {
      $element->blacklist() if $self->is_blacklisted();
      $element->check();
    }
  }
}



package Monitoring::GLPlugin::TableItem;
our @ISA = qw(Monitoring::GLPlugin::Item);

use strict;

sub new {
  my ($class, %params) = @_;
  my $self = {};
  bless $self, $class;
  foreach (keys %params) {
    $self->{$_} = $params{$_};
  }
  if ($self->can("finish")) {
    $self->finish(%params);
  }
  return $self;
}

sub check {
  my ($self) = @_;
  # some tableitems are not checkable, they are only used to enhance other
  # items (e.g. sensorthresholds enhance sensors)
  # normal tableitems should have their own check-method
}



package Monitoring::GLPlugin::SNMP;
our @ISA = qw(Monitoring::GLPlugin);
# ABSTRACT: helper functions to build a snmp-based monitoring plugin

use strict;
use File::Basename;
use Digest::MD5 qw(md5_hex);
use Module::Load;
use AutoLoader;
our $AUTOLOAD;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

{
  our $mode = undef;
  our $plugin = undef;
  our $blacklist = undef;
  our $session = undef;
  our $rawdata = {};
  our $tablecache = {};
  our $info = [];
  our $extendedinfo = [];
  our $summary = [];
  our $oidtrace = [];
  our $uptime = 0;
}

sub new {
  my ($class, %params) = @_;
  require Monitoring::GLPlugin
      if ! grep /BEGIN/, keys %Monitoring::GLPlugin::;
  require Monitoring::GLPlugin::SNMP::MibsAndOids
      if ! grep /BEGIN/, keys %Monitoring::GLPlugin::SNMP::MibsAndOids::;
  require Monitoring::GLPlugin::SNMP::CSF
      if ! grep /BEGIN/, keys %Monitoring::GLPlugin::SNMP::CSF::;
  require Monitoring::GLPlugin::SNMP::Item
      if ! grep /BEGIN/, keys %Monitoring::GLPlugin::SNMP::Item::;
  require Monitoring::GLPlugin::SNMP::TableItem
      if ! grep /BEGIN/, keys %Monitoring::GLPlugin::SNMP::TableItem::;
  my $self = Monitoring::GLPlugin->new(%params);
  bless $self, $class;
  return $self;
}

sub v2tov3 {
  my ($self) = @_;
  if ($self->opts->community && $self->opts->community =~ /^snmpv3(.)(.+)/) {
    my $separator = $1;
    my ($authprotocol, $authpassword, $privprotocol, $privpassword,
        $username, $contextengineid, $contextname) = split(/$separator/, $2);
    $self->override_opt('authprotocol', $authprotocol) 
        if defined($authprotocol) && $authprotocol;
    $self->override_opt('authpassword', $authpassword) 
        if defined($authpassword) && $authpassword;
    $self->override_opt('privprotocol', $privprotocol) 
        if defined($privprotocol) && $privprotocol;
    $self->override_opt('privpassword', $privpassword) 
        if defined($privpassword) && $privpassword;
    $self->override_opt('username', $username) 
        if defined($username) && $username;
    $self->override_opt('contextengineid', $contextengineid) 
        if defined($contextengineid) && $contextengineid;
    $self->override_opt('contextname', $contextname) 
        if defined($contextname) && $contextname;
    $self->override_opt('protocol', '3') ;
  }
  if (($self->opts->authpassword || $self->opts->authprotocol ||
      $self->opts->privpassword || $self->opts->privprotocol) && 
      $self->opts->protocol ne '3') {
    $self->override_opt('protocol', '3') ;
  }
}

sub add_snmp_modes {
  my ($self) = @_;
  $self->add_mode(
      internal => 'device::uptime',
      spec => 'uptime',
      alias => undef,
      help => 'Check the uptime of the device',
  );
  $self->add_mode(
      internal => 'device::walk',
      spec => 'walk',
      alias => undef,
      help => 'Show snmpwalk command with the oids necessary for a simulation',
  );
  $self->add_mode(
      internal => 'device::walkbulk',
      spec => 'bulkwalk',
      alias => undef,
      help => 'Show snmpbulkwalk command with the oids necessary for a simulation',
      hidden => 1,
  );
  $self->add_mode(
      internal => 'device::supportedmibs',
      spec => 'supportedmibs',
      alias => undef,
      help => 'Shows the names of the mibs which this devices has implemented (only lausser may run this command)',
  );
  $self->add_mode(
      internal => 'device::supportedoids',
      spec => 'supportedoids',
      alias => undef,
      help => 'Shows the names of the oids which this devices has implemented (only lausser may run this command)',
  );
}

sub add_snmp_args {
  my ($self) = @_;
  $self->add_arg(
      spec => 'hostname|H=s',
      help => '--hostname
   Hostname or IP-address of the switch or router',
      required => 0,
      env => 'HOSTNAME',
  );
  $self->add_arg(
      spec => 'port=i',
      help => '--port
   The SNMP port to use (default: 161)',
      required => 0,
      default => 161,
  );
  $self->add_arg(
      spec => 'domain=s',
      help => '--domain
   The transport domain to use (default: udp/ipv4, other possible values: udp6, udp/ipv6, tcp, tcp4, tcp/ipv4, tcp6, tcp/ipv6)',
      required => 0,
      default => 'udp',
  );
  $self->add_arg(
      spec => 'protocol|P=s',
      help => '--protocol
   The SNMP protocol to use (default: 2c, other possibilities: 1,3)',
      required => 0,
      default => '2c',
  );
  $self->add_arg(
      spec => 'community|C=s',
      help => '--community
   SNMP community of the server (SNMP v1/2 only)',
      required => 0,
      default => 'public',
  );
  $self->add_arg(
      spec => 'username:s',
      help => '--username
   The securityName for the USM security model (SNMPv3 only)',
      required => 0,
  );
  $self->add_arg(
      spec => 'authpassword:s',
      help => '--authpassword
   The authentication password for SNMPv3',
      required => 0,
  );
  $self->add_arg(
      spec => 'authprotocol:s',
      help => '--authprotocol
   The authentication protocol for SNMPv3 (md5|sha)',
      required => 0,
  );
  $self->add_arg(
      spec => 'privpassword:s',
      help => '--privpassword
   The password for authPriv security level',
      required => 0,
  );
  $self->add_arg(
      spec => 'privprotocol=s',
      help => '--privprotocol
   The private protocol for SNMPv3 (des|aes|aes128|3des|3desde)',
      required => 0,
  );
  $self->add_arg(
      spec => 'contextengineid=s',
      help => '--contextengineid
   The context engine id for SNMPv3 (10 to 64 hex characters)',
      required => 0,
  );
  $self->add_arg(
      spec => 'contextname=s',
      help => '--contextname
   The context name for SNMPv3 (empty represents the "default" context)',
      required => 0,
  );
  $self->add_arg(
      spec => 'community2=s',
      help => '--community2
   SNMP community which can be used to switch the context during runtime',
      required => 0,
  );
  $self->add_arg(
      spec => 'snmpwalk=s',
      help => '--snmpwalk
   A file with the output of a snmpwalk (used for simulation)
   Use it instead of --hostname',
      required => 0,
      env => 'SNMPWALK',
  );
  $self->add_arg(
      spec => 'servertype=s',
      help => '--servertype
     The type of the network device: cisco (default). Use it if auto-detection
     is not possible',
      required => 0,
  );
  $self->add_arg(
      spec => 'oids=s',
      help => '--oids
   A list of oids which are downloaded and written to a cache file.
   Use it together with --mode oidcache',
      required => 0,
  );
  $self->add_arg(
      spec => 'offline:i',
      help => '--offline
   The maximum number of seconds since the last update of cache file before
   it is considered too old',
      required => 0,
      env => 'OFFLINE',
  );
}

sub validate_args {
  my ($self) = @_;
  $self->SUPER::validate_args();
  if ($self->opts->mode =~ /^walk/) {
    if ($self->opts->snmpwalk && $self->opts->hostname) {
      if ($self->check_messages == CRITICAL) {
        # gemecker vom super-validierer, der sicherstellt, dass die datei
        # snmpwalk existiert. in diesem fall wird sie aber erst neu angelegt,
        # also schnauze.
        my ($code, $message) = $self->check_messages;
        if ($message eq sprintf("file %s not found", $self->opts->snmpwalk)) {
          $self->clear_critical;
        }
      }
      # snmp agent wird abgefragt, die ergebnisse landen in einem file
      # opts->snmpwalk ist der filename. da sich die ganzen get_snmp_table/object-aufrufe
      # an das walkfile statt an den agenten halten wuerden, muss opts->snmpwalk geloescht
      # werden. stattdessen wird opts->snmpdump als traeger des dateinamens mitgegeben.
      # nur sinnvoll mit mode=walk
      $self->create_opt('snmpdump');
      $self->override_opt('snmpdump', $self->opts->snmpwalk);
      $self->override_opt('snmpwalk', undef);
    } elsif (! $self->opts->snmpwalk && $self->opts->hostname && $self->opts->mode eq 'walk') {   
      # snmp agent wird abgefragt, die ergebnisse landen in einem file, dessen name
      # nicht vorgegeben ist
      $self->create_opt('snmpdump');
    }
  } else {    
    if ($self->opts->snmpwalk && ! $self->opts->hostname) {
      # normaler aufruf, mode != walk, oid-quelle ist eine datei
      $self->override_opt('hostname', 'snmpwalk.file'.md5_hex($self->opts->snmpwalk))
    } elsif ($self->opts->snmpwalk && $self->opts->hostname) {
      # snmpwalk hat vorrang
      $self->override_opt('hostname', undef);
    }
  }
}

sub init {
  my ($self) = @_;
  if ($self->mode =~ /device::walk/) {
    my @trees = ();
    my $name = $Monitoring::GLPlugin::pluginname;
    $name =~ s/.*\///g;
    $name = sprintf "/tmp/snmpwalk_%s_%s", $name, $self->opts->hostname;
    if ($self->opts->oids) {
      # create pid filename
      # already running?;x
      @trees = split(",", $self->opts->oids);

    } elsif ($self->can("trees")) {
      @trees = $self->trees;
      push(@trees, "1.3.6.1.2.1.1");
    } else {
      @trees = ("1.3.6.1.2.1", "1.3.6.1.4.1");
    }
    if ($self->opts->snmpdump) {
      $name = $self->opts->snmpdump;
    }
    $self->opts->override_opt("protocol", $1) if $self->opts->protocol =~ /^v(.*)/;
    if (defined $self->opts->offline) {
      $self->{pidfile} = $name.".pid";
      if (! $self->check_pidfile()) {
        $self->debug("Exiting because another walk is already running");
        printf STDERR "Exiting because another walk is already running\n";
        exit 3;
      }
      $self->write_pidfile();
      my $timedout = 0;
      my $snmpwalkpid = 0;
      $SIG{'ALRM'} = sub {
        $timedout = 1;
        printf "UNKNOWN - %s timed out after %d seconds\n",
            $Monitoring::GLPlugin::plugin->{name}, $self->opts->timeout;
        kill 9, $snmpwalkpid;
      };
      alarm($self->opts->timeout);
      unlink $name.".partial";
      while (! $timedout && @trees) {
        my $tree = shift @trees;
        $SIG{CHLD} = 'IGNORE';
        my $cmd = sprintf "%s -ObentU -v%s -c %s %s %s >> %s",
            ($self->mode =~ /bulk/) ? "snmpbulkwalk" : "snmpwalk",
            $self->opts->protocol,
            $self->opts->community,
            $self->opts->hostname,
            $tree, $name.".partial";
        $self->debug($cmd);
        $snmpwalkpid = fork;
        if (not $snmpwalkpid) {
          exec($cmd);
        } else {
          wait();
        }
      }
      rename $name.".partial", $name if ! $timedout;
      -f $self->{pidfile} && unlink $self->{pidfile};
      if ($timedout) {
        printf "CRITICAL - timeout. There are still %d snmpwalks left\n", scalar(@trees);
        exit 3;
      } else {
        printf "OK - all requested oids are in %s\n", $name;
      }
    } else {
      printf "rm -f %s\n", $name;
      foreach (@trees) {
        printf "%s -ObentU -v%s -c %s %s %s >> %s\n",
            ($self->mode =~ /bulk/) ? "snmpbulkwalk -t 15 -r 20" : "snmpwalk",
            $self->opts->protocol,
            $self->opts->community,
            $self->opts->hostname,
            $_, $name;
      }
    }
    exit 0;
  } elsif ($self->mode =~ /device::uptime/) {
    $self->add_info(sprintf 'device is up since %s',
        $self->human_timeticks($self->{uptime}));
    $self->set_thresholds(warning => '15:', critical => '5:');
    $self->add_message($self->check_thresholds($self->{uptime} / 60));
    $self->add_perfdata(
        label => 'uptime',
        value => $self->{uptime} / 60,
        places => 0,
    );
    my ($code, $message) = $self->check_messages(join => ', ', join_all => ', ');
    $Monitoring::GLPlugin::plugin->nagios_exit($code, $message);
  } elsif ($self->mode =~ /device::supportedmibs/) {
    our $mibdepot = [];
    my $unknowns = {};
    my @outputlist = ();
    %{$unknowns} = %{$self->rawdata};
    if ($self->opts->name && -f $self->opts->name) {
      eval { require $self->opts->name };
      $self->add_critical($@) if $@;
    } elsif ($self->opts->name && ! -f $self->opts->name) {
      $self->add_unknown("where is --name mibdepotfile?");
    }
    push(@{$mibdepot}, ['1.3.6.1.2.1.60', 'ietf', 'v2', 'ACCOUNTING-CONTROL-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.238', 'ietf', 'v2', 'ADSL2-LINE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.238.2', 'ietf', 'v2', 'ADSL2-LINE-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.94.3', 'ietf', 'v2', 'ADSL-LINE-EXT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.94', 'ietf', 'v2', 'ADSL-LINE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.94.2', 'ietf', 'v2', 'ADSL-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.74', 'ietf', 'v2', 'AGENTX-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.3.123', 'ietf', 'v2', 'AGGREGATE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.118', 'ietf', 'v2', 'ALARM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16.23', 'ietf', 'v2', 'APM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.34.3', 'ietf', 'v2', 'APPC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.13.1', 'ietf', 'v1', 'APPLETALK-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.27', 'ietf', 'v2', 'APPLICATION-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.62', 'ietf', 'v2', 'APPLICATION-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.34.5', 'ietf', 'v2', 'APPN-DLUR-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.34.4', 'ietf', 'v2', 'APPN-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.34.4', 'ietf', 'v2', 'APPN-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.34.4.0', 'ietf', 'v2', 'APPN-TRAP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.49', 'ietf', 'v2', 'APS-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.117', 'ietf', 'v2', 'ARC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.37.1.14', 'ietf', 'v2', 'ATM2-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.59', 'ietf', 'v2', 'ATM-ACCOUNTING-INFORMATION-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.37', 'ietf', 'v2', 'ATM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.37', 'ietf', 'v2', 'ATM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.37.3', 'ietf', 'v2', 'ATM-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.15', 'ietf', 'v2', 'BGP4-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.15', 'ietf', 'v2', 'BGP4-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.3.122', 'ietf', 'v2', 'BLDG-HVAC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.17.1', 'ietf', 'v1', 'BRIDGE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.17', 'ietf', 'v2', 'BRIDGE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.19', 'ietf', 'v2', 'CHARACTER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.94', 'ietf', 'v2', 'CIRCUIT-IF-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.3.1.1', 'ietf', 'v1', 'CLNS-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.3.1.1', 'ietf', 'v1', 'CLNS-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.132', 'ietf', 'v2', 'COFFEE-POT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.89', 'ietf', 'v2', 'COPS-CLIENT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.18.1', 'ietf', 'v1', 'DECNET-PHIV-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.21', 'ietf', 'v2', 'DIAL-CONTROL-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.108', 'ietf', 'v2', 'DIFFSERV-CONFIG-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.97', 'ietf', 'v2', 'DIFFSERV-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.66', 'ietf', 'v2', 'DIRECTORY-SERVER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.88', 'ietf', 'v2', 'DISMAN-EVENT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.90', 'ietf', 'v2', 'DISMAN-EXPRESSION-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.82', 'ietf', 'v2', 'DISMAN-NSLOOKUP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.82', 'ietf', 'v2', 'DISMAN-NSLOOKUP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.80', 'ietf', 'v2', 'DISMAN-PING-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.80', 'ietf', 'v2', 'DISMAN-PING-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.63', 'ietf', 'v2', 'DISMAN-SCHEDULE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.63', 'ietf', 'v2', 'DISMAN-SCHEDULE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.64', 'ietf', 'v2', 'DISMAN-SCRIPT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.64', 'ietf', 'v2', 'DISMAN-SCRIPT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.81', 'ietf', 'v2', 'DISMAN-TRACEROUTE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.81', 'ietf', 'v2', 'DISMAN-TRACEROUTE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.46', 'ietf', 'v2', 'DLSW-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.32.2', 'ietf', 'v2', 'DNS-RESOLVER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.32.1', 'ietf', 'v2', 'DNS-SERVER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.127.5', 'ietf', 'v2', 'DOCS-BPI-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.69', 'ietf', 'v2', 'DOCS-CABLE-DEVICE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.69', 'ietf', 'v2', 'DOCS-CABLE-DEVICE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.126', 'ietf', 'v2', 'DOCS-IETF-BPI2-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.132', 'ietf', 'v2', 'DOCS-IETF-CABLE-DEVICE-NOTIFICATION-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.127', 'ietf', 'v2', 'DOCS-IETF-QOS-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.125', 'ietf', 'v2', 'DOCS-IETF-SUBMGT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.127', 'ietf', 'v2', 'DOCS-IF-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.127', 'ietf', 'v2', 'DOCS-IF-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.45', 'ietf', 'v2', 'DOT12-IF-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.53', 'ietf', 'v2', 'DOT12-RPTR-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.155', 'ietf', 'v2', 'DOT3-EPON-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.158', 'ietf', 'v2', 'DOT3-OAM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.4.1.2.2.1.1', 'ietf', 'v1', 'DPI20-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.82', 'ietf', 'v2', 'DS0BUNDLE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.81', 'ietf', 'v2', 'DS0-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.18', 'ietf', 'v2', 'DS1-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.18', 'ietf', 'v2', 'DS1-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.18', 'ietf', 'v2', 'DS1-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.30', 'ietf', 'v2', 'DS3-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.30', 'ietf', 'v2', 'DS3-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.29', 'ietf', 'v2', 'DSA-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16.26', 'ietf', 'v2', 'DSMON-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.34.7', 'ietf', 'v2', 'EBN-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.167', 'ietf', 'v2', 'EFM-CU-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.47', 'ietf', 'v2', 'ENTITY-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.47', 'ietf', 'v2', 'ENTITY-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.47', 'ietf', 'v2', 'ENTITY-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.99', 'ietf', 'v2', 'ENTITY-SENSOR-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.131', 'ietf', 'v2', 'ENTITY-STATE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.130', 'ietf', 'v2', 'ENTITY-STATE-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.70', 'ietf', 'v2', 'ETHER-CHIPSET-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.7', 'ietf', 'v1', 'EtherLike-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.7', 'ietf', 'v1', 'EtherLike-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.35', 'ietf', 'v2', 'EtherLike-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.35', 'ietf', 'v2', 'EtherLike-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.35', 'ietf', 'v2', 'EtherLike-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.35', 'ietf', 'v2', 'EtherLike-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.224', 'ietf', 'v2', 'FCIP-MGMT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.56', 'ietf', 'v2', 'FC-MGMT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.15.73.1', 'ietf', 'v1', 'FDDI-SMT73-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.75', 'ietf', 'v2', 'FIBRE-CHANNEL-FE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.111', 'ietf', 'v2', 'Finisher-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.40', 'ietf', 'v2', 'FLOW-METER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.40', 'ietf', 'v2', 'FLOW-METER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.32', 'ietf', 'v2', 'FRAME-RELAY-DTE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.86', 'ietf', 'v2', 'FR-ATM-PVC-SERVICE-IWF-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.47', 'ietf', 'v2', 'FR-MFR-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.44', 'ietf', 'v2', 'FRNETSERV-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.44', 'ietf', 'v2', 'FRNETSERV-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.44', 'ietf', 'v2', 'FRNETSERV-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.95', 'ietf', 'v2', 'FRSLD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.166.16', 'ietf', 'v2', 'GMPLS-LABEL-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.166.15', 'ietf', 'v2', 'GMPLS-LSR-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.166.12', 'ietf', 'v2', 'GMPLS-TC-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.166.13', 'ietf', 'v2', 'GMPLS-TE-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.98', 'ietf', 'v2', 'GSMP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16.29', 'ietf', 'v2', 'HC-ALARM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.107', 'ietf', 'v2', 'HC-PerfHist-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16.20.5', 'ietf', 'v2', 'HC-RMON-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.25.1', 'ietf', 'v1', 'HOST-RESOURCES-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.25.1', 'ietf', 'v2', 'HOST-RESOURCES-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.34.6.1.5', 'ietf', 'v2', 'HPR-IP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.34.6', 'ietf', 'v2', 'HPR-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.106', 'ietf', 'v2', 'IANA-CHARSET-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.110', 'ietf', 'v2', 'IANA-FINISHER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.152', 'ietf', 'v2', 'IANA-GMPLS-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.30', 'ietf', 'v2', 'IANAifType-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.128', 'ietf', 'v2', 'IANA-IPPM-METRICS-REGISTRY-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.119', 'ietf', 'v2', 'IANA-ITU-ALARM-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.154', 'ietf', 'v2', 'IANA-MAU-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.109', 'ietf', 'v2', 'IANA-PRINTER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.4.1.2.6.2.13.1.1', 'ietf', 'v1', 'IBM-6611-APPN-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.166', 'ietf', 'v2', 'IF-CAP-STACK-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.230', 'ietf', 'v2', 'IFCP-MGMT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.77', 'ietf', 'v2', 'IF-INVERTED-STACK-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.31', 'ietf', 'v2', 'IF-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.31', 'ietf', 'v2', 'IF-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.31', 'ietf', 'v2', 'IF-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.85', 'ietf', 'v2', 'IGMP-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.76', 'ietf', 'v2', 'INET-ADDRESS-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.76', 'ietf', 'v2', 'INET-ADDRESS-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.76', 'ietf', 'v2', 'INET-ADDRESS-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.52.5', 'ietf', 'v2', 'INTEGRATED-SERVICES-GUARANTEED-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.52', 'ietf', 'v2', 'INTEGRATED-SERVICES-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16.27', 'ietf', 'v2', 'INTERFACETOPN-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.17', 'ietf', 'v2', 'IPATM-IPMC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.57', 'ietf', 'v2', 'IPATM-IPMC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.4.24', 'ietf', 'v2', 'IP-FORWARD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.4.24', 'ietf', 'v2', 'IP-FORWARD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.168', 'ietf', 'v2', 'IPMCAST-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.48', 'ietf', 'v2', 'IP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.48', 'ietf', 'v2', 'IP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.83', 'ietf', 'v2', 'IPMROUTE-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.46', 'ietf', 'v2', 'IPOA-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.141', 'ietf', 'v2', 'IPS-AUTH-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.153', 'ietf', 'v2', 'IPSEC-SPD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.103', 'ietf', 'v2', 'IPV6-FLOW-LABEL-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.56', 'ietf', 'v2', 'IPV6-ICMP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.55', 'ietf', 'v2', 'IPV6-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.91', 'ietf', 'v2', 'IPV6-MLD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.3.86', 'ietf', 'v2', 'IPV6-TCP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.3.87', 'ietf', 'v2', 'IPV6-UDP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.142', 'ietf', 'v2', 'ISCSI-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.20', 'ietf', 'v2', 'ISDN-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.138', 'ietf', 'v2', 'ISIS-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.163', 'ietf', 'v2', 'ISNS-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.121', 'ietf', 'v2', 'ITU-ALARM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.120', 'ietf', 'v2', 'ITU-ALARM-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.4.1.2699.1.1', 'ietf', 'v2', 'Job-Monitoring-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.95', 'ietf', 'v2', 'L2TP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.165', 'ietf', 'v2', 'LANGTAG-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.227', 'ietf', 'v2', 'LMP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.227', 'ietf', 'v2', 'LMP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.101', 'ietf', 'v2', 'MALLOC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.26.1', 'ietf', 'v1', 'MAU-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.26.6', 'ietf', 'v2', 'MAU-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.26.6', 'ietf', 'v2', 'MAU-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.26.6', 'ietf', 'v2', 'MAU-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.26.6', 'ietf', 'v2', 'MAU-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.171', 'ietf', 'v2', 'MIDCOM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.38.1', 'ietf', 'v1', 'MIOX25-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.44', 'ietf', 'v2', 'MIP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.133', 'ietf', 'v2', 'MOBILEIPV6-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.38', 'ietf', 'v2', 'Modem-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.166.8', 'ietf', 'v2', 'MPLS-FTN-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.166.11', 'ietf', 'v2', 'MPLS-L3VPN-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.166.9', 'ietf', 'v2', 'MPLS-LC-ATM-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.166.10', 'ietf', 'v2', 'MPLS-LC-FR-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.166.5', 'ietf', 'v2', 'MPLS-LDP-ATM-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.166.6', 'ietf', 'v2', 'MPLS-LDP-FRAME-RELAY-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.166.7', 'ietf', 'v2', 'MPLS-LDP-GENERIC-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.4.1.9.10.65', 'ietf', 'v2', 'MPLS-LDP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.166.4', 'ietf', 'v2', 'MPLS-LDP-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.166.2', 'ietf', 'v2', 'MPLS-LSR-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.166.1', 'ietf', 'v2', 'MPLS-TC-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.166.3', 'ietf', 'v2', 'MPLS-TE-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.3.92', 'ietf', 'v2', 'MSDP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.28', 'ietf', 'v2', 'MTA-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.28', 'ietf', 'v2', 'MTA-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.28', 'ietf', 'v2', 'MTA-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.123', 'ietf', 'v2', 'NAT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.27', 'ietf', 'v2', 'NETWORK-SERVICES-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.27', 'ietf', 'v2', 'NETWORK-SERVICES-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.71', 'ietf', 'v2', 'NHRP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.92', 'ietf', 'v2', 'NOTIFICATION-LOG-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.133', 'ietf', 'v2', 'OPT-IF-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.14', 'ietf', 'v2', 'OSPF-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.14', 'ietf', 'v2', 'OSPF-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.14.16', 'ietf', 'v2', 'OSPF-TRAP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.14.16', 'ietf', 'v2', 'OSPF-TRAP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.34', 'ietf', 'v2', 'PARALLEL-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.17.6', 'ietf', 'v2', 'P-BRIDGE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.58', 'ietf', 'v2', 'PerfHist-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.58', 'ietf', 'v2', 'PerfHist-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.172', 'ietf', 'v2', 'PIM-BSR-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.3.61', 'ietf', 'v2', 'PIM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.157', 'ietf', 'v2', 'PIM-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.93', 'ietf', 'v2', 'PINT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.140', 'ietf', 'v2', 'PKTC-IETF-MTA-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.169', 'ietf', 'v2', 'PKTC-IETF-SIG-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.124', 'ietf', 'v2', 'POLICY-BASED-MANAGEMENT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.105', 'ietf', 'v2', 'POWER-ETHERNET-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.23.4', 'ietf', 'v1', 'PPP-BRIDGE-NCP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.23.3', 'ietf', 'v1', 'PPP-IP-NCP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.23.1.1', 'ietf', 'v1', 'PPP-LCP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.23.2', 'ietf', 'v1', 'PPP-SEC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.43', 'ietf', 'v2', 'Printer-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.43', 'ietf', 'v2', 'Printer-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.79', 'ietf', 'v2', 'PTOPO-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.17.7', 'ietf', 'v2', 'Q-BRIDGE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.67.2.2', 'ietf', 'v2', 'RADIUS-ACC-CLIENT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.67.2.2', 'ietf', 'v2', 'RADIUS-ACC-CLIENT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.67.2.1', 'ietf', 'v2', 'RADIUS-ACC-SERVER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.67.2.1', 'ietf', 'v2', 'RADIUS-ACC-SERVER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.67.1.2', 'ietf', 'v2', 'RADIUS-AUTH-CLIENT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.67.1.2', 'ietf', 'v2', 'RADIUS-AUTH-CLIENT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.67.1.1', 'ietf', 'v2', 'RADIUS-AUTH-SERVER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.67.1.1', 'ietf', 'v2', 'RADIUS-AUTH-SERVER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.145', 'ietf', 'v2', 'RADIUS-DYNAUTH-CLIENT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.146', 'ietf', 'v2', 'RADIUS-DYNAUTH-SERVER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16.31', 'ietf', 'v2', 'RAQMON-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16.32', 'ietf', 'v2', 'RAQMON-RDS-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.39', 'ietf', 'v2', 'RDBMS-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.1', 'ietf', 'v1', 'RFC1066-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.1', 'ietf', 'v1', 'RFC1156-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.1', 'ietf', 'v1', 'RFC1158-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.1', 'ietf', 'v1', 'RFC1213-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.12', 'ietf', 'v1', 'RFC1229-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.3.7', 'ietf', 'v1', 'RFC1230-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.9', 'ietf', 'v1', 'RFC1231-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.3.2', 'ietf', 'v1', 'RFC1232-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.3.15', 'ietf', 'v1', 'RFC1233-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.13.1', 'ietf', 'v1', 'RFC1243-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.13.1', 'ietf', 'v1', 'RFC1248-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.13.1', 'ietf', 'v1', 'RFC1252-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.14.1', 'ietf', 'v1', 'RFC1253-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.15', 'ietf', 'v1', 'RFC1269-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16.1', 'ietf', 'v1', 'RFC1271-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.7', 'ietf', 'v1', 'RFC1284-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.15.1', 'ietf', 'v1', 'RFC1285-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.17.1', 'ietf', 'v1', 'RFC1286-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.18.1', 'ietf', 'v1', 'RFC1289-phivMIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.31', 'ietf', 'v1', 'RFC1304-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.32', 'ietf', 'v1', 'RFC1315-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.19', 'ietf', 'v1', 'RFC1316-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.33', 'ietf', 'v1', 'RFC1317-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.34', 'ietf', 'v1', 'RFC1318-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.20.2', 'ietf', 'v1', 'RFC1353-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.4.24', 'ietf', 'v1', 'RFC1354-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.16', 'ietf', 'v1', 'RFC1381-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.5', 'ietf', 'v1', 'RFC1382-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.23.1', 'ietf', 'v1', 'RFC1389-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.7', 'ietf', 'v1', 'RFC1398-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.18', 'ietf', 'v1', 'RFC1406-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.30', 'ietf', 'v1', 'RFC1407-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.24.1', 'ietf', 'v1', 'RFC1414-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.23', 'ietf', 'v2', 'RIPv2-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16', 'ietf', 'v2', 'RMON2-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16', 'ietf', 'v2', 'RMON2-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16.1', 'ietf', 'v1', 'RMON-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16.20.8', 'ietf', 'v2', 'RMON-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.112', 'ietf', 'v2', 'ROHC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.114', 'ietf', 'v2', 'ROHC-RTP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.113', 'ietf', 'v2', 'ROHC-UNCOMPRESSED-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.33', 'ietf', 'v2', 'RS-232-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.134', 'ietf', 'v2', 'RSTP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.51', 'ietf', 'v2', 'RSVP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.87', 'ietf', 'v2', 'RTP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.139', 'ietf', 'v2', 'SCSI-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.104', 'ietf', 'v2', 'SCTP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.4.1.4300.1', 'ietf', 'v2', 'SFLOW-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.149', 'ietf', 'v2', 'SIP-COMMON-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.36', 'ietf', 'v2', 'SIP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.151', 'ietf', 'v2', 'SIP-SERVER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.148', 'ietf', 'v2', 'SIP-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.150', 'ietf', 'v2', 'SIP-UA-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.3.88', 'ietf', 'v2', 'SLAPM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16.22', 'ietf', 'v2', 'SMON-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.4.1.4.4', 'ietf', 'v1', 'SMUX-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.34', 'ietf', 'v2', 'SNA-NAU-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.34', 'ietf', 'v2', 'SNA-NAU-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.41', 'ietf', 'v2', 'SNA-SDLC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.18', 'ietf', 'v2', 'SNMP-COMMUNITY-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.18', 'ietf', 'v2', 'SNMP-COMMUNITY-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.10', 'ietf', 'v2', 'SNMP-FRAMEWORK-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.10', 'ietf', 'v2', 'SNMP-FRAMEWORK-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.10', 'ietf', 'v2', 'SNMP-FRAMEWORK-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.21', 'ietf', 'v2', 'SNMP-IEEE802-TM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.11', 'ietf', 'v2', 'SNMP-MPD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.11', 'ietf', 'v2', 'SNMP-MPD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.11', 'ietf', 'v2', 'SNMP-MPD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.13', 'ietf', 'v2', 'SNMP-NOTIFICATION-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.13', 'ietf', 'v2', 'SNMP-NOTIFICATION-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.13', 'ietf', 'v2', 'SNMP-NOTIFICATION-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.14', 'ietf', 'v2', 'SNMP-PROXY-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.14', 'ietf', 'v2', 'SNMP-PROXY-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.14', 'ietf', 'v2', 'SNMP-PROXY-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.22.1.1', 'ietf', 'v1', 'SNMP-REPEATER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.22.1.1', 'ietf', 'v1', 'SNMP-REPEATER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.22.5', 'ietf', 'v2', 'SNMP-REPEATER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.12', 'ietf', 'v2', 'SNMP-TARGET-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.12', 'ietf', 'v2', 'SNMP-TARGET-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.12', 'ietf', 'v2', 'SNMP-TARGET-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.15', 'ietf', 'v2', 'SNMP-USER-BASED-SM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.15', 'ietf', 'v2', 'SNMP-USER-BASED-SM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.15', 'ietf', 'v2', 'SNMP-USER-BASED-SM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.20', 'ietf', 'v2', 'SNMP-USM-AES-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.3.101', 'ietf', 'v2', 'SNMP-USM-DH-OBJECTS-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.2', 'ietf', 'v2', 'SNMPv2-M2M-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.1', 'ietf', 'v2', 'SNMPv2-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.1', 'ietf', 'v2', 'SNMPv2-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.1', 'ietf', 'v2', 'SNMPv2-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.3', 'ietf', 'v2', 'SNMPv2-PARTY-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.6', 'ietf', 'v2', 'SNMPv2-USEC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.16', 'ietf', 'v2', 'SNMP-VIEW-BASED-ACM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.16', 'ietf', 'v2', 'SNMP-VIEW-BASED-ACM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.6.3.16', 'ietf', 'v2', 'SNMP-VIEW-BASED-ACM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.39', 'ietf', 'v2', 'SONET-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.39', 'ietf', 'v2', 'SONET-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.39', 'ietf', 'v2', 'SONET-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.17.3', 'ietf', 'v1', 'SOURCE-ROUTING-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16.28', 'ietf', 'v2', 'SSPM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.54', 'ietf', 'v2', 'SYSAPPL-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.137', 'ietf', 'v2', 'T11-FC-FABRIC-ADDR-MGR-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.162', 'ietf', 'v2', 'T11-FC-FABRIC-CONFIG-SERVER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.159', 'ietf', 'v2', 'T11-FC-FABRIC-LOCK-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.143', 'ietf', 'v2', 'T11-FC-FSPF-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.135', 'ietf', 'v2', 'T11-FC-NAME-SERVER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.144', 'ietf', 'v2', 'T11-FC-ROUTE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.161', 'ietf', 'v2', 'T11-FC-RSCN-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.176', 'ietf', 'v2', 'T11-FC-SP-AUTHENTICATION-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.178', 'ietf', 'v2', 'T11-FC-SP-POLICY-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.179', 'ietf', 'v2', 'T11-FC-SP-SA-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.175', 'ietf', 'v2', 'T11-FC-SP-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.177', 'ietf', 'v2', 'T11-FC-SP-ZONING-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.147', 'ietf', 'v2', 'T11-FC-VIRTUAL-FABRIC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.160', 'ietf', 'v2', 'T11-FC-ZONE-SERVER-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.136', 'ietf', 'v2', 'T11-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.156', 'ietf', 'v2', 'TCP-ESTATS-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.4.1.23.2.29.1', 'ietf', 'v1', 'TCPIPX-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.49', 'ietf', 'v2', 'TCP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.49', 'ietf', 'v2', 'TCP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.200', 'ietf', 'v2', 'TE-LINK-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.122', 'ietf', 'v2', 'TE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.3.124', 'ietf', 'v2', 'TIME-AGGREGATE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.34.8', 'ietf', 'v2', 'TN3270E-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.34.9', 'ietf', 'v2', 'TN3270E-RT-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.9', 'ietf', 'v2', 'TOKENRING-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.9', 'ietf', 'v2', 'TOKENRING-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16.1', 'ietf', 'v1', 'TOKEN-RING-RMON-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.42', 'ietf', 'v2', 'TOKENRING-STATION-SR-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.16.30', 'ietf', 'v2', 'TPM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.100', 'ietf', 'v2', 'TRANSPORT-ADDRESS-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.116', 'ietf', 'v2', 'TRIP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.115', 'ietf', 'v2', 'TRIP-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.131', 'ietf', 'v2', 'TUNNEL-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.131', 'ietf', 'v2', 'TUNNEL-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.170', 'ietf', 'v2', 'UDPLITE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.50', 'ietf', 'v2', 'UDP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.50', 'ietf', 'v2', 'UDP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.33', 'ietf', 'v2', 'UPS-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.164', 'ietf', 'v2', 'URI-TC-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.229', 'ietf', 'v2', 'VDSL-LINE-EXT-MCM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.228', 'ietf', 'v2', 'VDSL-LINE-EXT-SCM-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.10.97', 'ietf', 'v2', 'VDSL-LINE-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.129', 'ietf', 'v2', 'VPN-TC-STD-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.68', 'ietf', 'v2', 'VRRP-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.2.1.65', 'ietf', 'v2', 'WWW-MIB']);
    push(@{$mibdepot}, ['1.3.6.1.4.1.8072', 'net-snmp', 'v2', 'NET-SNMP-MIB']);
    my $oids = $self->get_entries_by_walk(-varbindlist => [
        '1.3.6.1.2.1', '1.3.6.1.4.1',
    ]);
    foreach my $mibinfo (@{$mibdepot}) {
      next if $self->opts->protocol eq "1" && $mibinfo->[2] ne "v1";
      next if $self->opts->protocol ne "1" && $mibinfo->[2] eq "v1";
      $Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mibinfo->[3]} = $mibinfo->[0];
    }
    $Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'MIB-2-MIB'} = "1.3.6.1.2.1";
    foreach my $mib (keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids}) {
      if ($self->implements_mib($mib)) {
        push(@outputlist, [$mib, $Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib}]);
        $unknowns = {@{[map {
            $_, $self->rawdata->{$_}
        } grep {
            substr($_, 0, length($Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib})) ne
                $Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib} || (
            substr($_, 0, length($Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib})) eq
                $Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib} &&
            substr($_, length($Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib}), 1) ne ".")
        } keys %{$unknowns}]}};
      }
    }
    my $toplevels = {};
    map {
        /^(1\.3\.6\.1\.(\d+)\.(\d+)\.\d+\.\d+)\./; $toplevels->{$1} = 1; 
    } keys %{$unknowns};
    foreach (sort {$a cmp $b} keys %{$toplevels}) {
      push(@outputlist, ["<unknown>", $_]);
    }
    foreach (sort {$a->[0] cmp $b->[0]} @outputlist) {
      printf "implements %s %s\n", $_->[0], $_->[1];
    }
    $self->add_ok("have fun");
    my ($code, $message) = $self->check_messages(join => ', ', join_all => ', ');
    $Monitoring::GLPlugin::plugin->nagios_exit($code, $message);
  } elsif ($self->mode =~ /device::supportedoids/) {
    my $unknowns = {};
    %{$unknowns} = %{$self->rawdata};
    my $confirmed = {};
    foreach my $mib (keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids}) {
      foreach my $sym (keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}}) {
        if (my $obj = $self->get_snmp_object($mib, $sym)) {
          my $oid = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$sym};
          if (exists $unknowns->{$oid}) {
            $confirmed->{$oid} = sprintf '%s::%s = %s', $mib, $sym, $obj;
            delete $unknowns->{$oid};
          } elsif (exists $unknowns->{$oid.'.0'}) {
            $confirmed->{$oid.'.0'} = sprintf '%s::%s = %s', $mib, $sym, $obj;
            delete $unknowns->{$oid.'.0'};
          }
        }
        if ($sym =~ /Table$/) {
          if (my @table = $self->get_snmp_table_objects($mib, $sym)) {
            my $oid = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$sym};
            $confirmed->{$oid} = sprintf '%s::%s', $mib, $sym;
            $self->add_rawdata($oid, '--------------------');
            foreach my $line (@table) {
              if ($line->{flat_indices}) {
                foreach my $column (grep !/(flat_indices)|(indices)/, keys %{$line}) {
                  my $oid = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$column};
                  if (exists $unknowns->{$oid.'.'.$line->{flat_indices}}) {
                    $confirmed->{$oid.'.'.$line->{flat_indices}} = 
                        sprintf '%s::%s.%s = %s', $mib, $column, $line->{flat_indices}, $line->{$column};
                    delete $unknowns->{$oid.'.'.$line->{flat_indices}};
                  }
                }
              }
            }
          }
        }
      }
    }
    my @sortedoids = map { $_->[0] }
        sort { $a->[1] cmp $b->[1] }
            map { [$_,
                join '', map { sprintf("%30d",$_) } split( /\./, $_)
            ] } keys %{$self->rawdata};
    foreach (@sortedoids) {
      if (exists $confirmed->{$_}) {
        printf "%s\n", $confirmed->{$_};
      } else {
        printf "%s = %s\n", $_, $unknowns->{$_};
      }
    }
  }
}

sub check_snmp_and_model {
  my ($self) = @_;
  if ($self->opts->snmpwalk) {
    my $response = {};
    if (! -f $self->opts->snmpwalk) {
      $self->add_message(CRITICAL, 
          sprintf 'file %s not found',
          $self->opts->snmpwalk);
    } elsif (-x $self->opts->snmpwalk) {
      my $cmd = sprintf "%s -ObentU -v%s -c%s %s 1.3.6.1.4.1 2>&1",
          $self->opts->snmpwalk,
          $self->opts->protocol,
          $self->opts->community,
          $self->opts->hostname;
      open(WALK, "$cmd |");
      while (<WALK>) {
        if (/^([\.\d]+) = .*?: (\-*\d+)/) {
          $response->{$1} = $2;
        } elsif (/^([\.\d]+) = .*?: "(.*?)"/) {
          $response->{$1} = $2;
          $response->{$1} =~ s/\s+$//;
        }
      }
      close WALK;
    } else {
      if (defined $self->opts->offline && $self->opts->mode ne 'walk') {
        if ((time - (stat($self->opts->snmpwalk))[9]) > $self->opts->offline) {
          $self->add_message(UNKNOWN,
              sprintf 'snmpwalk file %s is too old', $self->opts->snmpwalk);
        }
      }
      $self->opts->override_opt('hostname', 'walkhost') if $self->opts->mode ne 'walk';
      open(MESS, $self->opts->snmpwalk);
      while(<MESS>) {
        # SNMPv2-SMI::enterprises.232.6.2.6.7.1.3.1.4 = INTEGER: 6
        if (/^([\d\.]+) = .*?INTEGER: .*\((\-*\d+)\)/) {
          # .1.3.6.1.2.1.2.2.1.8.1 = INTEGER: down(2)
          $response->{$1} = $2;
        } elsif (/^([\d\.]+) = .*?Opaque:.*?Float:.*?([\-\.\d]+)/) {
          # .1.3.6.1.4.1.2021.10.1.6.1 = Opaque: Float: 0.938965
          $response->{$1} = $2;
        } elsif (/^([\d\.]+) = STRING:\s*$/) {
          $response->{$1} = "";
        } elsif (/^([\d\.]+) = Network Address: (.*)/) {
          $response->{$1} = $2;
        } elsif (/^([\d\.]+) = Hex-STRING: (.*)/) {
          my $k = $1;
          my $h = $2;
          $h =~ s/\s+//g;
          $response->{$k} = pack('H*', $h);
        } elsif (/^([\d\.]+) = \w+: (\-*\d+)\s*$/) {
          $response->{$1} = $2;
        } elsif (/^([\d\.]+) = \w+: "(.*?)"/) {
          $response->{$1} = $2;
          $response->{$1} =~ s/\s+$//;
        } elsif (/^([\d\.]+) = \w+: (.*)/) {
          $response->{$1} = $2;
          $response->{$1} =~ s/\s+$//;
        } elsif (/^([\d\.]+) = (\-*\d+)/) {
          $response->{$1} = $2;
        } elsif (/^([\d\.]+) = "(.*?)"/) {
          $response->{$1} = $2;
          $response->{$1} =~ s/\s+$//;
        }
      }
      close MESS;
    }
    foreach my $oid (keys %$response) {
      if ($oid =~ /^\./) {
        my $nodot = $oid;
        $nodot =~ s/^\.//g;
        $response->{$nodot} = $response->{$oid};
        delete $response->{$oid};
      }
    }
    map { $response->{$_} =~ s/^\s+//; $response->{$_} =~ s/\s+$//; }
        keys %$response;
    $self->set_rawdata($response);
  } else {
    $self->establish_snmp_session();
  }
  if (! $self->check_messages()) {
    my $tic = time;
    my $sysUptime = $self->get_snmp_object('MIB-2-MIB', 'sysUpTime', 0);
    my $snmpEngineTime = $self->get_snmp_object('SNMP-FRAMEWORK-MIB', 'snmpEngineTime');
    my $sysDescr = $self->get_snmp_object('MIB-2-MIB', 'sysDescr', 0);
    my $tac = time;
    if (defined $sysUptime && defined $sysDescr) {
      # drecksschrott asa liefert negative werte
      # und drecksschrott socomec liefert: wrong type (should be INTEGER): NULL
      if (defined $snmpEngineTime && $snmpEngineTime =~ /^\d+$/ && $snmpEngineTime > 0) {
        $self->{uptime} = $snmpEngineTime;
      } else {
        $self->{uptime} = $self->timeticks($sysUptime);
      }
      $self->{productname} = $sysDescr;
      $self->{sysobjectid} = $self->get_snmp_object('MIB-2-MIB', 'sysObjectID', 0);
      $self->debug(sprintf 'uptime: %s', $self->{uptime});
      $self->debug(sprintf 'up since: %s',
          scalar localtime (time - $self->{uptime}));
      $Monitoring::GLPlugin::SNMP::uptime = $self->{uptime};
      $self->debug('whoami: '.$self->{productname});
    } else {
      if ($tac - $tic >= $Monitoring::GLPlugin::SNMP::session->timeout) {
        $self->add_message(UNKNOWN,
            'could not contact snmp agent, timeout during snmp-get sysUptime');
      } else {
        $self->add_message(UNKNOWN,
            'got neither sysUptime nor sysDescr, is this snmp agent working correctly?');
      }
      $Monitoring::GLPlugin::SNMP::session->close if $Monitoring::GLPlugin::SNMP::session;
    }
  }
}

sub establish_snmp_session {
  my ($self) = @_;
  $self->set_timeout_alarm();
  if (eval "require Net::SNMP") {
    my %params = ();
    my $net_snmp_version = Net::SNMP->VERSION(); # 5.002000 or 6.000000
    $params{'-translate'} = [ # because we see "NULL" coming from socomec devices
      -all => 0x0,
      -nosuchobject => 1,
      -nosuchinstance => 1,
      -endofmibview => 1,
      -unsigned => 1,
    ];
    $params{'-hostname'} = $self->opts->hostname;
    $params{'-version'} = $self->opts->protocol;
    if ($self->opts->port) {
      $params{'-port'} = $self->opts->port;
    }
    if ($self->opts->domain) {
      $params{'-domain'} = $self->opts->domain;
    }
    $self->v2tov3;
    if ($self->opts->protocol eq '3') {
      $params{'-version'} = $self->opts->protocol;
      $params{'-username'} = $self->opts->username;
      if ($self->opts->authpassword) {
        $params{'-authpassword'} = 
            $self->decode_password($self->opts->authpassword);
      }
      if ($self->opts->authprotocol) {
        $params{'-authprotocol'} = $self->opts->authprotocol;
      }
      if ($self->opts->privpassword) {
        $params{'-privpassword'} = 
            $self->decode_password($self->opts->privpassword);
      }
      if ($self->opts->privprotocol) {
        $params{'-privprotocol'} = $self->opts->privprotocol;
      }
      # context hat in der session nix verloren, sondern wird
      # als zusatzinfo bei den requests mitgeschickt
      #if ($self->opts->contextengineid) {
      #  $params{'-contextengineid'} = $self->opts->contextengineid;
      #}
      #if ($self->opts->contextname) {
      #  $params{'-contextname'} = $self->opts->contextname;
      #}
    } else {
      $params{'-community'} = 
          $self->decode_password($self->opts->community);
    }
    my ($session, $error) = Net::SNMP->session(%params);
    if (! defined $session) {
      $self->add_message(CRITICAL, 
          sprintf 'cannot create session object: %s', $error);
      $self->debug(Data::Dumper::Dumper(\%params));
    } else {
      my $max_msg_size = $session->max_msg_size();
      $session->max_msg_size(4 * $max_msg_size);
      $Monitoring::GLPlugin::SNMP::session = $session;
    }
  } else {
    $self->add_message(CRITICAL,
        'could not find Net::SNMP module');
  }
}

sub session_translate {
  my ($self, $translation) = @_;
  $Monitoring::GLPlugin::SNMP::session->translate($translation) if
      $Monitoring::GLPlugin::SNMP::session;
}

sub establish_snmp_secondary_session {
  my ($self) = @_;
  if ($self->opts->protocol eq '3') {
  } else {
    if (defined $self->opts->community2 &&
        $self->decode_password($self->opts->community2) ne
        $self->decode_password($self->opts->community)) {
      $Monitoring::GLPlugin::SNMP::session = undef;
      $self->opts->override_opt('community',
        $self->decode_password($self->opts->community2)) ;
      $self->establish_snmp_session;
    }
  }
}

sub mult_snmp_max_msg_size {
  my ($self, $factor) = @_;
  $factor ||= 10;
  $self->debug(sprintf "raise maxmsgsize %d * %d", 
      $factor, $Monitoring::GLPlugin::SNMP::session->max_msg_size()) if $Monitoring::GLPlugin::SNMP::session;
  $Monitoring::GLPlugin::SNMP::session->max_msg_size($factor * $Monitoring::GLPlugin::SNMP::session->max_msg_size()) if $Monitoring::GLPlugin::SNMP::session;
}

sub no_such_model {
  my ($self) = @_;
  printf "Model %s is not implemented\n", $self->{productname};
  exit 3;
}

sub no_such_mode {
  my ($self) = @_;
  if (ref($self) eq "Classes::Generic") {
    $self->init();
  } elsif (ref($self) eq "Classes::Device") {
    $self->add_message(UNKNOWN, 'the device did not implement the mibs this plugin is asking for');
    $self->add_message(UNKNOWN,
        sprintf('unknown device%s', $self->{productname} eq 'unknown' ?
            '' : '('.$self->{productname}.')'));
  } elsif (ref($self) eq "Monitoring::GLPlugin::SNMP") {
    # uptime, offline
    $self->init();
  } else {
    eval {
      bless $self, "Classes::Generic";
      $self->init();
    };
    if ($@) {
      bless $self, "Monitoring::GLPlugin::SNMP";
      $self->init();
    }
  }
  if (ref($self) eq "Monitoring::GLPlugin::SNMP") {
    printf "Mode %s is not implemented for this type of device\n",
        $self->opts->mode;
    exit 3;
  }
}

sub uptime {
  my ($self) = @_;
  return $Monitoring::GLPlugin::SNMP::uptime;
}

sub map_oid_to_class {
  my ($self, $oid, $class) = @_;
  $Monitoring::GLPlugin::SNMP::MibsAndOids::discover_ids->{$oid} = $class;
}

sub discover_suitable_class {
  my ($self) = @_;
  my $sysobj = $self->get_snmp_object('MIB-2-MIB', 'sysObjectID', 0);
  $sysobj =~ s/^\.//g;
  foreach my $oid (keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::discover_ids}) {
    if ($sysobj && $oid eq $sysobj) {
      return $Monitoring::GLPlugin::SNMP::MibsAndOids::discover_ids->{$sysobj};
    }
  }
}

sub require_mib {
  my ($self, $mib) = @_;
  my $package = uc $mib;
  $package =~ s/-//g;
  if (exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib} ||
      exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib}) {
    $self->debug("i know package "."Monitoring::GLPlugin::SNMP::MibsAndOids::".$package);
    return;
  } else {
    eval {
      my @oldkeys = ();
      $self->set_variable("verbosity", 2);
      if ($self->get_variable("verbose")) {
        my @oldkeys = exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib} ?
            keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids} : 0;
      }
      $self->debug("load mib "."Monitoring::GLPlugin::SNMP::MibsAndOids::".$package);
      load "Monitoring::GLPlugin::SNMP::MibsAndOids::".$package;
      if ($self->get_variable("verbose")) {
        my @newkeys = exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib} ?
            keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids} : 0;
        $self->debug(sprintf "now i know: %s", join(" ", sort @newkeys));
        $self->debug(sprintf "now i know %d keys.", scalar(@newkeys));
        if (scalar(@newkeys) <= scalar(@oldkeys)) {
          $self->debug(sprintf "from %d to %d keys. why did we load?",
              scalar(@oldkeys), scalar(@newkeys));
        }
      }
    };
    if ($@) {
      $self->debug("failed to load "."Monitoring::GLPlugin::SNMP::MibsAndOids::".$package);
    } else {
      if (exists $Monitoring::GLPlugin::SNMP::MibsAndOids::requirements->{$mib}) {
        foreach my $submib (@{$Monitoring::GLPlugin::SNMP::MibsAndOids::requirements->{$mib}}) {
          $self->require_mib($submib);
        }
      }
    }
  }
}

sub implements_mib {
  my ($self, $mib) = @_;
  $self->require_mib($mib);
  if (! exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib}) {
    return 0;
  }
  my $sysobj = $self->get_snmp_object('MIB-2-MIB', 'sysObjectID', 0);
  $sysobj =~ s/^\.// if $sysobj;
  if ($sysobj && $sysobj eq $Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib}) {
    $self->debug(sprintf "implements %s (sysobj exact)", $mib);
    return 1;
  }
  if ($sysobj && $Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib} eq
      substr $sysobj, 0, length $Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib}) {
    $self->debug(sprintf "implements %s (sysobj)", $mib);
    return 1;
  }
  # some mibs are only composed of tables
  my $traces;
  if ($self->opts->snmpwalk) {
    my @matches;  
    # exact match  
    push(@matches, @{[map {  
        $_, $self->rawdata->{$_}  
    } grep {  
        $_ eq $Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib}  
    } keys %{$self->rawdata}]});  
  
    # partial match (add trailing dot)  
    my $check = $Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib};  
    $check =~ s/\.?$/./;  
    push(@matches, @{[map {  
        $_, $self->rawdata->{$_}  
    } grep {
        substr($_, 0, length($check)) eq $check  
    } keys %{$self->rawdata}]});  
    $traces = {@matches};  
  } else {
    my %params = (
        -varbindlist => [
            $Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib}
        ]
    );
    if ($Monitoring::GLPlugin::SNMP::session->version() == 3) {
      $params{-contextengineid} = $self->opts->contextengineid if $self->opts->contextengineid;
      $params{-contextname} = $self->opts->contextname if $self->opts->contextname;
    }
    $traces = $Monitoring::GLPlugin::SNMP::session->get_next_request(%params);
  }
  if ($traces && # must find oids following to the ident-oid
      ! exists $traces->{$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib}} && # must not be the ident-oid
      grep { # following oid is inside this tree
          substr($_, 0, length($Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib})) eq $Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{$mib};
      } keys %{$traces}) {
    $self->debug(sprintf "implements %s (found traces)", $mib);
    return 1;
  }
}

sub timeticks {
  my ($self, $timestr) = @_;
  if ($timestr =~ /\((\d+)\)/) {
    # Timeticks: (20718727) 2 days, 9:33:07.27
    $timestr = $1 / 100;
  } elsif ($timestr =~ /(\d+)\s*day[s]*.*?(\d+):(\d+):(\d+)\.(\d+)/) {
    # Timeticks: 2 days, 9:33:07.27
    $timestr = $1 * 24 * 3600 + $2 * 3600 + $3 * 60 + $4;
  } elsif ($timestr =~ /(\d+):(\d+):(\d+):(\d+)\.(\d+)/) {
    # Timeticks: 0001:03:18:42.77
    $timestr = $1 * 3600 * 24 + $2 * 3600 + $3 * 60 + $4;
  } elsif ($timestr =~ /(\d+):(\d+):(\d+)\.(\d+)/) {
    # Timeticks: 9:33:07.27
    $timestr = $1 * 3600 + $2 * 60 + $3;
  } elsif ($timestr =~ /(\d+)\s*hour[s]*.*?(\d+):(\d+)\.(\d+)/) {
    # Timeticks: 3 hours, 42:17.98
    $timestr = $1 * 3600 + $2 * 60 + $3;
  } elsif ($timestr =~ /(\d+)\s*minute[s]*.*?(\d+)\.(\d+)/) {
    # Timeticks: 36 minutes, 01.96
    $timestr = $1 * 60 + $2;
  } elsif ($timestr =~ /(\d+)\.\d+\s*second[s]/) {
    # Timeticks: 01.02 seconds
    $timestr = $1;
  } elsif ($timestr =~ /^(\d+)$/) {
    $timestr = $1 / 100;
  }
  return $timestr;
}

sub human_timeticks {
  my ($self, $timeticks) = @_;
  my $days = int($timeticks / 86400);
  $timeticks -= ($days * 86400);
  my $hours = int($timeticks / 3600);
  $timeticks -= ($hours * 3600);
  my $minutes = int($timeticks / 60);
  my $seconds = $timeticks % 60;
  $days = $days < 1 ? '' : $days .'d ';
  return $days . sprintf "%dh %dm %ds", $hours, $minutes, $seconds;
}

sub internal_name {
  my ($self) = @_;
  my $class = ref($self);
  $class =~ s/^.*:://;
  if (exists $self->{flat_indices}) {
    return sprintf "%s_%s", uc $class, $self->{flat_indices};
  } else {
    return sprintf "%s", uc $class;
  }
}

################################################################
# file-related functions
#
sub create_interface_cache_file {
  my ($self) = @_;
  my $extension = "";
  if ($self->opts->snmpwalk && ! $self->opts->hostname) {
    $self->opts->override_opt('hostname',
        'snmpwalk.file'.md5_hex($self->opts->snmpwalk))
  }
  if ($self->opts->community) { 
    $extension .= md5_hex($self->opts->community);
  }
  $extension =~ s/\//_/g;
  $extension =~ s/\(/_/g;
  $extension =~ s/\)/_/g;
  $extension =~ s/\*/_/g;
  $extension =~ s/\s/_/g;
  return sprintf "%s/%s_interface_cache_%s", $self->statefilesdir(),
      $self->opts->hostname, lc $extension;
}

sub create_entry_cache_file {
  my ($self, $mib, $table, $key_attr) = @_;
  return lc sprintf "%s_%s_%s_%s_cache",
      $self->create_interface_cache_file(),
      $mib, $table, join('#', @{$key_attr});
}

sub update_entry_cache {
  my ($self, $force, $mib, $table, $key_attr) = @_;
  if (ref($key_attr) ne "ARRAY") {
    $key_attr = [$key_attr];
  }
  my $cache = sprintf "%s_%s_%s_cache", 
      $mib, $table, join('#', @{$key_attr});
  my $statefile = $self->create_entry_cache_file($mib, $table, $key_attr);
  my $update = time - 3600;
  #my $update = time - 1;
  if ($force || ! -f $statefile || ((stat $statefile)[9]) < ($update)) {
    $self->debug(sprintf 'force update of %s %s %s %s cache',
        $self->opts->hostname, $self->opts->mode, $mib, $table);
    $self->{$cache} = {};
    foreach my $entry ($self->get_snmp_table_objects($mib, $table)) {
      my $key = join('#', map { $entry->{$_} } @{$key_attr});
      my $hash = $key . '-//-' . join('.', @{$entry->{indices}});
      $self->{$cache}->{$hash} = $entry->{indices};
    }
    $self->save_cache($mib, $table, $key_attr);
  }
  $self->load_cache($mib, $table, $key_attr);
}

sub save_cache {
  my ($self, $mib, $table, $key_attr) = @_;
  if (ref($key_attr) ne "ARRAY") {
    $key_attr = [$key_attr];
  }
  my $cache = sprintf "%s_%s_%s_cache", 
      $mib, $table, join('#', @{$key_attr});
  $self->create_statefilesdir();
  my $statefile = $self->create_entry_cache_file($mib, $table, $key_attr);
  open(STATE, ">".$statefile.".".$$);
  printf STATE Data::Dumper::Dumper($self->{$cache});
  close STATE;
  rename $statefile.".".$$, $statefile;
  $self->debug(sprintf "saved %s to %s",
      Data::Dumper::Dumper($self->{$cache}), $statefile);
}

sub load_cache {
  my ($self, $mib, $table, $key_attr) = @_;
  if (ref($key_attr) ne "ARRAY") {
    $key_attr = [$key_attr];
  }
  my $cache = sprintf "%s_%s_%s_cache", 
      $mib, $table, join('#', @{$key_attr});
  my $statefile = $self->create_entry_cache_file($mib, $table, $key_attr);
  $self->{$cache} = {};
  if ( -f $statefile) {
    our $VAR1;
    our $VAR2;
    eval {
      require $statefile;
    };
    if($@) {
      printf "rumms\n";
    }
    # keinesfalls mehr require verwenden!!!!!!
    # beim require enthaelt VAR1 andere werte als beim slurp
    # und zwar diejenigen, die beim letzten save_cache geschrieben wurden.
    my $content = do { local (@ARGV, $/) = $statefile; my $x = <>; close ARGV; $x };
    $VAR1 = eval "$content";
    $self->debug(sprintf "load %s", Data::Dumper::Dumper($VAR1));
    $self->{$cache} = $VAR1;
  }
}


################################################################
# top-level convenience functions
#
sub get_snmp_objects {
  my ($self, $mib, @mos) = @_;
  foreach (@mos) {
    #my $value = $self->get_snmp_object($mib, $_, 0);
    #if (defined $value) {
    #  $self->{$_} = $value;
    #} else {
      my $value = $self->get_snmp_object($mib, $_);
      if (defined $value) {
        $self->{$_} = $value;
      }
    #}
  }
}

sub get_snmp_tables {
  my ($self, $mib, $infos) = @_;
  foreach my $info (@{$infos}) {
    my $arrayname = $info->[0];
    my $table = $info->[1];
    my $class = $info->[2];
    my $filter = $info->[3];
    my $rows = $info->[4];
    $self->{$arrayname} = [] if ! exists $self->{$arrayname};
    if (! exists $Monitoring::GLPlugin::SNMP::tablecache->{$mib} || ! exists $Monitoring::GLPlugin::SNMP::tablecache->{$mib}->{$table}) {
      $Monitoring::GLPlugin::SNMP::tablecache->{$mib}->{$table} = [];
      foreach ($self->get_snmp_table_objects($mib, $table, undef, $rows)) {
        push(@{$Monitoring::GLPlugin::SNMP::tablecache->{$mib}->{$table}}, $_);
        my $new_object = $class->new(%{$_});
        next if (defined $filter && ! &$filter($new_object));
        push(@{$self->{$arrayname}}, $new_object);
      }
    } else {
      $self->debug(sprintf "get_snmp_tables %s %s cache hit", $mib, $table);
      foreach (@{$Monitoring::GLPlugin::SNMP::tablecache->{$mib}->{$table}}) {
        my $new_object = $class->new(%{$_});
        next if (defined $filter && ! &$filter($new_object));
        push(@{$self->{$arrayname}}, $new_object);
      }
    }
  }
}

sub merge_tables {
  my ($self, $into, @from) = @_;
  my $into_indices = {};
  map { $into_indices->{$_->{flat_indices}} = $_ } @{$self->{$into}};
  foreach (@from) {
    foreach my $element (@{$self->{$_}}) {
      if (exists $into_indices->{$element->{flat_indices}}) {
        foreach my $key (keys %{$element}) {
          $into_indices->{$element->{flat_indices}}->{$key} = $element->{$key};
        }
      }
    }
    delete $self->{$_};
  }
}

sub merge_tables_with_code {
  my ($self, $into, @from) = @_;
  my $into_indices = {};
  my @to_del = ();
  foreach my $into_elem (@{$self->{$into}}) {
    for (my $i = 0; $i < @from; $i += 2) {
      my ($from_elems, $func) = @from[$i, $i+1];
      foreach my $from_elem (@{$self->{$from_elems}}) {
        if (&$func($into_elem, $from_elem)) {
          foreach my $key (grep !/^(info|trace|warning|critical|blacklisted|extendedinfo|flat_indices|indices)/, sort keys %{$from_elem}) {
            $into_elem->{$key} = $from_elem->{$key};
          }
        }
      }
    }
  }
  for (my $i = 0; $i < @from; $i += 2) {
    my ($from_elems, $func) = @from[$i, $i+1];
    delete $self->{$from_elems};
  }
}

sub mibs_and_oids_definition {
  my ($self, $mib, $definition, @values) = @_;
  if (exists $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib} &&
      exists $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition}) {
    if (ref($Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition}) eq "CODE") {
      return $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition}->(@values);
    } elsif (ref($Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition}) eq "HASH") {
      return $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition}->{$values[0]};
    }
  } else {
    return "unknown_".$definition;
  }
}

sub clear_table_cache {
  my ($self, $mib, $table) = @_;
  if ($table && exists $Monitoring::GLPlugin::SNMP::tablecache->{$mib}) {
    delete $Monitoring::GLPlugin::SNMP::tablecache->{$mib}->{$table};
  } elsif ($mib) {
    delete $Monitoring::GLPlugin::SNMP::tablecache->{$mib};
  } else {
    $Monitoring::GLPlugin::SNMP::tablecache = {};
  }
}

################################################################
# 2nd level 
#
sub get_snmp_object {
  my ($self, $mib, $mo, $index) = @_;
  $self->require_mib($mib);
  if (exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib} &&
      exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$mo}) {
    my $oid = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$mo}.
        (defined $index ? '.'.$index : '');
    my $response = $self->get_request(-varbindlist => [$oid]);
    if (defined $response->{$oid}) {
      if ($response->{$oid} eq 'noSuchInstance' || $response->{$oid} eq 'noSuchObject') {
        $response->{$oid} = undef;
      } elsif (my @symbols = $self->make_symbolic($mib, $response, [[$index]])) {
        $response->{$oid} = $symbols[0]->{$mo};
      }
    }
    $self->debug(sprintf "GET: %s::%s (%s) : %s", $mib, $mo, $oid, defined $response->{$oid} ? $response->{$oid} : "<undef>");
    if (! defined $response->{$oid} && ! defined $index) {
      return $self->get_snmp_object($mib, $mo, 0);
    }
    return $response->{$oid};
  }
  return undef;
}

sub get_snmp_table_objects_with_cache {
  my ($self, $mib, $table, $key_attr) = @_;
  #return $self->get_snmp_table_objects($mib, $table);
  $self->update_entry_cache(0, $mib, $table, $key_attr);
  my @indices = $self->get_cache_indices($mib, $table, $key_attr);
  my @entries = ();
  foreach ($self->get_snmp_table_objects($mib, $table, \@indices)) {
    push(@entries, $_);
  }
  return @entries;
}

sub get_table_row_oids {
  my ($self, $mib, $table, $rows) = @_;
  $self->require_mib($mib);
  my $entry = $table;
  $entry =~ s/Table/Entry/g;
  my $eoid = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$entry}.'.';
  my $eoidlen = length($eoid);
  my @columns = scalar(@{$rows}) ?
  map {
      $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}
  } @{$rows}
  :
  map {
      $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}
  } grep {
    substr($Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}, 0, $eoidlen) eq
        $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$entry}.'.'
  } keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}};
  return @columns;
}

# get_snmp_table_objects('MIB-Name', 'Table-Name', 'Table-Entry', [indices])
# returns array of hashrefs
sub get_snmp_table_objects {
  my ($self, $mib, $table, $indices, $rows) = @_;
  $indices ||= [];
  $rows ||= [];
  $self->require_mib($mib);
  my @entries = ();
  my $augmenting_table;
  $self->debug(sprintf "get_snmp_table_objects %s %s", $mib, $table);
  if ($table =~ /^(.*?)\+(.*)/) {
    $table = $1;
    $augmenting_table = $2;
  }
  my $entry = $table;
  $entry =~ s/Table/Entry/g;
  if (exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib} &&
      exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$table}) {
    if (scalar(@{$indices}) == 1 && $indices->[0] == -1) {
      # get mini-version of a table
      my $result = {};
      my $eoid = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$entry}.'.';
      my $eoidlen = length($eoid);
      my @columns = map {
          $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}
      } grep {
        substr($Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}, 0, $eoidlen) eq
            $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$entry}.'.'
      } keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}};
      my $ifresult = $self->get_entries(
          -columns => \@columns,
      );
      map { $result->{$_} = $ifresult->{$_} }
          keys %{$ifresult};
      if ($augmenting_table &&
          exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$augmenting_table}) {
        my $entry = $augmenting_table;
        $entry =~ s/Table/Entry/g;
        my $eoid = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$entry}.'.';
        my $eoidlen = length($eoid);
        my @columns = map {
            $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}
        } grep {
          substr($Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}, 0, $eoidlen) eq $eoid
        } keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}};
        my $ifresult = $self->get_entries(
            -columns => \@columns,
        );
        map { $result->{$_} = $ifresult->{$_} }
            keys %{$ifresult};
      }
      my @indices = 
          $self->get_indices(
              -baseoid => $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$entry},
              -oids => [keys %{$result}]);
      $self->debug(sprintf "get_snmp_table_objects get_table returns %d indices",
          scalar(@indices));
      @entries = $self->make_symbolic($mib, $result, \@indices);
      @entries = map { $_->{indices} = shift @indices; $_ } @entries;
    } elsif (scalar(@{$indices}) == 1) {
      my $result = {};
      my $eoid = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$entry}.'.';
      my $eoidlen = length($eoid);
      my @columns = map {
          $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}
      } grep {
        substr($Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}, 0, $eoidlen) eq
            $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$entry}.'.'
      } keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}};
      my $index = join('.', @{$indices->[0]});
      my $ifresult = $self->get_entries(
          -startindex => $index,
          -endindex => $index,
          -columns => \@columns,
      );
      map { $result->{$_} = $ifresult->{$_} }
          keys %{$ifresult};
      if ($augmenting_table &&
          exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$augmenting_table}) {
        my $entry = $augmenting_table;
        $entry =~ s/Table/Entry/g;
        my $eoid = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$entry}.'.';
        my $eoidlen = length($eoid);
        my @columns = map {
            $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}
        } grep {
          substr($Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}, 0, $eoidlen) eq $eoid
        } keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}};
        my $ifresult = $self->get_entries(
            -startindex => $index,
            -endindex => $index,
            -columns => \@columns,
        );
        map { $result->{$_} = $ifresult->{$_} }
            keys %{$ifresult};
      }
      @entries = $self->make_symbolic($mib, $result, $indices);
      @entries = map { $_->{indices} = shift @{$indices}; $_ } @entries;
    } elsif (scalar(@{$indices}) > 1) {
    # man koennte hier pruefen, ob die indices aufeinanderfolgen
    # und dann get_entries statt get_table aufrufen
      my $result = {};
      my $eoid = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$entry}.'.';
      my $eoidlen = length($eoid);
      my @columns = map {
          $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}
      } grep {
        substr($Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}, 0, $eoidlen) eq $eoid
      } keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}};
      my @sortedindices = map { $_->[0] }
          sort { $a->[1] cmp $b->[1] }
              map { [$_,
                  join '', map { sprintf("%30d",$_) } split( /\./, $_)
              ] } map { join('.', @{$_})} @{$indices};
      my $startindex = $sortedindices[0];
      my $endindex = $sortedindices[$#sortedindices];
      if (0) {
        # holzweg. dicke ciscos liefern unvollstaendiges resultat, d.h.
        # bei 138,19,157 kommt nur 138..144, dann ist schluss.
        # maxrepetitions bringt nichts.
        $result = $self->get_entries(
            -startindex => $startindex,
            -endindex => $endindex,
            -columns => \@columns,
        );
      } else {
        foreach my $ifidx (@sortedindices) {
          my $ifresult = $self->get_entries(
              -startindex => $ifidx,
              -endindex => $ifidx,
              -columns => \@columns,
          );
          map { $result->{$_} = $ifresult->{$_} }
              keys %{$ifresult};
        }
      }
      if ($augmenting_table &&
          exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$augmenting_table}) {
        my $entry = $augmenting_table;
        $entry =~ s/Table/Entry/g;
        my $eoid = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$entry}.'.';
        my $eoidlen = length($eoid);
        my @columns = map {
            $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}
        } grep {
          substr($Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}, 0, $eoidlen) eq $eoid
        } keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}};
        foreach my $ifidx (@sortedindices) {
          my $ifresult = $self->get_entries(
              -startindex => $ifidx,
              -endindex => $ifidx,
              -columns => \@columns,
          );
          map { $result->{$_} = $ifresult->{$_} }
              keys %{$ifresult};
        }
      }
      # now we have numerical_oid+index => value
      # needs to become symboic_oid => value
      #my @indices =
      # $self->get_indices($Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$entry});
      @entries = $self->make_symbolic($mib, $result, $indices);
      @entries = map { $_->{indices} = shift @{$indices}; $_ } @entries;
    } elsif (scalar(@{$rows})) {
      my @columns = $self->get_table_row_oids($mib, $table, $rows);
      my $result = $self->get_entries(
          -columns => \@columns,
      );
      $self->debug(sprintf "get_snmp_table_objects get_table_r returns %d oids",
          scalar(keys %{$result}));
      my @indices =
          $self->get_indices(
              -baseoid => $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$entry},
              -oids => [keys %{$result}]);
      $self->debug(sprintf "get_snmp_table_objects get_table_r returns %d indices",
          scalar(@indices));
      @entries = $self->make_symbolic($mib, $result, \@indices);
      @entries = map { $_->{indices} = shift @indices; $_ } @entries;
    } else {
      $self->debug(sprintf "get_snmp_table_objects calls get_table %s",
          $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$table});
      my $result = $self->get_table(
          -baseoid => $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$table});
      $self->debug(sprintf "get_snmp_table_objects get_table returns %d oids",
          scalar(keys %{$result}));
      # now we have numerical_oid+index => value
      # needs to become symboic_oid => value
      my @indices = 
          $self->get_indices(
              -baseoid => $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$entry},
              -oids => [keys %{$result}]);
      $self->debug(sprintf "get_snmp_table_objects get_table returns %d indices",
          scalar(@indices));
      @entries = $self->make_symbolic($mib, $result, \@indices);
      @entries = map { $_->{indices} = shift @indices; $_ } @entries;
    }
  }
  @entries = map { $_->{flat_indices} = join(".", @{$_->{indices}}); $_ } @entries;
  return @entries;
}

sub bulk_is_baeh {
  my ($self, $maxrepetitions) = @_;
  $maxrepetitions ||= 1;
  $Monitoring::GLPlugin::SNMP::maxrepetitions = $maxrepetitions;
}

################################################################
# 3rd level functions. calling net::snmp-functions
# 
sub get_request {
  my ($self, %params) = @_;
  my @notcached = ();
  foreach my $oid (@{$params{'-varbindlist'}}) {
    $self->add_oidtrace($oid);
    if (! exists $Monitoring::GLPlugin::SNMP::rawdata->{$oid}) {
      push(@notcached, $oid);
    }
  }
  if (! $self->opts->snmpwalk && (scalar(@notcached) > 0)) {
    my %params = ();
    if ($Monitoring::GLPlugin::SNMP::session->version() == 0) {
      $params{-varbindlist} = \@notcached;
    } elsif ($Monitoring::GLPlugin::SNMP::session->version() == 1) {
      $params{-varbindlist} = \@notcached;
      #$params{-nonrepeaters} = scalar(@notcached);
    } elsif ($Monitoring::GLPlugin::SNMP::session->version() == 3) {
      $params{-varbindlist} = \@notcached;
      $params{-contextengineid} = $self->opts->contextengineid if $self->opts->contextengineid;
      $params{-contextname} = $self->opts->contextname if $self->opts->contextname;
    }
    my $result = $Monitoring::GLPlugin::SNMP::session->get_request(%params);
    # so, und jetzt gibts stinkstiefel, die kriegen
    # params{-varbindlist => [1.3.6.1.4.1.318.1.1.1.1.1.1]
    # und result ist
    # { 1.3.6.1.4.1.318.1.1.1.1.1.1.0 => "Smart-UPS RT 10000 XL" }
    # letzteres kommt in raw_data
    # und beim abschliessenden map wirds natuerlich nicht mehr gefunden 
    # also leeres return. <<kraftausdruck>>
    foreach my $key (%{$result}) {
      # so, und zwei jahre spaeter kommt man drauf, dass es viele sorten 
      # von stinkstiefeln gibt. die fragt man nach 1.3.6.1.4.1.13885.120.1.3.1
      # und kriegt als antwort 1.3.6.1.4.1.13885.120.1.3.1.0=[noSuchInstance]
      # bis zum 11.10.16 wurde das in den cache geschrieben. eine etage hoeher
      # wird aber dann nach 1.3.6.1.4.1.13885.120.1.3.1.0 gefallbacked, was
      # dann prompt aus dem cache gefischt wird, anstatt den agenten zu fragen,
      # der in diesem fall eine saubere antwort liefern wuerde.
      # ergo: keine fehlermeldungen in den chache
      $self->add_rawdata($key, $result->{$key}) if defined $result->{$key} && $result->{$key} ne 'noSuchInstance';
    }
  }
  my $result = {};
  map {
      $result->{$_} = exists $Monitoring::GLPlugin::SNMP::rawdata->{$_} ?
          $Monitoring::GLPlugin::SNMP::rawdata->{$_} :
      exists $Monitoring::GLPlugin::SNMP::rawdata->{$_.'.0'} ?
          $Monitoring::GLPlugin::SNMP::rawdata->{$_.'.0'} : undef;
  } @{$params{'-varbindlist'}};
  return $result;
}

sub get_entries_get_bulk {
  my ($self, %params) = @_;
  my $result = {};
  $self->debug(sprintf "get_entries_get_bulk %s", Data::Dumper::Dumper(\%params));
  my %newparams = ();
  $newparams{'-maxrepetitions'} = 3;
  $newparams{'-startindex'} = $params{'-startindex'}
      if defined $params{'-startindex'};
  $newparams{'-endindex'} = $params{'-endindex'}
      if defined $params{'-endindex'};
  $newparams{'-columns'} = $params{'-columns'};
  if ($Monitoring::GLPlugin::SNMP::session->version() == 3) {
    $newparams{-contextengineid} = $self->opts->contextengineid if $self->opts->contextengineid;
    $newparams{-contextname} = $self->opts->contextname if $self->opts->contextname;
  }
  $result = $Monitoring::GLPlugin::SNMP::session->get_entries(%newparams);
  return $result;
}

sub get_entries_get_next {
  my ($self, %params) = @_;
  my $result = {};
  $self->debug(sprintf "get_entries_get_next %s", Data::Dumper::Dumper(\%params));
  my %newparams = ();
  $newparams{'-maxrepetitions'} = 0;
  $newparams{'-startindex'} = $params{'-startindex'}
      if defined $params{'-startindex'};
  $newparams{'-endindex'} = $params{'-endindex'}
      if defined $params{'-endindex'};
  $newparams{'-columns'} = $params{'-columns'};
  if ($Monitoring::GLPlugin::SNMP::session->version() == 3) {
    $newparams{-contextengineid} = $self->opts->contextengineid if $self->opts->contextengineid;
    $newparams{-contextname} = $self->opts->contextname if $self->opts->contextname;
  }
  $result = $Monitoring::GLPlugin::SNMP::session->get_entries(%newparams);
  return $result;
}

sub get_entries_get_next_1index {
  my ($self, %params) = @_;
  my $result = {};
  $self->debug(sprintf "get_entries_get_next_1index %s", Data::Dumper::Dumper(\%params));
  my %newparams = ();
  $newparams{'-startindex'} = $params{'-startindex'}
      if defined $params{'-startindex'};
  $newparams{'-endindex'} = $params{'-endindex'}
      if defined $params{'-endindex'};
  $newparams{'-columns'} = $params{'-columns'};
  my %singleparams = ();
  $singleparams{'-maxrepetitions'} = 0;
  if ($Monitoring::GLPlugin::SNMP::session->version() == 3) {
    $singleparams{-contextengineid} = $self->opts->contextengineid if $self->opts->contextengineid;
    $singleparams{-contextname} = $self->opts->contextname if $self->opts->contextname;
  }
  foreach my $index ($newparams{'-startindex'}..$newparams{'-endindex'}) {
    foreach my $oid (@{$newparams{'-columns'}}) {
      $singleparams{'-columns'} = [$oid];
      $singleparams{'-startindex'} = $index;
      $singleparams{'-endindex'} =$index;
      my $singleresult = $Monitoring::GLPlugin::SNMP::session->get_entries(%singleparams);
      foreach my $key (keys %{$singleresult}) {
        $result->{$key} = $singleresult->{$key};
      }
    }
  }
  return $result;
}

sub get_entries_get_simple {
  my ($self, %params) = @_;
  my $result = {};
  $self->debug(sprintf "get_entries_get_simple %s", Data::Dumper::Dumper(\%params));
  my %newparams = ();
  $newparams{'-startindex'} = $params{'-startindex'}
      if defined $params{'-startindex'};
  $newparams{'-endindex'} = $params{'-endindex'}
      if defined $params{'-endindex'};
  $newparams{'-columns'} = $params{'-columns'};
  my %singleparams = ();
  if ($Monitoring::GLPlugin::SNMP::session->version() == 3) {
    $singleparams{-contextengineid} = $self->opts->contextengineid if $self->opts->contextengineid;
    $singleparams{-contextname} = $self->opts->contextname if $self->opts->contextname;
  }
  foreach my $index ($newparams{'-startindex'}..$newparams{'-endindex'}) {
    foreach my $oid (@{$newparams{'-columns'}}) {
      $singleparams{'-varbindlist'} = [$oid.".".$index];
      my $singleresult = $Monitoring::GLPlugin::SNMP::session->get_request(%singleparams);
      foreach my $key (keys %{$singleresult}) {
        $result->{$key} = $singleresult->{$key};
      }
    }
  }
  return $result;
}

sub get_entries {
  my ($self, %params) = @_;
  # [-startindex]
  # [-endindex]
  # -columns
  my $result = {};
  $self->debug(sprintf "get_entries %s", Data::Dumper::Dumper(\%params));
  if (! $self->opts->snmpwalk) {
    $result = $self->get_entries_get_bulk(%params);
    if (! $result) {
      if (scalar (@{$params{'-columns'}}) < 50 && $params{'-endindex'} && $params{'-startindex'} eq $params{'-endindex'}) {
        $result = $self->get_entries_get_simple(%params);
      } else {
        $result = $self->get_entries_get_next(%params);
      }
      if (! $result && defined $params{'-startindex'} && $params{'-startindex'} !~ /\./) {
        # compound indexes cannot continue, as these two methods iterate numerically
        if ($Monitoring::GLPlugin::SNMP::session->error() =~ /tooBig/i) {
          $result = $self->get_entries_get_next_1index(%params);
        }
        if (! $result) {
          $result = $self->get_entries_get_simple(%params);
        }
        if (! $result) {
          $self->debug(sprintf "nutzt nix\n");
        }
      }
    }
    foreach my $key (keys %{$result}) {
      if (substr($key, -1) eq " ") {
        my $value = $result->{$key};
        delete $result->{$key};
        $key =~ s/\s+$//g;
        $result->{$key} = $value;
        #
        # warum?
        #
        # %newparams ist:
        #  '-columns' => [
        #                  '1.3.6.1.2.1.2.2.1.8',
        #                  '1.3.6.1.2.1.2.2.1.13',
        #                  ...
        #                  '1.3.6.1.2.1.2.2.1.16'
        #                ],
        #  '-startindex' => '2',
        #  '-endindex' => '2'
        #
        # und $result ist:
        #  ...
        #  '1.3.6.1.2.1.2.2.1.2.2' => 'Adaptive Security Appliance \'outside\' interface',
        #  '1.3.6.1.2.1.2.2.1.16.2 ' => 4281465004,
        #  '1.3.6.1.2.1.2.2.1.13.2' => 0,
        #  ...
        #
        # stinkstiefel!
        #
      }
      $self->add_rawdata($key, $result->{$key});
    }
  } else {
    my $preresult = $self->get_matching_oids(
        -columns => $params{'-columns'});
    foreach (keys %{$preresult}) {
      $result->{$_} = $preresult->{$_};
    }
    my @sortedkeys = map { $_->[0] }
        sort { $a->[1] cmp $b->[1] }
            map { [$_,
                    join '', map { sprintf("%30d",$_) } split( /\./, $_)
                  ] } keys %{$result};
    my @to_del = ();
    if ($params{'-startindex'}) {
      foreach my $resoid (@sortedkeys) {
        foreach my $oid (@{$params{'-columns'}}) {
          my $poid = $oid.'.';
          my $lpoid = length($poid);
          if (substr($resoid, 0, $lpoid) eq $poid) {
            my $oidpattern = $poid;
            $oidpattern =~ s/\./\\./g;
            if ($resoid =~ /^$oidpattern(.+)$/) {
              if ($1 lt $params{'-startindex'}) {
                push(@to_del, $oid.'.'.$1);
              }
            }
          }
        }
      }
    }
    if ($params{'-endindex'}) {
      foreach my $resoid (@sortedkeys) {
        foreach my $oid (@{$params{'-columns'}}) {
          my $poid = $oid.'.';
          my $lpoid = length($poid);
          if (substr($resoid, 0, $lpoid) eq $poid) {
            my $oidpattern = $poid;
            $oidpattern =~ s/\./\\./g;
            if ($resoid =~ /^$oidpattern(.+)$/) {
              if ($1 gt $params{'-endindex'}) {
                push(@to_del, $oid.'.'.$1);
              }
            }
          }
        }
      }
    }
    foreach (@to_del) {
      delete $result->{$_};
    }
  }
  return $result;
}

sub get_entries_by_walk {
  my ($self, %params) = @_;
  if (! $self->opts->snmpwalk) {
    $self->add_ok("if you get this crap working correctly, let me know");
    if ($Monitoring::GLPlugin::SNMP::session->version() == 3) {
      $params{-contextengineid} = $self->opts->contextengineid if $self->opts->contextengineid;
      $params{-contextname} = $self->opts->contextname if $self->opts->contextname;
    }
    $self->debug(sprintf "get_tree %s", Data::Dumper::Dumper(\%params));
    my @baseoids = @{$params{-varbindlist}};
    delete $params{-varbindlist};
    if ($Monitoring::GLPlugin::SNMP::session->version() == 0) {
      foreach my $baseoid (@baseoids) {
        $params{-varbindlist} = [$baseoid];
        while (my $result = $Monitoring::GLPlugin::SNMP::session->get_next_request(%params)) {
          $params{-varbindlist} = [($Monitoring::GLPlugin::SNMP::session->var_bind_names)[0]];
        }
      }
    } else {
      $params{-maxrepetitions} = 200;
      foreach my $baseoid (@baseoids) {
        $params{-varbindlist} = [$baseoid];
        while (my $result = $Monitoring::GLPlugin::SNMP::session->get_bulk_request(%params)) {
          my @names = $Monitoring::GLPlugin::SNMP::session->var_bind_names();
          my @oids = $self->sort_oids(\@names);
          $params{-varbindlist} = [pop @oids];
        }
      }
    }
  } else {
    return $self->get_matching_oids(
        -columns => $params{-varbindlist});
  }
}

sub get_table {
  my ($self, %params) = @_;
  $self->add_oidtrace($params{'-baseoid'});
  if (! $self->opts->snmpwalk) {
    my @notcached = ();
    if ($Monitoring::GLPlugin::SNMP::session->version() == 3) {
      $params{-contextengineid} = $self->opts->contextengineid if $self->opts->contextengineid;
      $params{-contextname} = $self->opts->contextname if $self->opts->contextname;
    }
    if ($Monitoring::GLPlugin::SNMP::maxrepetitions) {
      # some devices (Bintec) don't like bulk-requests. They call bulk_is_baeh(), so
      # we immediately send get-next
      $params{'-maxrepetitions'} = $Monitoring::GLPlugin::SNMP::maxrepetitions;
    }
    $self->debug(sprintf "get_table %s", Data::Dumper::Dumper(\%params));
    my $result = $Monitoring::GLPlugin::SNMP::session->get_table(%params);
    $self->debug(sprintf "get_table returned %d oids", scalar(keys %{$result}));
    if (scalar(keys %{$result}) == 0) {
      $self->debug(sprintf "get_table error: %s", 
          $Monitoring::GLPlugin::SNMP::session->error());
      $self->debug("get_table error: try fallback");
      $params{'-maxrepetitions'} = 1;
      $self->debug(sprintf "get_table %s", Data::Dumper::Dumper(\%params));
      $result = $Monitoring::GLPlugin::SNMP::session->get_table(%params);
      $self->debug(sprintf "get_table returned %d oids", scalar(keys %{$result}));
      if (scalar(keys %{$result}) == 0) {
        $self->debug(sprintf "get_table error: %s", 
            $Monitoring::GLPlugin::SNMP::session->error());
        $self->debug("get_table error: no more fallbacks. Try --protocol 1");
      }
    }
    # Drecksstinkstiefel Net::SNMP
    # '1.3.6.1.2.1.2.2.1.22.4 ' => 'endOfMibView',
    # '1.3.6.1.2.1.2.2.1.22.4' => '0.0',
    foreach my $key (keys %{$result}) {
      if (substr($key, -1) eq " ") {
        my $value = $result->{$key};
        delete $result->{$key};
        (my $shortkey = $key) =~ s/\s+$//g;
        if (! exists $result->{shortkey}) {
          $result->{$shortkey} = $value;
        }
        $self->add_rawdata($key, $result->{$key}) if exists $result->{$key};
      } else {
        $self->add_rawdata($key, $result->{$key});
      }
    }
  }
  return $self->get_matching_oids(
      -columns => [$params{'-baseoid'}]);
}

################################################################
# helper functions
# 
sub valid_response {
  my ($self, $mib, $oid, $index) = @_;
  $self->require_mib($mib);
  if (exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib} &&
      exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$oid}) {
    # make it numerical
    my $oid = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$oid};
    if (defined $index) {
      $oid .= '.'.$index;
    }
    my $result = $self->get_request(
        -varbindlist => [$oid]
    );
    if (!defined($result) ||
        ! defined $result->{$oid} ||
        $result->{$oid} eq 'noSuchInstance' ||
        $result->{$oid} eq 'noSuchObject' ||
        $result->{$oid} eq 'endOfMibView') {
      return undef;
    } else {
      $self->add_rawdata($oid, $result->{$oid});
      return $result->{$oid};
    }
  } else {
    return undef;
  }
}

# make_symbolic
# mib is the name of a mib (must be in mibs_and_oids)
# result is a hash-key oid->value
# indices is a array ref of array refs. [[1],[2],...] or [[1,0],[1,1],[2,0]..
sub make_symbolic {
  my ($self, $mib, $result, $indices) = @_;
  $self->require_mib($mib);
  my @entries = ();
  if (! wantarray && ref(\$result) eq "SCALAR" && ref(\$indices) eq "SCALAR") {
    # $self->make_symbolic('CISCO-IETF-NAT-MIB', 'cnatProtocolStatsName', $self->{cnatProtocolStatsName});
    my $oid = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$result};
    $result = { $oid => $self->{$result} };
    $indices = [[]];
  }
  foreach my $index (@{$indices}) {
    # skip [], [[]], [[undef]]
    if (ref($index) eq "ARRAY") {
      if (scalar(@{$index}) == 0) {
        next;
      } elsif (!defined $index->[0]) {
        next;
      }
    }
    my $mo = {};
    my $idx = join('.', @{$index}); # index can be multi-level
    foreach my $symoid
        (keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}}) {
      my $oid = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$symoid};
      if (ref($oid) ne 'HASH') {
        my $fulloid = $oid . '.'.$idx;
        if (exists $result->{$fulloid}) {
          if (exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$symoid.'Definition'}) {
            if (ref($Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$symoid.'Definition'}) eq 'HASH') {
              if (exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$symoid.'Definition'}->{$result->{$fulloid}}) {
                $mo->{$symoid} = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$symoid.'Definition'}->{$result->{$fulloid}};
              } else {
                $mo->{$symoid} = 'unknown_'.$result->{$fulloid};
              }
            } elsif ($Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$symoid.'Definition'} =~ /^OID::(.*)/) {
              my $othermib = $1;
              my $value_which_is_a_oid = $result->{$fulloid};
              $value_which_is_a_oid =~ s/^\.//g;
              my @result = grep { $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$othermib}->{$_} eq $value_which_is_a_oid } keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$othermib}};
              if (scalar(@result)) {
                $mo->{$symoid} = $result[0];
              } else {
                $mo->{$symoid} = 'unknown_'.$result->{$fulloid};
              }
            } elsif ($Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$symoid.'Definition'} =~ /^(.*?)::(.*)/) {
              my $mib = $1;
              my $definition = $2;
              if  (exists $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib} &&
                  exists $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition} &&
                  ref($Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition}) eq 'CODE') {
                $mo->{$symoid} = $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition}->($result->{$fulloid});
              } elsif  (exists $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib} &&
                  exists $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition} &&
                  ref($Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition}) eq 'HASH' &&
                  exists $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition}->{$result->{$fulloid}}) {
                $mo->{$symoid} = $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition}->{$result->{$fulloid}};
              } else {
                $mo->{$symoid} = 'unknown_'.$result->{$fulloid};
              }
            } else {
              $mo->{$symoid} = 'unknown_'.$result->{$fulloid};
              # oder $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$symoid.'Definition'}?
            }
          } else {
            $mo->{$symoid} = $result->{$fulloid};
          }
        }
      }
    }
    push(@entries, $mo);
  }
  if (@{$indices} and scalar(@{$indices}) == 1 and !defined $indices->[0]->[0]) {
    my $mo = {};
    foreach my $symoid
        (keys %{$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}}) {
      my $oid = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$symoid};
      if (ref($oid) ne 'HASH') {
        if (exists $result->{$oid}) {
          if (exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$symoid.'Definition'}) {
            if (ref($Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$symoid.'Definition'}) eq 'HASH') {
              if (exists $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$symoid.'Definition'}->{$result->{$oid}}) {
                $mo->{$symoid} = $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$symoid.'Definition'}->{$result->{$oid}};
                push(@entries, $mo);
              }
            } elsif ($Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$symoid.'Definition'} =~ /^(.*?)::(.*)/) {
              my $mib = $1;
              my $definition = $2;
              if  (exists $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib} &&
                  exists $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition} &&
                  ref($Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition}) eq 'CODE') {
                $mo->{$symoid} = $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition}->($result->{$oid});
              } elsif  (exists $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib} &&
                  exists $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition} &&
                  ref($Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition}) eq 'HASH' &&
                  exists $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition}->{$result->{$oid}}) {
                $mo->{$symoid} = $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{$mib}->{$definition}->{$result->{$oid}};
              } else {
                $mo->{$symoid} = 'unknown_'.$result->{$oid};
              }
            } else {
              $mo->{$symoid} = 'unknown_'.$result->{$oid};
              # oder $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$symoid.'Definition'}?
            }
          }
        }
      }
    }
    push(@entries, $mo) if keys %{$mo};
  }
  if (wantarray) {
    return @entries;
  } else {
    foreach my $entry (@entries) {
      foreach my $key (keys %{$entry}) {
        $self->{$key} = $entry->{$key};
      }
    }
  }
}

sub sort_oids {
  my ($self, $oids) = @_;
  $oids ||= [];
  my @sortedkeys = map { $_->[0] }
      sort { $a->[1] cmp $b->[1] }
          map { [$_,
                  join '', map { sprintf("%30d",$_) } split( /\./, $_)
                ] } @{$oids};
  return @sortedkeys;
}

sub get_matching_oids {
  my ($self, %params) = @_;
  my $result = {};
  $self->debug(sprintf "get_matching_oids %s", Data::Dumper::Dumper(\%params));
  foreach my $oid (@{$params{'-columns'}}) {
    my $oidpattern = $oid;
    $oidpattern =~ s/\./\\./g;
    map { $result->{$_} = $Monitoring::GLPlugin::SNMP::rawdata->{$_} }
        grep /^$oidpattern(?=\.|$)/, keys %{$Monitoring::GLPlugin::SNMP::rawdata};
  }
  $self->debug(sprintf "get_matching_oids returns %d from %d oids", 
      scalar(keys %{$result}), scalar(keys %{$Monitoring::GLPlugin::SNMP::rawdata}));
  return $result;
}

sub get_indices {
  my ($self, %params) = @_;
  # -baseoid : entry
  # find all oids beginning with $entry
  # then skip one field for the sequence
  # then read the next numindices fields
  my $entrypat = $params{'-baseoid'};
  $entrypat =~ s/\./\\\./g;
  my @indices = map {
      /^$entrypat\.\d+\.(.*)/ && $1;
  } grep {
      /^$entrypat/
  } keys %{$Monitoring::GLPlugin::SNMP::rawdata};
  my %seen = ();
  my @o = map {[split /\./]} sort grep !$seen{$_}++, @indices;
  return @o;
}

# this flattens a n-dimensional array and returns the absolute position
# of the element at position idx1,idx2,...,idxn
# element 1,2 in table 0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2 is at pos 6
sub get_number {
  my ($self, $indexlists, @element) = @_;
  # $indexlists = zeiger auf array aus [1, 2]
  my $dimensions = scalar(@{$indexlists->[0]});
  my @sorted = ();
  my $number = 0;
  if ($dimensions == 1) {
    @sorted =
        sort { $a->[0] <=> $b->[0] } @{$indexlists};
  } elsif ($dimensions == 2) {
    @sorted =
        sort { $a->[0] <=> $b->[0] || $a->[1] <=> $b->[1] } @{$indexlists};
  } elsif ($dimensions == 3) {
    @sorted =
        sort { $a->[0] <=> $b->[0] ||
               $a->[1] <=> $b->[1] ||
               $a->[2] <=> $b->[2] } @{$indexlists};
  }
  foreach (@sorted) {
    if ($dimensions == 1) {
      if ($_->[0] == $element[0]) {
        last;
      }
    } elsif ($dimensions == 2) {
      if ($_->[0] == $element[0] && $_->[1] == $element[1]) {
        last;
      }
    } elsif ($dimensions == 3) {
      if ($_->[0] == $element[0] &&
          $_->[1] == $element[1] &&
          $_->[2] == $element[2]) {
        last;
      }
    }
    $number++;
  }
  return ++$number;
}

################################################################
# caching functions
# 
sub set_rawdata {
  my ($self, $rawdata) = @_;
  $Monitoring::GLPlugin::SNMP::rawdata = $rawdata;
}

sub add_rawdata {
  my ($self, $oid, $value) = @_;
  $Monitoring::GLPlugin::SNMP::rawdata->{$oid} = $value;
}

sub rawdata {
  my ($self) = @_;
  return $Monitoring::GLPlugin::SNMP::rawdata;
}

sub add_oidtrace {
  my ($self, $oid) = @_;
  $self->debug("cache: ".$oid);
  push(@{$Monitoring::GLPlugin::SNMP::oidtrace}, $oid);
}

#  $self->update_entry_cache(0, $mib, $table, $key_attr);
#  my @indices = $self->get_cache_indices();
sub get_cache_indices {
  my ($self, $mib, $table, $key_attr) = @_;
  if (ref($key_attr) ne "ARRAY") {
    $key_attr = [$key_attr];
  }
  my $cache = sprintf "%s_%s_%s_cache", 
      $mib, $table, join('#', @{$key_attr});
  my @indices = ();
  foreach my $key (keys %{$self->{$cache}}) {
    my ($descr, $index) = split('-//-', $key, 2);
    if ($self->opts->name) {
      if ($self->opts->regexp) {
        my $pattern = $self->opts->name;
        if ($descr =~ /$pattern/i) {
          push(@indices, $self->{$cache}->{$key});
        }
      } else {
        if ($self->opts->name =~ /^\d+$/) {
          if ($index == 1 * $self->opts->name) {
            push(@indices, [1 * $self->opts->name]);
          }
        } else {
          if (lc $descr eq lc $self->opts->name) {
            push(@indices, $self->{$cache}->{$key});
          }
        }
      }
    } else {
      push(@indices, $self->{$cache}->{$key});
    }
  }
  return @indices;
  return map { join('.', ref($_) eq "ARRAY" ? @{$_} : $_) } @indices;
}

sub get_entities {
  my ($self, $class, $filter) = @_;
  foreach ($self->get_sub_table('ENTITY-MIB', [
    'entPhysicalDescr',
    'entPhysicalName',
    'entPhysicalClass',
  ])) {
    my $new_object = $class->new(%{$_});
    next if (defined $filter && ! &$filter($new_object));
    push @{$self->{entities}}, $new_object;
  }
}

sub get_sub_table {
  my ($self, $mib, $names) = @_;
  $self->require_mib($mib);
  my @oids = map {
    $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{$mib}->{$_}
  } @$names;
  my $result = $self->get_entries(
    -columns => \@oids
  );
  my $indices = ();
  map { if ($_ =~ /\.(\d+)$/) { $indices->{$1} = [ $1 ]; } } keys %$result;
  my @indices = values %$indices;
  my @entries = $self->make_symbolic($mib, $result, \@indices);
  @entries = map { $_->{indices} = shift @indices; $_ } @entries;
  @entries = map { $_->{flat_indices} = join(".", @{$_->{indices}}); $_ } @entries;
  return @entries;
}

sub join_table {
  my ($self, $to, $from) = @_;
  my $to_i = {};
  foreach (@$to) {
    my $i = $_->{flat_indices};
    $to_i->{$i} = $_;
  }
  foreach my $f (@$from) {
    my $i = $f->{flat_indices};
    if (exists $to_i->{$i}) {
      foreach (keys %$f) {
        next if $_ =~ /indices/;
        $to_i->{$i}->{$_} = $f->{$_};
      }
    }
  }
}




package Monitoring::GLPlugin::SNMP::MibsAndOids;
our @ISA = qw(Monitoring::GLPlugin::SNMP);

{
  no warnings qw(once);
  $Monitoring::GLPlugin::SNMP::MibsAndOids::discover_ids = {};
  $Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids = {};
  $Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids = {};
  $Monitoring::GLPlugin::SNMP::MibsAndOids::definitions = {};
  $Monitoring::GLPlugin::SNMP::MibsAndOids::origin = {};
}



package Monitoring::GLPlugin::SNMP::MibsAndOids::MIB2MIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'MIB-2-MIB'} = {
  url => "",
  name => "MIB-2-MIB",
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'MIB-2-MIB'} = {
  sysDescr => '1.3.6.1.2.1.1.1',
  sysObjectID => '1.3.6.1.2.1.1.2',
  sysUpTime => '1.3.6.1.2.1.1.3',
  sysName => '1.3.6.1.2.1.1.5',
  sysORTable => '1.3.6.1.2.1.1.9',
  sysOREntry => '1.3.6.1.2.1.1.9.1',
  sysORIndex => '1.3.6.1.2.1.1.9.1.1',
  sysORID => '1.3.6.1.2.1.1.9.1.2',
  sysORDescr => '1.3.6.1.2.1.1.9.1.3',
  sysORUpTime => '1.3.6.1.2.1.1.9.1.4',
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::SNMPFRAMEWORKMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'SNMP-FRAMEWORK-MIB'} = {
  url => "",
  name => "MIB-II",
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'SNMP-FRAMEWORK-MIB'} = {
  snmpEngineID => '1.3.6.1.6.3.10.2.1.1.0',
  snmpEngineBoots => '1.3.6.1.6.3.10.2.1.2.0',
  snmpEngineTime => '1.3.6.1.6.3.10.2.1.3.0',
  snmpEngineMaxMessageSize => '1.3.6.1.6.3.10.2.1.4.0',
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::AIRESPACESWITCHINGMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'AIRESPACE-SWITCHING-MIB'} = {
  url => '',
  name => 'AIRESPACE-SWITCHING-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'AIRESPACE-SWITCHING-MIB'} = {
  'bsnSwitching' => '1.3.6.1.4.1.14179.1',
  'agentInfoGroup' => '1.3.6.1.4.1.14179.1.1',
  'agentInventoryGroup' => '1.3.6.1.4.1.14179.1.1.1',
  'agentInventorySysDescription' => '1.3.6.1.4.1.14179.1.1.1.1',
  'agentInventoryMachineType' => '1.3.6.1.4.1.14179.1.1.1.2',
  'agentInventoryMachineModel' => '1.3.6.1.4.1.14179.1.1.1.3',
  'agentInventorySerialNumber' => '1.3.6.1.4.1.14179.1.1.1.4',
  'agentInventoryMaintenanceLevel' => '1.3.6.1.4.1.14179.1.1.1.6',
  'agentInventoryBurnedInMacAddress' => '1.3.6.1.4.1.14179.1.1.1.9',
  'agentInventoryOperatingSystem' => '1.3.6.1.4.1.14179.1.1.1.10',
  'agentInventoryManufacturerName' => '1.3.6.1.4.1.14179.1.1.1.12',
  'agentInventoryProductName' => '1.3.6.1.4.1.14179.1.1.1.13',
  'agentInventoryProductVersion' => '1.3.6.1.4.1.14179.1.1.1.14',
  'agentInventoryIsGigECardPresent' => '1.3.6.1.4.1.14179.1.1.1.15',
  'agentInventoryIsCryptoCardPresent' => '1.3.6.1.4.1.14179.1.1.1.16',
  'agentInventoryIsForeignAPSupported' => '1.3.6.1.4.1.14179.1.1.1.17',
  'agentInventoryMaxNumberOfAPsSupported' => '1.3.6.1.4.1.14179.1.1.1.18',
  'agentInventoryIsCryptoCard2Present' => '1.3.6.1.4.1.14179.1.1.1.19',
  'agentInventoryFipsModeEnabled' => '1.3.6.1.4.1.14179.1.1.1.20',
  'agentTrapLogGroup' => '1.3.6.1.4.1.14179.1.1.2',
  'agentTrapLogTotal' => '1.3.6.1.4.1.14179.1.1.2.1',
  'agentTrapLogTotalSinceLastViewed' => '1.3.6.1.4.1.14179.1.1.2.3',
  'agentTrapLogTable' => '1.3.6.1.4.1.14179.1.1.2.4',
  'agentTrapLogEntry' => '1.3.6.1.4.1.14179.1.1.2.4.1',
  'agentTrapLogIndex' => '1.3.6.1.4.1.14179.1.1.2.4.1.1',
  'agentTrapLogSystemTime' => '1.3.6.1.4.1.14179.1.1.2.4.1.2',
  'agentTrapLogTrap' => '1.3.6.1.4.1.14179.1.1.2.4.1.22',
  'agentRadioUpDownTrapCount' => '1.3.6.1.4.1.14179.1.1.2.5',
  'agentApAssociateDisassociateTrapCount' => '1.3.6.1.4.1.14179.1.1.2.6',
  'agentApLoadProfileFailTrapCount' => '1.3.6.1.4.1.14179.1.1.2.7',
  'agentApNoiseProfileFailTrapCount' => '1.3.6.1.4.1.14179.1.1.2.8',
  'agentApInterferenceProfileFailTrapCount' => '1.3.6.1.4.1.14179.1.1.2.9',
  'agentApCoverageProfileFailTrapCount' => '1.3.6.1.4.1.14179.1.1.2.10',
  'agentSwitchInfoGroup' => '1.3.6.1.4.1.14179.1.1.3',
  'agentSwitchInfoLwappTransportMode' => '1.3.6.1.4.1.14179.1.1.3.1',
  'agentSwitchInfoPowerSupply1Present' => '1.3.6.1.4.1.14179.1.1.3.2',
  'agentSwitchInfoPowerSupply1PresentDefinition' => {
    '0' => 'false',
    '1' => 'true',
  },
  'agentSwitchInfoPowerSupply1Operational' => '1.3.6.1.4.1.14179.1.1.3.3',
  'agentSwitchInfoPowerSupply1OperationalDefinition' => {
    '0' => 'false',
    '1' => 'true',
  },
  'agentSwitchInfoPowerSupply2Present' => '1.3.6.1.4.1.14179.1.1.3.4',
  'agentSwitchInfoPowerSupply2PresentDefinition' => {
    '0' => 'false',
    '1' => 'true',
  },
  'agentSwitchInfoPowerSupply2Operational' => '1.3.6.1.4.1.14179.1.1.3.5',
  'agentSwitchInfoPowerSupply2OperationalDefinition' => {
    '0' => 'false',
    '1' => 'true',
  },
  'agentProductGroup' => '1.3.6.1.4.1.14179.1.1.4',
  'productGroup1' => '1.3.6.1.4.1.14179.1.1.4.1',
  'productGroup2' => '1.3.6.1.4.1.14179.1.1.4.2',
  'productGroup3' => '1.3.6.1.4.1.14179.1.1.4.3',
  'productGroup4' => '1.3.6.1.4.1.14179.1.1.4.4',
  'agentResourceInfoGroup' => '1.3.6.1.4.1.14179.1.1.5',
  'agentCurrentCPUUtilization' => '1.3.6.1.4.1.14179.1.1.5.1.0',
  'agentTotalMemory' => '1.3.6.1.4.1.14179.1.1.5.2.0',
  'agentFreeMemory' => '1.3.6.1.4.1.14179.1.1.5.3.0',
  'agentWcpInfoGroup' => '1.3.6.1.4.1.14179.1.1.6',
  'agentWcpDeviceName' => '1.3.6.1.4.1.14179.1.1.6.1',
  'agentWcpSlotNumber' => '1.3.6.1.4.1.14179.1.1.6.2',
  'agentWcpPortNumber' => '1.3.6.1.4.1.14179.1.1.6.3',
  'agentWcpPeerPortNumber' => '1.3.6.1.4.1.14179.1.1.6.4',
  'agentWcpPeerIpAddress' => '1.3.6.1.4.1.14179.1.1.6.5',
  'agentWcpControllerTableChecksum' => '1.3.6.1.4.1.14179.1.1.6.6',
  'agentWcpControllerInfoTable' => '1.3.6.1.4.1.14179.1.1.6.7',
  'agentWcpControllerInfoEntry' => '1.3.6.1.4.1.14179.1.1.6.7.1',
  'agentWcpControllerInfoSlotNumber' => '1.3.6.1.4.1.14179.1.1.6.7.1.1',
  'agentWcpControllerInfoPortNumber' => '1.3.6.1.4.1.14179.1.1.6.7.1.2',
  'agentWcpControllerInfoIpAddress' => '1.3.6.1.4.1.14179.1.1.6.7.1.10',
  'agentConfigGroup' => '1.3.6.1.4.1.14179.1.2',
  'agentCLIConfigGroup' => '1.3.6.1.4.1.14179.1.2.1',
  'agentLoginSessionTable' => '1.3.6.1.4.1.14179.1.2.1.1',
  'agentLoginSessionEntry' => '1.3.6.1.4.1.14179.1.2.1.1.1',
  'agentLoginSessionIndex' => '1.3.6.1.4.1.14179.1.2.1.1.1.1',
  'agentLoginSessionUserName' => '1.3.6.1.4.1.14179.1.2.1.1.1.2',
  'agentLoginSessionIPAddress' => '1.3.6.1.4.1.14179.1.2.1.1.1.3',
  'agentLoginSessionConnectionType' => '1.3.6.1.4.1.14179.1.2.1.1.1.4',
  'agentLoginSessionIdleTime' => '1.3.6.1.4.1.14179.1.2.1.1.1.5',
  'agentLoginSessionSessionTime' => '1.3.6.1.4.1.14179.1.2.1.1.1.6',
  'agentLoginSessionStatus' => '1.3.6.1.4.1.14179.1.2.1.1.1.26',
  'agentTelnetConfigGroup' => '1.3.6.1.4.1.14179.1.2.1.2',
  'agentTelnetLoginTimeout' => '1.3.6.1.4.1.14179.1.2.1.2.1',
  'agentTelnetMaxSessions' => '1.3.6.1.4.1.14179.1.2.1.2.2',
  'agentTelnetAllowNewMode' => '1.3.6.1.4.1.14179.1.2.1.2.3',
  'agentSSHAllowNewMode' => '1.3.6.1.4.1.14179.1.2.1.2.4',
  'agentSerialGroup' => '1.3.6.1.4.1.14179.1.2.1.5',
  'agentSerialTimeout' => '1.3.6.1.4.1.14179.1.2.1.5.1',
  'agentSerialBaudrate' => '1.3.6.1.4.1.14179.1.2.1.5.2',
  'agentSerialCharacterSize' => '1.3.6.1.4.1.14179.1.2.1.5.3',
  'agentSerialHWFlowControlMode' => '1.3.6.1.4.1.14179.1.2.1.5.4',
  'agentSerialStopBits' => '1.3.6.1.4.1.14179.1.2.1.5.5',
  'agentSerialParityType' => '1.3.6.1.4.1.14179.1.2.1.5.6',
  'agentLagConfigGroup' => '1.3.6.1.4.1.14179.1.2.2',
  'agentLagConfigCreate' => '1.3.6.1.4.1.14179.1.2.2.1',
  'agentLagSummaryConfigTable' => '1.3.6.1.4.1.14179.1.2.2.2',
  'agentLagSummaryConfigEntry' => '1.3.6.1.4.1.14179.1.2.2.2.1',
  'agentLagSummaryName' => '1.3.6.1.4.1.14179.1.2.2.2.1.1',
  'agentLagSummaryLagIndex' => '1.3.6.1.4.1.14179.1.2.2.2.1.2',
  'agentLagSummaryFlushTimer' => '1.3.6.1.4.1.14179.1.2.2.2.1.3',
  'agentLagSummaryLinkTrap' => '1.3.6.1.4.1.14179.1.2.2.2.1.4',
  'agentLagSummaryAdminMode' => '1.3.6.1.4.1.14179.1.2.2.2.1.5',
  'agentLagSummaryStpMode' => '1.3.6.1.4.1.14179.1.2.2.2.1.6',
  'agentLagSummaryAddPort' => '1.3.6.1.4.1.14179.1.2.2.2.1.7',
  'agentLagSummaryDeletePort' => '1.3.6.1.4.1.14179.1.2.2.2.1.8',
  'agentLagSummaryPortsBitMask' => '1.3.6.1.4.1.14179.1.2.2.2.1.9',
  'agentLagSummaryStatus' => '1.3.6.1.4.1.14179.1.2.2.2.1.30',
  'agentLagDetailedConfigTable' => '1.3.6.1.4.1.14179.1.2.2.3',
  'agentLagDetailedConfigEntry' => '1.3.6.1.4.1.14179.1.2.2.3.1',
  'agentLagDetailedLagIndex' => '1.3.6.1.4.1.14179.1.2.2.3.1.1',
  'agentLagDetailedIfIndex' => '1.3.6.1.4.1.14179.1.2.2.3.1.2',
  'agentLagDetailedPortSpeed' => '1.3.6.1.4.1.14179.1.2.2.3.1.22',
  'agentLagConfigMode' => '1.3.6.1.4.1.14179.1.2.2.4',
  'agentNetworkConfigGroup' => '1.3.6.1.4.1.14179.1.2.3',
  'agentNetworkIPAddress' => '1.3.6.1.4.1.14179.1.2.3.1',
  'agentNetworkSubnetMask' => '1.3.6.1.4.1.14179.1.2.3.2',
  'agentNetworkDefaultGateway' => '1.3.6.1.4.1.14179.1.2.3.3',
  'agentNetworkBurnedInMacAddress' => '1.3.6.1.4.1.14179.1.2.3.4',
  'agentNetworkConfigProtocol' => '1.3.6.1.4.1.14179.1.2.3.7',
  'agentNetworkWebMode' => '1.3.6.1.4.1.14179.1.2.3.8',
  'agentNetworkSecureWebMode' => '1.3.6.1.4.1.14179.1.2.3.9',
  'agentNetworkMulticastMode' => '1.3.6.1.4.1.14179.1.2.3.10',
  'agentNetworkDsPortNumber' => '1.3.6.1.4.1.14179.1.2.3.11',
  'agentNetworkUserIdleTimeout' => '1.3.6.1.4.1.14179.1.2.3.12',
  'agentNetworkArpTimeout' => '1.3.6.1.4.1.14179.1.2.3.13',
  'agentNetworkManagementVlan' => '1.3.6.1.4.1.14179.1.2.3.14',
  'agentNetworkGvrpStatus' => '1.3.6.1.4.1.14179.1.2.3.15',
  'agentNetworkAllowMgmtViaWireless' => '1.3.6.1.4.1.14179.1.2.3.16',
  'agentNetworkBroadcastSsidMode' => '1.3.6.1.4.1.14179.1.2.3.17',
  'agentNetworkSecureWebPassword' => '1.3.6.1.4.1.14179.1.2.3.18',
  'agentNetworkWebAdminCertType' => '1.3.6.1.4.1.14179.1.2.3.19',
  'agentNetworkWebAdminCertRegenerateCmdInvoke' => '1.3.6.1.4.1.14179.1.2.3.20',
  'agentNetworkWebAuthCertType' => '1.3.6.1.4.1.14179.1.2.3.21',
  'agentNetworkWebAuthCertRegenerateCmdInvoke' => '1.3.6.1.4.1.14179.1.2.3.22',
  'agentNetworkRouteConfigTable' => '1.3.6.1.4.1.14179.1.2.3.23',
  'agentNetworkRouteConfigEntry' => '1.3.6.1.4.1.14179.1.2.3.23.1',
  'agentNetworkRouteIPAddress' => '1.3.6.1.4.1.14179.1.2.3.23.1.1',
  'agentNetworkRouteIPNetmask' => '1.3.6.1.4.1.14179.1.2.3.23.1.2',
  'agentNetworkRouteGateway' => '1.3.6.1.4.1.14179.1.2.3.23.1.3',
  'agentNetworkRouteStatus' => '1.3.6.1.4.1.14179.1.2.3.23.1.23',
  'agentNetworkPeerToPeerBlockingMode' => '1.3.6.1.4.1.14179.1.2.3.24',
  'agentNetworkMulticastGroupAddress' => '1.3.6.1.4.1.14179.1.2.3.25',
  'agentServicePortConfigGroup' => '1.3.6.1.4.1.14179.1.2.4',
  'agentServicePortIPAddress' => '1.3.6.1.4.1.14179.1.2.4.1',
  'agentServicePortSubnetMask' => '1.3.6.1.4.1.14179.1.2.4.2',
  'agentServicePortDefaultGateway' => '1.3.6.1.4.1.14179.1.2.4.3',
  'agentServicePortBurnedInMacAddress' => '1.3.6.1.4.1.14179.1.2.4.4',
  'agentServicePortConfigProtocol' => '1.3.6.1.4.1.14179.1.2.4.5',
  'agentSnmpConfigGroup' => '1.3.6.1.4.1.14179.1.2.5',
  'agentSnmpTrapPortNumber' => '1.3.6.1.4.1.14179.1.2.5.1',
  'agentSnmpVersion1Status' => '1.3.6.1.4.1.14179.1.2.5.2',
  'agentSnmpVersion2cStatus' => '1.3.6.1.4.1.14179.1.2.5.3',
  'agentSnmpCommunityConfigTable' => '1.3.6.1.4.1.14179.1.2.5.5',
  'agentSnmpCommunityConfigEntry' => '1.3.6.1.4.1.14179.1.2.5.5.1',
  'agentSnmpCommunityName' => '1.3.6.1.4.1.14179.1.2.5.5.1.1',
  'agentSnmpCommunityIPAddress' => '1.3.6.1.4.1.14179.1.2.5.5.1.2',
  'agentSnmpCommunityIPMask' => '1.3.6.1.4.1.14179.1.2.5.5.1.3',
  'agentSnmpCommunityAccessMode' => '1.3.6.1.4.1.14179.1.2.5.5.1.4',
  'agentSnmpCommunityEnabled' => '1.3.6.1.4.1.14179.1.2.5.5.1.5',
  'agentSnmpCommunityStatus' => '1.3.6.1.4.1.14179.1.2.5.5.1.25',
  'agentSnmpTrapReceiverConfigTable' => '1.3.6.1.4.1.14179.1.2.5.6',
  'agentSnmpTrapReceiverConfigEntry' => '1.3.6.1.4.1.14179.1.2.5.6.1',
  'agentSnmpTrapReceiverName' => '1.3.6.1.4.1.14179.1.2.5.6.1.1',
  'agentSnmpTrapReceiverIPAddress' => '1.3.6.1.4.1.14179.1.2.5.6.1.2',
  'agentSnmpTrapReceiverEnabled' => '1.3.6.1.4.1.14179.1.2.5.6.1.3',
  'agentSnmpTrapReceiverStatus' => '1.3.6.1.4.1.14179.1.2.5.6.1.23',
  'agentSnmpTrapFlagsConfigGroup' => '1.3.6.1.4.1.14179.1.2.5.7',
  'agentSnmpAuthenticationTrapFlag' => '1.3.6.1.4.1.14179.1.2.5.7.1',
  'agentSnmpLinkUpDownTrapFlag' => '1.3.6.1.4.1.14179.1.2.5.7.2',
  'agentSnmpMultipleUsersTrapFlag' => '1.3.6.1.4.1.14179.1.2.5.7.3',
  'agentSnmpSpanningTreeTrapFlag' => '1.3.6.1.4.1.14179.1.2.5.7.4',
  'agentSnmpBroadcastStormTrapFlag' => '1.3.6.1.4.1.14179.1.2.5.7.5',
  'agentSnmpV3ConfigGroup' => '1.3.6.1.4.1.14179.1.2.6',
  'agentSnmpVersion3Status' => '1.3.6.1.4.1.14179.1.2.6.1',
  'agentSnmpV3UserConfigTable' => '1.3.6.1.4.1.14179.1.2.6.2',
  'agentSnmpV3UserConfigEntry' => '1.3.6.1.4.1.14179.1.2.6.2.1',
  'agentSnmpV3UserName' => '1.3.6.1.4.1.14179.1.2.6.2.1.1',
  'agentSnmpV3UserAccessMode' => '1.3.6.1.4.1.14179.1.2.6.2.1.2',
  'agentSnmpV3UserAuthenticationType' => '1.3.6.1.4.1.14179.1.2.6.2.1.3',
  'agentSnmpV3UserEncryptionType' => '1.3.6.1.4.1.14179.1.2.6.2.1.4',
  'agentSnmpV3UserAuthenticationPassword' => '1.3.6.1.4.1.14179.1.2.6.2.1.5',
  'agentSnmpV3UserEncryptionPassword' => '1.3.6.1.4.1.14179.1.2.6.2.1.6',
  'agentSnmpV3UserStatus' => '1.3.6.1.4.1.14179.1.2.6.2.1.26',
  'agentSpanningTreeConfigGroup' => '1.3.6.1.4.1.14179.1.2.7',
  'agentSpanningTreeMode' => '1.3.6.1.4.1.14179.1.2.7.1',
  'agentSwitchConfigGroup' => '1.3.6.1.4.1.14179.1.2.8',
  'agentSwitchBroadcastControlMode' => '1.3.6.1.4.1.14179.1.2.8.2',
  'agentSwitchDot3FlowControlMode' => '1.3.6.1.4.1.14179.1.2.8.3',
  'agentSwitchAddressAgingTimeoutTable' => '1.3.6.1.4.1.14179.1.2.8.4',
  'agentSwitchAddressAgingTimeoutEntry' => '1.3.6.1.4.1.14179.1.2.8.4.1',
  'agentSwitchAddressAgingTimeout' => '1.3.6.1.4.1.14179.1.2.8.4.1.10',
  'agentSwitchLwappTransportMode' => '1.3.6.1.4.1.14179.1.2.8.5',
  'agentTransferConfigGroup' => '1.3.6.1.4.1.14179.1.2.9',
  'agentTransferUploadGroup' => '1.3.6.1.4.1.14179.1.2.9.1',
  'agentTransferUploadMode' => '1.3.6.1.4.1.14179.1.2.9.1.1',
  'agentTransferUploadServerIP' => '1.3.6.1.4.1.14179.1.2.9.1.2',
  'agentTransferUploadPath' => '1.3.6.1.4.1.14179.1.2.9.1.3',
  'agentTransferUploadFilename' => '1.3.6.1.4.1.14179.1.2.9.1.4',
  'agentTransferUploadDataType' => '1.3.6.1.4.1.14179.1.2.9.1.5',
  'agentTransferUploadStart' => '1.3.6.1.4.1.14179.1.2.9.1.6',
  'agentTransferUploadStatus' => '1.3.6.1.4.1.14179.1.2.9.1.7',
  'agentTransferDownloadGroup' => '1.3.6.1.4.1.14179.1.2.9.2',
  'agentTransferDownloadMode' => '1.3.6.1.4.1.14179.1.2.9.2.1',
  'agentTransferDownloadServerIP' => '1.3.6.1.4.1.14179.1.2.9.2.2',
  'agentTransferDownloadPath' => '1.3.6.1.4.1.14179.1.2.9.2.3',
  'agentTransferDownloadFilename' => '1.3.6.1.4.1.14179.1.2.9.2.4',
  'agentTransferDownloadDataType' => '1.3.6.1.4.1.14179.1.2.9.2.5',
  'agentTransferDownloadStart' => '1.3.6.1.4.1.14179.1.2.9.2.6',
  'agentTransferDownloadStatus' => '1.3.6.1.4.1.14179.1.2.9.2.7',
  'agentTransferDownloadTftpMaxRetries' => '1.3.6.1.4.1.14179.1.2.9.2.8',
  'agentTransferDownloadTftpTimeout' => '1.3.6.1.4.1.14179.1.2.9.2.9',
  'agentTransferConfigurationFileEncryption' => '1.3.6.1.4.1.14179.1.2.9.3',
  'agentTransferConfigurationFileEncryptionKey' => '1.3.6.1.4.1.14179.1.2.9.4',
  'agentDot3adAggPortTable' => '1.3.6.1.4.1.14179.1.2.11',
  'agentDot3adAggPortEntry' => '1.3.6.1.4.1.14179.1.2.11.1',
  'agentDot3adAggPort' => '1.3.6.1.4.1.14179.1.2.11.1.1',
  'agentDot3adAggPortLACPMode' => '1.3.6.1.4.1.14179.1.2.11.1.21',
  'agentPortConfigTable' => '1.3.6.1.4.1.14179.1.2.12',
  'agentPortConfigEntry' => '1.3.6.1.4.1.14179.1.2.12.1',
  'agentPortDot1dBasePort' => '1.3.6.1.4.1.14179.1.2.12.1.1',
  'agentPortIfIndex' => '1.3.6.1.4.1.14179.1.2.12.1.2',
  'agentPortIanaType' => '1.3.6.1.4.1.14179.1.2.12.1.3',
  'agentPortSTPMode' => '1.3.6.1.4.1.14179.1.2.12.1.4',
  'agentPortSTPState' => '1.3.6.1.4.1.14179.1.2.12.1.5',
  'agentPortAdminMode' => '1.3.6.1.4.1.14179.1.2.12.1.6',
  'agentPortPhysicalMode' => '1.3.6.1.4.1.14179.1.2.12.1.7',
  'agentPortPhysicalStatus' => '1.3.6.1.4.1.14179.1.2.12.1.8',
  'agentPortLinkTrapMode' => '1.3.6.1.4.1.14179.1.2.12.1.9',
  'agentPortClearStats' => '1.3.6.1.4.1.14179.1.2.12.1.10',
  'agentPortDefaultType' => '1.3.6.1.4.1.14179.1.2.12.1.11',
  'agentPortType' => '1.3.6.1.4.1.14179.1.2.12.1.12',
  'agentPortAutoNegAdminStatus' => '1.3.6.1.4.1.14179.1.2.12.1.13',
  'agentPortDot3FlowControlMode' => '1.3.6.1.4.1.14179.1.2.12.1.14',
  'agentPortPowerMode' => '1.3.6.1.4.1.14179.1.2.12.1.15',
  'agentPortGvrpStatus' => '1.3.6.1.4.1.14179.1.2.12.1.16',
  'agentPortGarpJoinTime' => '1.3.6.1.4.1.14179.1.2.12.1.17',
  'agentPortGarpLeaveTime' => '1.3.6.1.4.1.14179.1.2.12.1.18',
  'agentPortGarpLeaveAllTime' => '1.3.6.1.4.1.14179.1.2.12.1.19',
  'agentPortMirrorMode' => '1.3.6.1.4.1.14179.1.2.12.1.20',
  'agentPortMulticastApplianceMode' => '1.3.6.1.4.1.14179.1.2.12.1.21',
  'agentPortOperationalStatus' => '1.3.6.1.4.1.14179.1.2.12.1.40',
  'agentInterfaceConfigTable' => '1.3.6.1.4.1.14179.1.2.13',
  'agentInterfaceConfigEntry' => '1.3.6.1.4.1.14179.1.2.13.1',
  'agentInterfaceName' => '1.3.6.1.4.1.14179.1.2.13.1.1',
  'agentInterfaceVlanId' => '1.3.6.1.4.1.14179.1.2.13.1.2',
  'agentInterfaceType' => '1.3.6.1.4.1.14179.1.2.13.1.3',
  'agentInterfaceMacAddress' => '1.3.6.1.4.1.14179.1.2.13.1.4',
  'agentInterfaceIPAddress' => '1.3.6.1.4.1.14179.1.2.13.1.5',
  'agentInterfaceIPNetmask' => '1.3.6.1.4.1.14179.1.2.13.1.6',
  'agentInterfaceIPGateway' => '1.3.6.1.4.1.14179.1.2.13.1.7',
  'agentInterfacePortNo' => '1.3.6.1.4.1.14179.1.2.13.1.8',
  'agentInterfacePrimaryDhcpAddress' => '1.3.6.1.4.1.14179.1.2.13.1.9',
  'agentInterfaceSecondaryDhcpAddress' => '1.3.6.1.4.1.14179.1.2.13.1.10',
  'agentInterfaceDhcpProtocol' => '1.3.6.1.4.1.14179.1.2.13.1.11',
  'agentInterfaceDnsHostName' => '1.3.6.1.4.1.14179.1.2.13.1.12',
  'agentInterfaceAclName' => '1.3.6.1.4.1.14179.1.2.13.1.13',
  'agentInterfaceAPManagementFeature' => '1.3.6.1.4.1.14179.1.2.13.1.14',
  'agentInterfaceActivePortNo' => '1.3.6.1.4.1.14179.1.2.13.1.15',
  'agentInterfaceBackupPortNo' => '1.3.6.1.4.1.14179.1.2.13.1.16',
  'agentInterfaceVlanQuarantine' => '1.3.6.1.4.1.14179.1.2.13.1.17',
  'agentInterfaceRowStatus' => '1.3.6.1.4.1.14179.1.2.13.1.31',
  'agentNtpConfigGroup' => '1.3.6.1.4.1.14179.1.2.14',
  'agentNtpPollingInterval' => '1.3.6.1.4.1.14179.1.2.14.1',
  'agentNtpServerTable' => '1.3.6.1.4.1.14179.1.2.14.2',
  'agentNtpServerEntry' => '1.3.6.1.4.1.14179.1.2.14.2.1',
  'agentNtpServerIndex' => '1.3.6.1.4.1.14179.1.2.14.2.1.1',
  'agentNtpServerAddress' => '1.3.6.1.4.1.14179.1.2.14.2.1.2',
  'agentNtpServerRowStatus' => '1.3.6.1.4.1.14179.1.2.14.2.1.20',
  'agentDhcpConfigGroup' => '1.3.6.1.4.1.14179.1.2.15',
  'agentDhcpScopeTable' => '1.3.6.1.4.1.14179.1.2.15.1',
  'agentDhcpScopeEntry' => '1.3.6.1.4.1.14179.1.2.15.1.1',
  'agentDhcpScopeIndex' => '1.3.6.1.4.1.14179.1.2.15.1.1.1',
  'agentDhcpScopeName' => '1.3.6.1.4.1.14179.1.2.15.1.1.2',
  'agentDhcpScopeLeaseTime' => '1.3.6.1.4.1.14179.1.2.15.1.1.3',
  'agentDhcpScopeNetwork' => '1.3.6.1.4.1.14179.1.2.15.1.1.4',
  'agentDhcpScopeNetmask' => '1.3.6.1.4.1.14179.1.2.15.1.1.5',
  'agentDhcpScopePoolStartAddress' => '1.3.6.1.4.1.14179.1.2.15.1.1.6',
  'agentDhcpScopePoolEndAddress' => '1.3.6.1.4.1.14179.1.2.15.1.1.7',
  'agentDhcpScopeDefaultRouterAddress1' => '1.3.6.1.4.1.14179.1.2.15.1.1.8',
  'agentDhcpScopeDefaultRouterAddress2' => '1.3.6.1.4.1.14179.1.2.15.1.1.9',
  'agentDhcpScopeDefaultRouterAddress3' => '1.3.6.1.4.1.14179.1.2.15.1.1.10',
  'agentDhcpScopeDnsDomainName' => '1.3.6.1.4.1.14179.1.2.15.1.1.11',
  'agentDhcpScopeDnsServerAddress1' => '1.3.6.1.4.1.14179.1.2.15.1.1.12',
  'agentDhcpScopeDnsServerAddress2' => '1.3.6.1.4.1.14179.1.2.15.1.1.13',
  'agentDhcpScopeDnsServerAddress3' => '1.3.6.1.4.1.14179.1.2.15.1.1.14',
  'agentDhcpScopeNetbiosNameServerAddress1' => '1.3.6.1.4.1.14179.1.2.15.1.1.15',
  'agentDhcpScopeNetbiosNameServerAddress2' => '1.3.6.1.4.1.14179.1.2.15.1.1.16',
  'agentDhcpScopeNetbiosNameServerAddress3' => '1.3.6.1.4.1.14179.1.2.15.1.1.17',
  'agentDhcpScopeState' => '1.3.6.1.4.1.14179.1.2.15.1.1.18',
  'agentDhcpScopeRowStatus' => '1.3.6.1.4.1.14179.1.2.15.1.1.30',
  'agentSystemGroup' => '1.3.6.1.4.1.14179.1.3',
  'agentSaveConfig' => '1.3.6.1.4.1.14179.1.3.1',
  'agentClearConfig' => '1.3.6.1.4.1.14179.1.3.2',
  'agentClearLags' => '1.3.6.1.4.1.14179.1.3.3',
  'agentClearLoginSessions' => '1.3.6.1.4.1.14179.1.3.4',
  'agentClearPortStats' => '1.3.6.1.4.1.14179.1.3.6',
  'agentClearSwitchStats' => '1.3.6.1.4.1.14179.1.3.7',
  'agentClearTrapLog' => '1.3.6.1.4.1.14179.1.3.8',
  'agentResetSystem' => '1.3.6.1.4.1.14179.1.3.10',
  'stats' => '1.3.6.1.4.1.14179.1.4',
  'portStatsTable' => '1.3.6.1.4.1.14179.1.4.1',
  'portStatsEntry' => '1.3.6.1.4.1.14179.1.4.1.1',
  'portStatsIndex' => '1.3.6.1.4.1.14179.1.4.1.1.1',
  'portStatsPktsTx64Octets' => '1.3.6.1.4.1.14179.1.4.1.1.2',
  'portStatsPktsTx65to127Octets' => '1.3.6.1.4.1.14179.1.4.1.1.3',
  'portStatsPktsTx128to255Octets' => '1.3.6.1.4.1.14179.1.4.1.1.4',
  'portStatsPktsTx256to511Octets' => '1.3.6.1.4.1.14179.1.4.1.1.5',
  'portStatsPktsTx512to1023Octets' => '1.3.6.1.4.1.14179.1.4.1.1.6',
  'portStatsPktsTx1024to1518Octets' => '1.3.6.1.4.1.14179.1.4.1.1.7',
  'portStatsPktsRx1519to1530Octets' => '1.3.6.1.4.1.14179.1.4.1.1.8',
  'portStatsPktsTx1519to1530Octets' => '1.3.6.1.4.1.14179.1.4.1.1.9',
  'portStatsPktsTxOversizeOctets' => '1.3.6.1.4.1.14179.1.4.1.1.30',
  'switchingTraps' => '1.3.6.1.4.1.14179.1.50',
  'multipleUsersTrap' => '1.3.6.1.4.1.14179.1.50.1',
  'broadcastStormStartTrap' => '1.3.6.1.4.1.14179.1.50.2',
  'broadcastStormEndTrap' => '1.3.6.1.4.1.14179.1.50.3',
  'linkFailureTrap' => '1.3.6.1.4.1.14179.1.50.4',
  'vlanRequestFailureTrap' => '1.3.6.1.4.1.14179.1.50.5',
  'vlanDeleteLastTrap' => '1.3.6.1.4.1.14179.1.50.6',
  'vlanDefaultCfgFailureTrap' => '1.3.6.1.4.1.14179.1.50.7',
  'vlanRestoreFailureTrap' => '1.3.6.1.4.1.14179.1.50.8',
  'fanFailureTrap' => '1.3.6.1.4.1.14179.1.50.9',
  'stpInstanceNewRootTrap' => '1.3.6.1.4.1.14179.1.50.10',
  'stpInstanceTopologyChangeTrap' => '1.3.6.1.4.1.14179.1.50.11',
  'powerSupplyStatusChangeTrap' => '1.3.6.1.4.1.14179.1.50.12',
  'bsnSwitchingGroups' => '1.3.6.1.4.1.14179.1.51',
  'bsnSwitchingAgentInfoGroup' => '1.3.6.1.4.1.14179.1.51.1',
  'bsnSwitchingAgentConfigGroup' => '1.3.6.1.4.1.14179.1.51.2',
  'bsnSwitchingAgentSystemGroup' => '1.3.6.1.4.1.14179.1.51.3',
  'bsnSwitchingAgentStatsGroup' => '1.3.6.1.4.1.14179.1.51.4',
  'bsnSwitchingObsGroup' => '1.3.6.1.4.1.14179.1.51.5',
  'bsnSwitchingTrap' => '1.3.6.1.4.1.14179.1.51.6',
  'bsnSwitchingCompliances' => '1.3.6.1.4.1.14179.1.52',
  'bsnSwitchingCompliance' => '1.3.6.1.4.1.14179.1.52.1',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::AIRESPACEWIRELESSMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'AIRESPACE-WIRELESS-MIB'} = {
  url => '',
  name => 'AIRESPACE-WIRELESS-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'AIRESPACE-WIRELESS-MIB'} = {
  'bsnWireless' => '1.3.6.1.4.1.14179.2',
  'bsnEss' => '1.3.6.1.4.1.14179.2.1',
  'bsnDot11EssTable' => '1.3.6.1.4.1.14179.2.1.1',
  'bsnDot11EssEntry' => '1.3.6.1.4.1.14179.2.1.1.1',
  'bsnDot11EssIndex' => '1.3.6.1.4.1.14179.2.1.1.1.1',
  'bsnDot11EssSsid' => '1.3.6.1.4.1.14179.2.1.1.1.2',
  'bsnDot11EssSessionTimeout' => '1.3.6.1.4.1.14179.2.1.1.1.4',
  'bsnDot11EssMacFiltering' => '1.3.6.1.4.1.14179.2.1.1.1.5',
  'bsnDot11EssAdminStatus' => '1.3.6.1.4.1.14179.2.1.1.1.6',
  'bsnDot11EssSecurityAuthType' => '1.3.6.1.4.1.14179.2.1.1.1.7',
  'bsnDot11EssStaticWEPSecurity' => '1.3.6.1.4.1.14179.2.1.1.1.8',
  'bsnDot11EssStaticWEPEncryptionType' => '1.3.6.1.4.1.14179.2.1.1.1.9',
  'bsnDot11EssStaticWEPDefaultKey' => '1.3.6.1.4.1.14179.2.1.1.1.10',
  'bsnDot11EssStaticWEPKeyIndex' => '1.3.6.1.4.1.14179.2.1.1.1.11',
  'bsnDot11EssStaticWEPKeyFormat' => '1.3.6.1.4.1.14179.2.1.1.1.12',
  'bsnDot11Ess8021xSecurity' => '1.3.6.1.4.1.14179.2.1.1.1.13',
  'bsnDot11Ess8021xEncryptionType' => '1.3.6.1.4.1.14179.2.1.1.1.14',
  'bsnDot11EssWPASecurity' => '1.3.6.1.4.1.14179.2.1.1.1.16',
  'bsnDot11EssWPAEncryptionType' => '1.3.6.1.4.1.14179.2.1.1.1.17',
  'bsnDot11EssIpsecSecurity' => '1.3.6.1.4.1.14179.2.1.1.1.18',
  'bsnDot11EssVpnEncrTransform' => '1.3.6.1.4.1.14179.2.1.1.1.19',
  'bsnDot11EssVpnAuthTransform' => '1.3.6.1.4.1.14179.2.1.1.1.20',
  'bsnDot11EssVpnIkeAuthMode' => '1.3.6.1.4.1.14179.2.1.1.1.21',
  'bsnDot11EssVpnSharedKey' => '1.3.6.1.4.1.14179.2.1.1.1.22',
  'bsnDot11EssVpnSharedKeySize' => '1.3.6.1.4.1.14179.2.1.1.1.23',
  'bsnDot11EssVpnIkePhase1Mode' => '1.3.6.1.4.1.14179.2.1.1.1.24',
  'bsnDot11EssVpnIkeLifetime' => '1.3.6.1.4.1.14179.2.1.1.1.25',
  'bsnDot11EssVpnIkeDHGroup' => '1.3.6.1.4.1.14179.2.1.1.1.26',
  'bsnDot11EssIpsecPassthruSecurity' => '1.3.6.1.4.1.14179.2.1.1.1.27',
  'bsnDot11EssVpnPassthruGateway' => '1.3.6.1.4.1.14179.2.1.1.1.28',
  'bsnDot11EssWebSecurity' => '1.3.6.1.4.1.14179.2.1.1.1.29',
  'bsnDot11EssRadioPolicy' => '1.3.6.1.4.1.14179.2.1.1.1.30',
  'bsnDot11EssQualityOfService' => '1.3.6.1.4.1.14179.2.1.1.1.31',
  'bsnDot11EssDhcpRequired' => '1.3.6.1.4.1.14179.2.1.1.1.32',
  'bsnDot11EssDhcpServerIpAddress' => '1.3.6.1.4.1.14179.2.1.1.1.33',
  'bsnDot11EssVpnContivityMode' => '1.3.6.1.4.1.14179.2.1.1.1.34',
  'bsnDot11EssVpnQotdServerAddress' => '1.3.6.1.4.1.14179.2.1.1.1.35',
  'bsnDot11EssBlacklistTimeout' => '1.3.6.1.4.1.14179.2.1.1.1.37',
  'bsnDot11EssNumberOfMobileStations' => '1.3.6.1.4.1.14179.2.1.1.1.38',
  'bsnDot11EssWebPassthru' => '1.3.6.1.4.1.14179.2.1.1.1.39',
  'bsnDot11EssCraniteSecurity' => '1.3.6.1.4.1.14179.2.1.1.1.40',
  'bsnDot11EssBlacklistingCapability' => '1.3.6.1.4.1.14179.2.1.1.1.41',
  'bsnDot11EssInterfaceName' => '1.3.6.1.4.1.14179.2.1.1.1.42',
  'bsnDot11EssAclName' => '1.3.6.1.4.1.14179.2.1.1.1.43',
  'bsnDot11EssAAAOverride' => '1.3.6.1.4.1.14179.2.1.1.1.44',
  'bsnDot11EssWPAAuthKeyMgmtMode' => '1.3.6.1.4.1.14179.2.1.1.1.45',
  'bsnDot11EssWPAAuthPresharedKey' => '1.3.6.1.4.1.14179.2.1.1.1.46',
  'bsnDot11EssFortressSecurity' => '1.3.6.1.4.1.14179.2.1.1.1.47',
  'bsnDot11EssWepAllowSharedKeyAuth' => '1.3.6.1.4.1.14179.2.1.1.1.48',
  'bsnDot11EssL2tpSecurity' => '1.3.6.1.4.1.14179.2.1.1.1.49',
  'bsnDot11EssWPAAuthPresharedKeyHex' => '1.3.6.1.4.1.14179.2.1.1.1.50',
  'bsnDot11EssBroadcastSsid' => '1.3.6.1.4.1.14179.2.1.1.1.51',
  'bsnDot11EssExternalPolicyValidation' => '1.3.6.1.4.1.14179.2.1.1.1.52',
  'bsnDot11EssRSNSecurity' => '1.3.6.1.4.1.14179.2.1.1.1.53',
  'bsnDot11EssRSNWPACompatibilityMode' => '1.3.6.1.4.1.14179.2.1.1.1.54',
  'bsnDot11EssRSNAllowTKIPClients' => '1.3.6.1.4.1.14179.2.1.1.1.55',
  'bsnDot11EssRSNAuthKeyMgmtMode' => '1.3.6.1.4.1.14179.2.1.1.1.56',
  'bsnDot11EssRSNAuthPresharedKey' => '1.3.6.1.4.1.14179.2.1.1.1.57',
  'bsnDot11EssRSNAuthPresharedKeyHex' => '1.3.6.1.4.1.14179.2.1.1.1.58',
  'bsnDot11EssIPv6Bridging' => '1.3.6.1.4.1.14179.2.1.1.1.59',
  'bsnDot11EssRowStatus' => '1.3.6.1.4.1.14179.2.1.1.1.60',
  'bsnDot11EssWmePolicySetting' => '1.3.6.1.4.1.14179.2.1.1.1.61',
  'bsnDot11Ess80211ePolicySetting' => '1.3.6.1.4.1.14179.2.1.1.1.62',
  'bsnDot11EssWebPassthroughEmail' => '1.3.6.1.4.1.14179.2.1.1.1.63',
  'bsnDot11Ess7920PhoneSupport' => '1.3.6.1.4.1.14179.2.1.1.1.64',
  'bsnDot11EssRadiusAuthPrimaryServer' => '1.3.6.1.4.1.14179.2.1.1.1.95',
  'bsnDot11EssRadiusAuthSecondaryServer' => '1.3.6.1.4.1.14179.2.1.1.1.96',
  'bsnDot11EssRadiusAuthTertiaryServer' => '1.3.6.1.4.1.14179.2.1.1.1.97',
  'bsnDot11EssRadiusAcctPrimaryServer' => '1.3.6.1.4.1.14179.2.1.1.1.98',
  'bsnDot11EssRadiusAcctSecondaryServer' => '1.3.6.1.4.1.14179.2.1.1.1.99',
  'bsnDot11EssRadiusAcctTertiaryServer' => '1.3.6.1.4.1.14179.2.1.1.1.100',
  'bsnMobileStationTable' => '1.3.6.1.4.1.14179.2.1.4',
  'bsnMobileStationEntry' => '1.3.6.1.4.1.14179.2.1.4.1',
  'bsnMobileStationMacAddress' => '1.3.6.1.4.1.14179.2.1.4.1.1',
  'bsnMobileStationIpAddress' => '1.3.6.1.4.1.14179.2.1.4.1.2',
  'bsnMobileStationUserName' => '1.3.6.1.4.1.14179.2.1.4.1.3',
  'bsnMobileStationAPMacAddr' => '1.3.6.1.4.1.14179.2.1.4.1.4',
  'bsnMobileStationAPIfSlotId' => '1.3.6.1.4.1.14179.2.1.4.1.5',
  'bsnMobileStationEssIndex' => '1.3.6.1.4.1.14179.2.1.4.1.6',
  'bsnMobileStationSsid' => '1.3.6.1.4.1.14179.2.1.4.1.7',
  'bsnMobileStationAID' => '1.3.6.1.4.1.14179.2.1.4.1.8',
  'bsnMobileStationStatus' => '1.3.6.1.4.1.14179.2.1.4.1.9',
  'bsnMobileStationReasonCode' => '1.3.6.1.4.1.14179.2.1.4.1.10',
  'bsnMobileStationMobilityStatus' => '1.3.6.1.4.1.14179.2.1.4.1.11',
  'bsnMobileStationAnchorAddress' => '1.3.6.1.4.1.14179.2.1.4.1.12',
  'bsnMobileStationCFPollable' => '1.3.6.1.4.1.14179.2.1.4.1.13',
  'bsnMobileStationCFPollRequest' => '1.3.6.1.4.1.14179.2.1.4.1.14',
  'bsnMobileStationChannelAgilityEnabled' => '1.3.6.1.4.1.14179.2.1.4.1.15',
  'bsnMobileStationPBCCOptionImplemented' => '1.3.6.1.4.1.14179.2.1.4.1.16',
  'bsnMobileStationShortPreambleOptionImplemented' => '1.3.6.1.4.1.14179.2.1.4.1.17',
  'bsnMobileStationSessionTimeout' => '1.3.6.1.4.1.14179.2.1.4.1.18',
  'bsnMobileStationAuthenticationAlgorithm' => '1.3.6.1.4.1.14179.2.1.4.1.19',
  'bsnMobileStationWepState' => '1.3.6.1.4.1.14179.2.1.4.1.20',
  'bsnMobileStationPortNumber' => '1.3.6.1.4.1.14179.2.1.4.1.21',
  'bsnMobileStationDeleteAction' => '1.3.6.1.4.1.14179.2.1.4.1.22',
  'bsnMobileStationPolicyManagerState' => '1.3.6.1.4.1.14179.2.1.4.1.23',
  'bsnMobileStationSecurityPolicyStatus' => '1.3.6.1.4.1.14179.2.1.4.1.24',
  'bsnMobileStationProtocol' => '1.3.6.1.4.1.14179.2.1.4.1.25',
  'bsnMobileStationMirrorMode' => '1.3.6.1.4.1.14179.2.1.4.1.26',
  'bsnMobileStationInterface' => '1.3.6.1.4.1.14179.2.1.4.1.27',
  'bsnMobileStationApMode' => '1.3.6.1.4.1.14179.2.1.4.1.28',
  'bsnMobileStationVlanId' => '1.3.6.1.4.1.14179.2.1.4.1.29',
  'bsnMobileStationPolicyType' => '1.3.6.1.4.1.14179.2.1.4.1.30',
  'bsnMobileStationEncryptionCypher' => '1.3.6.1.4.1.14179.2.1.4.1.31',
  'bsnMobileStationEapType' => '1.3.6.1.4.1.14179.2.1.4.1.32',
  'bsnMobileStationCcxVersion' => '1.3.6.1.4.1.14179.2.1.4.1.33',
  'bsnMobileStationE2eVersion' => '1.3.6.1.4.1.14179.2.1.4.1.34',
  'bsnMobileStationStatusCode' => '1.3.6.1.4.1.14179.2.1.4.1.42',
  'bsnMobileStationPerRadioPerVapTable' => '1.3.6.1.4.1.14179.2.1.5',
  'bsnMobileStationPerRadioPerVapEntry' => '1.3.6.1.4.1.14179.2.1.5.1',
  'bsnMobileStationPerRadioPerVapIndex' => '1.3.6.1.4.1.14179.2.1.5.1.1',
  'bsnMobileStationMacAddr' => '1.3.6.1.4.1.14179.2.1.5.1.20',
  'bsnMobileStationStatsTable' => '1.3.6.1.4.1.14179.2.1.6',
  'bsnMobileStationStatsEntry' => '1.3.6.1.4.1.14179.2.1.6.1',
  'bsnMobileStationRSSI' => '1.3.6.1.4.1.14179.2.1.6.1.1',
  'bsnMobileStationBytesReceived' => '1.3.6.1.4.1.14179.2.1.6.1.2',
  'bsnMobileStationBytesSent' => '1.3.6.1.4.1.14179.2.1.6.1.3',
  'bsnMobileStationPolicyErrors' => '1.3.6.1.4.1.14179.2.1.6.1.4',
  'bsnMobileStationPacketsReceived' => '1.3.6.1.4.1.14179.2.1.6.1.5',
  'bsnMobileStationPacketsSent' => '1.3.6.1.4.1.14179.2.1.6.1.6',
  'bsnMobileStationSnr' => '1.3.6.1.4.1.14179.2.1.6.1.26',
  'bsnRogueAPTable' => '1.3.6.1.4.1.14179.2.1.7',
  'bsnRogueAPEntry' => '1.3.6.1.4.1.14179.2.1.7.1',
  'bsnRogueAPDot11MacAddress' => '1.3.6.1.4.1.14179.2.1.7.1.1',
  'bsnRogueAPTotalDetectingAPs' => '1.3.6.1.4.1.14179.2.1.7.1.2',
  'bsnRogueAPFirstReported' => '1.3.6.1.4.1.14179.2.1.7.1.3',
  'bsnRogueAPLastReported' => '1.3.6.1.4.1.14179.2.1.7.1.4',
  'bsnRogueAPContainmentLevel' => '1.3.6.1.4.1.14179.2.1.7.1.5',
  'bsnRogueAPType' => '1.3.6.1.4.1.14179.2.1.7.1.6',
  'bsnRogueAPOnNetwork' => '1.3.6.1.4.1.14179.2.1.7.1.7',
  'bsnRogueAPTotalClients' => '1.3.6.1.4.1.14179.2.1.7.1.8',
  'bsnRogueAPRowStatus' => '1.3.6.1.4.1.14179.2.1.7.1.9',
  'bsnRogueAPMaxDetectedRSSI' => '1.3.6.1.4.1.14179.2.1.7.1.10',
  'bsnRogueAPSSID' => '1.3.6.1.4.1.14179.2.1.7.1.11',
  'bsnRogueAPDetectingAPRadioType' => '1.3.6.1.4.1.14179.2.1.7.1.12',
  'bsnRogueAPDetectingAPMacAddress' => '1.3.6.1.4.1.14179.2.1.7.1.13',
  'bsnRogueAPMaxRssiRadioType' => '1.3.6.1.4.1.14179.2.1.7.1.14',
  'bsnRogueAPState' => '1.3.6.1.4.1.14179.2.1.7.1.24',
  'bsnRogueAPClassType' => '1.3.6.1.4.1.14179.2.1.7.1.25',
  'bsnRogueAPChannel' => '1.3.6.1.4.1.14179.2.1.7.1.26',
  'bsnRogueAPDetectingAPName' => '1.3.6.1.4.1.14179.2.1.7.1.27',
  'bsnRogueAPAirespaceAPTable' => '1.3.6.1.4.1.14179.2.1.8',
  'bsnRogueAPAirespaceAPEntry' => '1.3.6.1.4.1.14179.2.1.8.1',
  'bsnRogueAPAirespaceAPMacAddress' => '1.3.6.1.4.1.14179.2.1.8.1.1',
  'bsnRogueAPAirespaceAPSlotId' => '1.3.6.1.4.1.14179.2.1.8.1.2',
  'bsnRogueAPRadioType' => '1.3.6.1.4.1.14179.2.1.8.1.3',
  'bsnRogueAPAirespaceAPName' => '1.3.6.1.4.1.14179.2.1.8.1.4',
  'bsnRogueAPChannelNumber' => '1.3.6.1.4.1.14179.2.1.8.1.5',
  'bsnRogueAPSsid' => '1.3.6.1.4.1.14179.2.1.8.1.6',
  'bsnRogueAPAirespaceAPRSSI' => '1.3.6.1.4.1.14179.2.1.8.1.7',
  'bsnRogueAPContainmentMode' => '1.3.6.1.4.1.14179.2.1.8.1.8',
  'bsnRogueAPContainmentChannelCount' => '1.3.6.1.4.1.14179.2.1.8.1.9',
  'bsnRogueAPContainmentChannels' => '1.3.6.1.4.1.14179.2.1.8.1.10',
  'bsnRogueAPAirespaceAPLastHeard' => '1.3.6.1.4.1.14179.2.1.8.1.11',
  'bsnRogueAPAirespaceAPWepMode' => '1.3.6.1.4.1.14179.2.1.8.1.12',
  'bsnRogueAPAirespaceAPPreamble' => '1.3.6.1.4.1.14179.2.1.8.1.13',
  'bsnRogueAPAirespaceAPWpaMode' => '1.3.6.1.4.1.14179.2.1.8.1.14',
  'bsnRogueAPAirespaceAPSNR' => '1.3.6.1.4.1.14179.2.1.8.1.27',
  'bsnRogueAPChannelWidth' => '1.3.6.1.4.1.14179.2.1.8.1.28',
  'bsnThirdPartyAPTable' => '1.3.6.1.4.1.14179.2.1.9',
  'bsnThirdPartyAPEntry' => '1.3.6.1.4.1.14179.2.1.9.1',
  'bsnThirdPartyAPMacAddress' => '1.3.6.1.4.1.14179.2.1.9.1.1',
  'bsnThirdPartyAPInterface' => '1.3.6.1.4.1.14179.2.1.9.1.2',
  'bsnThirdPartyAPIpAddress' => '1.3.6.1.4.1.14179.2.1.9.1.3',
  'bsnThirdPartyAP802Dot1XRequired' => '1.3.6.1.4.1.14179.2.1.9.1.4',
  'bsnThirdPartyAPMirrorMode' => '1.3.6.1.4.1.14179.2.1.9.1.5',
  'bsnThirdPartyAPRowStatus' => '1.3.6.1.4.1.14179.2.1.9.1.24',
  'bsnMobileStationByIpTable' => '1.3.6.1.4.1.14179.2.1.10',
  'bsnMobileStationByIpEntry' => '1.3.6.1.4.1.14179.2.1.10.1',
  'bsnMobileStationByIpAddress' => '1.3.6.1.4.1.14179.2.1.10.1.1',
  'bsnMobileStationByIpMacAddress' => '1.3.6.1.4.1.14179.2.1.10.1.2',
  'bsnMobileStationRssiDataTable' => '1.3.6.1.4.1.14179.2.1.11',
  'bsnMobileStationRssiDataEntry' => '1.3.6.1.4.1.14179.2.1.11.1',
  'bsnMobileStationRssiDataApMacAddress' => '1.3.6.1.4.1.14179.2.1.11.1.1',
  'bsnMobileStationRssiDataApIfSlotId' => '1.3.6.1.4.1.14179.2.1.11.1.2',
  'bsnMobileStationRssiDataApIfType' => '1.3.6.1.4.1.14179.2.1.11.1.3',
  'bsnMobileStationRssiDataApName' => '1.3.6.1.4.1.14179.2.1.11.1.4',
  'bsnMobileStationRssiData' => '1.3.6.1.4.1.14179.2.1.11.1.5',
  'bsnAPIfPhyAntennaIndex' => '1.3.6.1.4.1.14179.2.1.11.1.6',
  'bsnMobileStationRssiDataLastHeard' => '1.3.6.1.4.1.14179.2.1.11.1.25',
  'bsnWatchListClientTable' => '1.3.6.1.4.1.14179.2.1.12',
  'bsnWatchListClientEntry' => '1.3.6.1.4.1.14179.2.1.12.1',
  'bsnWatchListClientKey' => '1.3.6.1.4.1.14179.2.1.12.1.1',
  'bsnWatchListClientType' => '1.3.6.1.4.1.14179.2.1.12.1.2',
  'bsnWatchListClientRowStatus' => '1.3.6.1.4.1.14179.2.1.12.1.20',
  'bsnMobileStationByUsernameTable' => '1.3.6.1.4.1.14179.2.1.13',
  'bsnMobileStationByUsernameEntry' => '1.3.6.1.4.1.14179.2.1.13.1',
  'bsnMobileStationByUserName' => '1.3.6.1.4.1.14179.2.1.13.1.1',
  'bsnMobileStationByUserMacAddress' => '1.3.6.1.4.1.14179.2.1.13.1.2',
  'bsnRogueClientTable' => '1.3.6.1.4.1.14179.2.1.14',
  'bsnRogueClientEntry' => '1.3.6.1.4.1.14179.2.1.14.1',
  'bsnRogueClientDot11MacAddress' => '1.3.6.1.4.1.14179.2.1.14.1.1',
  'bsnRogueClientTotalDetectingAPs' => '1.3.6.1.4.1.14179.2.1.14.1.2',
  'bsnRogueClientFirstReported' => '1.3.6.1.4.1.14179.2.1.14.1.3',
  'bsnRogueClientLastReported' => '1.3.6.1.4.1.14179.2.1.14.1.4',
  'bsnRogueClientBSSID' => '1.3.6.1.4.1.14179.2.1.14.1.5',
  'bsnRogueClientContainmentLevel' => '1.3.6.1.4.1.14179.2.1.14.1.6',
  'bsnRogueClientLastHeard' => '1.3.6.1.4.1.14179.2.1.14.1.7',
  'bsnRogueClientState' => '1.3.6.1.4.1.14179.2.1.14.1.24',
  'bsnRogueClientAirespaceAPTable' => '1.3.6.1.4.1.14179.2.1.15',
  'bsnRogueClientAirespaceAPEntry' => '1.3.6.1.4.1.14179.2.1.15.1',
  'bsnRogueClientAirespaceAPMacAddress' => '1.3.6.1.4.1.14179.2.1.15.1.1',
  'bsnRogueClientAirespaceAPSlotId' => '1.3.6.1.4.1.14179.2.1.15.1.2',
  'bsnRogueClientRadioType' => '1.3.6.1.4.1.14179.2.1.15.1.3',
  'bsnRogueClientAirespaceAPName' => '1.3.6.1.4.1.14179.2.1.15.1.4',
  'bsnRogueClientChannelNumber' => '1.3.6.1.4.1.14179.2.1.15.1.5',
  'bsnRogueClientAirespaceAPRSSI' => '1.3.6.1.4.1.14179.2.1.15.1.7',
  'bsnRogueClientAirespaceAPLastHeard' => '1.3.6.1.4.1.14179.2.1.15.1.11',
  'bsnRogueClientAirespaceAPSNR' => '1.3.6.1.4.1.14179.2.1.15.1.27',
  'bsnRogueClientPerRogueAPTable' => '1.3.6.1.4.1.14179.2.1.16',
  'bsnRogueClientPerRogueAPEntry' => '1.3.6.1.4.1.14179.2.1.16.1',
  'bsnRogueAPDot11MacAddr' => '1.3.6.1.4.1.14179.2.1.16.1.1',
  'bsnRogueClientDot11MacAddr' => '1.3.6.1.4.1.14179.2.1.16.1.20',
  'bsnDot11QosProfileTable' => '1.3.6.1.4.1.14179.2.1.17',
  'bsnDot11QosProfileEntry' => '1.3.6.1.4.1.14179.2.1.17.1',
  'bsnDot11QosProfileName' => '1.3.6.1.4.1.14179.2.1.17.1.1',
  'bsnDot11QosProfileDesc' => '1.3.6.1.4.1.14179.2.1.17.1.2',
  'bsnDot11QosAverageDataRate' => '1.3.6.1.4.1.14179.2.1.17.1.3',
  'bsnDot11QosBurstDataRate' => '1.3.6.1.4.1.14179.2.1.17.1.4',
  'bsnDot11QosAvgRealTimeDataRate' => '1.3.6.1.4.1.14179.2.1.17.1.5',
  'bsnDot11QosBurstRealTimeDataRate' => '1.3.6.1.4.1.14179.2.1.17.1.6',
  'bsnDot11QosMaxRFUsagePerAP' => '1.3.6.1.4.1.14179.2.1.17.1.7',
  'bsnDot11QosProfileQueueDepth' => '1.3.6.1.4.1.14179.2.1.17.1.8',
  'bsnDot11WiredQosProtocol' => '1.3.6.1.4.1.14179.2.1.17.1.9',
  'bsnDot11802Dot1PTag' => '1.3.6.1.4.1.14179.2.1.17.1.10',
  'bsnDot11ResetProfileToDefault' => '1.3.6.1.4.1.14179.2.1.17.1.40',
  'bsnTagTable' => '1.3.6.1.4.1.14179.2.1.18',
  'bsnTagEntry' => '1.3.6.1.4.1.14179.2.1.18.1',
  'bsnTagDot11MacAddress' => '1.3.6.1.4.1.14179.2.1.18.1.1',
  'bsnTagType' => '1.3.6.1.4.1.14179.2.1.18.1.2',
  'bsnTagTimeInterval' => '1.3.6.1.4.1.14179.2.1.18.1.3',
  'bsnTagBatteryStatus' => '1.3.6.1.4.1.14179.2.1.18.1.4',
  'bsnTagLastReported' => '1.3.6.1.4.1.14179.2.1.18.1.23',
  'bsnTagRssiDataTable' => '1.3.6.1.4.1.14179.2.1.19',
  'bsnTagRssiDataEntry' => '1.3.6.1.4.1.14179.2.1.19.1',
  'bsnTagRssiDataApMacAddress' => '1.3.6.1.4.1.14179.2.1.19.1.1',
  'bsnTagRssiDataApIfSlotId' => '1.3.6.1.4.1.14179.2.1.19.1.2',
  'bsnTagRssiDataApIfType' => '1.3.6.1.4.1.14179.2.1.19.1.3',
  'bsnTagRssiDataApName' => '1.3.6.1.4.1.14179.2.1.19.1.4',
  'bsnTagRssiDataLastHeard' => '1.3.6.1.4.1.14179.2.1.19.1.5',
  'bsnTagRssiData' => '1.3.6.1.4.1.14179.2.1.19.1.6',
  'bsnTagRssiDataSnr' => '1.3.6.1.4.1.14179.2.1.19.1.26',
  'bsnTagStatsTable' => '1.3.6.1.4.1.14179.2.1.20',
  'bsnTagStatsEntry' => '1.3.6.1.4.1.14179.2.1.20.1',
  'bsnTagBytesReceived' => '1.3.6.1.4.1.14179.2.1.20.1.1',
  'bsnTagPacketsReceived' => '1.3.6.1.4.1.14179.2.1.20.1.20',
  'bsnMobileStationExtStatsTable' => '1.3.6.1.4.1.14179.2.1.21',
  'bsnMobileStationExtStatsEntry' => '1.3.6.1.4.1.14179.2.1.21.1',
  'bsnMobileStationSampleTime' => '1.3.6.1.4.1.14179.2.1.21.1.1',
  'bsnMobileStationTxExcessiveRetries' => '1.3.6.1.4.1.14179.2.1.21.1.2',
  'bsnMobileStationTxRetries' => '1.3.6.1.4.1.14179.2.1.21.1.3',
  'bsnMobileStationTxFiltered' => '1.3.6.1.4.1.14179.2.1.21.1.20',
  'bsnAP' => '1.3.6.1.4.1.14179.2.2',
  'bsnAPTable' => '1.3.6.1.4.1.14179.2.2.1',
  'bsnAPEntry' => '1.3.6.1.4.1.14179.2.2.1.1',
  'bsnAPDot3MacAddress' => '1.3.6.1.4.1.14179.2.2.1.1.1',
  'bsnAPNumOfSlots' => '1.3.6.1.4.1.14179.2.2.1.1.2',
  'bsnAPName' => '1.3.6.1.4.1.14179.2.2.1.1.3',
  'bsnAPLocation' => '1.3.6.1.4.1.14179.2.2.1.1.4',
  'bsnAPMonitorOnlyMode' => '1.3.6.1.4.1.14179.2.2.1.1.5',
  'bsnAPOperationStatus' => '1.3.6.1.4.1.14179.2.2.1.1.6',
  'bsnAPOperationStatusDefinition' => {
    '1' => 'associated',
    '2' => 'disassociating',
    '3' => 'downloading',
  },
  'bsnAPSoftwareVersion' => '1.3.6.1.4.1.14179.2.2.1.1.8',
  'bsnAPBootVersion' => '1.3.6.1.4.1.14179.2.2.1.1.9',
  'bsnAPPrimaryMwarName' => '1.3.6.1.4.1.14179.2.2.1.1.10',
  'bsnAPReset' => '1.3.6.1.4.1.14179.2.2.1.1.11',
  'bsnAPStatsTimer' => '1.3.6.1.4.1.14179.2.2.1.1.12',
  'bsnAPPortNumber' => '1.3.6.1.4.1.14179.2.2.1.1.13',
  'bsnAPModel' => '1.3.6.1.4.1.14179.2.2.1.1.16',
  'bsnAPSerialNumber' => '1.3.6.1.4.1.14179.2.2.1.1.17',
  'bsnAPClearConfig' => '1.3.6.1.4.1.14179.2.2.1.1.18',
  'bsnApIpAddress' => '1.3.6.1.4.1.14179.2.2.1.1.19',
  'bsnAPMirrorMode' => '1.3.6.1.4.1.14179.2.2.1.1.20',
  'bsnAPRemoteModeSupport' => '1.3.6.1.4.1.14179.2.2.1.1.21',
  'bsnAPType' => '1.3.6.1.4.1.14179.2.2.1.1.22',
  'bsnAPTypeDefinition' => {
    '1' => 'ap1000',
    '2' => 'ap1030',
    '3' => 'mimo',
    '4' => 'unknown',
    '5' => 'ap1100',
    '6' => 'ap1130',
    '7' => 'ap1240',
    '8' => 'ap1200',
    '9' => 'ap1310',
    '10' => 'ap1500',
    '11' => 'ap1250',
    '12' => 'ap1505',
    '13' => 'ap3201',
    '14' => 'ap1520',
    '15' => 'ap800',
    '16' => 'ap1140',
    '17' => 'ap800agn',
    '18' => 'ap3500i',
    '19' => 'ap3500e',
    '20' => 'ap1260',
  },
  'bsnAPSecondaryMwarName' => '1.3.6.1.4.1.14179.2.2.1.1.23',
  'bsnAPTertiaryMwarName' => '1.3.6.1.4.1.14179.2.2.1.1.24',
  'bsnAPIsStaticIP' => '1.3.6.1.4.1.14179.2.2.1.1.25',
  'bsnAPNetmask' => '1.3.6.1.4.1.14179.2.2.1.1.26',
  'bsnAPGateway' => '1.3.6.1.4.1.14179.2.2.1.1.27',
  'bsnAPStaticIPAddress' => '1.3.6.1.4.1.14179.2.2.1.1.28',
  'bsnAPBridgingSupport' => '1.3.6.1.4.1.14179.2.2.1.1.29',
  'bsnAPGroupVlanName' => '1.3.6.1.4.1.14179.2.2.1.1.30',
  'bsnAPIOSVersion' => '1.3.6.1.4.1.14179.2.2.1.1.31',
  'bsnAPCertificateType' => '1.3.6.1.4.1.14179.2.2.1.1.32',
  'bsnAPEthernetMacAddress' => '1.3.6.1.4.1.14179.2.2.1.1.33',
  'bsnAPAdminStatus' => '1.3.6.1.4.1.14179.2.2.1.1.37',
  'bsnAPIfTable' => '1.3.6.1.4.1.14179.2.2.2',
  'bsnAPIfEntry' => '1.3.6.1.4.1.14179.2.2.2.1',
  'bsnAPIfSlotId' => '1.3.6.1.4.1.14179.2.2.2.1.1',
  'bsnAPIfType' => '1.3.6.1.4.1.14179.2.2.2.1.2',
  'bsnAPIfPhyChannelAssignment' => '1.3.6.1.4.1.14179.2.2.2.1.3',
  'bsnAPIfPhyChannelNumber' => '1.3.6.1.4.1.14179.2.2.2.1.4',
  'bsnAPIfPhyTxPowerControl' => '1.3.6.1.4.1.14179.2.2.2.1.5',
  'bsnAPIfPhyTxPowerLevel' => '1.3.6.1.4.1.14179.2.2.2.1.6',
  'bsnAPIfPhyAntennaMode' => '1.3.6.1.4.1.14179.2.2.2.1.7',
  'bsnAPIfPhyAntennaType' => '1.3.6.1.4.1.14179.2.2.2.1.8',
  'bsnAPIfPhyAntennaDiversity' => '1.3.6.1.4.1.14179.2.2.2.1.9',
  'bsnAPIfCellSiteConfigId' => '1.3.6.1.4.1.14179.2.2.2.1.10',
  'bsnAPIfNumberOfVaps' => '1.3.6.1.4.1.14179.2.2.2.1.11',
  'bsnAPIfOperStatus' => '1.3.6.1.4.1.14179.2.2.2.1.12',
  'bsnAPIfPortNumber' => '1.3.6.1.4.1.14179.2.2.2.1.13',
  'bsnAPIfPhyAntennaOptions' => '1.3.6.1.4.1.14179.2.2.2.1.14',
  'bsnApIfNoOfUsers' => '1.3.6.1.4.1.14179.2.2.2.1.15',
  'bsnAPIfWlanOverride' => '1.3.6.1.4.1.14179.2.2.2.1.16',
  'bsnAPIfPacketsSniffingFeature' => '1.3.6.1.4.1.14179.2.2.2.1.17',
  'bsnAPIfSniffChannel' => '1.3.6.1.4.1.14179.2.2.2.1.18',
  'bsnAPIfSniffServerIPAddress' => '1.3.6.1.4.1.14179.2.2.2.1.19',
  'bsnAPIfAntennaGain' => '1.3.6.1.4.1.14179.2.2.2.1.20',
  'bsnAPIfChannelList' => '1.3.6.1.4.1.14179.2.2.2.1.21',
  'bsnAPIfAbsolutePowerList' => '1.3.6.1.4.1.14179.2.2.2.1.22',
  'bsnAPIfRegulatoryDomainSupport' => '1.3.6.1.4.1.14179.2.2.2.1.23',
  'bsnAPIfAdminStatus' => '1.3.6.1.4.1.14179.2.2.2.1.34',
  'bsnAPIfSmtParamTable' => '1.3.6.1.4.1.14179.2.2.3',
  'bsnAPIfSmtParamEntry' => '1.3.6.1.4.1.14179.2.2.3.1',
  'bsnAPIfDot11BeaconPeriod' => '1.3.6.1.4.1.14179.2.2.3.1.1',
  'bsnAPIfDot11MediumOccupancyLimit' => '1.3.6.1.4.1.14179.2.2.3.1.2',
  'bsnAPIfDot11CFPPeriod' => '1.3.6.1.4.1.14179.2.2.3.1.3',
  'bsnAPIfDot11CFPMaxDuration' => '1.3.6.1.4.1.14179.2.2.3.1.4',
  'bsnAPIfDot11OperationalRateSet' => '1.3.6.1.4.1.14179.2.2.3.1.5',
  'bsnAPIfDot11DTIMPeriod' => '1.3.6.1.4.1.14179.2.2.3.1.6',
  'bsnAPIfDot11MultiDomainCapabilityImplemented' => '1.3.6.1.4.1.14179.2.2.3.1.7',
  'bsnAPIfDot11MultiDomainCapabilityEnabled' => '1.3.6.1.4.1.14179.2.2.3.1.8',
  'bsnAPIfDot11CountryString' => '1.3.6.1.4.1.14179.2.2.3.1.9',
  'bsnAPIfDot11SmtParamsConfigType' => '1.3.6.1.4.1.14179.2.2.3.1.10',
  'bsnAPIfDot11BSSID' => '1.3.6.1.4.1.14179.2.2.3.1.30',
  'bsnAPIfMultiDomainCapabilityTable' => '1.3.6.1.4.1.14179.2.2.4',
  'bsnAPIfMultiDomainCapabilityEntry' => '1.3.6.1.4.1.14179.2.2.4.1',
  'bsnAPIfDot11MaximumTransmitPowerLevel' => '1.3.6.1.4.1.14179.2.2.4.1.1',
  'bsnAPIfDot11FirstChannelNumber' => '1.3.6.1.4.1.14179.2.2.4.1.2',
  'bsnAPIfDot11NumberofChannels' => '1.3.6.1.4.1.14179.2.2.4.1.20',
  'bsnAPIfMacOperationParamTable' => '1.3.6.1.4.1.14179.2.2.5',
  'bsnAPIfMacOperationParamEntry' => '1.3.6.1.4.1.14179.2.2.5.1',
  'bsnAPIfDot11MacRTSThreshold' => '1.3.6.1.4.1.14179.2.2.5.1.1',
  'bsnAPIfDot11MacShortRetryLimit' => '1.3.6.1.4.1.14179.2.2.5.1.2',
  'bsnAPIfDot11MacLongRetryLimit' => '1.3.6.1.4.1.14179.2.2.5.1.3',
  'bsnAPIfDot11MacFragmentationThreshold' => '1.3.6.1.4.1.14179.2.2.5.1.4',
  'bsnAPIfDot11MacMaxTransmitMSDULifetime' => '1.3.6.1.4.1.14179.2.2.5.1.5',
  'bsnAPIfDot11MacParamsConfigType' => '1.3.6.1.4.1.14179.2.2.5.1.6',
  'bsnAPIfDot11MacMaxReceiveLifetime' => '1.3.6.1.4.1.14179.2.2.5.1.25',
  'bsnAPIfDot11CountersTable' => '1.3.6.1.4.1.14179.2.2.6',
  'bsnAPIfDot11CountersEntry' => '1.3.6.1.4.1.14179.2.2.6.1',
  'bsnAPIfDot11TransmittedFragmentCount' => '1.3.6.1.4.1.14179.2.2.6.1.1',
  'bsnAPIfDot11MulticastTransmittedFrameCount' => '1.3.6.1.4.1.14179.2.2.6.1.2',
  'bsnAPIfDot11RetryCount' => '1.3.6.1.4.1.14179.2.2.6.1.3',
  'bsnAPIfDot11MultipleRetryCount' => '1.3.6.1.4.1.14179.2.2.6.1.4',
  'bsnAPIfDot11FrameDuplicateCount' => '1.3.6.1.4.1.14179.2.2.6.1.5',
  'bsnAPIfDot11RTSSuccessCount' => '1.3.6.1.4.1.14179.2.2.6.1.6',
  'bsnAPIfDot11RTSFailureCount' => '1.3.6.1.4.1.14179.2.2.6.1.7',
  'bsnAPIfDot11ACKFailureCount' => '1.3.6.1.4.1.14179.2.2.6.1.8',
  'bsnAPIfDot11ReceivedFragmentCount' => '1.3.6.1.4.1.14179.2.2.6.1.9',
  'bsnAPIfDot11MulticastReceivedFrameCount' => '1.3.6.1.4.1.14179.2.2.6.1.10',
  'bsnAPIfDot11FCSErrorCount' => '1.3.6.1.4.1.14179.2.2.6.1.11',
  'bsnAPIfDot11TransmittedFrameCount' => '1.3.6.1.4.1.14179.2.2.6.1.12',
  'bsnAPIfDot11WEPUndecryptableCount' => '1.3.6.1.4.1.14179.2.2.6.1.13',
  'bsnAPIfDot11FailedCount' => '1.3.6.1.4.1.14179.2.2.6.1.33',
  'bsnAPIfDot11PhyTxPowerTable' => '1.3.6.1.4.1.14179.2.2.8',
  'bsnAPIfDot11PhyTxPowerEntry' => '1.3.6.1.4.1.14179.2.2.8.1',
  'bsnAPIfDot11NumberSupportedPowerLevels' => '1.3.6.1.4.1.14179.2.2.8.1.1',
  'bsnAPIfDot11TxPowerLevel1' => '1.3.6.1.4.1.14179.2.2.8.1.2',
  'bsnAPIfDot11TxPowerLevel2' => '1.3.6.1.4.1.14179.2.2.8.1.3',
  'bsnAPIfDot11TxPowerLevel3' => '1.3.6.1.4.1.14179.2.2.8.1.4',
  'bsnAPIfDot11TxPowerLevel4' => '1.3.6.1.4.1.14179.2.2.8.1.5',
  'bsnAPIfDot11TxPowerLevel5' => '1.3.6.1.4.1.14179.2.2.8.1.6',
  'bsnAPIfDot11TxPowerLevel6' => '1.3.6.1.4.1.14179.2.2.8.1.7',
  'bsnAPIfDot11TxPowerLevel7' => '1.3.6.1.4.1.14179.2.2.8.1.8',
  'bsnAPIfDot11TxPowerLevel8' => '1.3.6.1.4.1.14179.2.2.8.1.28',
  'bsnAPIfDot11PhyChannelTable' => '1.3.6.1.4.1.14179.2.2.9',
  'bsnAPIfDot11PhyChannelEntry' => '1.3.6.1.4.1.14179.2.2.9.1',
  'bsnAPIfDot11CurrentCCAMode' => '1.3.6.1.4.1.14179.2.2.9.1.1',
  'bsnAPIfDot11EDThreshold' => '1.3.6.1.4.1.14179.2.2.9.1.2',
  'bsnAPIfDot11TIThreshold' => '1.3.6.1.4.1.14179.2.2.9.1.23',
  'bsnAPIfProfileThresholdConfigTable' => '1.3.6.1.4.1.14179.2.2.12',
  'bsnAPIfProfileThresholdConfigEntry' => '1.3.6.1.4.1.14179.2.2.12.1',
  'bsnAPIfProfileParamAssignment' => '1.3.6.1.4.1.14179.2.2.12.1.1',
  'bsnAPIfForeignInterferenceThreshold' => '1.3.6.1.4.1.14179.2.2.12.1.2',
  'bsnAPIfForeignNoiseThreshold' => '1.3.6.1.4.1.14179.2.2.12.1.3',
  'bsnAPIfRFUtilizationThreshold' => '1.3.6.1.4.1.14179.2.2.12.1.4',
  'bsnAPIfThroughputThreshold' => '1.3.6.1.4.1.14179.2.2.12.1.5',
  'bsnAPIfMobilesThreshold' => '1.3.6.1.4.1.14179.2.2.12.1.6',
  'bsnAPIfCoverageThreshold' => '1.3.6.1.4.1.14179.2.2.12.1.7',
  'bsnAPIfMobileMinExceptionLevel' => '1.3.6.1.4.1.14179.2.2.12.1.8',
  'bsnAPIfCoverageExceptionLevel' => '1.3.6.1.4.1.14179.2.2.12.1.28',
  'bsnAPIfLoadParametersTable' => '1.3.6.1.4.1.14179.2.2.13',
  'bsnAPIfLoadParametersEntry' => '1.3.6.1.4.1.14179.2.2.13.1',
  'bsnAPIfLoadRxUtilization' => '1.3.6.1.4.1.14179.2.2.13.1.1',
  'bsnAPIfLoadTxUtilization' => '1.3.6.1.4.1.14179.2.2.13.1.2',
  'bsnAPIfLoadChannelUtilization' => '1.3.6.1.4.1.14179.2.2.13.1.3',
  'bsnAPIfLoadNumOfClients' => '1.3.6.1.4.1.14179.2.2.13.1.4',
  'bsnAPIfPoorSNRClients' => '1.3.6.1.4.1.14179.2.2.13.1.24',
  'bsnAPIfChannelInterferenceInfoTable' => '1.3.6.1.4.1.14179.2.2.14',
  'bsnAPIfChannelInterferenceInfoEntry' => '1.3.6.1.4.1.14179.2.2.14.1',
  'bsnAPIfInterferenceChannelNo' => '1.3.6.1.4.1.14179.2.2.14.1.1',
  'bsnAPIfInterferencePower' => '1.3.6.1.4.1.14179.2.2.14.1.2',
  'bsnAPIfInterferenceUtilization' => '1.3.6.1.4.1.14179.2.2.14.1.22',
  'bsnAPIfChannelNoiseInfoTable' => '1.3.6.1.4.1.14179.2.2.15',
  'bsnAPIfChannelNoiseInfoEntry' => '1.3.6.1.4.1.14179.2.2.15.1',
  'bsnAPIfNoiseChannelNo' => '1.3.6.1.4.1.14179.2.2.15.1.1',
  'bsnAPIfDBNoisePower' => '1.3.6.1.4.1.14179.2.2.15.1.21',
  'bsnAPIfProfileStateTable' => '1.3.6.1.4.1.14179.2.2.16',
  'bsnAPIfProfileStateEntry' => '1.3.6.1.4.1.14179.2.2.16.1',
  'bsnAPIfLoadProfileState' => '1.3.6.1.4.1.14179.2.2.16.1.1',
  'bsnAPIfInterferenceProfileState' => '1.3.6.1.4.1.14179.2.2.16.1.2',
  'bsnAPIfNoiseProfileState' => '1.3.6.1.4.1.14179.2.2.16.1.3',
  'bsnAPIfCoverageProfileState' => '1.3.6.1.4.1.14179.2.2.16.1.24',
  'bsnAPIfRxNeighborsTable' => '1.3.6.1.4.1.14179.2.2.17',
  'bsnAPIfRxNeighborsEntry' => '1.3.6.1.4.1.14179.2.2.17.1',
  'bsnAPIfRxNeighborMacAddress' => '1.3.6.1.4.1.14179.2.2.17.1.1',
  'bsnAPIfRxNeighborIpAddress' => '1.3.6.1.4.1.14179.2.2.17.1.2',
  'bsnAPIfRxNeighborRSSI' => '1.3.6.1.4.1.14179.2.2.17.1.3',
  'bsnAPIfRxNeighborSlot' => '1.3.6.1.4.1.14179.2.2.17.1.24',
  'bsnAPIfRxNeighborChannel' => '1.3.6.1.4.1.14179.2.2.17.1.26',
  'bsnAPIfRxNeighborChannelWidth' => '1.3.6.1.4.1.14179.2.2.17.1.27',
  'bsnAPIfStationRSSICoverageInfoTable' => '1.3.6.1.4.1.14179.2.2.18',
  'bsnAPIfStationRSSICoverageInfoEntry' => '1.3.6.1.4.1.14179.2.2.18.1',
  'bsnAPIfStationRSSICoverageIndex' => '1.3.6.1.4.1.14179.2.2.18.1.1',
  'bsnAPIfRSSILevel' => '1.3.6.1.4.1.14179.2.2.18.1.2',
  'bsnAPIfStationCountOnRSSI' => '1.3.6.1.4.1.14179.2.2.18.1.23',
  'bsnAPIfStationSNRCoverageInfoTable' => '1.3.6.1.4.1.14179.2.2.19',
  'bsnAPIfStationSNRCoverageInfoEntry' => '1.3.6.1.4.1.14179.2.2.19.1',
  'bsnAPIfStationSNRCoverageIndex' => '1.3.6.1.4.1.14179.2.2.19.1.1',
  'bsnAPIfSNRLevel' => '1.3.6.1.4.1.14179.2.2.19.1.2',
  'bsnAPIfStationCountOnSNR' => '1.3.6.1.4.1.14179.2.2.19.1.23',
  'bsnAPIfRecommendedRFParametersTable' => '1.3.6.1.4.1.14179.2.2.20',
  'bsnAPIfRecommendedRFParametersEntry' => '1.3.6.1.4.1.14179.2.2.20.1',
  'bsnAPIfRecommendedChannelNumber' => '1.3.6.1.4.1.14179.2.2.20.1.1',
  'bsnAPIfRecommendedTxPowerLevel' => '1.3.6.1.4.1.14179.2.2.20.1.2',
  'bsnAPIfRecommendedRTSThreshold' => '1.3.6.1.4.1.14179.2.2.20.1.3',
  'bsnAPIfRecommendedFragmentationThreshold' => '1.3.6.1.4.1.14179.2.2.20.1.24',
  'bsnAPIfWlanOverrideTable' => '1.3.6.1.4.1.14179.2.2.21',
  'bsnAPIfWlanOverrideEntry' => '1.3.6.1.4.1.14179.2.2.21.1',
  'bsnAPIfWlanOverrideId' => '1.3.6.1.4.1.14179.2.2.21.1.1',
  'bsnAPIfWlanOverrideSsid' => '1.3.6.1.4.1.14179.2.2.21.1.2',
  'bsnAPIfWlanOverrideRowStatus' => '1.3.6.1.4.1.14179.2.2.21.1.15',
  'bsnMeshNodeTable' => '1.3.6.1.4.1.14179.2.2.22',
  'bsnMeshNodeEntry' => '1.3.6.1.4.1.14179.2.2.22.1',
  'bsnMeshNodeRole' => '1.3.6.1.4.1.14179.2.2.22.1.1',
  'bsnMeshNodeGroup' => '1.3.6.1.4.1.14179.2.2.22.1.2',
  'bsnMeshNodeBackhaul' => '1.3.6.1.4.1.14179.2.2.22.1.3',
  'bsnMeshNodeBackhaulPAP' => '1.3.6.1.4.1.14179.2.2.22.1.4',
  'bsnMeshNodeBackhaulRAP' => '1.3.6.1.4.1.14179.2.2.22.1.5',
  'bsnMeshNodeDataRate' => '1.3.6.1.4.1.14179.2.2.22.1.6',
  'bsnMeshNodeChannel' => '1.3.6.1.4.1.14179.2.2.22.1.7',
  'bsnMeshNodeRoutingState' => '1.3.6.1.4.1.14179.2.2.22.1.8',
  'bsnMeshNodeMalformedNeighPackets' => '1.3.6.1.4.1.14179.2.2.22.1.9',
  'bsnMeshNodePoorNeighSnr' => '1.3.6.1.4.1.14179.2.2.22.1.10',
  'bsnMeshNodeBlacklistPackets' => '1.3.6.1.4.1.14179.2.2.22.1.11',
  'bsnMeshNodeInsufficientMemory' => '1.3.6.1.4.1.14179.2.2.22.1.12',
  'bsnMeshNodeRxNeighReq' => '1.3.6.1.4.1.14179.2.2.22.1.13',
  'bsnMeshNodeRxNeighRsp' => '1.3.6.1.4.1.14179.2.2.22.1.14',
  'bsnMeshNodeTxNeighReq' => '1.3.6.1.4.1.14179.2.2.22.1.15',
  'bsnMeshNodeTxNeighRsp' => '1.3.6.1.4.1.14179.2.2.22.1.16',
  'bsnMeshNodeParentChanges' => '1.3.6.1.4.1.14179.2.2.22.1.17',
  'bsnMeshNodeNeighTimeout' => '1.3.6.1.4.1.14179.2.2.22.1.18',
  'bsnMeshNodeParentMacAddress' => '1.3.6.1.4.1.14179.2.2.22.1.19',
  'bsnMeshNodeAPType' => '1.3.6.1.4.1.14179.2.2.22.1.20',
  'bsnMeshNodeEthernetBridge' => '1.3.6.1.4.1.14179.2.2.22.1.21',
  'bsnMeshNodeHops' => '1.3.6.1.4.1.14179.2.2.22.1.30',
  'bsnMeshNeighsTable' => '1.3.6.1.4.1.14179.2.2.23',
  'bsnMeshNeighsEntry' => '1.3.6.1.4.1.14179.2.2.23.1',
  'bsnMeshNeighMacAddress' => '1.3.6.1.4.1.14179.2.2.23.1.1',
  'bsnMeshNeighType' => '1.3.6.1.4.1.14179.2.2.23.1.2',
  'bsnMeshNeighState' => '1.3.6.1.4.1.14179.2.2.23.1.3',
  'bsnMeshNeighSnr' => '1.3.6.1.4.1.14179.2.2.23.1.4',
  'bsnMeshNeighSnrUp' => '1.3.6.1.4.1.14179.2.2.23.1.5',
  'bsnMeshNeighSnrDown' => '1.3.6.1.4.1.14179.2.2.23.1.6',
  'bsnMeshNeighLinkSnr' => '1.3.6.1.4.1.14179.2.2.23.1.7',
  'bsnMeshNeighAdjustedEase' => '1.3.6.1.4.1.14179.2.2.23.1.8',
  'bsnMeshNeighUnadjustedEase' => '1.3.6.1.4.1.14179.2.2.23.1.9',
  'bsnMeshNeighRapEase' => '1.3.6.1.4.1.14179.2.2.23.1.10',
  'bsnMeshNeighTxParent' => '1.3.6.1.4.1.14179.2.2.23.1.11',
  'bsnMeshNeighRxParent' => '1.3.6.1.4.1.14179.2.2.23.1.12',
  'bsnMeshNeighPoorSnr' => '1.3.6.1.4.1.14179.2.2.23.1.13',
  'bsnMeshNeighLastUpdate' => '1.3.6.1.4.1.14179.2.2.23.1.14',
  'bsnMeshNeighParentChange' => '1.3.6.1.4.1.14179.2.2.23.1.20',
  'bsnAPIfRadarChannelStatisticsTable' => '1.3.6.1.4.1.14179.2.2.24',
  'bsnAPIfRadarChannelStatisticsEntry' => '1.3.6.1.4.1.14179.2.2.24.1',
  'bsnAPIfRadarDetectedChannelNumber' => '1.3.6.1.4.1.14179.2.2.24.1.1',
  'bsnAPIfRadarSignalLastHeard' => '1.3.6.1.4.1.14179.2.2.24.1.2',
  'bsnGlobalDot11' => '1.3.6.1.4.1.14179.2.3',
  'bsnGlobalDot11Config' => '1.3.6.1.4.1.14179.2.3.1',
  'bsnGlobalDot11PrivacyOptionImplemented' => '1.3.6.1.4.1.14179.2.3.1.1',
  'bsnGlobalDot11AuthenticationResponseTimeOut' => '1.3.6.1.4.1.14179.2.3.1.2',
  'bsnGlobalDot11MultiDomainCapabilityImplemented' => '1.3.6.1.4.1.14179.2.3.1.3',
  'bsnGlobalDot11MultiDomainCapabilityEnabled' => '1.3.6.1.4.1.14179.2.3.1.4',
  'bsnGlobalDot11CountryIndex' => '1.3.6.1.4.1.14179.2.3.1.5',
  'bsnGlobalDot11LoadBalancing' => '1.3.6.1.4.1.14179.2.3.1.6',
  'bsnGlobalDot11RogueTimer' => '1.3.6.1.4.1.14179.2.3.1.7',
  'bsnPrimaryMwarForAPs' => '1.3.6.1.4.1.14179.2.3.1.8',
  'bsnRtpProtocolPriority' => '1.3.6.1.4.1.14179.2.3.1.9',
  'bsnSystemCurrentTime' => '1.3.6.1.4.1.14179.2.3.1.10',
  'bsnUpdateSystemTime' => '1.3.6.1.4.1.14179.2.3.1.11',
  'bsnOperatingTemperatureEnvironment' => '1.3.6.1.4.1.14179.2.3.1.12',
  'bsnOperatingTemperatureEnvironmentDefinition' => {
    '0' => 'unknown',
    '1' => 'commercial',
    '2' => 'industrial',
  },
  'bsnSensorTemperature' => '1.3.6.1.4.1.14179.2.3.1.13',
  'bsnTemperatureAlarmLowLimit' => '1.3.6.1.4.1.14179.2.3.1.14',
  'bsnTemperatureAlarmHighLimit' => '1.3.6.1.4.1.14179.2.3.1.15',
  'bsnVirtualGatewayAddress' => '1.3.6.1.4.1.14179.2.3.1.16',
  'bsnRFMobilityDomainName' => '1.3.6.1.4.1.14179.2.3.1.17',
  'bsnClientWatchListFeature' => '1.3.6.1.4.1.14179.2.3.1.18',
  'bsnRogueLocationDiscoveryProtocol' => '1.3.6.1.4.1.14179.2.3.1.19',
  'bsnRogueAutoContainFeature' => '1.3.6.1.4.1.14179.2.3.1.20',
  'bsnOverAirProvisionApMode' => '1.3.6.1.4.1.14179.2.3.1.21',
  'bsnMaximumNumberOfConcurrentLogins' => '1.3.6.1.4.1.14179.2.3.1.22',
  'bsnAutoContainRoguesAdvertisingSsid' => '1.3.6.1.4.1.14179.2.3.1.23',
  'bsnAutoContainAdhocNetworks' => '1.3.6.1.4.1.14179.2.3.1.24',
  'bsnAutoContainTrustedClientsOnRogueAps' => '1.3.6.1.4.1.14179.2.3.1.25',
  'bsnValidateRogueClientsAgainstAAA' => '1.3.6.1.4.1.14179.2.3.1.26',
  'bsnSystemTimezoneDelta' => '1.3.6.1.4.1.14179.2.3.1.27',
  'bsnSystemTimezoneDaylightSavings' => '1.3.6.1.4.1.14179.2.3.1.28',
  'bsnAllowAuthorizeApAgainstAAA' => '1.3.6.1.4.1.14179.2.3.1.29',
  'bsnSystemTimezoneDeltaMinutes' => '1.3.6.1.4.1.14179.2.3.1.30',
  'bsnApFallbackEnabled' => '1.3.6.1.4.1.14179.2.3.1.31',
  'bsnAppleTalkEnabled' => '1.3.6.1.4.1.14179.2.3.1.32',
  'bsnTrustedApPolicyConfig' => '1.3.6.1.4.1.14179.2.3.1.40',
  'bsnPolicyForMisconfiguredAps' => '1.3.6.1.4.1.14179.2.3.1.40.1',
  'bsnEncryptionPolicyEnforced' => '1.3.6.1.4.1.14179.2.3.1.40.2',
  'bsnPreamblePolicyEnforced' => '1.3.6.1.4.1.14179.2.3.1.40.3',
  'bsnDot11ModePolicyEnforced' => '1.3.6.1.4.1.14179.2.3.1.40.4',
  'bsnRadioTypePolicyEnforced' => '1.3.6.1.4.1.14179.2.3.1.40.5',
  'bsnValidateSsidForTrustedAp' => '1.3.6.1.4.1.14179.2.3.1.40.6',
  'bsnAlertIfTrustedApMissing' => '1.3.6.1.4.1.14179.2.3.1.40.7',
  'bsnTrustedApEntryExpirationTimeout' => '1.3.6.1.4.1.14179.2.3.1.40.8',
  'bsnClientExclusionPolicyConfig' => '1.3.6.1.4.1.14179.2.3.1.41',
  'bsnExcessive80211AssocFailures' => '1.3.6.1.4.1.14179.2.3.1.41.1',
  'bsnExcessive80211AuthFailures' => '1.3.6.1.4.1.14179.2.3.1.41.2',
  'bsnExcessive8021xAuthFailures' => '1.3.6.1.4.1.14179.2.3.1.41.3',
  'bsnExternalPolicyServerFailures' => '1.3.6.1.4.1.14179.2.3.1.41.4',
  'bsnExcessiveWebAuthFailures' => '1.3.6.1.4.1.14179.2.3.1.41.5',
  'bsnIPTheftORReuse' => '1.3.6.1.4.1.14179.2.3.1.41.6',
  'bsnSignatureConfig' => '1.3.6.1.4.1.14179.2.3.1.42',
  'bsnStandardSignatureTable' => '1.3.6.1.4.1.14179.2.3.1.42.1',
  'bsnStandardSignatureEntry' => '1.3.6.1.4.1.14179.2.3.1.42.1.1',
  'bsnStandardSignaturePrecedence' => '1.3.6.1.4.1.14179.2.3.1.42.1.1.1',
  'bsnStandardSignatureName' => '1.3.6.1.4.1.14179.2.3.1.42.1.1.2',
  'bsnStandardSignatureDescription' => '1.3.6.1.4.1.14179.2.3.1.42.1.1.3',
  'bsnStandardSignatureFrameType' => '1.3.6.1.4.1.14179.2.3.1.42.1.1.4',
  'bsnStandardSignatureAction' => '1.3.6.1.4.1.14179.2.3.1.42.1.1.5',
  'bsnStandardSignatureState' => '1.3.6.1.4.1.14179.2.3.1.42.1.1.6',
  'bsnStandardSignatureFrequency' => '1.3.6.1.4.1.14179.2.3.1.42.1.1.7',
  'bsnStandardSignatureQuietTime' => '1.3.6.1.4.1.14179.2.3.1.42.1.1.8',
  'bsnStandardSignatureVersion' => '1.3.6.1.4.1.14179.2.3.1.42.1.1.9',
  'bsnStandardSignatureConfigType' => '1.3.6.1.4.1.14179.2.3.1.42.1.1.10',
  'bsnStandardSignatureEnable' => '1.3.6.1.4.1.14179.2.3.1.42.1.1.11',
  'bsnStandardSignatureMacInfo' => '1.3.6.1.4.1.14179.2.3.1.42.1.1.12',
  'bsnStandardSignatureMacFreq' => '1.3.6.1.4.1.14179.2.3.1.42.1.1.13',
  'bsnStandardSignatureRowStatus' => '1.3.6.1.4.1.14179.2.3.1.42.1.1.20',
  'bsnStandardSignatureInterval' => '1.3.6.1.4.1.14179.2.3.1.42.1.1.21',
  'bsnStandardSignaturePatternTable' => '1.3.6.1.4.1.14179.2.3.1.42.2',
  'bsnStandardSignaturePatternEntry' => '1.3.6.1.4.1.14179.2.3.1.42.2.1',
  'bsnStandardSignaturePatternIndex' => '1.3.6.1.4.1.14179.2.3.1.42.2.1.1',
  'bsnStandardSignaturePatternOffset' => '1.3.6.1.4.1.14179.2.3.1.42.2.1.2',
  'bsnStandardSignaturePatternString' => '1.3.6.1.4.1.14179.2.3.1.42.2.1.3',
  'bsnStandardSignaturePatternMask' => '1.3.6.1.4.1.14179.2.3.1.42.2.1.4',
  'bsnStandardSignaturePatternOffSetStart' => '1.3.6.1.4.1.14179.2.3.1.42.2.1.5',
  'bsnStandardSignaturePatternRowStatus' => '1.3.6.1.4.1.14179.2.3.1.42.2.1.15',
  'bsnCustomSignatureTable' => '1.3.6.1.4.1.14179.2.3.1.42.3',
  'bsnCustomSignatureEntry' => '1.3.6.1.4.1.14179.2.3.1.42.3.1',
  'bsnCustomSignaturePrecedence' => '1.3.6.1.4.1.14179.2.3.1.42.3.1.1',
  'bsnCustomSignatureName' => '1.3.6.1.4.1.14179.2.3.1.42.3.1.2',
  'bsnCustomSignatureDescription' => '1.3.6.1.4.1.14179.2.3.1.42.3.1.3',
  'bsnCustomSignatureFrameType' => '1.3.6.1.4.1.14179.2.3.1.42.3.1.4',
  'bsnCustomSignatureAction' => '1.3.6.1.4.1.14179.2.3.1.42.3.1.5',
  'bsnCustomSignatureState' => '1.3.6.1.4.1.14179.2.3.1.42.3.1.6',
  'bsnCustomSignatureFrequency' => '1.3.6.1.4.1.14179.2.3.1.42.3.1.7',
  'bsnCustomSignatureQuietTime' => '1.3.6.1.4.1.14179.2.3.1.42.3.1.8',
  'bsnCustomSignatureVersion' => '1.3.6.1.4.1.14179.2.3.1.42.3.1.9',
  'bsnCustomSignatureConfigType' => '1.3.6.1.4.1.14179.2.3.1.42.3.1.10',
  'bsnCustomSignatureEnable' => '1.3.6.1.4.1.14179.2.3.1.42.3.1.11',
  'bsnCustomSignatureMacInfo' => '1.3.6.1.4.1.14179.2.3.1.42.3.1.12',
  'bsnCustomSignatureMacFreq' => '1.3.6.1.4.1.14179.2.3.1.42.3.1.13',
  'bsnCustomSignatureRowStatus' => '1.3.6.1.4.1.14179.2.3.1.42.3.1.20',
  'bsnCustomSignatureInterval' => '1.3.6.1.4.1.14179.2.3.1.42.3.1.21',
  'bsnCustomSignaturePatternTable' => '1.3.6.1.4.1.14179.2.3.1.42.4',
  'bsnCustomSignaturePatternEntry' => '1.3.6.1.4.1.14179.2.3.1.42.4.1',
  'bsnCustomSignaturePatternIndex' => '1.3.6.1.4.1.14179.2.3.1.42.4.1.1',
  'bsnCustomSignaturePatternOffset' => '1.3.6.1.4.1.14179.2.3.1.42.4.1.2',
  'bsnCustomSignaturePatternString' => '1.3.6.1.4.1.14179.2.3.1.42.4.1.3',
  'bsnCustomSignaturePatternMask' => '1.3.6.1.4.1.14179.2.3.1.42.4.1.4',
  'bsnCustomSignaturePatternOffSetStart' => '1.3.6.1.4.1.14179.2.3.1.42.4.1.5',
  'bsnCustomSignaturePatternRowStatus' => '1.3.6.1.4.1.14179.2.3.1.42.4.1.15',
  'bsnSignatureCheckState' => '1.3.6.1.4.1.14179.2.3.1.42.5',
  'bsnRfIdTagConfig' => '1.3.6.1.4.1.14179.2.3.1.43',
  'bsnRfIdTagStatus' => '1.3.6.1.4.1.14179.2.3.1.43.1',
  'bsnRfIdTagDataTimeout' => '1.3.6.1.4.1.14179.2.3.1.43.2',
  'bsnRfIdTagAutoTimeoutStatus' => '1.3.6.1.4.1.14179.2.3.1.43.3',
  'bsnAPNeighborAuthConfig' => '1.3.6.1.4.1.14179.2.3.1.44',
  'bsnAPNeighborAuthStatus' => '1.3.6.1.4.1.14179.2.3.1.44.1',
  'bsnAPNeighborAuthAlarmThreshold' => '1.3.6.1.4.1.14179.2.3.1.44.2',
  'bsnRFNetworkName' => '1.3.6.1.4.1.14179.2.3.1.45',
  'bsnFastSSIDChangeFeature' => '1.3.6.1.4.1.14179.2.3.1.46',
  'bsnBridgingPolicyConfig' => '1.3.6.1.4.1.14179.2.3.1.47',
  'bsnBridgingZeroTouchConfig' => '1.3.6.1.4.1.14179.2.3.1.47.1',
  'bsnBridgingSharedSecretKey' => '1.3.6.1.4.1.14179.2.3.1.47.2',
  'bsnAcceptSelfSignedCertificate' => '1.3.6.1.4.1.14179.2.3.1.48',
  'bsnSystemClockTime' => '1.3.6.1.4.1.14179.2.3.1.49',
  'bsnGlobalDot11b' => '1.3.6.1.4.1.14179.2.3.2',
  'bsnGlobalDot11bConfig' => '1.3.6.1.4.1.14179.2.3.2.1',
  'bsnGlobalDot11bNetworkStatus' => '1.3.6.1.4.1.14179.2.3.2.1.1',
  'bsnGlobalDot11bBeaconPeriod' => '1.3.6.1.4.1.14179.2.3.2.1.2',
  'bsnGlobalDot11bDynamicChannelAssignment' => '1.3.6.1.4.1.14179.2.3.2.1.3',
  'bsnGlobalDot11bCurrentChannel' => '1.3.6.1.4.1.14179.2.3.2.1.4',
  'bsnGlobalDot11bDynamicChannelUpdateInterval' => '1.3.6.1.4.1.14179.2.3.2.1.5',
  'bsnGlobalDot11bInputsForDCA' => '1.3.6.1.4.1.14179.2.3.2.1.6',
  'bsnGlobalDot11bChannelUpdateCmdInvoke' => '1.3.6.1.4.1.14179.2.3.2.1.7',
  'bsnGlobalDot11bChannelUpdateCmdStatus' => '1.3.6.1.4.1.14179.2.3.2.1.8',
  'bsnGlobalDot11bDynamicTransmitPowerControl' => '1.3.6.1.4.1.14179.2.3.2.1.9',
  'bsnGlobalDot11bDynamicTxPowerControlInterval' => '1.3.6.1.4.1.14179.2.3.2.1.10',
  'bsnGlobalDot11bCurrentTxPowerLevel' => '1.3.6.1.4.1.14179.2.3.2.1.11',
  'bsnGlobalDot11bInputsForDTP' => '1.3.6.1.4.1.14179.2.3.2.1.12',
  'bsnGlobalDot11bPowerUpdateCmdInvoke' => '1.3.6.1.4.1.14179.2.3.2.1.13',
  'bsnGlobalDot11bPowerUpdateCmdStatus' => '1.3.6.1.4.1.14179.2.3.2.1.14',
  'bsnGlobalDot11bDataRate1Mhz' => '1.3.6.1.4.1.14179.2.3.2.1.15',
  'bsnGlobalDot11bDataRate2Mhz' => '1.3.6.1.4.1.14179.2.3.2.1.16',
  'bsnGlobalDot11bDataRate5AndHalfMhz' => '1.3.6.1.4.1.14179.2.3.2.1.17',
  'bsnGlobalDot11bDataRate11Mhz' => '1.3.6.1.4.1.14179.2.3.2.1.18',
  'bsnGlobalDot11bShortPreamble' => '1.3.6.1.4.1.14179.2.3.2.1.19',
  'bsnGlobalDot11bDot11gSupport' => '1.3.6.1.4.1.14179.2.3.2.1.20',
  'bsnGlobalDot11bDataRate6Mhz' => '1.3.6.1.4.1.14179.2.3.2.1.21',
  'bsnGlobalDot11bDataRate9Mhz' => '1.3.6.1.4.1.14179.2.3.2.1.22',
  'bsnGlobalDot11bDataRate12Mhz' => '1.3.6.1.4.1.14179.2.3.2.1.23',
  'bsnGlobalDot11bDataRate18Mhz' => '1.3.6.1.4.1.14179.2.3.2.1.24',
  'bsnGlobalDot11bDataRate24Mhz' => '1.3.6.1.4.1.14179.2.3.2.1.25',
  'bsnGlobalDot11bDataRate36Mhz' => '1.3.6.1.4.1.14179.2.3.2.1.26',
  'bsnGlobalDot11bDataRate48Mhz' => '1.3.6.1.4.1.14179.2.3.2.1.27',
  'bsnGlobalDot11bDataRate54Mhz' => '1.3.6.1.4.1.14179.2.3.2.1.28',
  'bsnGlobalDot11bPicoCellMode' => '1.3.6.1.4.1.14179.2.3.2.1.29',
  'bsnGlobalDot11bFastRoamingMode' => '1.3.6.1.4.1.14179.2.3.2.1.30',
  'bsnGlobalDot11bFastRoamingVoipMinRate' => '1.3.6.1.4.1.14179.2.3.2.1.31',
  'bsnGlobalDot11bFastRoamingVoipPercentage' => '1.3.6.1.4.1.14179.2.3.2.1.32',
  'bsnGlobalDot11b80211eMaxBandwidth' => '1.3.6.1.4.1.14179.2.3.2.1.33',
  'bsnGlobalDot11bDTPCSupport' => '1.3.6.1.4.1.14179.2.3.2.1.34',
  'bsnGlobalDot11bPhy' => '1.3.6.1.4.1.14179.2.3.2.2',
  'bsnGlobalDot11bMediumOccupancyLimit' => '1.3.6.1.4.1.14179.2.3.2.2.1',
  'bsnGlobalDot11bCFPPeriod' => '1.3.6.1.4.1.14179.2.3.2.2.2',
  'bsnGlobalDot11bCFPMaxDuration' => '1.3.6.1.4.1.14179.2.3.2.2.3',
  'bsnGlobalDot11bCFPollable' => '1.3.6.1.4.1.14179.2.3.2.2.5',
  'bsnGlobalDot11bCFPollRequest' => '1.3.6.1.4.1.14179.2.3.2.2.6',
  'bsnGlobalDot11bDTIMPeriod' => '1.3.6.1.4.1.14179.2.3.2.2.7',
  'bsnGlobalDot11bMaximumTransmitPowerLevel' => '1.3.6.1.4.1.14179.2.3.2.2.8',
  'bsnGlobalDot11bFirstChannelNumber' => '1.3.6.1.4.1.14179.2.3.2.2.9',
  'bsnGlobalDot11bNumberofChannels' => '1.3.6.1.4.1.14179.2.3.2.2.10',
  'bsnGlobalDot11bRTSThreshold' => '1.3.6.1.4.1.14179.2.3.2.2.11',
  'bsnGlobalDot11bShortRetryLimit' => '1.3.6.1.4.1.14179.2.3.2.2.12',
  'bsnGlobalDot11bLongRetryLimit' => '1.3.6.1.4.1.14179.2.3.2.2.13',
  'bsnGlobalDot11bFragmentationThreshold' => '1.3.6.1.4.1.14179.2.3.2.2.14',
  'bsnGlobalDot11bMaxTransmitMSDULifetime' => '1.3.6.1.4.1.14179.2.3.2.2.15',
  'bsnGlobalDot11bMaxReceiveLifetime' => '1.3.6.1.4.1.14179.2.3.2.2.16',
  'bsnGlobalDot11bEDThreshold' => '1.3.6.1.4.1.14179.2.3.2.2.17',
  'bsnGlobalDot11bChannelAgilityEnabled' => '1.3.6.1.4.1.14179.2.3.2.2.18',
  'bsnGlobalDot11bPBCCOptionImplemented' => '1.3.6.1.4.1.14179.2.3.2.2.19',
  'bsnGlobalDot11bShortPreambleOptionImplemented' => '1.3.6.1.4.1.14179.2.3.2.2.20',
  'bsnGlobalDot11a' => '1.3.6.1.4.1.14179.2.3.3',
  'bsnGlobalDot11aConfig' => '1.3.6.1.4.1.14179.2.3.3.1',
  'bsnGlobalDot11aNetworkStatus' => '1.3.6.1.4.1.14179.2.3.3.1.1',
  'bsnGlobalDot11aLowBandNetwork' => '1.3.6.1.4.1.14179.2.3.3.1.2',
  'bsnGlobalDot11aMediumBandNetwork' => '1.3.6.1.4.1.14179.2.3.3.1.3',
  'bsnGlobalDot11aHighBandNetwork' => '1.3.6.1.4.1.14179.2.3.3.1.4',
  'bsnGlobalDot11aBeaconPeriod' => '1.3.6.1.4.1.14179.2.3.3.1.5',
  'bsnGlobalDot11aDynamicChannelAssignment' => '1.3.6.1.4.1.14179.2.3.3.1.6',
  'bsnGlobalDot11aCurrentChannel' => '1.3.6.1.4.1.14179.2.3.3.1.7',
  'bsnGlobalDot11aDynamicChannelUpdateInterval' => '1.3.6.1.4.1.14179.2.3.3.1.8',
  'bsnGlobalDot11aInputsForDCA' => '1.3.6.1.4.1.14179.2.3.3.1.9',
  'bsnGlobalDot11aChannelUpdateCmdInvoke' => '1.3.6.1.4.1.14179.2.3.3.1.10',
  'bsnGlobalDot11aChannelUpdateCmdStatus' => '1.3.6.1.4.1.14179.2.3.3.1.11',
  'bsnGlobalDot11aDynamicTransmitPowerControl' => '1.3.6.1.4.1.14179.2.3.3.1.12',
  'bsnGlobalDot11aCurrentTxPowerLevel' => '1.3.6.1.4.1.14179.2.3.3.1.13',
  'bsnGlobalDot11aDynamicTxPowerControlInterval' => '1.3.6.1.4.1.14179.2.3.3.1.14',
  'bsnGlobalDot11aInputsForDTP' => '1.3.6.1.4.1.14179.2.3.3.1.15',
  'bsnGlobalDot11aPowerUpdateCmdInvoke' => '1.3.6.1.4.1.14179.2.3.3.1.16',
  'bsnGlobalDot11aPowerUpdateCmdStatus' => '1.3.6.1.4.1.14179.2.3.3.1.17',
  'bsnGlobalDot11aDataRate6Mhz' => '1.3.6.1.4.1.14179.2.3.3.1.19',
  'bsnGlobalDot11aDataRate9Mhz' => '1.3.6.1.4.1.14179.2.3.3.1.20',
  'bsnGlobalDot11aDataRate12Mhz' => '1.3.6.1.4.1.14179.2.3.3.1.21',
  'bsnGlobalDot11aDataRate18Mhz' => '1.3.6.1.4.1.14179.2.3.3.1.22',
  'bsnGlobalDot11aDataRate24Mhz' => '1.3.6.1.4.1.14179.2.3.3.1.23',
  'bsnGlobalDot11aDataRate36Mhz' => '1.3.6.1.4.1.14179.2.3.3.1.24',
  'bsnGlobalDot11aDataRate48Mhz' => '1.3.6.1.4.1.14179.2.3.3.1.25',
  'bsnGlobalDot11aDataRate54Mhz' => '1.3.6.1.4.1.14179.2.3.3.1.26',
  'bsnGlobalDot11aPicoCellMode' => '1.3.6.1.4.1.14179.2.3.3.1.27',
  'bsnGlobalDot11aFastRoamingMode' => '1.3.6.1.4.1.14179.2.3.3.1.28',
  'bsnGlobalDot11aFastRoamingVoipMinRate' => '1.3.6.1.4.1.14179.2.3.3.1.29',
  'bsnGlobalDot11aFastRoamingVoipPercentage' => '1.3.6.1.4.1.14179.2.3.3.1.30',
  'bsnGlobalDot11a80211eMaxBandwidth' => '1.3.6.1.4.1.14179.2.3.3.1.31',
  'bsnGlobalDot11aDTPCSupport' => '1.3.6.1.4.1.14179.2.3.3.1.32',
  'bsnGlobalDot11aPhy' => '1.3.6.1.4.1.14179.2.3.3.2',
  'bsnGlobalDot11aMediumOccupancyLimit' => '1.3.6.1.4.1.14179.2.3.3.2.1',
  'bsnGlobalDot11aCFPPeriod' => '1.3.6.1.4.1.14179.2.3.3.2.2',
  'bsnGlobalDot11aCFPMaxDuration' => '1.3.6.1.4.1.14179.2.3.3.2.3',
  'bsnGlobalDot11aCFPollable' => '1.3.6.1.4.1.14179.2.3.3.2.5',
  'bsnGlobalDot11aCFPollRequest' => '1.3.6.1.4.1.14179.2.3.3.2.6',
  'bsnGlobalDot11aDTIMPeriod' => '1.3.6.1.4.1.14179.2.3.3.2.7',
  'bsnGlobalDot11aMaximumTransmitPowerLevel' => '1.3.6.1.4.1.14179.2.3.3.2.8',
  'bsnGlobalDot11aFirstChannelNumber' => '1.3.6.1.4.1.14179.2.3.3.2.9',
  'bsnGlobalDot11aNumberofChannels' => '1.3.6.1.4.1.14179.2.3.3.2.10',
  'bsnGlobalDot11aRTSThreshold' => '1.3.6.1.4.1.14179.2.3.3.2.11',
  'bsnGlobalDot11aShortRetryLimit' => '1.3.6.1.4.1.14179.2.3.3.2.12',
  'bsnGlobalDot11aLongRetryLimit' => '1.3.6.1.4.1.14179.2.3.3.2.13',
  'bsnGlobalDot11aFragmentationThreshold' => '1.3.6.1.4.1.14179.2.3.3.2.14',
  'bsnGlobalDot11aMaxTransmitMSDULifetime' => '1.3.6.1.4.1.14179.2.3.3.2.15',
  'bsnGlobalDot11aMaxReceiveLifetime' => '1.3.6.1.4.1.14179.2.3.3.2.16',
  'bsnGlobalDot11aTIThreshold' => '1.3.6.1.4.1.14179.2.3.3.2.17',
  'bsnGlobalDot11aChannelAgilityEnabled' => '1.3.6.1.4.1.14179.2.3.3.2.18',
  'bsnGlobalDot11h' => '1.3.6.1.4.1.14179.2.3.4',
  'bsnGlobalDot11hConfig' => '1.3.6.1.4.1.14179.2.3.4.1',
  'bsnGlobalDot11hPowerConstraint' => '1.3.6.1.4.1.14179.2.3.4.1.1',
  'bsnGlobalDot11hChannelSwitchEnable' => '1.3.6.1.4.1.14179.2.3.4.1.2',
  'bsnGlobalDot11hChannelSwitchMode' => '1.3.6.1.4.1.14179.2.3.4.1.3',
  'bsnRrm' => '1.3.6.1.4.1.14179.2.4',
  'bsnRrmDot11a' => '1.3.6.1.4.1.14179.2.4.1',
  'bsnRrmDot11aGroup' => '1.3.6.1.4.1.14179.2.4.1.1',
  'bsnRrmDot11aGlobalAutomaticGrouping' => '1.3.6.1.4.1.14179.2.4.1.1.1',
  'bsnRrmDot11aGroupLeaderMacAddr' => '1.3.6.1.4.1.14179.2.4.1.1.2',
  'bsnRrmIsDot11aGroupLeader' => '1.3.6.1.4.1.14179.2.4.1.1.3',
  'bsnRrmDot11aGroupLastUpdateTime' => '1.3.6.1.4.1.14179.2.4.1.1.4',
  'bsnRrmDot11aGlobalGroupInterval' => '1.3.6.1.4.1.14179.2.4.1.1.5',
  'bsnWrasDot11aGroupTable' => '1.3.6.1.4.1.14179.2.4.1.1.9',
  'bsnWrasDot11aGroupEntry' => '1.3.6.1.4.1.14179.2.4.1.1.9.1',
  'bsnWrasDot11aPeerMacAddress' => '1.3.6.1.4.1.14179.2.4.1.1.9.1.1',
  'bsnWrasDot11aPeerIpAddress' => '1.3.6.1.4.1.14179.2.4.1.1.9.1.21',
  'bsnRrmDot11aAPDefault' => '1.3.6.1.4.1.14179.2.4.1.6',
  'bsnRrmDot11aForeignInterferenceThreshold' => '1.3.6.1.4.1.14179.2.4.1.6.1',
  'bsnRrmDot11aForeignNoiseThreshold' => '1.3.6.1.4.1.14179.2.4.1.6.2',
  'bsnRrmDot11aRFUtilizationThreshold' => '1.3.6.1.4.1.14179.2.4.1.6.3',
  'bsnRrmDot11aThroughputThreshold' => '1.3.6.1.4.1.14179.2.4.1.6.4',
  'bsnRrmDot11aMobilesThreshold' => '1.3.6.1.4.1.14179.2.4.1.6.5',
  'bsnRrmDot11aCoverageThreshold' => '1.3.6.1.4.1.14179.2.4.1.6.6',
  'bsnRrmDot11aMobileMinExceptionLevel' => '1.3.6.1.4.1.14179.2.4.1.6.7',
  'bsnRrmDot11aCoverageExceptionLevel' => '1.3.6.1.4.1.14179.2.4.1.6.8',
  'bsnRrmDot11aSignalMeasurementInterval' => '1.3.6.1.4.1.14179.2.4.1.6.9',
  'bsnRrmDot11aNoiseMeasurementInterval' => '1.3.6.1.4.1.14179.2.4.1.6.10',
  'bsnRrmDot11aLoadMeasurementInterval' => '1.3.6.1.4.1.14179.2.4.1.6.11',
  'bsnRrmDot11aCoverageMeasurementInterval' => '1.3.6.1.4.1.14179.2.4.1.6.12',
  'bsnRrmDot11aChannelMonitorList' => '1.3.6.1.4.1.14179.2.4.1.6.13',
  'bsnRrmDot11aSetFactoryDefault' => '1.3.6.1.4.1.14179.2.4.1.7',
  'bsnRrmDot11b' => '1.3.6.1.4.1.14179.2.4.2',
  'bsnRrmDot11bGroup' => '1.3.6.1.4.1.14179.2.4.2.1',
  'bsnRrmDot11bGlobalAutomaticGrouping' => '1.3.6.1.4.1.14179.2.4.2.1.1',
  'bsnRrmDot11bGroupLeaderMacAddr' => '1.3.6.1.4.1.14179.2.4.2.1.2',
  'bsnRrmIsDot11bGroupLeader' => '1.3.6.1.4.1.14179.2.4.2.1.3',
  'bsnRrmDot11bGroupLastUpdateTime' => '1.3.6.1.4.1.14179.2.4.2.1.4',
  'bsnRrmDot11bGlobalGroupInterval' => '1.3.6.1.4.1.14179.2.4.2.1.5',
  'bsnWrasDot11bGroupTable' => '1.3.6.1.4.1.14179.2.4.2.1.9',
  'bsnWrasDot11bGroupEntry' => '1.3.6.1.4.1.14179.2.4.2.1.9.1',
  'bsnWrasDot11bPeerMacAddress' => '1.3.6.1.4.1.14179.2.4.2.1.9.1.1',
  'bsnWrasDot11bPeerIpAddress' => '1.3.6.1.4.1.14179.2.4.2.1.9.1.21',
  'bsnRrmDot11bAPDefault' => '1.3.6.1.4.1.14179.2.4.2.6',
  'bsnRrmDot11bForeignInterferenceThreshold' => '1.3.6.1.4.1.14179.2.4.2.6.1',
  'bsnRrmDot11bForeignNoiseThreshold' => '1.3.6.1.4.1.14179.2.4.2.6.2',
  'bsnRrmDot11bRFUtilizationThreshold' => '1.3.6.1.4.1.14179.2.4.2.6.3',
  'bsnRrmDot11bThroughputThreshold' => '1.3.6.1.4.1.14179.2.4.2.6.4',
  'bsnRrmDot11bMobilesThreshold' => '1.3.6.1.4.1.14179.2.4.2.6.5',
  'bsnRrmDot11bCoverageThreshold' => '1.3.6.1.4.1.14179.2.4.2.6.6',
  'bsnRrmDot11bMobileMinExceptionLevel' => '1.3.6.1.4.1.14179.2.4.2.6.7',
  'bsnRrmDot11bCoverageExceptionLevel' => '1.3.6.1.4.1.14179.2.4.2.6.8',
  'bsnRrmDot11bSignalMeasurementInterval' => '1.3.6.1.4.1.14179.2.4.2.6.9',
  'bsnRrmDot11bNoiseMeasurementInterval' => '1.3.6.1.4.1.14179.2.4.2.6.10',
  'bsnRrmDot11bLoadMeasurementInterval' => '1.3.6.1.4.1.14179.2.4.2.6.11',
  'bsnRrmDot11bCoverageMeasurementInterval' => '1.3.6.1.4.1.14179.2.4.2.6.12',
  'bsnRrmDot11bChannelMonitorList' => '1.3.6.1.4.1.14179.2.4.2.6.13',
  'bsnRrmDot11bSetFactoryDefault' => '1.3.6.1.4.1.14179.2.4.2.7',
  'bsnAAA' => '1.3.6.1.4.1.14179.2.5',
  'bsnRadiusAuthServerTable' => '1.3.6.1.4.1.14179.2.5.1',
  'bsnRadiusAuthServerEntry' => '1.3.6.1.4.1.14179.2.5.1.1',
  'bsnRadiusAuthServerIndex' => '1.3.6.1.4.1.14179.2.5.1.1.1',
  'bsnRadiusAuthServerAddress' => '1.3.6.1.4.1.14179.2.5.1.1.2',
  'bsnRadiusAuthClientServerPortNumber' => '1.3.6.1.4.1.14179.2.5.1.1.3',
  'bsnRadiusAuthServerKey' => '1.3.6.1.4.1.14179.2.5.1.1.4',
  'bsnRadiusAuthServerStatus' => '1.3.6.1.4.1.14179.2.5.1.1.5',
  'bsnRadiusAuthServerKeyFormat' => '1.3.6.1.4.1.14179.2.5.1.1.6',
  'bsnRadiusAuthServerRFC3576' => '1.3.6.1.4.1.14179.2.5.1.1.7',
  'bsnRadiusAuthServerIPSec' => '1.3.6.1.4.1.14179.2.5.1.1.8',
  'bsnRadiusAuthServerIPSecAuth' => '1.3.6.1.4.1.14179.2.5.1.1.9',
  'bsnRadiusAuthServerIPSecEncryption' => '1.3.6.1.4.1.14179.2.5.1.1.10',
  'bsnRadiusAuthServerIPSecIKEPhase1' => '1.3.6.1.4.1.14179.2.5.1.1.11',
  'bsnRadiusAuthServerIPSecIKELifetime' => '1.3.6.1.4.1.14179.2.5.1.1.12',
  'bsnRadiusAuthServerIPSecDHGroup' => '1.3.6.1.4.1.14179.2.5.1.1.13',
  'bsnRadiusAuthServerNetworkUserConfig' => '1.3.6.1.4.1.14179.2.5.1.1.14',
  'bsnRadiusAuthServerMgmtUserConfig' => '1.3.6.1.4.1.14179.2.5.1.1.15',
  'bsnRadiusAuthServerRetransmitTimeout' => '1.3.6.1.4.1.14179.2.5.1.1.17',
  'bsnRadiusAuthServerKeyWrapKEKkey' => '1.3.6.1.4.1.14179.2.5.1.1.18',
  'bsnRadiusAuthServerKeyWrapMACKkey' => '1.3.6.1.4.1.14179.2.5.1.1.19',
  'bsnRadiusAuthServerKeyWrapFormat' => '1.3.6.1.4.1.14179.2.5.1.1.20',
  'bsnRadiusAuthServerRowStatus' => '1.3.6.1.4.1.14179.2.5.1.1.26',
  'bsnRadiusAccServerTable' => '1.3.6.1.4.1.14179.2.5.2',
  'bsnRadiusAccServerEntry' => '1.3.6.1.4.1.14179.2.5.2.1',
  'bsnRadiusAccServerIndex' => '1.3.6.1.4.1.14179.2.5.2.1.1',
  'bsnRadiusAccServerAddress' => '1.3.6.1.4.1.14179.2.5.2.1.2',
  'bsnRadiusAccClientServerPortNumber' => '1.3.6.1.4.1.14179.2.5.2.1.3',
  'bsnRadiusAccServerKey' => '1.3.6.1.4.1.14179.2.5.2.1.4',
  'bsnRadiusAccServerStatus' => '1.3.6.1.4.1.14179.2.5.2.1.5',
  'bsnRadiusAccServerKeyFormat' => '1.3.6.1.4.1.14179.2.5.2.1.6',
  'bsnRadiusAccServerIPSec' => '1.3.6.1.4.1.14179.2.5.2.1.7',
  'bsnRadiusAccServerIPSecAuth' => '1.3.6.1.4.1.14179.2.5.2.1.8',
  'bsnRadiusAccServerIPSecEncryption' => '1.3.6.1.4.1.14179.2.5.2.1.9',
  'bsnRadiusAccServerIPSecIKEPhase1' => '1.3.6.1.4.1.14179.2.5.2.1.10',
  'bsnRadiusAccServerIPSecIKELifetime' => '1.3.6.1.4.1.14179.2.5.2.1.11',
  'bsnRadiusAccServerIPSecDHGroup' => '1.3.6.1.4.1.14179.2.5.2.1.12',
  'bsnRadiusAccServerNetworkUserConfig' => '1.3.6.1.4.1.14179.2.5.2.1.13',
  'bsnRadiusAccServerRetransmitTimeout' => '1.3.6.1.4.1.14179.2.5.2.1.14',
  'bsnRadiusAccServerRowStatus' => '1.3.6.1.4.1.14179.2.5.2.1.26',
  'bsnRadiusAuthServerStatsTable' => '1.3.6.1.4.1.14179.2.5.3',
  'bsnRadiusAuthServerStatsEntry' => '1.3.6.1.4.1.14179.2.5.3.1',
  'bsnRadiusAuthClientRoundTripTime' => '1.3.6.1.4.1.14179.2.5.3.1.6',
  'bsnRadiusAuthClientAccessRequests' => '1.3.6.1.4.1.14179.2.5.3.1.7',
  'bsnRadiusAuthClientAccessRetransmissions' => '1.3.6.1.4.1.14179.2.5.3.1.8',
  'bsnRadiusAuthClientAccessAccepts' => '1.3.6.1.4.1.14179.2.5.3.1.9',
  'bsnRadiusAuthClientAccessRejects' => '1.3.6.1.4.1.14179.2.5.3.1.10',
  'bsnRadiusAuthClientAccessChallenges' => '1.3.6.1.4.1.14179.2.5.3.1.11',
  'bsnRadiusAuthClientMalformedAccessResponses' => '1.3.6.1.4.1.14179.2.5.3.1.12',
  'bsnRadiusAuthClientBadAuthenticators' => '1.3.6.1.4.1.14179.2.5.3.1.13',
  'bsnRadiusAuthClientPendingRequests' => '1.3.6.1.4.1.14179.2.5.3.1.14',
  'bsnRadiusAuthClientTimeouts' => '1.3.6.1.4.1.14179.2.5.3.1.15',
  'bsnRadiusAuthClientUnknownTypes' => '1.3.6.1.4.1.14179.2.5.3.1.16',
  'bsnRadiusAuthClientPacketsDropped' => '1.3.6.1.4.1.14179.2.5.3.1.36',
  'bsnRadiusAccServerStatsTable' => '1.3.6.1.4.1.14179.2.5.4',
  'bsnRadiusAccServerStatsEntry' => '1.3.6.1.4.1.14179.2.5.4.1',
  'bsnRadiusAccClientRoundTripTime' => '1.3.6.1.4.1.14179.2.5.4.1.6',
  'bsnRadiusAccClientRequests' => '1.3.6.1.4.1.14179.2.5.4.1.7',
  'bsnRadiusAccClientRetransmissions' => '1.3.6.1.4.1.14179.2.5.4.1.8',
  'bsnRadiusAccClientResponses' => '1.3.6.1.4.1.14179.2.5.4.1.9',
  'bsnRadiusAccClientMalformedResponses' => '1.3.6.1.4.1.14179.2.5.4.1.10',
  'bsnRadiusAccClientBadAuthenticators' => '1.3.6.1.4.1.14179.2.5.4.1.11',
  'bsnRadiusAccClientPendingRequests' => '1.3.6.1.4.1.14179.2.5.4.1.12',
  'bsnRadiusAccClientTimeouts' => '1.3.6.1.4.1.14179.2.5.4.1.13',
  'bsnRadiusAccClientUnknownTypes' => '1.3.6.1.4.1.14179.2.5.4.1.14',
  'bsnRadiusAccClientPacketsDropped' => '1.3.6.1.4.1.14179.2.5.4.1.34',
  'bsnUsersTable' => '1.3.6.1.4.1.14179.2.5.5',
  'bsnUsersEntry' => '1.3.6.1.4.1.14179.2.5.5.1',
  'bsnUserName' => '1.3.6.1.4.1.14179.2.5.5.1.2',
  'bsnUserPassword' => '1.3.6.1.4.1.14179.2.5.5.1.3',
  'bsnUserEssIndex' => '1.3.6.1.4.1.14179.2.5.5.1.4',
  'bsnUserAccessMode' => '1.3.6.1.4.1.14179.2.5.5.1.5',
  'bsnUserType' => '1.3.6.1.4.1.14179.2.5.5.1.6',
  'bsnUserInterfaceName' => '1.3.6.1.4.1.14179.2.5.5.1.7',
  'bsnUserRowStatus' => '1.3.6.1.4.1.14179.2.5.5.1.26',
  'bsnBlackListClientTable' => '1.3.6.1.4.1.14179.2.5.6',
  'bsnBlackListClientEntry' => '1.3.6.1.4.1.14179.2.5.6.1',
  'bsnBlackListClientMacAddress' => '1.3.6.1.4.1.14179.2.5.6.1.1',
  'bsnBlackListClientDescription' => '1.3.6.1.4.1.14179.2.5.6.1.2',
  'bsnBlackListClientRowStatus' => '1.3.6.1.4.1.14179.2.5.6.1.22',
  'bsnAclTable' => '1.3.6.1.4.1.14179.2.5.7',
  'bsnAclEntry' => '1.3.6.1.4.1.14179.2.5.7.1',
  'bsnAclName' => '1.3.6.1.4.1.14179.2.5.7.1.1',
  'bsnAclApplyMode' => '1.3.6.1.4.1.14179.2.5.7.1.2',
  'bsnAclRowStatus' => '1.3.6.1.4.1.14179.2.5.7.1.20',
  'bsnAclRuleTable' => '1.3.6.1.4.1.14179.2.5.8',
  'bsnAclRuleEntry' => '1.3.6.1.4.1.14179.2.5.8.1',
  'bsnAclRuleIndex' => '1.3.6.1.4.1.14179.2.5.8.1.2',
  'bsnAclRuleAction' => '1.3.6.1.4.1.14179.2.5.8.1.3',
  'bsnAclRuleDirection' => '1.3.6.1.4.1.14179.2.5.8.1.4',
  'bsnAclRuleSourceIpAddress' => '1.3.6.1.4.1.14179.2.5.8.1.5',
  'bsnAclRuleSourceIpNetmask' => '1.3.6.1.4.1.14179.2.5.8.1.6',
  'bsnAclRuleDestinationIpAddress' => '1.3.6.1.4.1.14179.2.5.8.1.7',
  'bsnAclRuleDestinationIpNetmask' => '1.3.6.1.4.1.14179.2.5.8.1.8',
  'bsnAclRuleProtocol' => '1.3.6.1.4.1.14179.2.5.8.1.9',
  'bsnAclRuleStartSourcePort' => '1.3.6.1.4.1.14179.2.5.8.1.10',
  'bsnAclRuleEndSourcePort' => '1.3.6.1.4.1.14179.2.5.8.1.11',
  'bsnAclRuleStartDestinationPort' => '1.3.6.1.4.1.14179.2.5.8.1.12',
  'bsnAclRuleEndDestinationPort' => '1.3.6.1.4.1.14179.2.5.8.1.13',
  'bsnAclRuleDscp' => '1.3.6.1.4.1.14179.2.5.8.1.14',
  'bsnAclNewRuleIndex' => '1.3.6.1.4.1.14179.2.5.8.1.15',
  'bsnAclRuleRowStatus' => '1.3.6.1.4.1.14179.2.5.8.1.40',
  'bsnMacFilterTable' => '1.3.6.1.4.1.14179.2.5.9',
  'bsnMacFilterEntry' => '1.3.6.1.4.1.14179.2.5.9.1',
  'bsnMacFilterAddress' => '1.3.6.1.4.1.14179.2.5.9.1.1',
  'bsnMacFilterWlanId' => '1.3.6.1.4.1.14179.2.5.9.1.2',
  'bsnMacFilterInterfaceName' => '1.3.6.1.4.1.14179.2.5.9.1.3',
  'bsnMacFilterDescription' => '1.3.6.1.4.1.14179.2.5.9.1.4',
  'bsnMacFilterRowStatus' => '1.3.6.1.4.1.14179.2.5.9.1.24',
  'bsnLocalNetUserTable' => '1.3.6.1.4.1.14179.2.5.10',
  'bsnLocalNetUserEntry' => '1.3.6.1.4.1.14179.2.5.10.1',
  'bsnLocalNetUserName' => '1.3.6.1.4.1.14179.2.5.10.1.1',
  'bsnLocalNetUserWlanId' => '1.3.6.1.4.1.14179.2.5.10.1.2',
  'bsnLocalNetUserPassword' => '1.3.6.1.4.1.14179.2.5.10.1.3',
  'bsnLocalNetUserDescription' => '1.3.6.1.4.1.14179.2.5.10.1.4',
  'bsnLocalNetUserLifetime' => '1.3.6.1.4.1.14179.2.5.10.1.5',
  'bsnLocalNetUserStartTime' => '1.3.6.1.4.1.14179.2.5.10.1.6',
  'bsnLocalNetUserRemainingTime' => '1.3.6.1.4.1.14179.2.5.10.1.7',
  'bsnLocalNetUserRowStatus' => '1.3.6.1.4.1.14179.2.5.10.1.24',
  'bsnLocalManagementUserTable' => '1.3.6.1.4.1.14179.2.5.11',
  'bsnLocalManagementUserEntry' => '1.3.6.1.4.1.14179.2.5.11.1',
  'bsnLocalManagementUserName' => '1.3.6.1.4.1.14179.2.5.11.1.1',
  'bsnLocalManagementUserPassword' => '1.3.6.1.4.1.14179.2.5.11.1.2',
  'bsnLocalManagementUserAccessMode' => '1.3.6.1.4.1.14179.2.5.11.1.3',
  'bsnLocalManagementUserRowStatus' => '1.3.6.1.4.1.14179.2.5.11.1.23',
  'bsnRadiusAuthKeyWrapEnable' => '1.3.6.1.4.1.14179.2.5.12',
  'bsnRadiusAuthCacheCredentialsLocally' => '1.3.6.1.4.1.14179.2.5.14',
  'bsnAAAMacDelimiter' => '1.3.6.1.4.1.14179.2.5.15',
  'bsnAAARadiusCompatibilityMode' => '1.3.6.1.4.1.14179.2.5.16',
  'bsnAAARadiusCallStationIdType' => '1.3.6.1.4.1.14179.2.5.17',
  'bsnExternalPolicyServerAclName' => '1.3.6.1.4.1.14179.2.5.18',
  'bsnExternalPolicyServerTable' => '1.3.6.1.4.1.14179.2.5.19',
  'bsnExternalPolicyServerEntry' => '1.3.6.1.4.1.14179.2.5.19.1',
  'bsnExternalPolicyServerIndex' => '1.3.6.1.4.1.14179.2.5.19.1.1',
  'bsnExternalPolicyServerAddress' => '1.3.6.1.4.1.14179.2.5.19.1.2',
  'bsnExternalPolicyServerPortNumber' => '1.3.6.1.4.1.14179.2.5.19.1.3',
  'bsnExternalPolicyServerKey' => '1.3.6.1.4.1.14179.2.5.19.1.4',
  'bsnExternalPolicyServerAdminStatus' => '1.3.6.1.4.1.14179.2.5.19.1.5',
  'bsnExternalPolicyServerConnectionStatus' => '1.3.6.1.4.1.14179.2.5.19.1.6',
  'bsnExternalPolicyServerRowStatus' => '1.3.6.1.4.1.14179.2.5.19.1.26',
  'bsnAAALocalDatabaseSize' => '1.3.6.1.4.1.14179.2.5.20',
  'bsnAAACurrentLocalDatabaseSize' => '1.3.6.1.4.1.14179.2.5.21',
  'bsnAPAuthorizationTable' => '1.3.6.1.4.1.14179.2.5.22',
  'bsnAPAuthorizationEntry' => '1.3.6.1.4.1.14179.2.5.22.1',
  'bsnAPAuthMacAddress' => '1.3.6.1.4.1.14179.2.5.22.1.1',
  'bsnAPAuthCertificateType' => '1.3.6.1.4.1.14179.2.5.22.1.2',
  'bsnAPAuthHashKey' => '1.3.6.1.4.1.14179.2.5.22.1.3',
  'bsnAPAuthRowStatus' => '1.3.6.1.4.1.14179.2.5.22.1.20',
  'bsnTrap' => '1.3.6.1.4.1.14179.2.6',
  'bsnTrapControl' => '1.3.6.1.4.1.14179.2.6.1',
  'bsnDot11StationTrapControlMask' => '1.3.6.1.4.1.14179.2.6.1.1',
  'bsnAPTrapControlMask' => '1.3.6.1.4.1.14179.2.6.1.2',
  'bsnAPProfileTrapControlMask' => '1.3.6.1.4.1.14179.2.6.1.3',
  'bsnAPParamUpdateTrapControlMask' => '1.3.6.1.4.1.14179.2.6.1.4',
  'bsnIpsecTrapsMask' => '1.3.6.1.4.1.14179.2.6.1.5',
  'bsnRogueAPTrapEnable' => '1.3.6.1.4.1.14179.2.6.1.6',
  'bsnRADIUSServerTrapEnable' => '1.3.6.1.4.1.14179.2.6.1.7',
  'bsnAuthenticationFailureTrapEnable' => '1.3.6.1.4.1.14179.2.6.1.8',
  'bsnConfigSaveTrapEnable' => '1.3.6.1.4.1.14179.2.6.1.9',
  'bsn80211SecurityTrapControlMask' => '1.3.6.1.4.1.14179.2.6.1.10',
  'bsnWpsTrapControlEnable' => '1.3.6.1.4.1.14179.2.6.1.11',
  'bsnTrapVariable' => '1.3.6.1.4.1.14179.2.6.2',
  'bsnAuthFailureUserName' => '1.3.6.1.4.1.14179.2.6.2.1',
  'bsnAuthFailureUserType' => '1.3.6.1.4.1.14179.2.6.2.2',
  'bsnRemoteIPv4Address' => '1.3.6.1.4.1.14179.2.6.2.3',
  'bsnIpsecErrorCount' => '1.3.6.1.4.1.14179.2.6.2.4',
  'bsnIpsecSPI' => '1.3.6.1.4.1.14179.2.6.2.5',
  'bsnRemoteUdpPort' => '1.3.6.1.4.1.14179.2.6.2.6',
  'bsnIkeAuthMethod' => '1.3.6.1.4.1.14179.2.6.2.7',
  'bsnIkeTotalInitFailures' => '1.3.6.1.4.1.14179.2.6.2.8',
  'bsnIkeTotalInitNoResponses' => '1.3.6.1.4.1.14179.2.6.2.9',
  'bsnIkeTotalRespFailures' => '1.3.6.1.4.1.14179.2.6.2.10',
  'bsnNotifiesSent' => '1.3.6.1.4.1.14179.2.6.2.11',
  'bsnNotifiesReceived' => '1.3.6.1.4.1.14179.2.6.2.12',
  'bsnSuiteInitFailures' => '1.3.6.1.4.1.14179.2.6.2.13',
  'bsnSuiteRespondFailures' => '1.3.6.1.4.1.14179.2.6.2.14',
  'bsnInitiatorCookie' => '1.3.6.1.4.1.14179.2.6.2.15',
  'bsnResponderCookie' => '1.3.6.1.4.1.14179.2.6.2.16',
  'bsnIsakmpInvalidCookies' => '1.3.6.1.4.1.14179.2.6.2.17',
  'bsnCurrentRadiosCount' => '1.3.6.1.4.1.14179.2.6.2.18',
  'bsnLicenseRadioCount' => '1.3.6.1.4.1.14179.2.6.2.19',
  'bsnAPMacAddrTrapVariable' => '1.3.6.1.4.1.14179.2.6.2.20',
  'bsnAPNameTrapVariable' => '1.3.6.1.4.1.14179.2.6.2.21',
  'bsnAPSlotIdTrapVariable' => '1.3.6.1.4.1.14179.2.6.2.22',
  'bsnAPChannelNumberTrapVariable' => '1.3.6.1.4.1.14179.2.6.2.23',
  'bsnAPCoverageThresholdTrapVariable' => '1.3.6.1.4.1.14179.2.6.2.24',
  'bsnAPCoverageFailedClients' => '1.3.6.1.4.1.14179.2.6.2.25',
  'bsnAPCoverageTotalClients' => '1.3.6.1.4.1.14179.2.6.2.26',
  'bsnClientMacAddr' => '1.3.6.1.4.1.14179.2.6.2.27',
  'bsnClientRssi' => '1.3.6.1.4.1.14179.2.6.2.28',
  'bsnClientSnr' => '1.3.6.1.4.1.14179.2.6.2.29',
  'bsnInterferenceEnergyBeforeChannelUpdate' => '1.3.6.1.4.1.14179.2.6.2.30',
  'bsnInterferenceEnergyAfterChannelUpdate' => '1.3.6.1.4.1.14179.2.6.2.31',
  'bsnAPPortNumberTrapVariable' => '1.3.6.1.4.1.14179.2.6.2.32',
  'bsnMaxRogueCount' => '1.3.6.1.4.1.14179.2.6.2.33',
  'bsnStationMacAddress' => '1.3.6.1.4.1.14179.2.6.2.34',
  'bsnStationAPMacAddr' => '1.3.6.1.4.1.14179.2.6.2.35',
  'bsnStationAPIfSlotId' => '1.3.6.1.4.1.14179.2.6.2.36',
  'bsnStationReasonCode' => '1.3.6.1.4.1.14179.2.6.2.37',
  'bsnStationBlacklistingReasonCode' => '1.3.6.1.4.1.14179.2.6.2.38',
  'bsnStationUserName' => '1.3.6.1.4.1.14179.2.6.2.39',
  'bsnRogueAPOnWiredNetwork' => '1.3.6.1.4.1.14179.2.6.2.40',
  'bsnNavDosAttackSourceMacAddr' => '1.3.6.1.4.1.14179.2.6.2.41',
  'bsnWlanIdTrapVariable' => '1.3.6.1.4.1.14179.2.6.2.42',
  'bsnUserIpAddress' => '1.3.6.1.4.1.14179.2.6.2.43',
  'bsnRogueAdhocMode' => '1.3.6.1.4.1.14179.2.6.2.44',
  'bsnClearTrapVariable' => '1.3.6.1.4.1.14179.2.6.2.45',
  'bsnDuplicateIpTrapVariable' => '1.3.6.1.4.1.14179.2.6.2.46',
  'bsnDuplicateIpTrapClear' => '1.3.6.1.4.1.14179.2.6.2.47',
  'bsnDuplicateIpReportedByAP' => '1.3.6.1.4.1.14179.2.6.2.48',
  'bsnTrustedApRadioPolicyRequired' => '1.3.6.1.4.1.14179.2.6.2.49',
  'bsnTrustedApEncryptionUsed' => '1.3.6.1.4.1.14179.2.6.2.50',
  'bsnTrustedApEncryptionRequired' => '1.3.6.1.4.1.14179.2.6.2.51',
  'bsnTrustedApRadioPolicyUsed' => '1.3.6.1.4.1.14179.2.6.2.52',
  'bsnNetworkType' => '1.3.6.1.4.1.14179.2.6.2.53',
  'bsnNetworkState' => '1.3.6.1.4.1.14179.2.6.2.54',
  'bsnSignatureType' => '1.3.6.1.4.1.14179.2.6.2.55',
  'bsnSignatureName' => '1.3.6.1.4.1.14179.2.6.2.56',
  'bsnSignatureDescription' => '1.3.6.1.4.1.14179.2.6.2.57',
  'bsnImpersonatedAPMacAddr' => '1.3.6.1.4.1.14179.2.6.2.58',
  'bsnTrustedApPreambleUsed' => '1.3.6.1.4.1.14179.2.6.2.59',
  'bsnTrustedApPreambleRequired' => '1.3.6.1.4.1.14179.2.6.2.60',
  'bsnSignatureAttackPreced' => '1.3.6.1.4.1.14179.2.6.2.61',
  'bsnSignatureAttackFrequency' => '1.3.6.1.4.1.14179.2.6.2.62',
  'bsnSignatureAttackChannel' => '1.3.6.1.4.1.14179.2.6.2.63',
  'bsnSignatureAttackerMacAddress' => '1.3.6.1.4.1.14179.2.6.2.64',
  'bsnLicenseKeyTrapVariable' => '1.3.6.1.4.1.14179.2.6.2.65',
  'bsnApFunctionalityDisableReasonCode' => '1.3.6.1.4.1.14179.2.6.2.66',
  'bsnLicenseKeyFeatureSetTrapVariable' => '1.3.6.1.4.1.14179.2.6.2.67',
  'bsnApRegulatoryDomain' => '1.3.6.1.4.1.14179.2.6.2.68',
  'bsnAPAuthorizationFailureCause' => '1.3.6.1.4.1.14179.2.6.2.69',
  'bsnAPIfUpDownCause' => '1.3.6.1.4.1.14179.2.6.2.70',
  'bsnAPInvalidRadioType' => '1.3.6.1.4.1.14179.2.6.2.71',
  'locationNotifyContent' => '1.3.6.1.4.1.14179.2.6.2.72',
  'bsnSignatureMacInfo' => '1.3.6.1.4.1.14179.2.6.2.73',
  'bsnImpersonatingSourceMacAddr' => '1.3.6.1.4.1.14179.2.6.2.74',
  'bsnAPPreviousChannelNumberTrapVariable' => '1.3.6.1.4.1.14179.2.6.2.83',
  'bsnAPReasonCodeTrapVariable' => '1.3.6.1.4.1.14179.2.6.2.84',
  'bsnNoiseBeforeChannelUpdate' => '1.3.6.1.4.1.14179.2.6.2.85',
  'bsnNoiseAfterChannelUpdate' => '1.3.6.1.4.1.14179.2.6.2.86',
  'bsnInterferenceBeforeChannelUpdate' => '1.3.6.1.4.1.14179.2.6.2.87',
  'bsnInterferenceAfterChannelUpdate' => '1.3.6.1.4.1.14179.2.6.2.88',
  'bsnTraps' => '1.3.6.1.4.1.14179.2.6.3',
  'bsnDot11StationDisassociate' => '1.3.6.1.4.1.14179.2.6.3.1',
  'bsnDot11StationDeauthenticate' => '1.3.6.1.4.1.14179.2.6.3.2',
  'bsnDot11StationAuthenticateFail' => '1.3.6.1.4.1.14179.2.6.3.3',
  'bsnDot11StationAssociateFail' => '1.3.6.1.4.1.14179.2.6.3.4',
  'bsnAPUp' => '1.3.6.1.4.1.14179.2.6.3.5',
  'bsnAPDown' => '1.3.6.1.4.1.14179.2.6.3.6',
  'bsnAPAssociated' => '1.3.6.1.4.1.14179.2.6.3.7',
  'bsnAPDisassociated' => '1.3.6.1.4.1.14179.2.6.3.8',
  'bsnAPIfUp' => '1.3.6.1.4.1.14179.2.6.3.9',
  'bsnAPIfDown' => '1.3.6.1.4.1.14179.2.6.3.10',
  'bsnAPLoadProfileFailed' => '1.3.6.1.4.1.14179.2.6.3.11',
  'bsnAPNoiseProfileFailed' => '1.3.6.1.4.1.14179.2.6.3.12',
  'bsnAPInterferenceProfileFailed' => '1.3.6.1.4.1.14179.2.6.3.13',
  'bsnAPCoverageProfileFailed' => '1.3.6.1.4.1.14179.2.6.3.14',
  'bsnAPCurrentTxPowerChanged' => '1.3.6.1.4.1.14179.2.6.3.15',
  'bsnAPCurrentChannelChanged' => '1.3.6.1.4.1.14179.2.6.3.16',
  'bsnRrmDot11aGroupingDone' => '1.3.6.1.4.1.14179.2.6.3.21',
  'bsnRrmDot11bGroupingDone' => '1.3.6.1.4.1.14179.2.6.3.22',
  'bsnConfigSaved' => '1.3.6.1.4.1.14179.2.6.3.23',
  'bsnDot11EssCreated' => '1.3.6.1.4.1.14179.2.6.3.24',
  'bsnDot11EssDeleted' => '1.3.6.1.4.1.14179.2.6.3.25',
  'bsnRADIUSServerNotResponding' => '1.3.6.1.4.1.14179.2.6.3.26',
  'bsnAuthenticationFailure' => '1.3.6.1.4.1.14179.2.6.3.27',
  'bsnIpsecEspAuthFailureTrap' => '1.3.6.1.4.1.14179.2.6.3.28',
  'bsnIpsecEspReplayFailureTrap' => '1.3.6.1.4.1.14179.2.6.3.29',
  'bsnIpsecEspInvalidSpiTrap' => '1.3.6.1.4.1.14179.2.6.3.31',
  'bsnIpsecIkeNegFailure' => '1.3.6.1.4.1.14179.2.6.3.33',
  'bsnIpsecSuiteNegFailure' => '1.3.6.1.4.1.14179.2.6.3.34',
  'bsnIpsecInvalidCookieTrap' => '1.3.6.1.4.1.14179.2.6.3.35',
  'bsnRogueAPDetected' => '1.3.6.1.4.1.14179.2.6.3.36',
  'bsnAPLoadProfileUpdatedToPass' => '1.3.6.1.4.1.14179.2.6.3.37',
  'bsnAPNoiseProfileUpdatedToPass' => '1.3.6.1.4.1.14179.2.6.3.38',
  'bsnAPInterferenceProfileUpdatedToPass' => '1.3.6.1.4.1.14179.2.6.3.39',
  'bsnAPCoverageProfileUpdatedToPass' => '1.3.6.1.4.1.14179.2.6.3.40',
  'bsnRogueAPRemoved' => '1.3.6.1.4.1.14179.2.6.3.41',
  'bsnRadiosExceedLicenseCount' => '1.3.6.1.4.1.14179.2.6.3.42',
  'bsnSensedTemperatureTooHigh' => '1.3.6.1.4.1.14179.2.6.3.43',
  'bsnSensedTemperatureTooLow' => '1.3.6.1.4.1.14179.2.6.3.44',
  'bsnTemperatureSensorFailure' => '1.3.6.1.4.1.14179.2.6.3.45',
  'bsnTemperatureSensorClear' => '1.3.6.1.4.1.14179.2.6.3.46',
  'bsnPOEControllerFailure' => '1.3.6.1.4.1.14179.2.6.3.47',
  'bsnMaxRogueCountExceeded' => '1.3.6.1.4.1.14179.2.6.3.48',
  'bsnMaxRogueCountClear' => '1.3.6.1.4.1.14179.2.6.3.49',
  'bsnApMaxRogueCountExceeded' => '1.3.6.1.4.1.14179.2.6.3.50',
  'bsnApMaxRogueCountClear' => '1.3.6.1.4.1.14179.2.6.3.51',
  'bsnDot11StationBlacklisted' => '1.3.6.1.4.1.14179.2.6.3.52',
  'bsnDot11StationAssociate' => '1.3.6.1.4.1.14179.2.6.3.53',
  'bsnApBigNavDosAttack' => '1.3.6.1.4.1.14179.2.6.3.55',
  'bsnTooManyUnsuccessLoginAttempts' => '1.3.6.1.4.1.14179.2.6.3.56',
  'bsnWepKeyDecryptError' => '1.3.6.1.4.1.14179.2.6.3.57',
  'bsnWpaMicErrorCounterActivated' => '1.3.6.1.4.1.14179.2.6.3.58',
  'bsnRogueAPDetectedOnWiredNetwork' => '1.3.6.1.4.1.14179.2.6.3.59',
  'bsnApHasNoRadioCards' => '1.3.6.1.4.1.14179.2.6.3.60',
  'bsnDuplicateIpAddressReported' => '1.3.6.1.4.1.14179.2.6.3.61',
  'bsnAPContainedAsARogue' => '1.3.6.1.4.1.14179.2.6.3.62',
  'bsnTrustedApHasInvalidSsid' => '1.3.6.1.4.1.14179.2.6.3.63',
  'bsnTrustedApIsMissing' => '1.3.6.1.4.1.14179.2.6.3.64',
  'bsnAdhocRogueAutoContained' => '1.3.6.1.4.1.14179.2.6.3.65',
  'bsnRogueApAutoContained' => '1.3.6.1.4.1.14179.2.6.3.66',
  'bsnTrustedApHasInvalidEncryption' => '1.3.6.1.4.1.14179.2.6.3.67',
  'bsnTrustedApHasInvalidRadioPolicy' => '1.3.6.1.4.1.14179.2.6.3.68',
  'bsnNetworkStateChanged' => '1.3.6.1.4.1.14179.2.6.3.69',
  'bsnSignatureAttackDetected' => '1.3.6.1.4.1.14179.2.6.3.70',
  'bsnAPRadioCardTxFailure' => '1.3.6.1.4.1.14179.2.6.3.71',
  'bsnAPRadioCardTxFailureClear' => '1.3.6.1.4.1.14179.2.6.3.72',
  'bsnAPRadioCardRxFailure' => '1.3.6.1.4.1.14179.2.6.3.73',
  'bsnAPRadioCardRxFailureClear' => '1.3.6.1.4.1.14179.2.6.3.74',
  'bsnAPImpersonationDetected' => '1.3.6.1.4.1.14179.2.6.3.75',
  'bsnTrustedApHasInvalidPreamble' => '1.3.6.1.4.1.14179.2.6.3.76',
  'bsnAPIPAddressFallback' => '1.3.6.1.4.1.14179.2.6.3.77',
  'bsnAPFunctionalityDisabled' => '1.3.6.1.4.1.14179.2.6.3.78',
  'bsnAPRegulatoryDomainMismatch' => '1.3.6.1.4.1.14179.2.6.3.79',
  'bsnRxMulticastQueueFull' => '1.3.6.1.4.1.14179.2.6.3.80',
  'bsnRadarChannelDetected' => '1.3.6.1.4.1.14179.2.6.3.81',
  'bsnRadarChannelCleared' => '1.3.6.1.4.1.14179.2.6.3.82',
  'bsnAPAuthorizationFailure' => '1.3.6.1.4.1.14179.2.6.3.83',
  'radioCoreDumpTrap' => '1.3.6.1.4.1.14179.2.6.3.84',
  'invalidRadioTrap' => '1.3.6.1.4.1.14179.2.6.3.85',
  'countryChangeTrap' => '1.3.6.1.4.1.14179.2.6.3.86',
  'unsupportedAPTrap' => '1.3.6.1.4.1.14179.2.6.3.87',
  'heartbeatLossTrap' => '1.3.6.1.4.1.14179.2.6.3.88',
  'locationNotifyTrap' => '1.3.6.1.4.1.14179.2.6.3.89',
  'bsnUtility' => '1.3.6.1.4.1.14179.2.7',
  'bsnSyslog' => '1.3.6.1.4.1.14179.2.7.1',
  'bsnSyslogEnable' => '1.3.6.1.4.1.14179.2.7.1.1',
  'bsnSyslogRemoteAddress' => '1.3.6.1.4.1.14179.2.7.1.2',
  'bsnPing' => '1.3.6.1.4.1.14179.2.7.2',
  'bsnPingTestTable' => '1.3.6.1.4.1.14179.2.7.2.1',
  'bsnPingTestEntry' => '1.3.6.1.4.1.14179.2.7.2.1.1',
  'bsnPingTestId' => '1.3.6.1.4.1.14179.2.7.2.1.1.1',
  'bsnPingTestIPAddress' => '1.3.6.1.4.1.14179.2.7.2.1.1.2',
  'bsnPingTestSendCount' => '1.3.6.1.4.1.14179.2.7.2.1.1.3',
  'bsnPingTestReceivedCount' => '1.3.6.1.4.1.14179.2.7.2.1.1.4',
  'bsnPingTestStatus' => '1.3.6.1.4.1.14179.2.7.2.1.1.5',
  'bsnPingTestMaxTimeInterval' => '1.3.6.1.4.1.14179.2.7.2.1.1.6',
  'bsnPingTestMinTimeInterval' => '1.3.6.1.4.1.14179.2.7.2.1.1.7',
  'bsnPingTestAvgTimeInterval' => '1.3.6.1.4.1.14179.2.7.2.1.1.8',
  'bsnPingTestRowStatus' => '1.3.6.1.4.1.14179.2.7.2.1.1.25',
  'bsnLinkTest' => '1.3.6.1.4.1.14179.2.7.3',
  'bsnLinkTestTable' => '1.3.6.1.4.1.14179.2.7.3.1',
  'bsnLinkTestEntry' => '1.3.6.1.4.1.14179.2.7.3.1.1',
  'bsnLinkTestId' => '1.3.6.1.4.1.14179.2.7.3.1.1.1',
  'bsnLinkTestMacAddress' => '1.3.6.1.4.1.14179.2.7.3.1.1.2',
  'bsnLinkTestSendPktCount' => '1.3.6.1.4.1.14179.2.7.3.1.1.3',
  'bsnLinkTestSendPktLength' => '1.3.6.1.4.1.14179.2.7.3.1.1.4',
  'bsnLinkTestReceivedPktCount' => '1.3.6.1.4.1.14179.2.7.3.1.1.5',
  'bsnLinkTestClientRSSI' => '1.3.6.1.4.1.14179.2.7.3.1.1.6',
  'bsnLinkTestLocalSNR' => '1.3.6.1.4.1.14179.2.7.3.1.1.7',
  'bsnLinkTestLocalRSSI' => '1.3.6.1.4.1.14179.2.7.3.1.1.8',
  'bsnLinkTestStatus' => '1.3.6.1.4.1.14179.2.7.3.1.1.9',
  'bsnLinkTestRowStatus' => '1.3.6.1.4.1.14179.2.7.3.1.1.30',
  'bsnMobility' => '1.3.6.1.4.1.14179.2.8',
  'bsnMobilityConfig' => '1.3.6.1.4.1.14179.2.8.1',
  'bsnMobilityProtocolPortNum' => '1.3.6.1.4.1.14179.2.8.1.1',
  'bsnMobilityDynamicDiscovery' => '1.3.6.1.4.1.14179.2.8.1.3',
  'bsnMobilityStatsReset' => '1.3.6.1.4.1.14179.2.8.1.4',
  'bsnMobilityGroupMembersTable' => '1.3.6.1.4.1.14179.2.8.1.10',
  'bsnMobilityGroupMembersEntry' => '1.3.6.1.4.1.14179.2.8.1.10.1',
  'bsnMobilityGroupMemberMacAddress' => '1.3.6.1.4.1.14179.2.8.1.10.1.1',
  'bsnMobilityGroupMemberIPAddress' => '1.3.6.1.4.1.14179.2.8.1.10.1.2',
  'bsnMobilityGroupMemberGroupName' => '1.3.6.1.4.1.14179.2.8.1.10.1.3',
  'bsnMobilityGroupMemberRowStatus' => '1.3.6.1.4.1.14179.2.8.1.10.1.22',
  'bsnMobilityAnchorsTable' => '1.3.6.1.4.1.14179.2.8.1.11',
  'bsnMobilityAnchorsEntry' => '1.3.6.1.4.1.14179.2.8.1.11.1',
  'bsnMobilityAnchorWlanSsid' => '1.3.6.1.4.1.14179.2.8.1.11.1.1',
  'bsnMobilityAnchorSwitchIPAddress' => '1.3.6.1.4.1.14179.2.8.1.11.1.2',
  'bsnMobilityAnchorRowStatus' => '1.3.6.1.4.1.14179.2.8.1.11.1.20',
  'bsnMobilityStats' => '1.3.6.1.4.1.14179.2.8.2',
  'bsnTotalHandoffRequests' => '1.3.6.1.4.1.14179.2.8.2.1',
  'bsnTotalHandoffs' => '1.3.6.1.4.1.14179.2.8.2.2',
  'bsnCurrentExportedClients' => '1.3.6.1.4.1.14179.2.8.2.3',
  'bsnTotalExportedClients' => '1.3.6.1.4.1.14179.2.8.2.4',
  'bsnCurrentImportedClients' => '1.3.6.1.4.1.14179.2.8.2.5',
  'bsnTotalImportedClients' => '1.3.6.1.4.1.14179.2.8.2.6',
  'bsnTotalHandoffErrors' => '1.3.6.1.4.1.14179.2.8.2.7',
  'bsnTotalCommunicationErrors' => '1.3.6.1.4.1.14179.2.8.2.8',
  'bsnMobilityGroupDirectoryTable' => '1.3.6.1.4.1.14179.2.8.2.9',
  'bsnMobilityGroupDirectoryEntry' => '1.3.6.1.4.1.14179.2.8.2.9.1',
  'bsnGroupDirectoryMemberIPAddress' => '1.3.6.1.4.1.14179.2.8.2.9.1.1',
  'bsnGroupDirectoryMemberMacAddress' => '1.3.6.1.4.1.14179.2.8.2.9.1.2',
  'bsnGroupDirectoryDicoveryType' => '1.3.6.1.4.1.14179.2.8.2.9.1.3',
  'bsnMemberCurrentAnchoredClients' => '1.3.6.1.4.1.14179.2.8.2.9.1.4',
  'bsnMemberTotalAnchoredClients' => '1.3.6.1.4.1.14179.2.8.2.9.1.5',
  'bsnMemberCurrentExportedClients' => '1.3.6.1.4.1.14179.2.8.2.9.1.6',
  'bsnMemberTotalExportedClients' => '1.3.6.1.4.1.14179.2.8.2.9.1.7',
  'bsnMemberCurrentImportedClients' => '1.3.6.1.4.1.14179.2.8.2.9.1.8',
  'bsnMemberTotalImportedClients' => '1.3.6.1.4.1.14179.2.8.2.9.1.9',
  'bsnMemberTotalHandoffErrors' => '1.3.6.1.4.1.14179.2.8.2.9.1.10',
  'bsnMemberTotalCommunicationErrors' => '1.3.6.1.4.1.14179.2.8.2.9.1.30',
  'bsnTotalReceiveErrors' => '1.3.6.1.4.1.14179.2.8.2.10',
  'bsnTotalTransmitErrors' => '1.3.6.1.4.1.14179.2.8.2.11',
  'bsnTotalResponsesRetransmitted' => '1.3.6.1.4.1.14179.2.8.2.12',
  'bsnTotalHandoffEndRequestsReceived' => '1.3.6.1.4.1.14179.2.8.2.13',
  'bsnTotalStateTransitionsDisallowed' => '1.3.6.1.4.1.14179.2.8.2.14',
  'bsnTotalResourceErrors' => '1.3.6.1.4.1.14179.2.8.2.15',
  'bsnTotalHandoffRequestsSent' => '1.3.6.1.4.1.14179.2.8.2.16',
  'bsnTotalHandoffRepliesReceived' => '1.3.6.1.4.1.14179.2.8.2.17',
  'bsnTotalHandoffAsLocalReceived' => '1.3.6.1.4.1.14179.2.8.2.18',
  'bsnTotalHandoffAsForeignReceived' => '1.3.6.1.4.1.14179.2.8.2.19',
  'bsnTotalHandoffDeniesReceived' => '1.3.6.1.4.1.14179.2.8.2.20',
  'bsnTotalAnchorRequestsSent' => '1.3.6.1.4.1.14179.2.8.2.21',
  'bsnTotalAnchorDenyReceived' => '1.3.6.1.4.1.14179.2.8.2.22',
  'bsnTotalAnchorGrantReceived' => '1.3.6.1.4.1.14179.2.8.2.23',
  'bsnTotalAnchorTransferReceived' => '1.3.6.1.4.1.14179.2.8.2.24',
  'bsnTotalHandoffRequestsIgnored' => '1.3.6.1.4.1.14179.2.8.2.25',
  'bsnTotalPingPongHandoffRequestsDropped' => '1.3.6.1.4.1.14179.2.8.2.26',
  'bsnTotalHandoffRequestsDropped' => '1.3.6.1.4.1.14179.2.8.2.27',
  'bsnTotalHandoffRequestsDenied' => '1.3.6.1.4.1.14179.2.8.2.28',
  'bsnTotalClientHandoffAsLocal' => '1.3.6.1.4.1.14179.2.8.2.29',
  'bsnTotalClientHandoffAsForeign' => '1.3.6.1.4.1.14179.2.8.2.30',
  'bsnTotalAnchorRequestsReceived' => '1.3.6.1.4.1.14179.2.8.2.31',
  'bsnTotalAnchorRequestsDenied' => '1.3.6.1.4.1.14179.2.8.2.32',
  'bsnTotalAnchorRequestsGranted' => '1.3.6.1.4.1.14179.2.8.2.33',
  'bsnTotalAnchorTransferred' => '1.3.6.1.4.1.14179.2.8.2.34',
  'bsnTotalHandoffRequestsReceived' => '1.3.6.1.4.1.14179.2.8.2.35',
  'bsnIpsec' => '1.3.6.1.4.1.14179.2.9',
  'bsnWrasIpsecCACertificate' => '1.3.6.1.4.1.14179.2.9.1',
  'bsnWrasIpsecCACertificateUpdate' => '1.3.6.1.4.1.14179.2.9.2',
  'bsnWrasIpsecCertTable' => '1.3.6.1.4.1.14179.2.9.3',
  'bsnWrasIpsecCertEntry' => '1.3.6.1.4.1.14179.2.9.3.1',
  'bsnWrasIpsecCertName' => '1.3.6.1.4.1.14179.2.9.3.1.1',
  'bsnWrasIpsecCertificateUpdate' => '1.3.6.1.4.1.14179.2.9.3.1.2',
  'bsnWrasIpsecCertificate' => '1.3.6.1.4.1.14179.2.9.3.1.3',
  'bsnWrasIpsecCertPassword' => '1.3.6.1.4.1.14179.2.9.3.1.4',
  'bsnWrasIpsecCertStatus' => '1.3.6.1.4.1.14179.2.9.3.1.24',
  'bsnAPGroupsVlanConfig' => '1.3.6.1.4.1.14179.2.10',
  'bsnAPGroupsVlanFeature' => '1.3.6.1.4.1.14179.2.10.1',
  'bsnAPGroupsVlanTable' => '1.3.6.1.4.1.14179.2.10.2',
  'bsnAPGroupsVlanEntry' => '1.3.6.1.4.1.14179.2.10.2.1',
  'bsnAPGroupsVlanName' => '1.3.6.1.4.1.14179.2.10.2.1.1',
  'bsnAPGroupsVlanDescription' => '1.3.6.1.4.1.14179.2.10.2.1.2',
  'bsnAPGroupsVlanRowStatus' => '1.3.6.1.4.1.14179.2.10.2.1.20',
  'bsnAPGroupsVlanMappingTable' => '1.3.6.1.4.1.14179.2.10.3',
  'bsnAPGroupsVlanMappingEntry' => '1.3.6.1.4.1.14179.2.10.3.1',
  'bsnAPGroupsVlanMappingSsid' => '1.3.6.1.4.1.14179.2.10.3.1.1',
  'bsnAPGroupsVlanMappingInterfaceName' => '1.3.6.1.4.1.14179.2.10.3.1.2',
  'bsnAPGroupsVlanMappingRowStatus' => '1.3.6.1.4.1.14179.2.10.3.1.20',
  'bsnWrasGroups' => '1.3.6.1.4.1.14179.2.50',
  'bsnEssGroup' => '1.3.6.1.4.1.14179.2.50.1',
  'bsnApGroup' => '1.3.6.1.4.1.14179.2.50.2',
  'bsnGlobalDot11Group' => '1.3.6.1.4.1.14179.2.50.3',
  'bsnRrmGroup' => '1.3.6.1.4.1.14179.2.50.4',
  'bsnAAAGroup' => '1.3.6.1.4.1.14179.2.50.5',
  'bsnTrapsGroup' => '1.3.6.1.4.1.14179.2.50.6',
  'bsnUtilityGroup' => '1.3.6.1.4.1.14179.2.50.7',
  'bsnMobilityGroup' => '1.3.6.1.4.1.14179.2.50.8',
  'bsnIpsecGroup' => '1.3.6.1.4.1.14179.2.50.9',
  'bsnWrasDepGroup' => '1.3.6.1.4.1.14179.2.50.10',
  'bsnWrasObsGroup' => '1.3.6.1.4.1.14179.2.50.11',
  'bsnWrasTrap' => '1.3.6.1.4.1.14179.2.50.12',
  'bsnEssGroupRev1' => '1.3.6.1.4.1.14179.2.50.13',
  'bsnGlobalDot11GroupRev1' => '1.3.6.1.4.1.14179.2.50.14',
  'bsnAAAGroupRev1' => '1.3.6.1.4.1.14179.2.50.15',
  'bsnTrapsGroupRev1' => '1.3.6.1.4.1.14179.2.50.16',
  'bsnWrasTrapRev1' => '1.3.6.1.4.1.14179.2.50.17',
  'bsnApGroupRev1' => '1.3.6.1.4.1.14179.2.50.18',
  'bsnUtilityGroupRev1' => '1.3.6.1.4.1.14179.2.50.19',
  'bsnWrasObsGroupRev1' => '1.3.6.1.4.1.14179.2.50.20',
  'bsnWrasObsTrap' => '1.3.6.1.4.1.14179.2.50.21',
  'bsnWrasCompliances' => '1.3.6.1.4.1.14179.2.51',
  'bsnWrasCompliance' => '1.3.6.1.4.1.14179.2.51.1',
  'bsnWrasComplianceRev1' => '1.3.6.1.4.1.14179.2.51.2',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::ALARMMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'ALARM-MIB'} = {
  url => '',
  name => 'ALARM-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'ALARM-MIB'} = {
  'alarmMIB' => '1.3.6.1.2.1.118',
  'alarmNotifications' => '1.3.6.1.2.1.118.0',
  'alarmObjects' => '1.3.6.1.2.1.118.1',
  'alarmModel' => '1.3.6.1.2.1.118.1.1',
  'alarmModelLastChanged' => '1.3.6.1.2.1.118.1.1.1',
  'alarmModelTable' => '1.3.6.1.2.1.118.1.1.2',
  'alarmModelEntry' => '1.3.6.1.2.1.118.1.1.2.1',
  'alarmModelIndex' => '1.3.6.1.2.1.118.1.1.2.1.1',
  'alarmModelState' => '1.3.6.1.2.1.118.1.1.2.1.2',
  'alarmModelNotificationId' => '1.3.6.1.2.1.118.1.1.2.1.3',
  'alarmModelVarbindIndex' => '1.3.6.1.2.1.118.1.1.2.1.4',
  'alarmModelVarbindValue' => '1.3.6.1.2.1.118.1.1.2.1.5',
  'alarmModelDescription' => '1.3.6.1.2.1.118.1.1.2.1.6',
  'alarmModelSpecificPointer' => '1.3.6.1.2.1.118.1.1.2.1.7',
  'alarmModelVarbindSubtree' => '1.3.6.1.2.1.118.1.1.2.1.8',
  'alarmModelResourcePrefix' => '1.3.6.1.2.1.118.1.1.2.1.9',
  'alarmModelRowStatus' => '1.3.6.1.2.1.118.1.1.2.1.10',
  'alarmActive' => '1.3.6.1.2.1.118.1.2',
  'alarmActiveLastChanged' => '1.3.6.1.2.1.118.1.2.1',
  'alarmActiveTable' => '1.3.6.1.2.1.118.1.2.2',
  'alarmActiveEntry' => '1.3.6.1.2.1.118.1.2.2.1',
  'alarmListName' => '1.3.6.1.2.1.118.1.2.2.1.1',
  'alarmActiveDateAndTime' => '1.3.6.1.2.1.118.1.2.2.1.2',
  'alarmActiveIndex' => '1.3.6.1.2.1.118.1.2.2.1.3',
  'alarmActiveEngineID' => '1.3.6.1.2.1.118.1.2.2.1.4',
  'alarmActiveEngineAddressType' => '1.3.6.1.2.1.118.1.2.2.1.5',
  'alarmActiveEngineAddress' => '1.3.6.1.2.1.118.1.2.2.1.6',
  'alarmActiveContextName' => '1.3.6.1.2.1.118.1.2.2.1.7',
  'alarmActiveVariables' => '1.3.6.1.2.1.118.1.2.2.1.8',
  'alarmActiveNotificationID' => '1.3.6.1.2.1.118.1.2.2.1.9',
  'alarmActiveResourceId' => '1.3.6.1.2.1.118.1.2.2.1.10',
  'alarmActiveDescription' => '1.3.6.1.2.1.118.1.2.2.1.11',
  'alarmActiveLogPointer' => '1.3.6.1.2.1.118.1.2.2.1.12',
  'alarmActiveModelPointer' => '1.3.6.1.2.1.118.1.2.2.1.13',
  'alarmActiveSpecificPointer' => '1.3.6.1.2.1.118.1.2.2.1.14',
  'alarmActiveVariableTable' => '1.3.6.1.2.1.118.1.2.3',
  'alarmActiveVariableEntry' => '1.3.6.1.2.1.118.1.2.3.1',
  'alarmActiveVariableIndex' => '1.3.6.1.2.1.118.1.2.3.1.1',
  'alarmActiveVariableID' => '1.3.6.1.2.1.118.1.2.3.1.2',
  'alarmActiveVariableValueType' => '1.3.6.1.2.1.118.1.2.3.1.3',
  'alarmActiveVariableValueTypeDefinition' => 'ALARM-MIB::alarmActiveVariableValueType',
  'alarmActiveVariableCounter32Val' => '1.3.6.1.2.1.118.1.2.3.1.4',
  'alarmActiveVariableUnsigned32Val' => '1.3.6.1.2.1.118.1.2.3.1.5',
  'alarmActiveVariableTimeTicksVal' => '1.3.6.1.2.1.118.1.2.3.1.6',
  'alarmActiveVariableInteger32Val' => '1.3.6.1.2.1.118.1.2.3.1.7',
  'alarmActiveVariableOctetStringVal' => '1.3.6.1.2.1.118.1.2.3.1.8',
  'alarmActiveVariableIpAddressVal' => '1.3.6.1.2.1.118.1.2.3.1.9',
  'alarmActiveVariableOidVal' => '1.3.6.1.2.1.118.1.2.3.1.10',
  'alarmActiveVariableCounter64Val' => '1.3.6.1.2.1.118.1.2.3.1.11',
  'alarmActiveVariableOpaqueVal' => '1.3.6.1.2.1.118.1.2.3.1.12',
  'alarmActiveStatsTable' => '1.3.6.1.2.1.118.1.2.4',
  'alarmActiveStatsEntry' => '1.3.6.1.2.1.118.1.2.4.1',
  'alarmActiveStatsActiveCurrent' => '1.3.6.1.2.1.118.1.2.4.1.1',
  'alarmActiveStatsActives' => '1.3.6.1.2.1.118.1.2.4.1.2',
  'alarmActiveStatsLastRaise' => '1.3.6.1.2.1.118.1.2.4.1.3',
  'alarmActiveStatsLastClear' => '1.3.6.1.2.1.118.1.2.4.1.4',
  'alarmActiveOverflow' => '1.3.6.1.2.1.118.1.2.5',
  'alarmClear' => '1.3.6.1.2.1.118.1.3',
  'alarmClearMaximum' => '1.3.6.1.2.1.118.1.3.1',
  'alarmClearTable' => '1.3.6.1.2.1.118.1.3.2',
  'alarmClearEntry' => '1.3.6.1.2.1.118.1.3.2.1',
  'alarmClearIndex' => '1.3.6.1.2.1.118.1.3.2.1.1',
  'alarmClearDateAndTime' => '1.3.6.1.2.1.118.1.3.2.1.2',
  'alarmClearEngineID' => '1.3.6.1.2.1.118.1.3.2.1.3',
  'alarmClearEngineAddressType' => '1.3.6.1.2.1.118.1.3.2.1.4',
  'alarmClearEngineAddress' => '1.3.6.1.2.1.118.1.3.2.1.5',
  'alarmClearContextName' => '1.3.6.1.2.1.118.1.3.2.1.6',
  'alarmClearNotificationID' => '1.3.6.1.2.1.118.1.3.2.1.7',
  'alarmClearResourceId' => '1.3.6.1.2.1.118.1.3.2.1.8',
  'alarmClearLogIndex' => '1.3.6.1.2.1.118.1.3.2.1.9',
  'alarmClearModelPointer' => '1.3.6.1.2.1.118.1.3.2.1.10',
  'alarmConformance' => '1.3.6.1.2.1.118.2',
  'alarmCompliances' => '1.3.6.1.2.1.118.2.1',
  'alarmGroups' => '1.3.6.1.2.1.118.2.2',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'ALARM-MIB'} = {
  'alarmActiveVariableValueType' => {
    '1' => 'counter32',
    '2' => 'unsigned32',
    '3' => 'timeTicks',
    '4' => 'integer32',
    '5' => 'ipAddress',
    '6' => 'octetString',
    '7' => 'objectId',
    '8' => 'counter64',
    '9' => 'opaque',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::ALCATELIND1BASEMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'ALCATEL-IND1-BASE-MIB'} = {
  url => '',
  name => 'ALCATEL-IND1-BASE-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'ALCATEL-IND1-BASE-MIB'} = 
  '1.3.6.1.4.1.6486.800';



package Monitoring::GLPlugin::SNMP::MibsAndOids::ARISTAENTITYSENSORMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'ARISTA-ENTITY-SENSOR-MIB'} = {
  url => '',
  name => 'ARISTA-ENTITY-SENSOR-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'ARISTA-ENTITY-SENSOR-MIB'} =
    '1.3.6.1.4.1.30065.3.12';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'ARISTA-ENTITY-SENSOR-MIB'} = {
  aristaEntSensorMIB => '1.3.6.1.4.1.30065.3.12',
  aristaEntSensorMibNotifications => '1.3.6.1.4.1.30065.3.12.0',
  aristaEntSensorMibObjects => '1.3.6.1.4.1.30065.3.12.1',
  aristaEntSensorThresholdTable => '1.3.6.1.4.1.30065.3.12.1.1',
  aristaEntSensorThresholdEntry => '1.3.6.1.4.1.30065.3.12.1.1.1',
  aristaEntSensorThresholdLowWarning => '1.3.6.1.4.1.30065.3.12.1.1.1.1',
  aristaEntSensorThresholdLowCritical => '1.3.6.1.4.1.30065.3.12.1.1.1.2',
  aristaEntSensorThresholdHighWarning => '1.3.6.1.4.1.30065.3.12.1.1.1.3',
  aristaEntSensorThresholdHighCritical => '1.3.6.1.4.1.30065.3.12.1.1.1.4',
  aristaEntSensorStatusDescr => '1.3.6.1.4.1.30065.3.12.1.1.1.5',
  aristaEntSensorMibConformance => '1.3.6.1.4.1.30065.3.12.2',
  aristaEntSensorMibCompliances => '1.3.6.1.4.1.30065.3.12.2.1',
  aristaEntSensorMibGroups => '1.3.6.1.4.1.30065.3.12.2.2',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'ARISTA-ENTITY-SENSOR-MIB'} = {
};

package Monitoring::GLPlugin::SNMP::MibsAndOids::ARUBATCMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'ARUBA-TC-MIB'} = {
  url => 'http://www.circitor.fr/Mibs/Files/ARUBA-TC.mib',
  name => 'ARUBA-TC-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'ARUBA-TC-MIB'} = {
  'ArubaSwitchRole' => {
    1 => 'master',
    2 => 'local',
    3 => 'backupmaster',
  },
  'ArubaActiveState' => {
    1 => 'active',
    2 => 'inactive',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::ASYNCOSMAILMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'ASYNCOS-MAIL-MIB'} = {
  url => '',
  name => 'ASYNCOS-MAIL-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::requirements->{'ASYNCOS-MAIL-MIB'} = [
  'SNMPv2-TC-v1-MIB',
];

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'ASYNCOS-MAIL-MIB'} = {
  'asyncOSMailObjects' => '1.3.6.1.4.1.15497.1.1.1',
  'perCentMemoryUtilization' => '1.3.6.1.4.1.15497.1.1.1.1.0',
  'perCentCPUUtilization' => '1.3.6.1.4.1.15497.1.1.1.2.0',
  'perCentDiskIOUtilization' => '1.3.6.1.4.1.15497.1.1.1.3.0',
  'perCentQueueUtilization' => '1.3.6.1.4.1.15497.1.1.1.4.0',
  'queueAvailabilityStatus' => '1.3.6.1.4.1.15497.1.1.1.5.0',
  'queueAvailabilityStatusDefinition' => {
    '1' => 'queueSpaceAvailable',
    '2' => 'queueSpaceShortage',
    '3' => 'queueFull',
  },
  'resourceConservationReason' => '1.3.6.1.4.1.15497.1.1.1.6.0',
  'memoryAvailabilityStatus' => '1.3.6.1.4.1.15497.1.1.1.7.0',
  'memoryAvailabilityStatusDefinition' => {
    '1' => 'memoryAvailable',
    '2' => 'memoryShortage',
    '3' => 'memoryFull',
  },
  'powerSupplyTable' => '1.3.6.1.4.1.15497.1.1.1.8',
  'powerSupplyEntry' => '1.3.6.1.4.1.15497.1.1.1.8.1',
  'powerSupplyIndex' => '1.3.6.1.4.1.15497.1.1.1.8.1.1',
  'powerSupplyStatus' => '1.3.6.1.4.1.15497.1.1.1.8.1.2',
  'powerSupplyStatusDefinition' => {
    '1' => 'powerSupplyNotInstalled',
    '2' => 'powerSupplyHealthy',
    '3' => 'powerSupplyNoAC',
    '4' => 'powerSupplyFaulty',
  },
  'powerSupplyRedundancy' => '1.3.6.1.4.1.15497.1.1.1.8.1.3',
  'powerSupplyName' => '1.3.6.1.4.1.15497.1.1.1.8.1.4',
  'temperatureTable' => '1.3.6.1.4.1.15497.1.1.1.9',
  'temperatureEntry' => '1.3.6.1.4.1.15497.1.1.1.9.1',
  'temperatureIndex' => '1.3.6.1.4.1.15497.1.1.1.9.1.1',
  'degreesCelsius' => '1.3.6.1.4.1.15497.1.1.1.9.1.2',
  'temperatureName' => '1.3.6.1.4.1.15497.1.1.1.9.1.3',
  'fanTable' => '1.3.6.1.4.1.15497.1.1.1.10',
  'fanEntry' => '1.3.6.1.4.1.15497.1.1.1.10.1',
  'fanIndex' => '1.3.6.1.4.1.15497.1.1.1.10.1.1',
  'fanRPMs' => '1.3.6.1.4.1.15497.1.1.1.10.1.2',
  'fanName' => '1.3.6.1.4.1.15497.1.1.1.10.1.3',
  'workQueueMessages' => '1.3.6.1.4.1.15497.1.1.1.11.0',
  'keyExpirationTable' => '1.3.6.1.4.1.15497.1.1.1.12',
  'keyExpirationEntry' => '1.3.6.1.4.1.15497.1.1.1.12.1',
  'keyExpirationIndex' => '1.3.6.1.4.1.15497.1.1.1.12.1.1',
  'keyDescription' => '1.3.6.1.4.1.15497.1.1.1.12.1.2',
  'keyIsPerpetual' => '1.3.6.1.4.1.15497.1.1.1.12.1.3',
  'keyIsPerpetualDefinition' => 'SNMPv2-TC-v1-MIB::TruthValue',
  'keySecondsUntilExpire' => '1.3.6.1.4.1.15497.1.1.1.12.1.4',
  'updateTable' => '1.3.6.1.4.1.15497.1.1.1.13',
  'updateEntry' => '1.3.6.1.4.1.15497.1.1.1.13.1',
  'updateIndex' => '1.3.6.1.4.1.15497.1.1.1.13.1.1',
  'updateServiceName' => '1.3.6.1.4.1.15497.1.1.1.13.1.2',
  'updates' => '1.3.6.1.4.1.15497.1.1.1.13.1.3',
  'updateFailures' => '1.3.6.1.4.1.15497.1.1.1.13.1.4',
  'oldestMessageAge' => '1.3.6.1.4.1.15497.1.1.1.14.0',
  'outstandingDNSRequests' => '1.3.6.1.4.1.15497.1.1.1.15.0',
  'pendingDNSRequests' => '1.3.6.1.4.1.15497.1.1.1.16.0',
  'raidEvents' => '1.3.6.1.4.1.15497.1.1.1.17.0',
  'raidTable' => '1.3.6.1.4.1.15497.1.1.1.18',
  'raidEntry' => '1.3.6.1.4.1.15497.1.1.1.18.1',
  'raidIndex' => '1.3.6.1.4.1.15497.1.1.1.18.1.1',
  'raidStatus' => '1.3.6.1.4.1.15497.1.1.1.18.1.2',
  'raidStatusDefinition' => {
    '1' => 'driveHealthy',
    '2' => 'driveFailure',
    '3' => 'driveRebuild',
  },
  'raidID' => '1.3.6.1.4.1.15497.1.1.1.18.1.3',
  'raidLastError' => '1.3.6.1.4.1.15497.1.1.1.18.1.4',
  'openFilesOrSockets' => '1.3.6.1.4.1.15497.1.1.1.19.0',
  'mailTransferThreads' => '1.3.6.1.4.1.15497.1.1.1.20.0',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::ATTACKMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'ATTACK-MIB'} = {
  url => '',
  name => 'ATTACK-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'ATTACK-MIB'} = {
  'deviceAttackTable' => '1.3.6.1.4.1.3417.2.3.1.1.1',
  'deviceAttackEntry' => '1.3.6.1.4.1.3417.2.3.1.1.1.1',
  'deviceAttackIndex' => '1.3.6.1.4.1.3417.2.3.1.1.1.1.1',
  'deviceAttackName' => '1.3.6.1.4.1.3417.2.3.1.1.1.1.2',
  'deviceAttackStatus' => '1.3.6.1.4.1.3417.2.3.1.1.1.1.3',
  'deviceAttackStatusDefinition' => {
    '1' => 'no-attack',
    '2' => 'under-attack',
  },
  'deviceAttackTime' => '1.3.6.1.4.1.3417.2.3.1.1.1.1.4',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::BGP4MIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'BGP4-MIB'} = {
  url => '',
  name => 'BGP4-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'BGP4-MIB'} = {
  'bgpVersion' => '1.3.6.1.2.1.15.1.0',
  'bgpLocalAs' => '1.3.6.1.2.1.15.2.0',
  'bgpPeerTable' => '1.3.6.1.2.1.15.3',
  'bgpPeerEntry' => '1.3.6.1.2.1.15.3.1',
  'bgpPeerIdentifier' => '1.3.6.1.2.1.15.3.1.1',
  'bgpPeerState' => '1.3.6.1.2.1.15.3.1.2',
  'bgpPeerStateDefinition' => {
    '1' => 'idle',
    '2' => 'connect',
    '3' => 'active',
    '4' => 'opensent',
    '5' => 'openconfirm',
    '6' => 'established',
  },
  'bgpPeerAdminStatus' => '1.3.6.1.2.1.15.3.1.3',
  'bgpPeerAdminStatusDefinition' => {
    '1' => 'stop',
    '2' => 'start',
  },
  'bgpPeerNegotiatedVersion' => '1.3.6.1.2.1.15.3.1.4',
  'bgpPeerLocalAddr' => '1.3.6.1.2.1.15.3.1.5',
  'bgpPeerLocalPort' => '1.3.6.1.2.1.15.3.1.6',
  'bgpPeerRemoteAddr' => '1.3.6.1.2.1.15.3.1.7',
  'bgpPeerRemotePort' => '1.3.6.1.2.1.15.3.1.8',
  'bgpPeerRemoteAs' => '1.3.6.1.2.1.15.3.1.9',
  'bgpPeerInUpdates' => '1.3.6.1.2.1.15.3.1.10',
  'bgpPeerOutUpdates' => '1.3.6.1.2.1.15.3.1.11',
  'bgpPeerInTotalMessages' => '1.3.6.1.2.1.15.3.1.12',
  'bgpPeerOutTotalMessages' => '1.3.6.1.2.1.15.3.1.13',
  'bgpPeerLastError' => '1.3.6.1.2.1.15.3.1.14',
  'bgpPeerFsmEstablishedTransitions' => '1.3.6.1.2.1.15.3.1.15',
  'bgpPeerFsmEstablishedTime' => '1.3.6.1.2.1.15.3.1.16',
  'bgpPeerConnectRetryInterval' => '1.3.6.1.2.1.15.3.1.17',
  'bgpPeerHoldTime' => '1.3.6.1.2.1.15.3.1.18',
  'bgpPeerKeepAlive' => '1.3.6.1.2.1.15.3.1.19',
  'bgpPeerHoldTimeConfigured' => '1.3.6.1.2.1.15.3.1.20',
  'bgpPeerKeepAliveConfigured' => '1.3.6.1.2.1.15.3.1.21',
  'bgpPeerMinASOriginationInterval' => '1.3.6.1.2.1.15.3.1.22',
  'bgpPeerMinRouteAdvertisementInterval' => '1.3.6.1.2.1.15.3.1.23',
  'bgpPeerInUpdateElapsedTime' => '1.3.6.1.2.1.15.3.1.24',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::MIBRESOURCE;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'BIANCA-BRICK-MIBRES-MIB'} = {
  url => '',
  name => 'BIANCA-BRICK-MIBRES-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'BIANCA-BRICK-MIBRES-MIB'} =
    '1.3.6.1.4.1.272.4.17.4';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'BIANCA-BRICK-MIBRES-MIB'} = {
  resource => '1.3.6.1.4.1.272.4.17.4.255',
  cpuTable => '1.3.6.1.4.1.272.4.17.4.1',
  cpuEntry => '1.3.6.1.4.1.272.4.17.4.1.1',
  cpuNumber => '1.3.6.1.4.1.272.4.17.4.1.1.1',
  cpuDescr => '1.3.6.1.4.1.272.4.17.4.1.1.2',
  cpuTotalUser => '1.3.6.1.4.1.272.4.17.4.1.1.3',
  cpuTotalSystem => '1.3.6.1.4.1.272.4.17.4.1.1.4',
  cpuTotalStreams => '1.3.6.1.4.1.272.4.17.4.1.1.5',
  cpuTotalIdle => '1.3.6.1.4.1.272.4.17.4.1.1.6',
  cpuLoadUser => '1.3.6.1.4.1.272.4.17.4.1.1.7',
  cpuLoadSystem => '1.3.6.1.4.1.272.4.17.4.1.1.8',
  cpuLoadStreams => '1.3.6.1.4.1.272.4.17.4.1.1.9',
  cpuLoadIdle => '1.3.6.1.4.1.272.4.17.4.1.1.10',
  cpuLoadUser10s => '1.3.6.1.4.1.272.4.17.4.1.1.11',
  cpuLoadSystem10s => '1.3.6.1.4.1.272.4.17.4.1.1.12',
  cpuLoadStreams10s => '1.3.6.1.4.1.272.4.17.4.1.1.13',
  cpuLoadIdle10s => '1.3.6.1.4.1.272.4.17.4.1.1.14',
  cpuLoadUser60s => '1.3.6.1.4.1.272.4.17.4.1.1.15',
  cpuLoadSystem60s => '1.3.6.1.4.1.272.4.17.4.1.1.16',
  cpuLoadStreams60s => '1.3.6.1.4.1.272.4.17.4.1.1.17',
  cpuLoadIdle60s => '1.3.6.1.4.1.272.4.17.4.1.1.18',
  memoryTable => '1.3.6.1.4.1.272.4.17.4.2',
  memoryEntry => '1.3.6.1.4.1.272.4.17.4.2.1',
  memoryType => '1.3.6.1.4.1.272.4.17.4.2.1.1',
  memoryTypeDefinition => 'BIANCA-BRICK-MIBRES-MIB::memoryType',
  memoryDescr => '1.3.6.1.4.1.272.4.17.4.2.1.2',
  memoryBlockSize => '1.3.6.1.4.1.272.4.17.4.2.1.3',
  memoryTotal => '1.3.6.1.4.1.272.4.17.4.2.1.4',
  memoryInuse => '1.3.6.1.4.1.272.4.17.4.2.1.5',
  memoryDramUse => '1.3.6.1.4.1.272.4.17.4.2.1.6',
  memoryNAllocs => '1.3.6.1.4.1.272.4.17.4.2.1.7',
  memoryNFrees => '1.3.6.1.4.1.272.4.17.4.2.1.8',
  memoryNFails => '1.3.6.1.4.1.272.4.17.4.2.1.9',
  dspTable => '1.3.6.1.4.1.272.4.17.4.3',
  dspEntry => '1.3.6.1.4.1.272.4.17.4.3.1',
  dspSlot => '1.3.6.1.4.1.272.4.17.4.3.1.1',
  dspUnit => '1.3.6.1.4.1.272.4.17.4.3.1.2',
  dspDescr => '1.3.6.1.4.1.272.4.17.4.3.1.3',
  dspCapabilities => '1.3.6.1.4.1.272.4.17.4.3.1.4',
  dspTotalChannels => '1.3.6.1.4.1.272.4.17.4.3.1.5',
  dspUsedChannels => '1.3.6.1.4.1.272.4.17.4.3.1.6',
  resourceMIB => '1.3.6.1.4.1.272.4.17.4.255',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'BIANCA-BRICK-MIBRES-MIB'} = {
  memoryType => {
    '1' => 'flash',
    '2' => 'dram',
    '3' => 'dpool',
  },
};

package Monitoring::GLPlugin::SNMP::MibsAndOids::BLUECOATAVMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'BLUECOAT-AV-MIB'} = {
  url => '',
  name => 'BLUECOAT-AV-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'BLUECOAT-AV-MIB'} = {
  'avFilesScanned' => '1.3.6.1.4.1.3417.2.10.1.1.0',
  'avVirusesDetected' => '1.3.6.1.4.1.3417.2.10.1.2.0',
  'avPatternVersion' => '1.3.6.1.4.1.3417.2.10.1.3.0',
  'avPatternDateTime' => '1.3.6.1.4.1.3417.2.10.1.4.0',
  'avEngineVersion' => '1.3.6.1.4.1.3417.2.10.1.5.0',
  'avVendorName' => '1.3.6.1.4.1.3417.2.10.1.6.0',
  'avLicenseDaysRemaining' => '1.3.6.1.4.1.3417.2.10.1.7.0',
  'avPublishedFirmwareVersion' => '1.3.6.1.4.1.3417.2.10.1.8.0',
  'avInstalledFirmwareVersion' => '1.3.6.1.4.1.3417.2.10.1.9.0',
  'avSlowICAPConnections' => '1.3.6.1.4.1.3417.2.10.1.10.0',
  'avUpdateFailureReason' => '1.3.6.1.4.1.3417.2.10.2.1.0',
  'avUrl' => '1.3.6.1.4.1.3417.2.10.2.2.0',
  'avVirusName' => '1.3.6.1.4.1.3417.2.10.2.3.0',
  'avVirusDetails' => '1.3.6.1.4.1.3417.2.10.2.4.0',
  'avErrorCode' => '1.3.6.1.4.1.3417.2.10.2.5.0',
  'avErrorDetails' => '1.3.6.1.4.1.3417.2.10.2.6.0',
  'avPreviousFirmwareVersion' => '1.3.6.1.4.1.3417.2.10.2.7.0',
  'avICTMWarningReason' => '1.3.6.1.4.1.3417.2.10.2.8.0',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::BLUECOATSGPROXYMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'BLUECOAT-SG-PROXY-MIB'} = {
  url => '',
  name => 'BLUECOAT-SG-PROXY-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'BLUECOAT-SG-PROXY-MIB'} = {
  'blueCoatMgmt' => '1.3.6.1.4.1.3417.2',
  'bluecoatSGProxyMIB' => '1.3.6.1.4.1.3417.2.11',
  'sgProxyConfig' => '1.3.6.1.4.1.3417.2.11.1',
  'sgProxySystem' => '1.3.6.1.4.1.3417.2.11.2',
  'sgProxyMemAvailable' => '1.3.6.1.4.1.3417.2.11.2.3.1.0',
  'sgProxyMemCacheUsage' => '1.3.6.1.4.1.3417.2.11.2.3.2.0',
  'sgProxyMemSysUsage' => '1.3.6.1.4.1.3417.2.11.2.3.3.0',
  'sgProxyMemPressure' => '1.3.6.1.4.1.3417.2.11.2.3.4.0',
  'sgProxyCpuCoreTable' => '1.3.6.1.4.1.3417.2.11.2.4',
  'sgProxyCpuCoreEntry' => '1.3.6.1.4.1.3417.2.11.2.4.1',
  'sgProxyCpuCoreIndex' => '1.3.6.1.4.1.3417.2.11.2.4.1.1',
  'sgProxyCpuCoreUpTime' => '1.3.6.1.4.1.3417.2.11.2.4.1.2',
  'sgProxyCpuCoreBusyTime' => '1.3.6.1.4.1.3417.2.11.2.4.1.3',
  'sgProxyCpuCoreIdleTime' => '1.3.6.1.4.1.3417.2.11.2.4.1.4',
  'sgProxyCpuCoreUpTimeSinceLastAccess' => '1.3.6.1.4.1.3417.2.11.2.4.1.5',
  'sgProxyCpuCoreBusyTimeSinceLastAccess' => '1.3.6.1.4.1.3417.2.11.2.4.1.6',
  'sgProxyCpuCoreIdleTimeSinceLastAccess' => '1.3.6.1.4.1.3417.2.11.2.4.1.7',
  'sgProxyCpuCoreBusyPerCent' => '1.3.6.1.4.1.3417.2.11.2.4.1.8',
  'sgProxyCpuCoreIdlePerCent' => '1.3.6.1.4.1.3417.2.11.2.4.1.9',
  'sgProxyHttp' => '1.3.6.1.4.1.3417.2.11.3',
  'sgProxyHttpPerf' => '1.3.6.1.4.1.3417.2.11.3.1',
  'sgProxyHttpClient' => '1.3.6.1.4.1.3417.2.11.3.1.1',
  'sgProxyHttpServer' => '1.3.6.1.4.1.3417.2.11.3.1.2',
  'sgProxyHttpConnections' => '1.3.6.1.4.1.3417.2.11.3.1.3',
  'sgProxyHttpClientConnections' => '1.3.6.1.4.1.3417.2.11.3.1.3.1',
  'sgProxyHttpClientConnectionsActive' => '1.3.6.1.4.1.3417.2.11.3.1.3.2',
  'sgProxyHttpClientConnectionsIdle' => '1.3.6.1.4.1.3417.2.11.3.1.3.3',
  'sgProxyHttpServerConnections' => '1.3.6.1.4.1.3417.2.11.3.1.3.4',
  'sgProxyHttpServerConnectionsActive' => '1.3.6.1.4.1.3417.2.11.3.1.3.5',
  'sgProxyHttpServerConnectionsIdle' => '1.3.6.1.4.1.3417.2.11.3.1.3.6',
  'sgProxyHttpResponse' => '1.3.6.1.4.1.3417.2.11.3.2',
  'sgProxyHttpResponseTime' => '1.3.6.1.4.1.3417.2.11.3.2.1',
  'sgProxyHttpResponseTimeAll' => '1.3.6.1.4.1.3417.2.11.3.2.1.1',
  'sgProxyHttpResponseFirstByte' => '1.3.6.1.4.1.3417.2.11.3.2.1.2',
  'sgProxyHttpResponseByteRate' => '1.3.6.1.4.1.3417.2.11.3.2.1.3',
  'sgProxyHttpResponseSize' => '1.3.6.1.4.1.3417.2.11.3.2.1.4',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::CHECKPOINTMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CHECKPOINT-MIB'} = {
  url => '',
  name => 'CHECKPOINT-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'CHECKPOINT-MIB'} =
    '1.3.6.1.4.1.2620.1';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CHECKPOINT-MIB'} = {
  'checkpoint' => '1.3.6.1.4.1.2620',
  'products' => '1.3.6.1.4.1.2620.1',
  'fw' => '1.3.6.1.4.1.2620.1.1',
  'fwTrapPrefix' => '1.3.6.1.4.1.2620.1.1.0',
  'fwModuleState' => '1.3.6.1.4.1.2620.1.1.1',
  'fwFilterName' => '1.3.6.1.4.1.2620.1.1.2',
  'fwFilterDate' => '1.3.6.1.4.1.2620.1.1.3',
  'fwAccepted' => '1.3.6.1.4.1.2620.1.1.4',
  'fwRejected' => '1.3.6.1.4.1.2620.1.1.5',
  'fwDropped' => '1.3.6.1.4.1.2620.1.1.6',
  'fwLogged' => '1.3.6.1.4.1.2620.1.1.7',
  'fwMajor' => '1.3.6.1.4.1.2620.1.1.8',
  'fwMinor' => '1.3.6.1.4.1.2620.1.1.9',
  'fwProduct' => '1.3.6.1.4.1.2620.1.1.10',
  'fwEvent' => '1.3.6.1.4.1.2620.1.1.11',
  'fwSICTrustState' => '1.3.6.1.4.1.2620.1.1.12',
  'fwProdName' => '1.3.6.1.4.1.2620.1.1.21',
  'fwVerMajor' => '1.3.6.1.4.1.2620.1.1.22',
  'fwVerMinor' => '1.3.6.1.4.1.2620.1.1.23',
  'fwKernelBuild' => '1.3.6.1.4.1.2620.1.1.24',
  'fwPolicyStat' => '1.3.6.1.4.1.2620.1.1.25',
  'fwPolicyName' => '1.3.6.1.4.1.2620.1.1.25.1',
  'fwInstallTime' => '1.3.6.1.4.1.2620.1.1.25.2',
  'fwNumConn' => '1.3.6.1.4.1.2620.1.1.25.3',
  'fwPeakNumConn' => '1.3.6.1.4.1.2620.1.1.25.4',
  'fwIfTable' => '1.3.6.1.4.1.2620.1.1.25.5',
  'fwIfEntry' => '1.3.6.1.4.1.2620.1.1.25.5.1',
  'fwIfIndex' => '1.3.6.1.4.1.2620.1.1.25.5.1.1',
  'fwIfName' => '1.3.6.1.4.1.2620.1.1.25.5.1.2',
  'fwAcceptPcktsIn' => '1.3.6.1.4.1.2620.1.1.25.5.1.5',
  'fwAcceptPcktsOut' => '1.3.6.1.4.1.2620.1.1.25.5.1.6',
  'fwAcceptBytesIn' => '1.3.6.1.4.1.2620.1.1.25.5.1.7',
  'fwAcceptBytesOut' => '1.3.6.1.4.1.2620.1.1.25.5.1.8',
  'fwDropPcktsIn' => '1.3.6.1.4.1.2620.1.1.25.5.1.9',
  'fwDropPcktsOut' => '1.3.6.1.4.1.2620.1.1.25.5.1.10',
  'fwRejectPcktsIn' => '1.3.6.1.4.1.2620.1.1.25.5.1.11',
  'fwRejectPcktsOut' => '1.3.6.1.4.1.2620.1.1.25.5.1.12',
  'fwLogIn' => '1.3.6.1.4.1.2620.1.1.25.5.1.13',
  'fwLogOut' => '1.3.6.1.4.1.2620.1.1.25.5.1.14',
  'fwPacketsRate' => '1.3.6.1.4.1.2620.1.1.25.6',
  'fwAcceptedBytesTotalRate' => '1.3.6.1.4.1.2620.1.1.25.8',
  'fwDroppedBytesTotalRate' => '1.3.6.1.4.1.2620.1.1.25.9',
  'fwConnTableLimit' => '1.3.6.1.4.1.2620.1.1.25.10',
  'fwDroppedTotalRate' => '1.3.6.1.4.1.2620.1.1.25.16',
  'fwPerfStat' => '1.3.6.1.4.1.2620.1.1.26',
  'fwHmem' => '1.3.6.1.4.1.2620.1.1.26.1',
  'fwHmem-block-size' => '1.3.6.1.4.1.2620.1.1.26.1.1',
  'fwHmem-requested-bytes' => '1.3.6.1.4.1.2620.1.1.26.1.2',
  'fwHmem-initial-allocated-bytes' => '1.3.6.1.4.1.2620.1.1.26.1.3',
  'fwHmem-initial-allocated-blocks' => '1.3.6.1.4.1.2620.1.1.26.1.4',
  'fwHmem-initial-allocated-pools' => '1.3.6.1.4.1.2620.1.1.26.1.5',
  'fwHmem-current-allocated-bytes' => '1.3.6.1.4.1.2620.1.1.26.1.6',
  'fwHmem-current-allocated-blocks' => '1.3.6.1.4.1.2620.1.1.26.1.7',
  'fwHmem-current-allocated-pools' => '1.3.6.1.4.1.2620.1.1.26.1.8',
  'fwHmem-maximum-bytes' => '1.3.6.1.4.1.2620.1.1.26.1.9',
  'fwHmem-maximum-pools' => '1.3.6.1.4.1.2620.1.1.26.1.10',
  'fwHmem-bytes-used' => '1.3.6.1.4.1.2620.1.1.26.1.11',
  'fwHmem-blocks-used' => '1.3.6.1.4.1.2620.1.1.26.1.12',
  'fwHmem-bytes-unused' => '1.3.6.1.4.1.2620.1.1.26.1.13',
  'fwHmem-blocks-unused' => '1.3.6.1.4.1.2620.1.1.26.1.14',
  'fwHmem-bytes-peak' => '1.3.6.1.4.1.2620.1.1.26.1.15',
  'fwHmem-blocks-peak' => '1.3.6.1.4.1.2620.1.1.26.1.16',
  'fwHmem-bytes-internal-use' => '1.3.6.1.4.1.2620.1.1.26.1.17',
  'fwHmem-number-of-items' => '1.3.6.1.4.1.2620.1.1.26.1.18',
  'fwHmem-alloc-operations' => '1.3.6.1.4.1.2620.1.1.26.1.19',
  'fwHmem-free-operations' => '1.3.6.1.4.1.2620.1.1.26.1.20',
  'fwHmem-failed-alloc' => '1.3.6.1.4.1.2620.1.1.26.1.21',
  'fwHmem-failed-free' => '1.3.6.1.4.1.2620.1.1.26.1.22',
  'fwKmem' => '1.3.6.1.4.1.2620.1.1.26.2',
  'fwKmem-system-physical-mem' => '1.3.6.1.4.1.2620.1.1.26.2.1',
  'fwKmem-available-physical-mem' => '1.3.6.1.4.1.2620.1.1.26.2.2',
  'fwKmem-aix-heap-size' => '1.3.6.1.4.1.2620.1.1.26.2.3',
  'fwKmem-bytes-used' => '1.3.6.1.4.1.2620.1.1.26.2.4',
  'fwKmem-blocking-bytes-used' => '1.3.6.1.4.1.2620.1.1.26.2.5',
  'fwKmem-non-blocking-bytes-used' => '1.3.6.1.4.1.2620.1.1.26.2.6',
  'fwKmem-bytes-unused' => '1.3.6.1.4.1.2620.1.1.26.2.7',
  'fwKmem-bytes-peak' => '1.3.6.1.4.1.2620.1.1.26.2.8',
  'fwKmem-blocking-bytes-peak' => '1.3.6.1.4.1.2620.1.1.26.2.9',
  'fwKmem-non-blocking-bytes-peak' => '1.3.6.1.4.1.2620.1.1.26.2.10',
  'fwKmem-bytes-internal-use' => '1.3.6.1.4.1.2620.1.1.26.2.11',
  'fwKmem-number-of-items' => '1.3.6.1.4.1.2620.1.1.26.2.12',
  'fwKmem-alloc-operations' => '1.3.6.1.4.1.2620.1.1.26.2.13',
  'fwKmem-free-operations' => '1.3.6.1.4.1.2620.1.1.26.2.14',
  'fwKmem-failed-alloc' => '1.3.6.1.4.1.2620.1.1.26.2.15',
  'fwKmem-failed-free' => '1.3.6.1.4.1.2620.1.1.26.2.16',
  'fwInspect' => '1.3.6.1.4.1.2620.1.1.26.3',
  'fwInspect-packets' => '1.3.6.1.4.1.2620.1.1.26.3.1',
  'fwInspect-operations' => '1.3.6.1.4.1.2620.1.1.26.3.2',
  'fwInspect-lookups' => '1.3.6.1.4.1.2620.1.1.26.3.3',
  'fwInspect-record' => '1.3.6.1.4.1.2620.1.1.26.3.4',
  'fwInspect-extract' => '1.3.6.1.4.1.2620.1.1.26.3.5',
  'fwCookies' => '1.3.6.1.4.1.2620.1.1.26.4',
  'fwCookies-total' => '1.3.6.1.4.1.2620.1.1.26.4.1',
  'fwCookies-allocfwCookies-total' => '1.3.6.1.4.1.2620.1.1.26.4.2',
  'fwCookies-freefwCookies-total' => '1.3.6.1.4.1.2620.1.1.26.4.3',
  'fwCookies-dupfwCookies-total' => '1.3.6.1.4.1.2620.1.1.26.4.4',
  'fwCookies-getfwCookies-total' => '1.3.6.1.4.1.2620.1.1.26.4.5',
  'fwCookies-putfwCookies-total' => '1.3.6.1.4.1.2620.1.1.26.4.6',
  'fwCookies-lenfwCookies-total' => '1.3.6.1.4.1.2620.1.1.26.4.7',
  'fwChains' => '1.3.6.1.4.1.2620.1.1.26.5',
  'fwChains-alloc' => '1.3.6.1.4.1.2620.1.1.26.5.1',
  'fwChains-free' => '1.3.6.1.4.1.2620.1.1.26.5.2',
  'fwFragments' => '1.3.6.1.4.1.2620.1.1.26.6',
  'fwFrag-fragments' => '1.3.6.1.4.1.2620.1.1.26.6.1',
  'fwFrag-expired' => '1.3.6.1.4.1.2620.1.1.26.6.2',
  'fwFrag-packets' => '1.3.6.1.4.1.2620.1.1.26.6.3',
  'fwUfp' => '1.3.6.1.4.1.2620.1.1.26.8',
  'fwUfpHitRatio' => '1.3.6.1.4.1.2620.1.1.26.8.1',
  'fwUfpInspected' => '1.3.6.1.4.1.2620.1.1.26.8.2',
  'fwUfpHits' => '1.3.6.1.4.1.2620.1.1.26.8.3',
  'fwSS' => '1.3.6.1.4.1.2620.1.1.26.9',
  'fwSS-http' => '1.3.6.1.4.1.2620.1.1.26.9.1',
  'fwSS-http-pid' => '1.3.6.1.4.1.2620.1.1.26.9.1.1',
  'fwSS-http-proto' => '1.3.6.1.4.1.2620.1.1.26.9.1.2',
  'fwSS-http-port' => '1.3.6.1.4.1.2620.1.1.26.9.1.3',
  'fwSS-http-logical-port' => '1.3.6.1.4.1.2620.1.1.26.9.1.4',
  'fwSS-http-max-avail-socket' => '1.3.6.1.4.1.2620.1.1.26.9.1.5',
  'fwSS-http-socket-in-use-max' => '1.3.6.1.4.1.2620.1.1.26.9.1.6',
  'fwSS-http-socket-in-use-curr' => '1.3.6.1.4.1.2620.1.1.26.9.1.7',
  'fwSS-http-socket-in-use-count' => '1.3.6.1.4.1.2620.1.1.26.9.1.8',
  'fwSS-http-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.1.9',
  'fwSS-http-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.1.10',
  'fwSS-http-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.1.11',
  'fwSS-http-auth-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.1.12',
  'fwSS-http-auth-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.1.13',
  'fwSS-http-auth-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.1.14',
  'fwSS-http-accepted-sess' => '1.3.6.1.4.1.2620.1.1.26.9.1.15',
  'fwSS-http-rejected-sess' => '1.3.6.1.4.1.2620.1.1.26.9.1.16',
  'fwSS-http-auth-failures' => '1.3.6.1.4.1.2620.1.1.26.9.1.17',
  'fwSS-http-ops-cvp-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.1.18',
  'fwSS-http-ops-cvp-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.1.19',
  'fwSS-http-ops-cvp-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.1.20',
  'fwSS-http-ops-cvp-rej-sess' => '1.3.6.1.4.1.2620.1.1.26.9.1.21',
  'fwSS-http-ssl-encryp-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.1.22',
  'fwSS-http-ssl-encryp-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.1.23',
  'fwSS-http-ssl-encryp-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.1.24',
  'fwSS-http-transp-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.1.25',
  'fwSS-http-transp-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.1.26',
  'fwSS-http-transp-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.1.27',
  'fwSS-http-proxied-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.1.28',
  'fwSS-http-proxied-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.1.29',
  'fwSS-http-proxied-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.1.30',
  'fwSS-http-tunneled-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.1.31',
  'fwSS-http-tunneled-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.1.32',
  'fwSS-http-tunneled-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.1.33',
  'fwSS-http-ftp-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.1.34',
  'fwSS-http-ftp-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.1.35',
  'fwSS-http-ftp-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.1.36',
  'fwSS-http-time-stamp' => '1.3.6.1.4.1.2620.1.1.26.9.1.37',
  'fwSS-http-is-alive' => '1.3.6.1.4.1.2620.1.1.26.9.1.38',
  'fwSS-http-blocked-cnt' => '1.3.6.1.4.1.2620.1.1.26.9.1.39',
  'fwSS-http-blocked-total' => '1.3.6.1.4.1.2620.1.1.26.9.1.40',
  'fwSS-http-scanned-total' => '1.3.6.1.4.1.2620.1.1.26.9.1.41',
  'fwSS-http-blocked-by-file-type' => '1.3.6.1.4.1.2620.1.1.26.9.1.42',
  'fwSS-http-blocked-by-size-limit' => '1.3.6.1.4.1.2620.1.1.26.9.1.43',
  'fwSS-http-blocked-by-archive-limit' => '1.3.6.1.4.1.2620.1.1.26.9.1.44',
  'fwSS-http-blocked-by-internal-error' => '1.3.6.1.4.1.2620.1.1.26.9.1.45',
  'fwSS-http-passed-cnt' => '1.3.6.1.4.1.2620.1.1.26.9.1.46',
  'fwSS-http-passed-by-file-type' => '1.3.6.1.4.1.2620.1.1.26.9.1.47',
  'fwSS-http-passed-by-size-limit' => '1.3.6.1.4.1.2620.1.1.26.9.1.48',
  'fwSS-http-passed-by-archive-limit' => '1.3.6.1.4.1.2620.1.1.26.9.1.49',
  'fwSS-http-passed-by-internal-error' => '1.3.6.1.4.1.2620.1.1.26.9.1.50',
  'fwSS-http-passed-total' => '1.3.6.1.4.1.2620.1.1.26.9.1.51',
  'fwSS-http-blocked-by-AV-settings' => '1.3.6.1.4.1.2620.1.1.26.9.1.52',
  'fwSS-http-passed-by-AV-settings' => '1.3.6.1.4.1.2620.1.1.26.9.1.53',
  'fwSS-http-blocked-by-URL-filter-category' => '1.3.6.1.4.1.2620.1.1.26.9.1.54',
  'fwSS-http-blocked-by-URL-block-list' => '1.3.6.1.4.1.2620.1.1.26.9.1.55',
  'fwSS-http-passed-by-URL-allow-list' => '1.3.6.1.4.1.2620.1.1.26.9.1.56',
  'fwSS-http-passed-by-URL-filter-category' => '1.3.6.1.4.1.2620.1.1.26.9.1.57',
  'fwSS-ftp' => '1.3.6.1.4.1.2620.1.1.26.9.2',
  'fwSS-ftp-pid' => '1.3.6.1.4.1.2620.1.1.26.9.2.1',
  'fwSS-ftp-proto' => '1.3.6.1.4.1.2620.1.1.26.9.2.2',
  'fwSS-ftp-port' => '1.3.6.1.4.1.2620.1.1.26.9.2.3',
  'fwSS-ftp-logical-port' => '1.3.6.1.4.1.2620.1.1.26.9.2.4',
  'fwSS-ftp-max-avail-socket' => '1.3.6.1.4.1.2620.1.1.26.9.2.5',
  'fwSS-ftp-socket-in-use-max' => '1.3.6.1.4.1.2620.1.1.26.9.2.6',
  'fwSS-ftp-socket-in-use-curr' => '1.3.6.1.4.1.2620.1.1.26.9.2.7',
  'fwSS-ftp-socket-in-use-count' => '1.3.6.1.4.1.2620.1.1.26.9.2.8',
  'fwSS-ftp-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.2.9',
  'fwSS-ftp-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.2.10',
  'fwSS-ftp-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.2.11',
  'fwSS-ftp-auth-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.2.12',
  'fwSS-ftp-auth-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.2.13',
  'fwSS-ftp-auth-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.2.14',
  'fwSS-ftp-accepted-sess' => '1.3.6.1.4.1.2620.1.1.26.9.2.15',
  'fwSS-ftp-rejected-sess' => '1.3.6.1.4.1.2620.1.1.26.9.2.16',
  'fwSS-ftp-auth-failures' => '1.3.6.1.4.1.2620.1.1.26.9.2.17',
  'fwSS-ftp-ops-cvp-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.2.18',
  'fwSS-ftp-ops-cvp-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.2.19',
  'fwSS-ftp-ops-cvp-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.2.20',
  'fwSS-ftp-ops-cvp-rej-sess' => '1.3.6.1.4.1.2620.1.1.26.9.2.21',
  'fwSS-ftp-time-stamp' => '1.3.6.1.4.1.2620.1.1.26.9.2.22',
  'fwSS-ftp-is-alive' => '1.3.6.1.4.1.2620.1.1.26.9.2.23',
  'fwSS-ftp-blocked-cnt' => '1.3.6.1.4.1.2620.1.1.26.9.2.24',
  'fwSS-ftp-blocked-total' => '1.3.6.1.4.1.2620.1.1.26.9.2.25',
  'fwSS-ftp-scanned-total' => '1.3.6.1.4.1.2620.1.1.26.9.2.26',
  'fwSS-ftp-blocked-by-file-type' => '1.3.6.1.4.1.2620.1.1.26.9.2.27',
  'fwSS-ftp-blocked-by-size-limit' => '1.3.6.1.4.1.2620.1.1.26.9.2.28',
  'fwSS-ftp-blocked-by-archive-limit' => '1.3.6.1.4.1.2620.1.1.26.9.2.29',
  'fwSS-ftp-blocked-by-internal-error' => '1.3.6.1.4.1.2620.1.1.26.9.2.30',
  'fwSS-ftp-passed-cnt' => '1.3.6.1.4.1.2620.1.1.26.9.2.31',
  'fwSS-ftp-passed-by-file-type' => '1.3.6.1.4.1.2620.1.1.26.9.2.32',
  'fwSS-ftp-passed-by-size-limit' => '1.3.6.1.4.1.2620.1.1.26.9.2.33',
  'fwSS-ftp-passed-by-archive-limit' => '1.3.6.1.4.1.2620.1.1.26.9.2.34',
  'fwSS-ftp-passed-by-internal-error' => '1.3.6.1.4.1.2620.1.1.26.9.2.35',
  'fwSS-ftp-passed-total' => '1.3.6.1.4.1.2620.1.1.26.9.2.36',
  'fwSS-ftp-blocked-by-AV-settings' => '1.3.6.1.4.1.2620.1.1.26.9.2.37',
  'fwSS-ftp-passed-by-AV-settings' => '1.3.6.1.4.1.2620.1.1.26.9.2.38',
  'fwSS-telnet' => '1.3.6.1.4.1.2620.1.1.26.9.3',
  'fwSS-telnet-pid' => '1.3.6.1.4.1.2620.1.1.26.9.3.1',
  'fwSS-telnet-proto' => '1.3.6.1.4.1.2620.1.1.26.9.3.2',
  'fwSS-telnet-port' => '1.3.6.1.4.1.2620.1.1.26.9.3.3',
  'fwSS-telnet-logical-port' => '1.3.6.1.4.1.2620.1.1.26.9.3.4',
  'fwSS-telnet-max-avail-socket' => '1.3.6.1.4.1.2620.1.1.26.9.3.5',
  'fwSS-telnet-socket-in-use-max' => '1.3.6.1.4.1.2620.1.1.26.9.3.6',
  'fwSS-telnet-socket-in-use-curr' => '1.3.6.1.4.1.2620.1.1.26.9.3.7',
  'fwSS-telnet-socket-in-use-count' => '1.3.6.1.4.1.2620.1.1.26.9.3.8',
  'fwSS-telnet-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.3.9',
  'fwSS-telnet-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.3.10',
  'fwSS-telnet-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.3.11',
  'fwSS-telnet-auth-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.3.12',
  'fwSS-telnet-auth-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.3.13',
  'fwSS-telnet-auth-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.3.14',
  'fwSS-telnet-accepted-sess' => '1.3.6.1.4.1.2620.1.1.26.9.3.15',
  'fwSS-telnet-rejected-sess' => '1.3.6.1.4.1.2620.1.1.26.9.3.16',
  'fwSS-telnet-auth-failures' => '1.3.6.1.4.1.2620.1.1.26.9.3.17',
  'fwSS-telnet-time-stamp' => '1.3.6.1.4.1.2620.1.1.26.9.3.18',
  'fwSS-telnet-is-alive' => '1.3.6.1.4.1.2620.1.1.26.9.3.19',
  'fwSS-rlogin' => '1.3.6.1.4.1.2620.1.1.26.9.4',
  'fwSS-rlogin-pid' => '1.3.6.1.4.1.2620.1.1.26.9.4.1',
  'fwSS-rlogin-proto' => '1.3.6.1.4.1.2620.1.1.26.9.4.2',
  'fwSS-rlogin-port' => '1.3.6.1.4.1.2620.1.1.26.9.4.3',
  'fwSS-rlogin-logical-port' => '1.3.6.1.4.1.2620.1.1.26.9.4.4',
  'fwSS-rlogin-max-avail-socket' => '1.3.6.1.4.1.2620.1.1.26.9.4.5',
  'fwSS-rlogin-socket-in-use-max' => '1.3.6.1.4.1.2620.1.1.26.9.4.6',
  'fwSS-rlogin-socket-in-use-curr' => '1.3.6.1.4.1.2620.1.1.26.9.4.7',
  'fwSS-rlogin-socket-in-use-count' => '1.3.6.1.4.1.2620.1.1.26.9.4.8',
  'fwSS-rlogin-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.4.9',
  'fwSS-rlogin-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.4.10',
  'fwSS-rlogin-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.4.11',
  'fwSS-rlogin-auth-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.4.12',
  'fwSS-rlogin-auth-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.4.13',
  'fwSS-rlogin-auth-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.4.14',
  'fwSS-rlogin-accepted-sess' => '1.3.6.1.4.1.2620.1.1.26.9.4.15',
  'fwSS-rlogin-rejected-sess' => '1.3.6.1.4.1.2620.1.1.26.9.4.16',
  'fwSS-rlogin-auth-failures' => '1.3.6.1.4.1.2620.1.1.26.9.4.17',
  'fwSS-rlogin-time-stamp' => '1.3.6.1.4.1.2620.1.1.26.9.4.18',
  'fwSS-rlogin-is-alive' => '1.3.6.1.4.1.2620.1.1.26.9.4.19',
  'fwSS-ufp' => '1.3.6.1.4.1.2620.1.1.26.9.5',
  'fwSS-ufp-ops-ufp-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.5.1',
  'fwSS-ufp-ops-ufp-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.5.2',
  'fwSS-ufp-ops-ufp-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.5.3',
  'fwSS-ufp-ops-ufp-rej-sess' => '1.3.6.1.4.1.2620.1.1.26.9.5.4',
  'fwSS-ufp-time-stamp' => '1.3.6.1.4.1.2620.1.1.26.9.5.5',
  'fwSS-ufp-is-alive' => '1.3.6.1.4.1.2620.1.1.26.9.5.6',
  'fwSS-smtp' => '1.3.6.1.4.1.2620.1.1.26.9.6',
  'fwSS-smtp-pid' => '1.3.6.1.4.1.2620.1.1.26.9.6.1',
  'fwSS-smtp-proto' => '1.3.6.1.4.1.2620.1.1.26.9.6.2',
  'fwSS-smtp-port' => '1.3.6.1.4.1.2620.1.1.26.9.6.3',
  'fwSS-smtp-logical-port' => '1.3.6.1.4.1.2620.1.1.26.9.6.4',
  'fwSS-smtp-max-avail-socket' => '1.3.6.1.4.1.2620.1.1.26.9.6.5',
  'fwSS-smtp-socket-in-use-max' => '1.3.6.1.4.1.2620.1.1.26.9.6.6',
  'fwSS-smtp-socket-in-use-curr' => '1.3.6.1.4.1.2620.1.1.26.9.6.7',
  'fwSS-smtp-socket-in-use-count' => '1.3.6.1.4.1.2620.1.1.26.9.6.8',
  'fwSS-smtp-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.6.9',
  'fwSS-smtp-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.6.10',
  'fwSS-smtp-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.6.11',
  'fwSS-smtp-auth-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.6.12',
  'fwSS-smtp-auth-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.6.13',
  'fwSS-smtp-auth-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.6.14',
  'fwSS-smtp-accepted-sess' => '1.3.6.1.4.1.2620.1.1.26.9.6.15',
  'fwSS-smtp-rejected-sess' => '1.3.6.1.4.1.2620.1.1.26.9.6.16',
  'fwSS-smtp-auth-failures' => '1.3.6.1.4.1.2620.1.1.26.9.6.17',
  'fwSS-smtp-mail-max' => '1.3.6.1.4.1.2620.1.1.26.9.6.18',
  'fwSS-smtp-mail-curr' => '1.3.6.1.4.1.2620.1.1.26.9.6.19',
  'fwSS-smtp-mail-count' => '1.3.6.1.4.1.2620.1.1.26.9.6.20',
  'fwSS-smtp-outgoing-mail-max' => '1.3.6.1.4.1.2620.1.1.26.9.6.21',
  'fwSS-smtp-outgoing-mail-curr' => '1.3.6.1.4.1.2620.1.1.26.9.6.22',
  'fwSS-smtp-outgoing-mail-count' => '1.3.6.1.4.1.2620.1.1.26.9.6.23',
  'fwSS-smtp-max-mail-on-conn' => '1.3.6.1.4.1.2620.1.1.26.9.6.24',
  'fwSS-smtp-total-mails' => '1.3.6.1.4.1.2620.1.1.26.9.6.25',
  'fwSS-smtp-time-stamp' => '1.3.6.1.4.1.2620.1.1.26.9.6.26',
  'fwSS-smtp-is-alive' => '1.3.6.1.4.1.2620.1.1.26.9.6.27',
  'fwSS-smtp-blocked-cnt' => '1.3.6.1.4.1.2620.1.1.26.9.6.28',
  'fwSS-smtp-blocked-total' => '1.3.6.1.4.1.2620.1.1.26.9.6.29',
  'fwSS-smtp-scanned-total' => '1.3.6.1.4.1.2620.1.1.26.9.6.30',
  'fwSS-smtp-blocked-by-file-type' => '1.3.6.1.4.1.2620.1.1.26.9.6.31',
  'fwSS-smtp-blocked-by-size-limit' => '1.3.6.1.4.1.2620.1.1.26.9.6.32',
  'fwSS-smtp-blocked-by-archive-limit' => '1.3.6.1.4.1.2620.1.1.26.9.6.33',
  'fwSS-smtp-blocked-by-internal-error' => '1.3.6.1.4.1.2620.1.1.26.9.6.34',
  'fwSS-smtp-passed-cnt' => '1.3.6.1.4.1.2620.1.1.26.9.6.35',
  'fwSS-smtp-passed-by-file-type' => '1.3.6.1.4.1.2620.1.1.26.9.6.36',
  'fwSS-smtp-passed-by-size-limit' => '1.3.6.1.4.1.2620.1.1.26.9.6.37',
  'fwSS-smtp-passed-by-archive-limit' => '1.3.6.1.4.1.2620.1.1.26.9.6.38',
  'fwSS-smtp-passed-by-internal-error' => '1.3.6.1.4.1.2620.1.1.26.9.6.39',
  'fwSS-smtp-passed-total' => '1.3.6.1.4.1.2620.1.1.26.9.6.40',
  'fwSS-smtp-blocked-by-AV-settings' => '1.3.6.1.4.1.2620.1.1.26.9.6.41',
  'fwSS-smtp-passed-by-AV-settings' => '1.3.6.1.4.1.2620.1.1.26.9.6.42',
  'fwSS-POP3' => '1.3.6.1.4.1.2620.1.1.26.9.7',
  'fwSS-POP3-pid' => '1.3.6.1.4.1.2620.1.1.26.9.7.1',
  'fwSS-POP3-proto' => '1.3.6.1.4.1.2620.1.1.26.9.7.2',
  'fwSS-POP3-port' => '1.3.6.1.4.1.2620.1.1.26.9.7.3',
  'fwSS-POP3-logical-port' => '1.3.6.1.4.1.2620.1.1.26.9.7.4',
  'fwSS-POP3-max-avail-socket' => '1.3.6.1.4.1.2620.1.1.26.9.7.5',
  'fwSS-POP3-socket-in-use-max' => '1.3.6.1.4.1.2620.1.1.26.9.7.6',
  'fwSS-POP3-socket-in-use-curr' => '1.3.6.1.4.1.2620.1.1.26.9.7.7',
  'fwSS-POP3-socket-in-use-count' => '1.3.6.1.4.1.2620.1.1.26.9.7.8',
  'fwSS-POP3-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.7.9',
  'fwSS-POP3-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.7.10',
  'fwSS-POP3-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.7.11',
  'fwSS-POP3-auth-sess-max' => '1.3.6.1.4.1.2620.1.1.26.9.7.12',
  'fwSS-POP3-auth-sess-curr' => '1.3.6.1.4.1.2620.1.1.26.9.7.13',
  'fwSS-POP3-auth-sess-count' => '1.3.6.1.4.1.2620.1.1.26.9.7.14',
  'fwSS-POP3-accepted-sess' => '1.3.6.1.4.1.2620.1.1.26.9.7.15',
  'fwSS-POP3-rejected-sess' => '1.3.6.1.4.1.2620.1.1.26.9.7.16',
  'fwSS-POP3-auth-failures' => '1.3.6.1.4.1.2620.1.1.26.9.7.17',
  'fwSS-POP3-mail-max' => '1.3.6.1.4.1.2620.1.1.26.9.7.18',
  'fwSS-POP3-mail-curr' => '1.3.6.1.4.1.2620.1.1.26.9.7.19',
  'fwSS-POP3-mail-count' => '1.3.6.1.4.1.2620.1.1.26.9.7.20',
  'fwSS-POP3-outgoing-mail-max' => '1.3.6.1.4.1.2620.1.1.26.9.7.21',
  'fwSS-POP3-outgoing-mail-curr' => '1.3.6.1.4.1.2620.1.1.26.9.7.22',
  'fwSS-POP3-outgoing-mail-count' => '1.3.6.1.4.1.2620.1.1.26.9.7.23',
  'fwSS-POP3-max-mail-on-conn' => '1.3.6.1.4.1.2620.1.1.26.9.7.24',
  'fwSS-POP3-total-mails' => '1.3.6.1.4.1.2620.1.1.26.9.7.25',
  'fwSS-POP3-time-stamp' => '1.3.6.1.4.1.2620.1.1.26.9.7.26',
  'fwSS-POP3-is-alive' => '1.3.6.1.4.1.2620.1.1.26.9.7.27',
  'fwSS-POP3-blocked-cnt' => '1.3.6.1.4.1.2620.1.1.26.9.7.28',
  'fwSS-POP3-blocked-total' => '1.3.6.1.4.1.2620.1.1.26.9.7.29',
  'fwSS-POP3-scanned-total' => '1.3.6.1.4.1.2620.1.1.26.9.7.30',
  'fwSS-POP3-blocked-by-file-type' => '1.3.6.1.4.1.2620.1.1.26.9.7.31',
  'fwSS-POP3-blocked-by-size-limit' => '1.3.6.1.4.1.2620.1.1.26.9.7.32',
  'fwSS-POP3-blocked-by-archive-limit' => '1.3.6.1.4.1.2620.1.1.26.9.7.33',
  'fwSS-POP3-blocked-by-internal-error' => '1.3.6.1.4.1.2620.1.1.26.9.7.34',
  'fwSS-POP3-passed-cnt' => '1.3.6.1.4.1.2620.1.1.26.9.7.35',
  'fwSS-POP3-passed-by-file-type' => '1.3.6.1.4.1.2620.1.1.26.9.7.36',
  'fwSS-POP3-passed-by-size-limit' => '1.3.6.1.4.1.2620.1.1.26.9.7.37',
  'fwSS-POP3-passed-by-archive-limit' => '1.3.6.1.4.1.2620.1.1.26.9.7.38',
  'fwSS-POP3-passed-by-internal-error' => '1.3.6.1.4.1.2620.1.1.26.9.7.39',
  'fwSS-POP3-passed-total' => '1.3.6.1.4.1.2620.1.1.26.9.7.40',
  'fwSS-POP3-blocked-by-AV-settings' => '1.3.6.1.4.1.2620.1.1.26.9.7.41',
  'fwSS-POP3-passed-by-AV-settings' => '1.3.6.1.4.1.2620.1.1.26.9.7.42',
  'fwSS-av-total' => '1.3.6.1.4.1.2620.1.1.26.9.10',
  'fwSS-total-blocked-by-av' => '1.3.6.1.4.1.2620.1.1.26.9.10.1',
  'fwSS-total-blocked' => '1.3.6.1.4.1.2620.1.1.26.9.10.2',
  'fwSS-total-scanned' => '1.3.6.1.4.1.2620.1.1.26.9.10.3',
  'fwSS-total-blocked-by-file-type' => '1.3.6.1.4.1.2620.1.1.26.9.10.4',
  'fwSS-total-blocked-by-size-limit' => '1.3.6.1.4.1.2620.1.1.26.9.10.5',
  'fwSS-total-blocked-by-archive-limit' => '1.3.6.1.4.1.2620.1.1.26.9.10.6',
  'fwSS-total-blocked-by-interal-error' => '1.3.6.1.4.1.2620.1.1.26.9.10.7',
  'fwSS-total-passed-by-av' => '1.3.6.1.4.1.2620.1.1.26.9.10.8',
  'fwSS-total-passed-by-file-type' => '1.3.6.1.4.1.2620.1.1.26.9.10.9',
  'fwSS-total-passed-by-size-limit' => '1.3.6.1.4.1.2620.1.1.26.9.10.10',
  'fwSS-total-passed-by-archive-limit' => '1.3.6.1.4.1.2620.1.1.26.9.10.11',
  'fwSS-total-passed-by-interal-error' => '1.3.6.1.4.1.2620.1.1.26.9.10.12',
  'fwSS-total-passed' => '1.3.6.1.4.1.2620.1.1.26.9.10.13',
  'fwSS-total-blocked-by-av-settings' => '1.3.6.1.4.1.2620.1.1.26.9.10.14',
  'fwSS-total-passed-by-av-settings' => '1.3.6.1.4.1.2620.1.1.26.9.10.15',
  'fwConnectionsStat' => '1.3.6.1.4.1.2620.1.1.26.11',
  'fwConnectionsStatConnectionsTcp' => '1.3.6.1.4.1.2620.1.1.26.11.1',
  'fwConnectionsStatConnectionsUdp' => '1.3.6.1.4.1.2620.1.1.26.11.2',
  'fwConnectionsStatConnectionsIcmp' => '1.3.6.1.4.1.2620.1.1.26.11.3',
  'fwConnectionsStatConnectionsOther' => '1.3.6.1.4.1.2620.1.1.26.11.4',
  'fwConnectionsStatConnections' => '1.3.6.1.4.1.2620.1.1.26.11.5',
  'fwConnectionsStatConnectionRate' => '1.3.6.1.4.1.2620.1.1.26.11.6',
  'fwHmem64' => '1.3.6.1.4.1.2620.1.1.26.12',
  'fwHmem64-block-size' => '1.3.6.1.4.1.2620.1.1.26.12.1',
  'fwHmem64-requested-bytes' => '1.3.6.1.4.1.2620.1.1.26.12.2',
  'fwHmem64-initial-allocated-bytes' => '1.3.6.1.4.1.2620.1.1.26.12.3',
  'fwHmem64-initial-allocated-blocks' => '1.3.6.1.4.1.2620.1.1.26.12.4',
  'fwHmem64-initial-allocated-pools' => '1.3.6.1.4.1.2620.1.1.26.12.5',
  'fwHmem64-current-allocated-bytes' => '1.3.6.1.4.1.2620.1.1.26.12.6',
  'fwHmem64-current-allocated-blocks' => '1.3.6.1.4.1.2620.1.1.26.12.7',
  'fwHmem64-current-allocated-pools' => '1.3.6.1.4.1.2620.1.1.26.12.8',
  'fwHmem64-maximum-bytes' => '1.3.6.1.4.1.2620.1.1.26.12.9',
  'fwHmem64-maximum-pools' => '1.3.6.1.4.1.2620.1.1.26.12.10',
  'fwHmem64-bytes-used' => '1.3.6.1.4.1.2620.1.1.26.12.11',
  'fwHmem64-blocks-used' => '1.3.6.1.4.1.2620.1.1.26.12.12',
  'fwHmem64-bytes-unused' => '1.3.6.1.4.1.2620.1.1.26.12.13',
  'fwHmem64-blocks-unused' => '1.3.6.1.4.1.2620.1.1.26.12.14',
  'fwHmem64-bytes-peak' => '1.3.6.1.4.1.2620.1.1.26.12.15',
  'fwHmem64-blocks-peak' => '1.3.6.1.4.1.2620.1.1.26.12.16',
  'fwHmem64-bytes-internal-use' => '1.3.6.1.4.1.2620.1.1.26.12.17',
  'fwHmem64-number-of-items' => '1.3.6.1.4.1.2620.1.1.26.12.18',
  'fwHmem64-alloc-operations' => '1.3.6.1.4.1.2620.1.1.26.12.19',
  'fwHmem64-free-operations' => '1.3.6.1.4.1.2620.1.1.26.12.20',
  'fwHmem64-failed-alloc' => '1.3.6.1.4.1.2620.1.1.26.12.21',
  'fwHmem64-failed-free' => '1.3.6.1.4.1.2620.1.1.26.12.22',
  'fwNetIfTable' => '1.3.6.1.4.1.2620.1.1.27',
  'fwNetIfEntry' => '1.3.6.1.4.1.2620.1.1.27.1',
  'fwNetIfIndex' => '1.3.6.1.4.1.2620.1.1.27.1.1',
  'fwNetIfName' => '1.3.6.1.4.1.2620.1.1.27.1.2',
  'fwNetIfIPAddr' => '1.3.6.1.4.1.2620.1.1.27.1.3',
  'fwNetIfNetmask' => '1.3.6.1.4.1.2620.1.1.27.1.4',
  'fwNetIfFlags' => '1.3.6.1.4.1.2620.1.1.27.1.5',
  'fwNetIfPeerName' => '1.3.6.1.4.1.2620.1.1.27.1.6',
  'fwNetIfRemoteIp' => '1.3.6.1.4.1.2620.1.1.27.1.7',
  'fwNetIfTopology' => '1.3.6.1.4.1.2620.1.1.27.1.8',
  'fwNetIfProxyName' => '1.3.6.1.4.1.2620.1.1.27.1.9',
  'fwNetIfSlaves' => '1.3.6.1.4.1.2620.1.1.27.1.10',
  'fwNetIfPorts' => '1.3.6.1.4.1.2620.1.1.27.1.11',
  'fwNetIfIPV6Addr' => '1.3.6.1.4.1.2620.1.1.27.1.12',
  'fwNetIfIPV6AddrLen' => '1.3.6.1.4.1.2620.1.1.27.1.13',
  'fwLSConn' => '1.3.6.1.4.1.2620.1.1.30',
  'fwLSConnOverall' => '1.3.6.1.4.1.2620.1.1.30.1',
  'fwLSConnOverallDesc' => '1.3.6.1.4.1.2620.1.1.30.2',
  'fwLSConnTable' => '1.3.6.1.4.1.2620.1.1.30.3',
  'fwLSConnEntry' => '1.3.6.1.4.1.2620.1.1.30.3.1',
  'fwLSConnIndex' => '1.3.6.1.4.1.2620.1.1.30.3.1.1',
  'fwLSConnName' => '1.3.6.1.4.1.2620.1.1.30.3.1.2',
  'fwLSConnState' => '1.3.6.1.4.1.2620.1.1.30.3.1.3',
  'fwLSConnStateDesc' => '1.3.6.1.4.1.2620.1.1.30.3.1.4',
  'fwLSConnSendRate' => '1.3.6.1.4.1.2620.1.1.30.3.1.5',
  'fwLocalLoggingDesc' => '1.3.6.1.4.1.2620.1.1.30.4',
  'fwLocalLoggingStat' => '1.3.6.1.4.1.2620.1.1.30.5',
  'fwLocalLoggingWriteRate' => '1.3.6.1.4.1.2620.1.1.30.6',
  'fwLoggingHandlingRate' => '1.3.6.1.4.1.2620.1.1.30.7',
  'vpn' => '1.3.6.1.4.1.2620.1.2',
  'cpvProdName' => '1.3.6.1.4.1.2620.1.2.1',
  'cpvVerMajor' => '1.3.6.1.4.1.2620.1.2.2',
  'cpvVerMinor' => '1.3.6.1.4.1.2620.1.2.3',
  'cpvGeneral' => '1.3.6.1.4.1.2620.1.2.4',
  'cpvStatistics' => '1.3.6.1.4.1.2620.1.2.4.1',
  'cpvEncPackets' => '1.3.6.1.4.1.2620.1.2.4.1.1',
  'cpvDecPackets' => '1.3.6.1.4.1.2620.1.2.4.1.2',
  'cpvErrors' => '1.3.6.1.4.1.2620.1.2.4.2',
  'cpvErrOut' => '1.3.6.1.4.1.2620.1.2.4.2.1',
  'cpvErrIn' => '1.3.6.1.4.1.2620.1.2.4.2.2',
  'cpvErrIke' => '1.3.6.1.4.1.2620.1.2.4.2.3',
  'cpvErrPolicy' => '1.3.6.1.4.1.2620.1.2.4.2.4',
  'cpvIpsec' => '1.3.6.1.4.1.2620.1.2.5',
  'cpvSaStatistics' => '1.3.6.1.4.1.2620.1.2.5.2',
  'cpvCurrEspSAsIn' => '1.3.6.1.4.1.2620.1.2.5.2.1',
  'cpvTotalEspSAsIn' => '1.3.6.1.4.1.2620.1.2.5.2.2',
  'cpvCurrEspSAsOut' => '1.3.6.1.4.1.2620.1.2.5.2.3',
  'cpvTotalEspSAsOut' => '1.3.6.1.4.1.2620.1.2.5.2.4',
  'cpvCurrAhSAsIn' => '1.3.6.1.4.1.2620.1.2.5.2.5',
  'cpvTotalAhSAsIn' => '1.3.6.1.4.1.2620.1.2.5.2.6',
  'cpvCurrAhSAsOut' => '1.3.6.1.4.1.2620.1.2.5.2.7',
  'cpvTotalAhSAsOut' => '1.3.6.1.4.1.2620.1.2.5.2.8',
  'cpvMaxConncurEspSAsIn' => '1.3.6.1.4.1.2620.1.2.5.2.9',
  'cpvMaxConncurEspSAsOut' => '1.3.6.1.4.1.2620.1.2.5.2.10',
  'cpvMaxConncurAhSAsIn' => '1.3.6.1.4.1.2620.1.2.5.2.11',
  'cpvMaxConncurAhSAsOut' => '1.3.6.1.4.1.2620.1.2.5.2.12',
  'cpvSaErrors' => '1.3.6.1.4.1.2620.1.2.5.3',
  'cpvSaDecrErr' => '1.3.6.1.4.1.2620.1.2.5.3.1',
  'cpvSaAuthErr' => '1.3.6.1.4.1.2620.1.2.5.3.2',
  'cpvSaReplayErr' => '1.3.6.1.4.1.2620.1.2.5.3.3',
  'cpvSaPolicyErr' => '1.3.6.1.4.1.2620.1.2.5.3.4',
  'cpvSaOtherErrIn' => '1.3.6.1.4.1.2620.1.2.5.3.5',
  'cpvSaOtherErrOut' => '1.3.6.1.4.1.2620.1.2.5.3.6',
  'cpvSaUnknownSpiErr' => '1.3.6.1.4.1.2620.1.2.5.3.7',
  'cpvIpsecStatistics' => '1.3.6.1.4.1.2620.1.2.5.4',
  'cpvIpsecUdpEspEncPkts' => '1.3.6.1.4.1.2620.1.2.5.4.1',
  'cpvIpsecUdpEspDecPkts' => '1.3.6.1.4.1.2620.1.2.5.4.2',
  'cpvIpsecAhEncPkts' => '1.3.6.1.4.1.2620.1.2.5.4.3',
  'cpvIpsecAhDecPkts' => '1.3.6.1.4.1.2620.1.2.5.4.4',
  'cpvIpsecEspEncPkts' => '1.3.6.1.4.1.2620.1.2.5.4.5',
  'cpvIpsecEspDecPkts' => '1.3.6.1.4.1.2620.1.2.5.4.6',
  'cpvIpsecDecomprBytesBefore' => '1.3.6.1.4.1.2620.1.2.5.4.7',
  'cpvIpsecDecomprBytesAfter' => '1.3.6.1.4.1.2620.1.2.5.4.8',
  'cpvIpsecDecomprOverhead' => '1.3.6.1.4.1.2620.1.2.5.4.9',
  'cpvIpsecDecomprPkts' => '1.3.6.1.4.1.2620.1.2.5.4.10',
  'cpvIpsecDecomprErr' => '1.3.6.1.4.1.2620.1.2.5.4.11',
  'cpvIpsecComprBytesBefore' => '1.3.6.1.4.1.2620.1.2.5.4.12',
  'cpvIpsecComprBytesAfter' => '1.3.6.1.4.1.2620.1.2.5.4.13',
  'cpvIpsecComprOverhead' => '1.3.6.1.4.1.2620.1.2.5.4.14',
  'cpvIpsecNonCompressibleBytes' => '1.3.6.1.4.1.2620.1.2.5.4.15',
  'cpvIpsecCompressiblePkts' => '1.3.6.1.4.1.2620.1.2.5.4.16',
  'cpvIpsecNonCompressiblePkts' => '1.3.6.1.4.1.2620.1.2.5.4.17',
  'cpvIpsecComprErrors' => '1.3.6.1.4.1.2620.1.2.5.4.18',
  'cpvIpsecEspEncBytes' => '1.3.6.1.4.1.2620.1.2.5.4.19',
  'cpvIpsecEspDecBytes' => '1.3.6.1.4.1.2620.1.2.5.4.20',
  'cpvFwz' => '1.3.6.1.4.1.2620.1.2.6',
  'cpvFwzStatistics' => '1.3.6.1.4.1.2620.1.2.6.1',
  'cpvFwzEncapsEncPkts' => '1.3.6.1.4.1.2620.1.2.6.1.1',
  'cpvFwzEncapsDecPkts' => '1.3.6.1.4.1.2620.1.2.6.1.2',
  'cpvFwzEncPkts' => '1.3.6.1.4.1.2620.1.2.6.1.3',
  'cpvFwzDecPkts' => '1.3.6.1.4.1.2620.1.2.6.1.4',
  'cpvFwzErrors' => '1.3.6.1.4.1.2620.1.2.6.2',
  'cpvFwzEncapsEncErrs' => '1.3.6.1.4.1.2620.1.2.6.2.1',
  'cpvFwzEncapsDecErrs' => '1.3.6.1.4.1.2620.1.2.6.2.2',
  'cpvFwzEncErrs' => '1.3.6.1.4.1.2620.1.2.6.2.3',
  'cpvFwzDecErrs' => '1.3.6.1.4.1.2620.1.2.6.2.4',
  'cpvAccelerator' => '1.3.6.1.4.1.2620.1.2.8',
  'cpvHwAccelGeneral' => '1.3.6.1.4.1.2620.1.2.8.1',
  'cpvHwAccelVendor' => '1.3.6.1.4.1.2620.1.2.8.1.1',
  'cpvHwAccelStatus' => '1.3.6.1.4.1.2620.1.2.8.1.2',
  'cpvHwAccelDriverMajorVer' => '1.3.6.1.4.1.2620.1.2.8.1.3',
  'cpvHwAccelDriverMinorVer' => '1.3.6.1.4.1.2620.1.2.8.1.4',
  'cpvHwAccelStatistics' => '1.3.6.1.4.1.2620.1.2.8.2',
  'cpvHwAccelEspEncPkts' => '1.3.6.1.4.1.2620.1.2.8.2.1',
  'cpvHwAccelEspDecPkts' => '1.3.6.1.4.1.2620.1.2.8.2.2',
  'cpvHwAccelEspEncBytes' => '1.3.6.1.4.1.2620.1.2.8.2.3',
  'cpvHwAccelEspDecBytes' => '1.3.6.1.4.1.2620.1.2.8.2.4',
  'cpvHwAccelAhEncPkts' => '1.3.6.1.4.1.2620.1.2.8.2.5',
  'cpvHwAccelAhDecPkts' => '1.3.6.1.4.1.2620.1.2.8.2.6',
  'cpvHwAccelAhEncBytes' => '1.3.6.1.4.1.2620.1.2.8.2.7',
  'cpvHwAccelAhDecBytes' => '1.3.6.1.4.1.2620.1.2.8.2.8',
  'cpvIKE' => '1.3.6.1.4.1.2620.1.2.9',
  'cpvIKEglobals' => '1.3.6.1.4.1.2620.1.2.9.1',
  'cpvIKECurrSAs' => '1.3.6.1.4.1.2620.1.2.9.1.1',
  'cpvIKECurrInitSAs' => '1.3.6.1.4.1.2620.1.2.9.1.2',
  'cpvIKECurrRespSAs' => '1.3.6.1.4.1.2620.1.2.9.1.3',
  'cpvIKETotalSAs' => '1.3.6.1.4.1.2620.1.2.9.1.4',
  'cpvIKETotalInitSAs' => '1.3.6.1.4.1.2620.1.2.9.1.5',
  'cpvIKETotalRespSAs' => '1.3.6.1.4.1.2620.1.2.9.1.6',
  'cpvIKETotalSAsAttempts' => '1.3.6.1.4.1.2620.1.2.9.1.7',
  'cpvIKETotalSAsInitAttempts' => '1.3.6.1.4.1.2620.1.2.9.1.8',
  'cpvIKETotalSAsRespAttempts' => '1.3.6.1.4.1.2620.1.2.9.1.9',
  'cpvIKEMaxConncurSAs' => '1.3.6.1.4.1.2620.1.2.9.1.10',
  'cpvIKEMaxConncurInitSAs' => '1.3.6.1.4.1.2620.1.2.9.1.11',
  'cpvIKEMaxConncurRespSAs' => '1.3.6.1.4.1.2620.1.2.9.1.12',
  'cpvIKEerrors' => '1.3.6.1.4.1.2620.1.2.9.2',
  'cpvIKETotalFailuresInit' => '1.3.6.1.4.1.2620.1.2.9.2.1',
  'cpvIKENoResp' => '1.3.6.1.4.1.2620.1.2.9.2.2',
  'cpvIKETotalFailuresResp' => '1.3.6.1.4.1.2620.1.2.9.2.3',
  'cpvIPsec' => '1.3.6.1.4.1.2620.1.2.10',
  'cpvIPsecNIC' => '1.3.6.1.4.1.2620.1.2.10.1',
  'cpvIPsecNICsNum' => '1.3.6.1.4.1.2620.1.2.10.1.1',
  'cpvIPsecNICTotalDownLoadedSAs' => '1.3.6.1.4.1.2620.1.2.10.1.2',
  'cpvIPsecNICCurrDownLoadedSAs' => '1.3.6.1.4.1.2620.1.2.10.1.3',
  'cpvIPsecNICDecrBytes' => '1.3.6.1.4.1.2620.1.2.10.1.4',
  'cpvIPsecNICEncrBytes' => '1.3.6.1.4.1.2620.1.2.10.1.5',
  'cpvIPsecNICDecrPackets' => '1.3.6.1.4.1.2620.1.2.10.1.6',
  'cpvIPsecNICEncrPackets' => '1.3.6.1.4.1.2620.1.2.10.1.7',
  'fg' => '1.3.6.1.4.1.2620.1.3',
  'fgProdName' => '1.3.6.1.4.1.2620.1.3.1',
  'fgVerMajor' => '1.3.6.1.4.1.2620.1.3.2',
  'fgVerMinor' => '1.3.6.1.4.1.2620.1.3.3',
  'fgVersionString' => '1.3.6.1.4.1.2620.1.3.4',
  'fgModuleKernelBuild' => '1.3.6.1.4.1.2620.1.3.5',
  'fgStrPolicyName' => '1.3.6.1.4.1.2620.1.3.6',
  'fgInstallTime' => '1.3.6.1.4.1.2620.1.3.7',
  'fgNumInterfaces' => '1.3.6.1.4.1.2620.1.3.8',
  'fgIfTable' => '1.3.6.1.4.1.2620.1.3.9',
  'fgIfEntry' => '1.3.6.1.4.1.2620.1.3.9.1',
  'fgIfIndex' => '1.3.6.1.4.1.2620.1.3.9.1.1',
  'fgIfName' => '1.3.6.1.4.1.2620.1.3.9.1.2',
  'fgPolicyName' => '1.3.6.1.4.1.2620.1.3.9.1.3',
  'fgRateLimitIn' => '1.3.6.1.4.1.2620.1.3.9.1.4',
  'fgRateLimitOut' => '1.3.6.1.4.1.2620.1.3.9.1.5',
  'fgAvrRateIn' => '1.3.6.1.4.1.2620.1.3.9.1.6',
  'fgAvrRateOut' => '1.3.6.1.4.1.2620.1.3.9.1.7',
  'fgRetransPcktsIn' => '1.3.6.1.4.1.2620.1.3.9.1.8',
  'fgRetransPcktsOut' => '1.3.6.1.4.1.2620.1.3.9.1.9',
  'fgPendPcktsIn' => '1.3.6.1.4.1.2620.1.3.9.1.10',
  'fgPendPcktsOut' => '1.3.6.1.4.1.2620.1.3.9.1.11',
  'fgPendBytesIn' => '1.3.6.1.4.1.2620.1.3.9.1.12',
  'fgPendBytesOut' => '1.3.6.1.4.1.2620.1.3.9.1.13',
  'fgNumConnIn' => '1.3.6.1.4.1.2620.1.3.9.1.14',
  'fgNumConnOut' => '1.3.6.1.4.1.2620.1.3.9.1.15',
  'ha' => '1.3.6.1.4.1.2620.1.5',
  'haProdName' => '1.3.6.1.4.1.2620.1.5.1',
  'haInstalled' => '1.3.6.1.4.1.2620.1.5.2',
  'haVerMajor' => '1.3.6.1.4.1.2620.1.5.3',
  'haVerMinor' => '1.3.6.1.4.1.2620.1.5.4',
  'haStarted' => '1.3.6.1.4.1.2620.1.5.5',
  'haState' => '1.3.6.1.4.1.2620.1.5.6',
  'haBlockState' => '1.3.6.1.4.1.2620.1.5.7',
  'haIdentifier' => '1.3.6.1.4.1.2620.1.5.8',
  'haProtoVersion' => '1.3.6.1.4.1.2620.1.5.10',
  'haWorkMode' => '1.3.6.1.4.1.2620.1.5.11',
  'haIfTable' => '1.3.6.1.4.1.2620.1.5.12',
  'haIfEntry' => '1.3.6.1.4.1.2620.1.5.12.1',
  'haIfIndex' => '1.3.6.1.4.1.2620.1.5.12.1.1',
  'haIfName' => '1.3.6.1.4.1.2620.1.5.12.1.2',
  'haIP' => '1.3.6.1.4.1.2620.1.5.12.1.3',
  'haStatus' => '1.3.6.1.4.1.2620.1.5.12.1.4',
  'haVerified' => '1.3.6.1.4.1.2620.1.5.12.1.5',
  'haTrusted' => '1.3.6.1.4.1.2620.1.5.12.1.6',
  'haShared' => '1.3.6.1.4.1.2620.1.5.12.1.7',
  'haProblemTable' => '1.3.6.1.4.1.2620.1.5.13',
  'haProblemEntry' => '1.3.6.1.4.1.2620.1.5.13.1',
  'haProblemIndex' => '1.3.6.1.4.1.2620.1.5.13.1.1',
  'haProblemName' => '1.3.6.1.4.1.2620.1.5.13.1.2',
  'haProblemStatus' => '1.3.6.1.4.1.2620.1.5.13.1.3',
  'haProblemPriority' => '1.3.6.1.4.1.2620.1.5.13.1.4',
  'haProblemVerified' => '1.3.6.1.4.1.2620.1.5.13.1.5',
  'haProblemDescr' => '1.3.6.1.4.1.2620.1.5.13.1.6',
  'haVersionSting' => '1.3.6.1.4.1.2620.1.5.14',
  'haClusterIpTable' => '1.3.6.1.4.1.2620.1.5.15',
  'haClusterIpEntry' => '1.3.6.1.4.1.2620.1.5.15.1',
  'haClusterIpIndex' => '1.3.6.1.4.1.2620.1.5.15.1.1',
  'haClusterIpIfName' => '1.3.6.1.4.1.2620.1.5.15.1.2',
  'haClusterIpAddr' => '1.3.6.1.4.1.2620.1.5.15.1.3',
  'haClusterIpNetMask' => '1.3.6.1.4.1.2620.1.5.15.1.4',
  'haClusterIpMemberNet' => '1.3.6.1.4.1.2620.1.5.15.1.5',
  'haClusterIpMemberNetMask' => '1.3.6.1.4.1.2620.1.5.15.1.6',
  'haClusterSyncTable' => '1.3.6.1.4.1.2620.1.5.16',
  'haClusterSyncEntry' => '1.3.6.1.4.1.2620.1.5.16.1',
  'haClusterSyncIndex' => '1.3.6.1.4.1.2620.1.5.16.1.1',
  'haClusterSyncName' => '1.3.6.1.4.1.2620.1.5.16.1.2',
  'haClusterSyncAddr' => '1.3.6.1.4.1.2620.1.5.16.1.3',
  'haClusterSyncNetMask' => '1.3.6.1.4.1.2620.1.5.16.1.4',
  'haStatCode' => '1.3.6.1.4.1.2620.1.5.101',
  'haStatShort' => '1.3.6.1.4.1.2620.1.5.102',
  'haStatLong' => '1.3.6.1.4.1.2620.1.5.103',
  'haServicePack' => '1.3.6.1.4.1.2620.1.5.999',
  'svn' => '1.3.6.1.4.1.2620.1.6',
  'svnProdName' => '1.3.6.1.4.1.2620.1.6.1',
  'svnProdVerMajor' => '1.3.6.1.4.1.2620.1.6.2',
  'svnProdVerMinor' => '1.3.6.1.4.1.2620.1.6.3',
  'svnInfo' => '1.3.6.1.4.1.2620.1.6.4',
  'svnVersion' => '1.3.6.1.4.1.2620.1.6.4.1',
  'svnBuild' => '1.3.6.1.4.1.2620.1.6.4.2',
  'svnOSInfo' => '1.3.6.1.4.1.2620.1.6.5',
  'osName' => '1.3.6.1.4.1.2620.1.6.5.1',
  'osMajorVer' => '1.3.6.1.4.1.2620.1.6.5.2',
  'osMinorVer' => '1.3.6.1.4.1.2620.1.6.5.3',
  'osBuildNum' => '1.3.6.1.4.1.2620.1.6.5.4',
  'osSPmajor' => '1.3.6.1.4.1.2620.1.6.5.5',
  'osSPminor' => '1.3.6.1.4.1.2620.1.6.5.6',
  'osVersionLevel' => '1.3.6.1.4.1.2620.1.6.5.7',
  'routingTable' => '1.3.6.1.4.1.2620.1.6.6',
  'routingEntry' => '1.3.6.1.4.1.2620.1.6.6.1',
  'routingIndex' => '1.3.6.1.4.1.2620.1.6.6.1.1',
  'routingDest' => '1.3.6.1.4.1.2620.1.6.6.1.2',
  'routingMask' => '1.3.6.1.4.1.2620.1.6.6.1.3',
  'routingGatweway' => '1.3.6.1.4.1.2620.1.6.6.1.4',
  'routingIntrfName' => '1.3.6.1.4.1.2620.1.6.6.1.5',
  'svnPerf' => '1.3.6.1.4.1.2620.1.6.7',
  'svnMem' => '1.3.6.1.4.1.2620.1.6.7.1',
  'memTotalVirtual' => '1.3.6.1.4.1.2620.1.6.7.1.1',
  'memActiveVirtual' => '1.3.6.1.4.1.2620.1.6.7.1.2',
  'memTotalReal' => '1.3.6.1.4.1.2620.1.6.7.1.3',
  'memActiveReal' => '1.3.6.1.4.1.2620.1.6.7.1.4',
  'memFreeReal' => '1.3.6.1.4.1.2620.1.6.7.1.5',
  'memSwapsSec' => '1.3.6.1.4.1.2620.1.6.7.1.6',
  'memDiskTransfers' => '1.3.6.1.4.1.2620.1.6.7.1.7',
  'svnProc' => '1.3.6.1.4.1.2620.1.6.7.2',
  'procUsrTime' => '1.3.6.1.4.1.2620.1.6.7.2.1',
  'procSysTime' => '1.3.6.1.4.1.2620.1.6.7.2.2',
  'procIdleTime' => '1.3.6.1.4.1.2620.1.6.7.2.3',
  'procUsage' => '1.3.6.1.4.1.2620.1.6.7.2.4',
  'procQueue' => '1.3.6.1.4.1.2620.1.6.7.2.5',
  'procInterrupts' => '1.3.6.1.4.1.2620.1.6.7.2.6',
  'procNum' => '1.3.6.1.4.1.2620.1.6.7.2.7',
  'svnDisk' => '1.3.6.1.4.1.2620.1.6.7.3',
  'diskTime' => '1.3.6.1.4.1.2620.1.6.7.3.1',
  'diskQueue' => '1.3.6.1.4.1.2620.1.6.7.3.2',
  'diskPercent' => '1.3.6.1.4.1.2620.1.6.7.3.3',
  'diskFreeTotal' => '1.3.6.1.4.1.2620.1.6.7.3.4',
  'diskFreeAvail' => '1.3.6.1.4.1.2620.1.6.7.3.5',
  'diskTotal' => '1.3.6.1.4.1.2620.1.6.7.3.6',
  'svnMem64' => '1.3.6.1.4.1.2620.1.6.7.4',
  'memTotalVirtual64' => '1.3.6.1.4.1.2620.1.6.7.4.1',
  'memActiveVirtual64' => '1.3.6.1.4.1.2620.1.6.7.4.2',
  'memTotalReal64' => '1.3.6.1.4.1.2620.1.6.7.4.3',
  'memActiveReal64' => '1.3.6.1.4.1.2620.1.6.7.4.4',
  'memFreeReal64' => '1.3.6.1.4.1.2620.1.6.7.4.5',
  'memSwapsSec64' => '1.3.6.1.4.1.2620.1.6.7.4.6',
  'memDiskTransfers64' => '1.3.6.1.4.1.2620.1.6.7.4.7',
  'multiProcTable' => '1.3.6.1.4.1.2620.1.6.7.5',
  'multiProcEntry' => '1.3.6.1.4.1.2620.1.6.7.5.1',
  'multiProcIndex' => '1.3.6.1.4.1.2620.1.6.7.5.1.1',
  'multiProcUserTime' => '1.3.6.1.4.1.2620.1.6.7.5.1.2',
  'multiProcSystemTime' => '1.3.6.1.4.1.2620.1.6.7.5.1.3',
  'multiProcIdleTime' => '1.3.6.1.4.1.2620.1.6.7.5.1.4',
  'multiProcUsage' => '1.3.6.1.4.1.2620.1.6.7.5.1.5',
  'multiProcRunQueue' => '1.3.6.1.4.1.2620.1.6.7.5.1.6',
  'multiProcInterrupts' => '1.3.6.1.4.1.2620.1.6.7.5.1.7',
  'multiDiskTable' => '1.3.6.1.4.1.2620.1.6.7.6',
  'multiDiskEntry' => '1.3.6.1.4.1.2620.1.6.7.6.1',
  'multiDiskIndex' => '1.3.6.1.4.1.2620.1.6.7.6.1.1',
  'multiDiskName' => '1.3.6.1.4.1.2620.1.6.7.6.1.2',
  'multiDiskSize' => '1.3.6.1.4.1.2620.1.6.7.6.1.3',
  'multiDiskUsed' => '1.3.6.1.4.1.2620.1.6.7.6.1.4',
  'multiDiskFreeTotalBytes' => '1.3.6.1.4.1.2620.1.6.7.6.1.5',
  'multiDiskFreeTotalPercent' => '1.3.6.1.4.1.2620.1.6.7.6.1.6',
  'multiDiskFreeAvailableBytes' => '1.3.6.1.4.1.2620.1.6.7.6.1.7',
  'multiDiskFreeAvailablePercent' => '1.3.6.1.4.1.2620.1.6.7.6.1.8',
  'raidInfo' => '1.3.6.1.4.1.2620.1.6.7.7',
  'raidVolumeTable' => '1.3.6.1.4.1.2620.1.6.7.7.1',
  'raidVolumeEntry' => '1.3.6.1.4.1.2620.1.6.7.7.1.1',
  'raidVolumeIndex' => '1.3.6.1.4.1.2620.1.6.7.7.1.1.1',
  'raidVolumeID' => '1.3.6.1.4.1.2620.1.6.7.7.1.1.2',
  'raidVolumeType' => '1.3.6.1.4.1.2620.1.6.7.7.1.1.3',
  'numOfDisksOnRaid' => '1.3.6.1.4.1.2620.1.6.7.7.1.1.4',
  'raidVolumeMaxLBA' => '1.3.6.1.4.1.2620.1.6.7.7.1.1.5',
  'raidVolumeState' => '1.3.6.1.4.1.2620.1.6.7.7.1.1.6',
  'raidVolumeStateDefinition' => {
    0 => 'optimal',
    1 => 'degraded',
    2 => 'failed',
  },
  'raidVolumeFlags' => '1.3.6.1.4.1.2620.1.6.7.7.1.1.7',
  'raidVolumeSize' => '1.3.6.1.4.1.2620.1.6.7.7.1.1.8',
  'raidDiskTable' => '1.3.6.1.4.1.2620.1.6.7.7.2',
  'raidDiskEntry' => '1.3.6.1.4.1.2620.1.6.7.7.2.1',
  'raidDiskIndex' => '1.3.6.1.4.1.2620.1.6.7.7.2.1.1',
  'raidDiskVolumeID' => '1.3.6.1.4.1.2620.1.6.7.7.2.1.2',
  'raidDiskID' => '1.3.6.1.4.1.2620.1.6.7.7.2.1.3',
  'raidDiskNumber' => '1.3.6.1.4.1.2620.1.6.7.7.2.1.4',
  'raidDiskVendor' => '1.3.6.1.4.1.2620.1.6.7.7.2.1.5',
  'raidDiskProductID' => '1.3.6.1.4.1.2620.1.6.7.7.2.1.6',
  'raidDiskRevision' => '1.3.6.1.4.1.2620.1.6.7.7.2.1.7',
  'raidDiskMaxLBA' => '1.3.6.1.4.1.2620.1.6.7.7.2.1.8',
  'raidDiskState' => '1.3.6.1.4.1.2620.1.6.7.7.2.1.9',
  'raidDiskStateDefinition' => {
    0 => 'online',
    1 => 'missing',
    2 => 'not_compatible',
    3 => 'disc_failed',
    4 => 'initializing',
    5 => 'offline_requested',
    6 => 'failed_requested',
    7 => 'unconfigured_good_spun_up',
    8 => 'unconfigured_good_spun_down',
    9 => 'unconfigured_bad',
    10 => 'hotspare',
    11 => 'drive_offline',
    12 => 'rebuild',
    13 => 'failed',
    15 => 'copyback',
    255 => 'rebuild',
  },
  'raidDiskFlags' => '1.3.6.1.4.1.2620.1.6.7.7.2.1.10',
  'raidDiskSyncState' => '1.3.6.1.4.1.2620.1.6.7.7.2.1.11',
  'raidDiskSize' => '1.3.6.1.4.1.2620.1.6.7.7.2.1.12',
  'sensorInfo' => '1.3.6.1.4.1.2620.1.6.7.8',
  'tempertureSensorTable' => '1.3.6.1.4.1.2620.1.6.7.8.1',
  'tempertureSensorEntry' => '1.3.6.1.4.1.2620.1.6.7.8.1.1',
  'tempertureSensorIndex' => '1.3.6.1.4.1.2620.1.6.7.8.1.1.1',
  'tempertureSensorName' => '1.3.6.1.4.1.2620.1.6.7.8.1.1.2',
  'tempertureSensorValue' => '1.3.6.1.4.1.2620.1.6.7.8.1.1.3',
  'tempertureSensorUnit' => '1.3.6.1.4.1.2620.1.6.7.8.1.1.4',
  'tempertureSensorType' => '1.3.6.1.4.1.2620.1.6.7.8.1.1.5',
  'tempertureSensorStatus' => '1.3.6.1.4.1.2620.1.6.7.8.1.1.6',
  'tempertureSensorStatusDefinition' => {
    0 => 'normal', # In normal range
    1 => 'abnormal', # Out of normal range
    2 => 'unknown', # Reading error
  },
  'fanSpeedSensorTable' => '1.3.6.1.4.1.2620.1.6.7.8.2',
  'fanSpeedSensorEntry' => '1.3.6.1.4.1.2620.1.6.7.8.2.1',
  'fanSpeedSensorIndex' => '1.3.6.1.4.1.2620.1.6.7.8.2.1.1',
  'fanSpeedSensorName' => '1.3.6.1.4.1.2620.1.6.7.8.2.1.2',
  'fanSpeedSensorValue' => '1.3.6.1.4.1.2620.1.6.7.8.2.1.3',
  'fanSpeedSensorUnit' => '1.3.6.1.4.1.2620.1.6.7.8.2.1.4',
  'fanSpeedSensorType' => '1.3.6.1.4.1.2620.1.6.7.8.2.1.5',
  'fanSpeedSensorStatus' => '1.3.6.1.4.1.2620.1.6.7.8.2.1.6',
  'fanSpeedSensorStatusDefinition' => {
    0 => 'normal',
    1 => 'abnormal',
    2 => 'unknown',
  },
  'voltageSensorTable' => '1.3.6.1.4.1.2620.1.6.7.8.3',
  'voltageSensorEntry' => '1.3.6.1.4.1.2620.1.6.7.8.3.1',
  'voltageSensorIndex' => '1.3.6.1.4.1.2620.1.6.7.8.3.1.1',
  'voltageSensorName' => '1.3.6.1.4.1.2620.1.6.7.8.3.1.2',
  'voltageSensorValue' => '1.3.6.1.4.1.2620.1.6.7.8.3.1.3',
  'voltageSensorUnit' => '1.3.6.1.4.1.2620.1.6.7.8.3.1.4',
  'voltageSensorType' => '1.3.6.1.4.1.2620.1.6.7.8.3.1.5',
  'voltageSensorStatus' => '1.3.6.1.4.1.2620.1.6.7.8.3.1.6',
  'voltageSensorStatusDefinition' => {
    0 => 'normal',
    1 => 'abnormal',
    2 => 'unknown',
  },
  'powerSupplyInfo' => '1.3.6.1.4.1.2620.1.6.7.9',
  'powerSupplyTable' => '1.3.6.1.4.1.2620.1.6.7.9.1',
  'powerSupplyEntry' => '1.3.6.1.4.1.2620.1.6.7.9.1.1',
  'powerSupplyIndex' => '1.3.6.1.4.1.2620.1.6.7.9.1.1.1',
  'powerSupplyStatus' => '1.3.6.1.4.1.2620.1.6.7.9.1.1.2',
  'svnSysTime' => '1.3.6.1.4.1.2620.1.6.8',
  'svnRoutingModify' => '1.3.6.1.4.1.2620.1.6.9',
  'svnRouteModDest' => '1.3.6.1.4.1.2620.1.6.9.2',
  'svnRouteModMask' => '1.3.6.1.4.1.2620.1.6.9.3',
  'svnRouteModGateway' => '1.3.6.1.4.1.2620.1.6.9.4',
  'svnRouteModIfIndex' => '1.3.6.1.4.1.2620.1.6.9.5',
  'svnRouteModIfName' => '1.3.6.1.4.1.2620.1.6.9.6',
  'svnRouteModAction' => '1.3.6.1.4.1.2620.1.6.9.10',
  'svnUTCTimeOffset' => '1.3.6.1.4.1.2620.1.6.10',
  'svnLogDaemon' => '1.3.6.1.4.1.2620.1.6.11',
  'svnLogDStat' => '1.3.6.1.4.1.2620.1.6.11.1',
  'svnSysStartTime' => '1.3.6.1.4.1.2620.1.6.12',
  'svnSysUniqId' => '1.3.6.1.4.1.2620.1.6.13',
  'svnWebUIPort' => '1.3.6.1.4.1.2620.1.6.15',
  'svnApplianceInfo' => '1.3.6.1.4.1.2620.1.6.16',
  'svnApplianceSerialNumber' => '1.3.6.1.4.1.2620.1.6.16.3',
  'svnApplianceProductName' => '1.3.6.1.4.1.2620.1.6.16.7',
  'svnApplianceManufacturer' => '1.3.6.1.4.1.2620.1.6.16.9',
  'svnApplianceSeriesString' => '1.3.6.1.4.1.2620.1.6.16.10',
  'svnLicensing' => '1.3.6.1.4.1.2620.1.6.18',
  'licensingTable' => '1.3.6.1.4.1.2620.1.6.18.1',
  'licensingEntry' => '1.3.6.1.4.1.2620.1.6.18.1.1',
  'licensingIndex' => '1.3.6.1.4.1.2620.1.6.18.1.1.1',
  'licensingID' => '1.3.6.1.4.1.2620.1.6.18.1.1.2',
  'licensingBladeName' => '1.3.6.1.4.1.2620.1.6.18.1.1.3',
  'licensingState' => '1.3.6.1.4.1.2620.1.6.18.1.1.4',
  'licensingExpirationDate' => '1.3.6.1.4.1.2620.1.6.18.1.1.5',
  'licensingImpact' => '1.3.6.1.4.1.2620.1.6.18.1.1.6',
  'licensingBladeActive' => '1.3.6.1.4.1.2620.1.6.18.1.1.7',
  'licensingTotalQuota' => '1.3.6.1.4.1.2620.1.6.18.1.1.8',
  'licensingUsedQuota' => '1.3.6.1.4.1.2620.1.6.18.1.1.9',
  'licensingAssetInfo' => '1.3.6.1.4.1.2620.1.6.18.2',
  'licensingAssetAccountId' => '1.3.6.1.4.1.2620.1.6.18.2.1',
  'licensingAssetPackageDescription' => '1.3.6.1.4.1.2620.1.6.18.2.2',
  'licensingAssetContainerCK' => '1.3.6.1.4.1.2620.1.6.18.2.3',
  'licensingAssetContainerSKU' => '1.3.6.1.4.1.2620.1.6.18.2.4',
  'licensingAssetSupportLevel' => '1.3.6.1.4.1.2620.1.6.18.2.5',
  'licensingAssetSupportExpiration' => '1.3.6.1.4.1.2620.1.6.18.2.6',
  'licensingAssetActivationStatus' => '1.3.6.1.4.1.2620.1.6.18.2.7',
  'svnConnectivity' => '1.3.6.1.4.1.2620.1.6.19',
  'svnUpdatesInfo' => '1.3.6.1.4.1.2620.1.6.20',
  'svnUpdatesInfoBuild' => '1.3.6.1.4.1.2620.1.6.20.1',
  'svnUpdatesInfoStatus' => '1.3.6.1.4.1.2620.1.6.20.2',
  'svnUpdatesInfoConnection' => '1.3.6.1.4.1.2620.1.6.20.3',
  'svnUpdatesInfoAvailablePackages' => '1.3.6.1.4.1.2620.1.6.20.4',
  'svnUpdatesInfoAvailableRecommended' => '1.3.6.1.4.1.2620.1.6.20.5',
  'svnUpdatesInfoAvailableHotfixes' => '1.3.6.1.4.1.2620.1.6.20.6',
  'updatesInstalledTable' => '1.3.6.1.4.1.2620.1.6.20.7',
  'updatesInstalledEntry' => '1.3.6.1.4.1.2620.1.6.20.7.1',
  'updatesInstalledIndex' => '1.3.6.1.4.1.2620.1.6.20.7.1.1',
  'updatesInstalledName' => '1.3.6.1.4.1.2620.1.6.20.7.1.2',
  'updatesInstalledType' => '1.3.6.1.4.1.2620.1.6.20.7.1.3',
  'updatesRecommendedTable' => '1.3.6.1.4.1.2620.1.6.20.8',
  'updatesRecommendedEntry' => '1.3.6.1.4.1.2620.1.6.20.8.1',
  'updatesRecommendedIndex' => '1.3.6.1.4.1.2620.1.6.20.8.1.1',
  'updatesRecommendedName' => '1.3.6.1.4.1.2620.1.6.20.8.1.2',
  'updatesRecommendedType' => '1.3.6.1.4.1.2620.1.6.20.8.1.3',
  'updatesRecommendedStatus' => '1.3.6.1.4.1.2620.1.6.20.8.1.4',
  'svnNetStat' => '1.3.6.1.4.1.2620.1.6.50',
  'svnNetIfTable' => '1.3.6.1.4.1.2620.1.6.50.1',
  'svnNetIfTableEntry' => '1.3.6.1.4.1.2620.1.6.50.1.1',
  'svnNetIfIndex' => '1.3.6.1.4.1.2620.1.6.50.1.1.1',
  'svnNetIfVsid' => '1.3.6.1.4.1.2620.1.6.50.1.1.2',
  'svnNetIfName' => '1.3.6.1.4.1.2620.1.6.50.1.1.3',
  'svnNetIfAddress' => '1.3.6.1.4.1.2620.1.6.50.1.1.4',
  'svnNetIfMask' => '1.3.6.1.4.1.2620.1.6.50.1.1.5',
  'svnNetIfMTU' => '1.3.6.1.4.1.2620.1.6.50.1.1.6',
  'svnNetIfState' => '1.3.6.1.4.1.2620.1.6.50.1.1.7',
  'svnNetIfMAC' => '1.3.6.1.4.1.2620.1.6.50.1.1.8',
  'svnNetIfDescription' => '1.3.6.1.4.1.2620.1.6.50.1.1.9',
  'svnNetIfOperState' => '1.3.6.1.4.1.2620.1.6.50.1.1.10',
  'vsRoutingTable' => '1.3.6.1.4.1.2620.1.6.51',
  'vsRoutingEntry' => '1.3.6.1.4.1.2620.1.6.51.1',
  'vsRoutingIndex' => '1.3.6.1.4.1.2620.1.6.51.1.1',
  'vsRoutingDest' => '1.3.6.1.4.1.2620.1.6.51.1.2',
  'vsRoutingMask' => '1.3.6.1.4.1.2620.1.6.51.1.3',
  'vsRoutingGateway' => '1.3.6.1.4.1.2620.1.6.51.1.4',
  'vsRoutingIntrfName' => '1.3.6.1.4.1.2620.1.6.51.1.5',
  'vsRoutingVsId' => '1.3.6.1.4.1.2620.1.6.51.1.6',
  'svnStatCode' => '1.3.6.1.4.1.2620.1.6.101',
  'svnStatShortDescr' => '1.3.6.1.4.1.2620.1.6.102',
  'svnStatLongDescr' => '1.3.6.1.4.1.2620.1.6.103',
  'svnPlatformInfo' => '1.3.6.1.4.1.2620.1.6.123',
  'supportedPlatforms' => '1.3.6.1.4.1.2620.1.6.123.1',
  'checkPointUTM-1450' => '1.3.6.1.4.1.2620.1.6.123.1.1',
  'checkPointUTM-11050' => '1.3.6.1.4.1.2620.1.6.123.1.2',
  'checkPointUTM-12050' => '1.3.6.1.4.1.2620.1.6.123.1.3',
  'checkPointUTM-1130' => '1.3.6.1.4.1.2620.1.6.123.1.4',
  'checkPointUTM-1270' => '1.3.6.1.4.1.2620.1.6.123.1.5',
  'checkPointUTM-1570' => '1.3.6.1.4.1.2620.1.6.123.1.6',
  'checkPointUTM-11070' => '1.3.6.1.4.1.2620.1.6.123.1.7',
  'checkPointUTM-12070' => '1.3.6.1.4.1.2620.1.6.123.1.8',
  'checkPointUTM-13070' => '1.3.6.1.4.1.2620.1.6.123.1.9',
  'checkPointPower-15070' => '1.3.6.1.4.1.2620.1.6.123.1.10',
  'checkPointPower-19070' => '1.3.6.1.4.1.2620.1.6.123.1.11',
  'checkPointPower-111000' => '1.3.6.1.4.1.2620.1.6.123.1.12',
  'checkPointSmart-15' => '1.3.6.1.4.1.2620.1.6.123.1.13',
  'checkPointSmart-125' => '1.3.6.1.4.1.2620.1.6.123.1.14',
  'checkPointSmart-150' => '1.3.6.1.4.1.2620.1.6.123.1.15',
  'checkPointSmart-1150' => '1.3.6.1.4.1.2620.1.6.123.1.16',
  'checkPointIP150' => '1.3.6.1.4.1.2620.1.6.123.1.17',
  'checkPointIP280' => '1.3.6.1.4.1.2620.1.6.123.1.18',
  'checkPointIP290' => '1.3.6.1.4.1.2620.1.6.123.1.19',
  'checkPointIP390' => '1.3.6.1.4.1.2620.1.6.123.1.20',
  'checkPointIP560' => '1.3.6.1.4.1.2620.1.6.123.1.21',
  'checkPointIP690' => '1.3.6.1.4.1.2620.1.6.123.1.22',
  'checkPointIP1280' => '1.3.6.1.4.1.2620.1.6.123.1.23',
  'checkPointIP2450' => '1.3.6.1.4.1.2620.1.6.123.1.24',
  'checkPointUNIVERGEUnifiedWall1000' => '1.3.6.1.4.1.2620.1.6.123.1.25',
  'checkPointUNIVERGEUnifiedWall2000' => '1.3.6.1.4.1.2620.1.6.123.1.26',
  'checkPointUNIVERGEUnifiedWall4000' => '1.3.6.1.4.1.2620.1.6.123.1.27',
  'checkPointUNIVERGEUnifiedWall100' => '1.3.6.1.4.1.2620.1.6.123.1.28',
  'checkPointDLP-19571' => '1.3.6.1.4.1.2620.1.6.123.1.29',
  'checkPointDLP-12571' => '1.3.6.1.4.1.2620.1.6.123.1.30',
  'checkPointIPS-12076' => '1.3.6.1.4.1.2620.1.6.123.1.31',
  'checkPointIPS-15076' => '1.3.6.1.4.1.2620.1.6.123.1.32',
  'checkPointIPS-19076' => '1.3.6.1.4.1.2620.1.6.123.1.33',
  'checkPoint2200' => '1.3.6.1.4.1.2620.1.6.123.1.34',
  'checkPoint4200' => '1.3.6.1.4.1.2620.1.6.123.1.35',
  'checkPoint4400' => '1.3.6.1.4.1.2620.1.6.123.1.36',
  'checkPoint4600' => '1.3.6.1.4.1.2620.1.6.123.1.37',
  'checkPoint4800' => '1.3.6.1.4.1.2620.1.6.123.1.38',
  'checkPointTE250' => '1.3.6.1.4.1.2620.1.6.123.1.39',
  'checkPoint12200' => '1.3.6.1.4.1.2620.1.6.123.1.40',
  'checkPoint12400' => '1.3.6.1.4.1.2620.1.6.123.1.41',
  'checkPoint12600' => '1.3.6.1.4.1.2620.1.6.123.1.42',
  'checkPointTE1000' => '1.3.6.1.4.1.2620.1.6.123.1.43',
  'checkPoint13500' => '1.3.6.1.4.1.2620.1.6.123.1.44',
  'checkPoint21400' => '1.3.6.1.4.1.2620.1.6.123.1.45',
  'checkPoint21600' => '1.3.6.1.4.1.2620.1.6.123.1.46',
  'checkPoint21700' => '1.3.6.1.4.1.2620.1.6.123.1.47',
  'checkPointVMware' => '1.3.6.1.4.1.2620.1.6.123.1.48',
  'checkPointOpenServer' => '1.3.6.1.4.1.2620.1.6.123.1.49',
  'checkPointSmart-1205' => '1.3.6.1.4.1.2620.1.6.123.1.50',
  'checkPointSmart-1210' => '1.3.6.1.4.1.2620.1.6.123.1.51',
  'checkPointSmart-1225' => '1.3.6.1.4.1.2620.1.6.123.1.52',
  'checkPointSmart-13050' => '1.3.6.1.4.1.2620.1.6.123.1.53',
  'checkPointSmart-13150' => '1.3.6.1.4.1.2620.1.6.123.1.54',
  'checkPoint13800' => '1.3.6.1.4.1.2620.1.6.123.1.55',
  'checkPoint21800' => '1.3.6.1.4.1.2620.1.6.123.1.56',
  'svnServicePack' => '1.3.6.1.4.1.2620.1.6.999',
  'mngmt' => '1.3.6.1.4.1.2620.1.7',
  'mgProdName' => '1.3.6.1.4.1.2620.1.7.1',
  'mgVerMajor' => '1.3.6.1.4.1.2620.1.7.2',
  'mgVerMinor' => '1.3.6.1.4.1.2620.1.7.3',
  'mgBuildNumber' => '1.3.6.1.4.1.2620.1.7.4',
  'mgActiveStatus' => '1.3.6.1.4.1.2620.1.7.5',
  'mgFwmIsAlive' => '1.3.6.1.4.1.2620.1.7.6',
  'mgConnectedClientsTable' => '1.3.6.1.4.1.2620.1.7.7',
  'mgConnectedClientsEntry' => '1.3.6.1.4.1.2620.1.7.7.1',
  'mgIndex' => '1.3.6.1.4.1.2620.1.7.7.1.1',
  'mgClientName' => '1.3.6.1.4.1.2620.1.7.7.1.2',
  'mgClientHost' => '1.3.6.1.4.1.2620.1.7.7.1.3',
  'mgClientDbLock' => '1.3.6.1.4.1.2620.1.7.7.1.4',
  'mgApplicationType' => '1.3.6.1.4.1.2620.1.7.7.1.5',
  'mgLogServerInfo' => '1.3.6.1.4.1.2620.1.7.14',
  'mgLSLogReceiveRate' => '1.3.6.1.4.1.2620.1.7.14.1',
  'mgLSLogReceiveRatePeak' => '1.3.6.1.4.1.2620.1.7.14.2',
  'mgLSLogReceiveRate10Min' => '1.3.6.1.4.1.2620.1.7.14.3',
  'mgConnectedGatewaysTable' => '1.3.6.1.4.1.2620.1.7.14.4',
  'mgConnectedGatewaysEntry' => '1.3.6.1.4.1.2620.1.7.14.4.1',
  'mglsGWIndex' => '1.3.6.1.4.1.2620.1.7.14.4.1.1',
  'mglsGWIP' => '1.3.6.1.4.1.2620.1.7.14.4.1.2',
  'mglsGWState' => '1.3.6.1.4.1.2620.1.7.14.4.1.3',
  'mglsGWLastLoginTime' => '1.3.6.1.4.1.2620.1.7.14.4.1.4',
  'mglsGWLogReceiveRate' => '1.3.6.1.4.1.2620.1.7.14.4.1.5',
  'mgIndexerInfo' => '1.3.6.1.4.1.2620.1.7.14.5',
  'mgIndexerInfoTotalReadLogs' => '1.3.6.1.4.1.2620.1.7.14.5.1',
  'mgIndexerInfoTotalUpdatesAndLogsIndexed' => '1.3.6.1.4.1.2620.1.7.14.5.2',
  'mgIndexerInfoTotalReadLogsErrors' => '1.3.6.1.4.1.2620.1.7.14.5.3',
  'mgIndexerInfoTotalUpdatesAndLogsIndexedErrors' => '1.3.6.1.4.1.2620.1.7.14.5.4',
  'mgIndexerInfoUpdatesAndLogsIndexedRate' => '1.3.6.1.4.1.2620.1.7.14.5.5',
  'mgIndexerInfoReadLogsRate' => '1.3.6.1.4.1.2620.1.7.14.5.6',
  'mgIndexerInfoUpdatesAndLogsIndexedRate10min' => '1.3.6.1.4.1.2620.1.7.14.5.7',
  'mgIndexerInfoReadLogsRate10min' => '1.3.6.1.4.1.2620.1.7.14.5.8',
  'mgIndexerInfoUpdatesAndLogsIndexedRate60min' => '1.3.6.1.4.1.2620.1.7.14.5.9',
  'mgIndexerInfoReadLogsRate60min' => '1.3.6.1.4.1.2620.1.7.14.5.10',
  'mgIndexerInfoUpdatesAndLogsIndexedRatePeak' => '1.3.6.1.4.1.2620.1.7.14.5.11',
  'mgIndexerInfoReadLogsRatePeak' => '1.3.6.1.4.1.2620.1.7.14.5.12',
  'mgIndexerInfoReadLogsDelay' => '1.3.6.1.4.1.2620.1.7.14.5.13',
  'mgLSLogReceiveRate1Hour' => '1.3.6.1.4.1.2620.1.7.14.6',
  'mgStatCode' => '1.3.6.1.4.1.2620.1.7.101',
  'mgStatShortDescr' => '1.3.6.1.4.1.2620.1.7.102',
  'mgStatLongDescr' => '1.3.6.1.4.1.2620.1.7.103',
  'wam' => '1.3.6.1.4.1.2620.1.8',
  'wamProdName' => '1.3.6.1.4.1.2620.1.8.1',
  'wamVerMajor' => '1.3.6.1.4.1.2620.1.8.2',
  'wamVerMinor' => '1.3.6.1.4.1.2620.1.8.3',
  'wamState' => '1.3.6.1.4.1.2620.1.8.4',
  'wamName' => '1.3.6.1.4.1.2620.1.8.5',
  'wamPluginPerformance' => '1.3.6.1.4.1.2620.1.8.6',
  'wamAcceptReq' => '1.3.6.1.4.1.2620.1.8.6.1',
  'wamRejectReq' => '1.3.6.1.4.1.2620.1.8.6.2',
  'wamPolicy' => '1.3.6.1.4.1.2620.1.8.7',
  'wamPolicyName' => '1.3.6.1.4.1.2620.1.8.7.1',
  'wamPolicyUpdate' => '1.3.6.1.4.1.2620.1.8.7.2',
  'wamUagQueries' => '1.3.6.1.4.1.2620.1.8.8',
  'wamUagHost' => '1.3.6.1.4.1.2620.1.8.8.1',
  'wamUagIp' => '1.3.6.1.4.1.2620.1.8.8.2',
  'wamUagPort' => '1.3.6.1.4.1.2620.1.8.8.3',
  'wamUagNoQueries' => '1.3.6.1.4.1.2620.1.8.8.4',
  'wamUagLastQuery' => '1.3.6.1.4.1.2620.1.8.8.5',
  'wamGlobalPerformance' => '1.3.6.1.4.1.2620.1.8.9',
  'wamOpenSessions' => '1.3.6.1.4.1.2620.1.8.9.1',
  'wamLastSession' => '1.3.6.1.4.1.2620.1.8.9.2',
  'wamStatCode' => '1.3.6.1.4.1.2620.1.8.101',
  'wamStatShortDescr' => '1.3.6.1.4.1.2620.1.8.102',
  'wamStatLongDescr' => '1.3.6.1.4.1.2620.1.8.103',
  'dtps' => '1.3.6.1.4.1.2620.1.9',
  'dtpsProdName' => '1.3.6.1.4.1.2620.1.9.1',
  'dtpsVerMajor' => '1.3.6.1.4.1.2620.1.9.2',
  'dtpsVerMinor' => '1.3.6.1.4.1.2620.1.9.3',
  'dtpsLicensedUsers' => '1.3.6.1.4.1.2620.1.9.4',
  'dtpsConnectedUsers' => '1.3.6.1.4.1.2620.1.9.5',
  'dtpsStatCode' => '1.3.6.1.4.1.2620.1.9.101',
  'dtpsStatShortDescr' => '1.3.6.1.4.1.2620.1.9.102',
  'dtpsStatLongDescr' => '1.3.6.1.4.1.2620.1.9.103',
  'ls' => '1.3.6.1.4.1.2620.1.11',
  'lsProdName' => '1.3.6.1.4.1.2620.1.11.1',
  'lsVerMajor' => '1.3.6.1.4.1.2620.1.11.2',
  'lsVerMinor' => '1.3.6.1.4.1.2620.1.11.3',
  'lsBuildNumber' => '1.3.6.1.4.1.2620.1.11.4',
  'lsFwmIsAlive' => '1.3.6.1.4.1.2620.1.11.5',
  'lsConnectedClientsTable' => '1.3.6.1.4.1.2620.1.11.7',
  'lsConnectedClientsEntry' => '1.3.6.1.4.1.2620.1.11.7.1',
  'lsIndex' => '1.3.6.1.4.1.2620.1.11.7.1.1',
  'lsClientName' => '1.3.6.1.4.1.2620.1.11.7.1.2',
  'lsClientHost' => '1.3.6.1.4.1.2620.1.11.7.1.3',
  'lsClientDbLock' => '1.3.6.1.4.1.2620.1.11.7.1.4',
  'lsApplicationType' => '1.3.6.1.4.1.2620.1.11.7.1.5',
  'lsLoggingInfo' => '1.3.6.1.4.1.2620.1.11.14',
  'lsLogReceiveRate' => '1.3.6.1.4.1.2620.1.11.14.1',
  'lsLogReceiveRatePeak' => '1.3.6.1.4.1.2620.1.11.14.2',
  'lsLogReceiveRate10Min' => '1.3.6.1.4.1.2620.1.11.14.3',
  'lsConnectedGatewaysTable' => '1.3.6.1.4.1.2620.1.11.14.4',
  'lsConnectedGatewaysEntry' => '1.3.6.1.4.1.2620.1.11.14.4.1',
  'lsGWIndex' => '1.3.6.1.4.1.2620.1.11.14.4.1.1',
  'lsGWIP' => '1.3.6.1.4.1.2620.1.11.14.4.1.2',
  'lsGWState' => '1.3.6.1.4.1.2620.1.11.14.4.1.3',
  'lsGWLastLoginTime' => '1.3.6.1.4.1.2620.1.11.14.4.1.4',
  'lsGWLogReceiveRate' => '1.3.6.1.4.1.2620.1.11.14.4.1.5',
  'lsIndexerInfo' => '1.3.6.1.4.1.2620.1.11.14.5',
  'lsIndexerInfoTotalReadLogs' => '1.3.6.1.4.1.2620.1.11.14.5.1',
  'lsIndexerInfoTotalUpdatesAndLogsIndexed' => '1.3.6.1.4.1.2620.1.11.14.5.2',
  'lsIndexerInfoTotalReadLogsErrors' => '1.3.6.1.4.1.2620.1.11.14.5.3',
  'lsIndexerInfoTotalUpdatesAndLogsIndexedErrors' => '1.3.6.1.4.1.2620.1.11.14.5.4',
  'lsIndexerInfoUpdatesAndLogsIndexedRate' => '1.3.6.1.4.1.2620.1.11.14.5.5',
  'lsIndexerInfoReadLogsRate' => '1.3.6.1.4.1.2620.1.11.14.5.6',
  'lsIndexerInfoUpdatesAndLogsIndexedRatePeak' => '1.3.6.1.4.1.2620.1.11.14.5.7',
  'lsIndexerInfoReadLogsRatePeak' => '1.3.6.1.4.1.2620.1.11.14.5.8',
  'lsLogReceiveRate1Hour' => '1.3.6.1.4.1.2620.1.11.14.6',
  'lsStatCode' => '1.3.6.1.4.1.2620.1.11.101',
  'lsStatShortDescr' => '1.3.6.1.4.1.2620.1.11.102',
  'lsStatLongDescr' => '1.3.6.1.4.1.2620.1.11.103',
  'vsx' => '1.3.6.1.4.1.2620.1.16',
  'vsxVsSupported' => '1.3.6.1.4.1.2620.1.16.11',
  'vsxVsConfigured' => '1.3.6.1.4.1.2620.1.16.12',
  'vsxVsInstalled' => '1.3.6.1.4.1.2620.1.16.13',
  'vsxStatus' => '1.3.6.1.4.1.2620.1.16.22',
  'vsxStatusTable' => '1.3.6.1.4.1.2620.1.16.22.1',
  'vsxStatusEntry' => '1.3.6.1.4.1.2620.1.16.22.1.1',
  'vsxStatusVSId' => '1.3.6.1.4.1.2620.1.16.22.1.1.1',
  'vsxStatusVRId' => '1.3.6.1.4.1.2620.1.16.22.1.1.2',
  'vsxStatusVsName' => '1.3.6.1.4.1.2620.1.16.22.1.1.3',
  'vsxStatusVsType' => '1.3.6.1.4.1.2620.1.16.22.1.1.4',
  'vsxStatusMainIP' => '1.3.6.1.4.1.2620.1.16.22.1.1.5',
  'vsxStatusPolicyName' => '1.3.6.1.4.1.2620.1.16.22.1.1.6',
  'vsxStatusVsPolicyType' => '1.3.6.1.4.1.2620.1.16.22.1.1.7',
  'vsxStatusSicTrustState' => '1.3.6.1.4.1.2620.1.16.22.1.1.8',
  'vsxStatusHAState' => '1.3.6.1.4.1.2620.1.16.22.1.1.9',
  'vsxStatusVSWeight' => '1.3.6.1.4.1.2620.1.16.22.1.1.10',
  'vsxStatusCPUUsageTable' => '1.3.6.1.4.1.2620.1.16.22.2',
  'vsxStatusCPUUsageEntry' => '1.3.6.1.4.1.2620.1.16.22.2.1',
  'vsxStatusCPUUsage1sec' => '1.3.6.1.4.1.2620.1.16.22.2.1.1',
  'vsxStatusCPUUsage10sec' => '1.3.6.1.4.1.2620.1.16.22.2.1.2',
  'vsxStatusCPUUsage1min' => '1.3.6.1.4.1.2620.1.16.22.2.1.3',
  'vsxStatusCPUUsage1hr' => '1.3.6.1.4.1.2620.1.16.22.2.1.4',
  'vsxStatusCPUUsage24hr' => '1.3.6.1.4.1.2620.1.16.22.2.1.5',
  'vsxStatusCPUUsageVSId' => '1.3.6.1.4.1.2620.1.16.22.2.1.6',
  'vsxCounters' => '1.3.6.1.4.1.2620.1.16.23',
  'vsxCountersTable' => '1.3.6.1.4.1.2620.1.16.23.1',
  'vsxCountersEntry' => '1.3.6.1.4.1.2620.1.16.23.1.1',
  'vsxCountersVSId' => '1.3.6.1.4.1.2620.1.16.23.1.1.1',
  'vsxCountersConnNum' => '1.3.6.1.4.1.2620.1.16.23.1.1.2',
  'vsxCountersConnPeakNum' => '1.3.6.1.4.1.2620.1.16.23.1.1.3',
  'vsxCountersConnTableLimit' => '1.3.6.1.4.1.2620.1.16.23.1.1.4',
  'vsxCountersPackets' => '1.3.6.1.4.1.2620.1.16.23.1.1.5',
  'vsxCountersDroppedTotal' => '1.3.6.1.4.1.2620.1.16.23.1.1.6',
  'vsxCountersAcceptedTotal' => '1.3.6.1.4.1.2620.1.16.23.1.1.7',
  'vsxCountersRejectedTotal' => '1.3.6.1.4.1.2620.1.16.23.1.1.8',
  'vsxCountersBytesAcceptedTotal' => '1.3.6.1.4.1.2620.1.16.23.1.1.9',
  'vsxCountersBytesDroppedTotal' => '1.3.6.1.4.1.2620.1.16.23.1.1.10',
  'vsxCountersBytesRejectedTotal' => '1.3.6.1.4.1.2620.1.16.23.1.1.11',
  'vsxCountersLoggedTotal' => '1.3.6.1.4.1.2620.1.16.23.1.1.12',
  'vsxCountersIsDataValid' => '1.3.6.1.4.1.2620.1.16.23.1.1.13',
  'smartDefense' => '1.3.6.1.4.1.2620.1.17',
  'asmAttacks' => '1.3.6.1.4.1.2620.1.17.1',
  'asmLayer3' => '1.3.6.1.4.1.2620.1.17.1.1',
  'asmLayer4' => '1.3.6.1.4.1.2620.1.17.1.2',
  'asmTCP' => '1.3.6.1.4.1.2620.1.17.1.2.1',
  'asmSynatk' => '1.3.6.1.4.1.2620.1.17.1.2.1.1',
  'asmSynatkSynAckTimeout' => '1.3.6.1.4.1.2620.1.17.1.2.1.1.1',
  'asmSynatkSynAckReset' => '1.3.6.1.4.1.2620.1.17.1.2.1.1.2',
  'asmSynatkModeChange' => '1.3.6.1.4.1.2620.1.17.1.2.1.1.3',
  'asmSynatkCurrentMode' => '1.3.6.1.4.1.2620.1.17.1.2.1.1.4',
  'asmSynatkNumberofunAckedSyns' => '1.3.6.1.4.1.2620.1.17.1.2.1.1.5',
  'asmSmallPmtu' => '1.3.6.1.4.1.2620.1.17.1.2.1.2',
  'smallPMTUNumberOfAttacks' => '1.3.6.1.4.1.2620.1.17.1.2.1.2.1',
  'smallPMTUValueOfMinimalMTUsize' => '1.3.6.1.4.1.2620.1.17.1.2.1.2.2',
  'asmSeqval' => '1.3.6.1.4.1.2620.1.17.1.2.1.3',
  'sequenceVerifierInvalidAck' => '1.3.6.1.4.1.2620.1.17.1.2.1.3.1',
  'sequenceVerifierInvalidSequence' => '1.3.6.1.4.1.2620.1.17.1.2.1.3.2',
  'sequenceVerifierInvalidretransmit' => '1.3.6.1.4.1.2620.1.17.1.2.1.3.3',
  'asmUDP' => '1.3.6.1.4.1.2620.1.17.1.2.2',
  'asmScans' => '1.3.6.1.4.1.2620.1.17.1.2.3',
  'asmHostPortScan' => '1.3.6.1.4.1.2620.1.17.1.2.3.1',
  'numOfhostPortScan' => '1.3.6.1.4.1.2620.1.17.1.2.3.1.1',
  'asmIPSweep' => '1.3.6.1.4.1.2620.1.17.1.2.3.2',
  'numOfIpSweep' => '1.3.6.1.4.1.2620.1.17.1.2.3.2.1',
  'asmLayer5' => '1.3.6.1.4.1.2620.1.17.1.3',
  'asmHTTP' => '1.3.6.1.4.1.2620.1.17.1.3.1',
  'asmHttpWorms' => '1.3.6.1.4.1.2620.1.17.1.3.1.1',
  'httpWorms' => '1.3.6.1.4.1.2620.1.17.1.3.1.1.1',
  'asmHttpFormatViolatoin' => '1.3.6.1.4.1.2620.1.17.1.3.1.2',
  'httpURLLengthViolation' => '1.3.6.1.4.1.2620.1.17.1.3.1.2.1',
  'httpHeaderLengthViolations' => '1.3.6.1.4.1.2620.1.17.1.3.1.2.2',
  'httpMaxHeaderReached' => '1.3.6.1.4.1.2620.1.17.1.3.1.2.3',
  'asmHttpAsciiViolation' => '1.3.6.1.4.1.2620.1.17.1.3.1.3',
  'numOfHttpASCIIViolations' => '1.3.6.1.4.1.2620.1.17.1.3.1.3.1',
  'asmHttpP2PHeaderFilter' => '1.3.6.1.4.1.2620.1.17.1.3.1.4',
  'numOfHttpP2PHeaders' => '1.3.6.1.4.1.2620.1.17.1.3.1.4.1',
  'asmCIFS' => '1.3.6.1.4.1.2620.1.17.1.3.2',
  'asmCIFSWorms' => '1.3.6.1.4.1.2620.1.17.1.3.2.1',
  'numOfCIFSworms' => '1.3.6.1.4.1.2620.1.17.1.3.2.1.1',
  'asmCIFSNullSession' => '1.3.6.1.4.1.2620.1.17.1.3.2.2',
  'numOfCIFSNullSessions' => '1.3.6.1.4.1.2620.1.17.1.3.2.2.1',
  'asmCIFSBlockedPopUps' => '1.3.6.1.4.1.2620.1.17.1.3.2.3',
  'numOfCIFSBlockedPopUps' => '1.3.6.1.4.1.2620.1.17.1.3.2.3.1',
  'asmCIFSBlockedCommands' => '1.3.6.1.4.1.2620.1.17.1.3.2.4',
  'numOfCIFSBlockedCommands' => '1.3.6.1.4.1.2620.1.17.1.3.2.4.1',
  'asmCIFSPasswordLengthViolations' => '1.3.6.1.4.1.2620.1.17.1.3.2.5',
  'numOfCIFSPasswordLengthViolations' => '1.3.6.1.4.1.2620.1.17.1.3.2.5.1',
  'asmP2P' => '1.3.6.1.4.1.2620.1.17.1.3.3',
  'asmP2POtherConAttempts' => '1.3.6.1.4.1.2620.1.17.1.3.3.1',
  'numOfP2POtherConAttempts' => '1.3.6.1.4.1.2620.1.17.1.3.3.1.1',
  'asmP2PKazaaConAttempts' => '1.3.6.1.4.1.2620.1.17.1.3.3.2',
  'numOfP2PKazaaConAttempts' => '1.3.6.1.4.1.2620.1.17.1.3.3.2.1',
  'asmP2PeMuleConAttempts' => '1.3.6.1.4.1.2620.1.17.1.3.3.3',
  'numOfP2PeMuleConAttempts' => '1.3.6.1.4.1.2620.1.17.1.3.3.3.1',
  'asmP2PGnutellaConAttempts' => '1.3.6.1.4.1.2620.1.17.1.3.3.4',
  'numOfGnutellaConAttempts' => '1.3.6.1.4.1.2620.1.17.1.3.3.4.1',
  'asmP2PSkypeCon' => '1.3.6.1.4.1.2620.1.17.1.3.3.5',
  'numOfP2PSkypeCon' => '1.3.6.1.4.1.2620.1.17.1.3.3.5.1',
  'asmP2PBitTorrentCon' => '1.3.6.1.4.1.2620.1.17.1.3.3.6',
  'numOfBitTorrentCon' => '1.3.6.1.4.1.2620.1.17.1.3.3.6.1',
  'avi' => '1.3.6.1.4.1.2620.1.24',
  'aviEngines' => '1.3.6.1.4.1.2620.1.24.1',
  'aviEngineTable' => '1.3.6.1.4.1.2620.1.24.1.1',
  'aviEngineEntry' => '1.3.6.1.4.1.2620.1.24.1.1.1',
  'aviEngineIndex' => '1.3.6.1.4.1.2620.1.24.1.1.1.1',
  'aviEngineName' => '1.3.6.1.4.1.2620.1.24.1.1.1.2',
  'aviEngineVer' => '1.3.6.1.4.1.2620.1.24.1.1.1.3',
  'aviEngineDate' => '1.3.6.1.4.1.2620.1.24.1.1.1.4',
  'aviSignatureName' => '1.3.6.1.4.1.2620.1.24.1.1.1.5',
  'aviSignatureVer' => '1.3.6.1.4.1.2620.1.24.1.1.1.6',
  'aviSignatureDate' => '1.3.6.1.4.1.2620.1.24.1.1.1.7',
  'aviLastSigCheckTime' => '1.3.6.1.4.1.2620.1.24.1.1.1.8',
  'aviLastSigLocation' => '1.3.6.1.4.1.2620.1.24.1.1.1.9',
  'aviLastLicExp' => '1.3.6.1.4.1.2620.1.24.1.1.1.10',
  'aviTopViruses' => '1.3.6.1.4.1.2620.1.24.2',
  'aviTopVirusesTable' => '1.3.6.1.4.1.2620.1.24.2.1',
  'aviTopVirusesEntry' => '1.3.6.1.4.1.2620.1.24.2.1.1',
  'aviTopVirusesIndex' => '1.3.6.1.4.1.2620.1.24.2.1.1.1',
  'aviTopVirusesName' => '1.3.6.1.4.1.2620.1.24.2.1.1.2',
  'aviTopVirusesCnt' => '1.3.6.1.4.1.2620.1.24.2.1.1.3',
  'aviTopEverViruses' => '1.3.6.1.4.1.2620.1.24.3',
  'aviTopEverVirusesTable' => '1.3.6.1.4.1.2620.1.24.3.1',
  'aviTopEverVirusesEntry' => '1.3.6.1.4.1.2620.1.24.3.1.1',
  'aviTopEverVirusesIndex' => '1.3.6.1.4.1.2620.1.24.3.1.1.1',
  'aviTopEverVirusesName' => '1.3.6.1.4.1.2620.1.24.3.1.1.2',
  'aviTopEverVirusesCnt' => '1.3.6.1.4.1.2620.1.24.3.1.1.3',
  'aviServices' => '1.3.6.1.4.1.2620.1.24.4',
  'aviServicesHTTP' => '1.3.6.1.4.1.2620.1.24.4.1',
  'aviHTTPState' => '1.3.6.1.4.1.2620.1.24.4.1.1',
  'aviHTTPLastVirusName' => '1.3.6.1.4.1.2620.1.24.4.1.2',
  'aviHTTPLastVirusTime' => '1.3.6.1.4.1.2620.1.24.4.1.3',
  'aviHTTPTopVirusesTable' => '1.3.6.1.4.1.2620.1.24.4.1.4',
  'aviHTTPTopVirusesEntry' => '1.3.6.1.4.1.2620.1.24.4.1.4.1',
  'aviHTTPTopVirusesIndex' => '1.3.6.1.4.1.2620.1.24.4.1.4.1.1',
  'aviHTTPTopVirusesName' => '1.3.6.1.4.1.2620.1.24.4.1.4.1.2',
  'aviHTTPTopVirusesCnt' => '1.3.6.1.4.1.2620.1.24.4.1.4.1.3',
  'aviServicesFTP' => '1.3.6.1.4.1.2620.1.24.4.2',
  'aviFTPState' => '1.3.6.1.4.1.2620.1.24.4.2.1',
  'aviFTPLastVirusName' => '1.3.6.1.4.1.2620.1.24.4.2.2',
  'aviFTPLastVirusTime' => '1.3.6.1.4.1.2620.1.24.4.2.3',
  'aviFTPTopVirusesTable' => '1.3.6.1.4.1.2620.1.24.4.2.4',
  'aviFTPTopVirusesEntry' => '1.3.6.1.4.1.2620.1.24.4.2.4.1',
  'aviFTPTopVirusesIndex' => '1.3.6.1.4.1.2620.1.24.4.2.4.1.1',
  'aviFTPTopVirusesName' => '1.3.6.1.4.1.2620.1.24.4.2.4.1.2',
  'aviFTPTopVirusesCnt' => '1.3.6.1.4.1.2620.1.24.4.2.4.1.3',
  'aviServicesSMTP' => '1.3.6.1.4.1.2620.1.24.4.3',
  'aviSMTPState' => '1.3.6.1.4.1.2620.1.24.4.3.1',
  'aviSMTPLastVirusName' => '1.3.6.1.4.1.2620.1.24.4.3.2',
  'aviSMTPLastVirusTime' => '1.3.6.1.4.1.2620.1.24.4.3.3',
  'aviSMTPTopVirusesTable' => '1.3.6.1.4.1.2620.1.24.4.3.4',
  'aviSMTPTopVirusesEntry' => '1.3.6.1.4.1.2620.1.24.4.3.4.1',
  'aviSMTPTopVirusesIndex' => '1.3.6.1.4.1.2620.1.24.4.3.4.1.1',
  'aviSMTPTopVirusesName' => '1.3.6.1.4.1.2620.1.24.4.3.4.1.2',
  'aviSMTPTopVirusesCnt' => '1.3.6.1.4.1.2620.1.24.4.3.4.1.3',
  'aviServicesPOP3' => '1.3.6.1.4.1.2620.1.24.4.4',
  'aviPOP3State' => '1.3.6.1.4.1.2620.1.24.4.4.1',
  'aviPOP3LastVirusName' => '1.3.6.1.4.1.2620.1.24.4.4.2',
  'aviPOP3LastVirusTime' => '1.3.6.1.4.1.2620.1.24.4.4.3',
  'aviPOP3TopVirusesTable' => '1.3.6.1.4.1.2620.1.24.4.4.4',
  'aviPOP3TopVirusesEntry' => '1.3.6.1.4.1.2620.1.24.4.4.4.1',
  'aviPOP3TopVirusesIndex' => '1.3.6.1.4.1.2620.1.24.4.4.4.1.1',
  'aviPOP3TopVirusesName' => '1.3.6.1.4.1.2620.1.24.4.4.4.1.2',
  'aviPOP3TopVirusesCnt' => '1.3.6.1.4.1.2620.1.24.4.4.4.1.3',
  'aviStatCode' => '1.3.6.1.4.1.2620.1.24.101',
  'aviStatShortDescr' => '1.3.6.1.4.1.2620.1.24.102',
  'aviStatLongDescr' => '1.3.6.1.4.1.2620.1.24.103',
  'eventiaAnalyzer' => '1.3.6.1.4.1.2620.1.25',
  'cpsemd' => '1.3.6.1.4.1.2620.1.25.1',
  'cpsemdProcAlive' => '1.3.6.1.4.1.2620.1.25.1.1',
  'cpsemdNewEventsHandled' => '1.3.6.1.4.1.2620.1.25.1.2',
  'cpsemdUpdatesHandled' => '1.3.6.1.4.1.2620.1.25.1.3',
  'cpsemdLastEventTime' => '1.3.6.1.4.1.2620.1.25.1.4',
  'cpsemdCurrentDBSize' => '1.3.6.1.4.1.2620.1.25.1.5',
  'cpsemdDBCapacity' => '1.3.6.1.4.1.2620.1.25.1.6',
  'cpsemdNumEvents' => '1.3.6.1.4.1.2620.1.25.1.7',
  'cpsemdDBDiskSpace' => '1.3.6.1.4.1.2620.1.25.1.8',
  'cpsemdCorrelationUnitTable' => '1.3.6.1.4.1.2620.1.25.1.9',
  'cpsemdCorrelationUnitEntry' => '1.3.6.1.4.1.2620.1.25.1.9.1',
  'cpsemdCorrelationUnitIndex' => '1.3.6.1.4.1.2620.1.25.1.9.1.1',
  'cpsemdCorrelationUnitIP' => '1.3.6.1.4.1.2620.1.25.1.9.1.2',
  'cpsemdCorrelationUnitLastRcvdTime' => '1.3.6.1.4.1.2620.1.25.1.9.1.3',
  'cpsemdCorrelationUnitNumEventsRcvd' => '1.3.6.1.4.1.2620.1.25.1.9.1.4',
  'cpsemdConnectionDuration' => '1.3.6.1.4.1.2620.1.25.1.9.1.5',
  'cpsemdDBIsFull' => '1.3.6.1.4.1.2620.1.25.1.10',
  'cpsemdStatCode' => '1.3.6.1.4.1.2620.1.25.1.101',
  'cpsemdStatShortDescr' => '1.3.6.1.4.1.2620.1.25.1.102',
  'cpsemdStatLongDescr' => '1.3.6.1.4.1.2620.1.25.1.103',
  'cpsead' => '1.3.6.1.4.1.2620.1.25.2',
  'cpseadProcAlive' => '1.3.6.1.4.1.2620.1.25.2.1',
  'cpseadConnectedToSem' => '1.3.6.1.4.1.2620.1.25.2.2',
  'cpseadNumProcessedLogs' => '1.3.6.1.4.1.2620.1.25.2.3',
  'cpseadJobsTable' => '1.3.6.1.4.1.2620.1.25.2.4',
  'cpseadJobsEntry' => '1.3.6.1.4.1.2620.1.25.2.4.1',
  'cpseadJobIndex' => '1.3.6.1.4.1.2620.1.25.2.4.1.1',
  'cpseadJobID' => '1.3.6.1.4.1.2620.1.25.2.4.1.2',
  'cpseadJobName' => '1.3.6.1.4.1.2620.1.25.2.4.1.3',
  'cpseadJobState' => '1.3.6.1.4.1.2620.1.25.2.4.1.4',
  'cpseadJobIsOnline' => '1.3.6.1.4.1.2620.1.25.2.4.1.5',
  'cpseadJobLogServer' => '1.3.6.1.4.1.2620.1.25.2.4.1.6',
  'cpseadJobDataType' => '1.3.6.1.4.1.2620.1.25.2.4.1.7',
  'cpseadConnectedToLogServer' => '1.3.6.1.4.1.2620.1.25.2.4.1.8',
  'cpseadNumAnalyzedLogs' => '1.3.6.1.4.1.2620.1.25.2.4.1.9',
  'cpseadFileName' => '1.3.6.1.4.1.2620.1.25.2.4.1.10',
  'cpseadFileCurrentPosition' => '1.3.6.1.4.1.2620.1.25.2.4.1.11',
  'cpseadStateDescriptionCode' => '1.3.6.1.4.1.2620.1.25.2.4.1.12',
  'cpseadStateDescription' => '1.3.6.1.4.1.2620.1.25.2.4.1.13',
  'cpseadNoFreeDiskSpace' => '1.3.6.1.4.1.2620.1.25.2.5',
  'cpseadStatCode' => '1.3.6.1.4.1.2620.1.25.2.101',
  'cpseadStatShortDescr' => '1.3.6.1.4.1.2620.1.25.2.102',
  'cpseadStatLongDescr' => '1.3.6.1.4.1.2620.1.25.2.103',
  'uf' => '1.3.6.1.4.1.2620.1.29',
  'ufEngine' => '1.3.6.1.4.1.2620.1.29.1',
  'ufEngineName' => '1.3.6.1.4.1.2620.1.29.1.1',
  'ufEngineVer' => '1.3.6.1.4.1.2620.1.29.1.2',
  'ufEngineDate' => '1.3.6.1.4.1.2620.1.29.1.3',
  'ufSignatureDate' => '1.3.6.1.4.1.2620.1.29.1.4',
  'ufSignatureVer' => '1.3.6.1.4.1.2620.1.29.1.5',
  'ufLastSigCheckTime' => '1.3.6.1.4.1.2620.1.29.1.6',
  'ufLastSigLocation' => '1.3.6.1.4.1.2620.1.29.1.7',
  'ufLastLicExp' => '1.3.6.1.4.1.2620.1.29.1.8',
  'ufSS' => '1.3.6.1.4.1.2620.1.29.2',
  'ufIsMonitor' => '1.3.6.1.4.1.2620.1.29.2.1',
  'ufScannedCnt' => '1.3.6.1.4.1.2620.1.29.2.2',
  'ufBlockedCnt' => '1.3.6.1.4.1.2620.1.29.2.3',
  'ufTopBlockedCatTable' => '1.3.6.1.4.1.2620.1.29.2.4',
  'ufTopBlockedCatEntry' => '1.3.6.1.4.1.2620.1.29.2.4.1',
  'ufTopBlockedCatIndex' => '1.3.6.1.4.1.2620.1.29.2.4.1.1',
  'ufTopBlockedCatName' => '1.3.6.1.4.1.2620.1.29.2.4.1.2',
  'ufTopBlockedCatCnt' => '1.3.6.1.4.1.2620.1.29.2.4.1.3',
  'ufTopBlockedSiteTable' => '1.3.6.1.4.1.2620.1.29.2.5',
  'ufTopBlockedSiteEntry' => '1.3.6.1.4.1.2620.1.29.2.5.1',
  'ufTopBlockedSiteIndex' => '1.3.6.1.4.1.2620.1.29.2.5.1.1',
  'ufTopBlockedSiteName' => '1.3.6.1.4.1.2620.1.29.2.5.1.2',
  'ufTopBlockedSiteCnt' => '1.3.6.1.4.1.2620.1.29.2.5.1.3',
  'ufTopBlockedUserTable' => '1.3.6.1.4.1.2620.1.29.2.6',
  'ufTopBlockedUserEntry' => '1.3.6.1.4.1.2620.1.29.2.6.1',
  'ufTopBlockedUserIndex' => '1.3.6.1.4.1.2620.1.29.2.6.1.1',
  'ufTopBlockedUserName' => '1.3.6.1.4.1.2620.1.29.2.6.1.2',
  'ufTopBlockedUserCnt' => '1.3.6.1.4.1.2620.1.29.2.6.1.3',
  'ufStatCode' => '1.3.6.1.4.1.2620.1.29.101',
  'ufStatShortDescr' => '1.3.6.1.4.1.2620.1.29.102',
  'ufStatLongDescr' => '1.3.6.1.4.1.2620.1.29.103',
  'ms' => '1.3.6.1.4.1.2620.1.30',
  'msProductName' => '1.3.6.1.4.1.2620.1.30.1',
  'msMajorVersion' => '1.3.6.1.4.1.2620.1.30.2',
  'msMinorVersion' => '1.3.6.1.4.1.2620.1.30.3',
  'msBuildNumber' => '1.3.6.1.4.1.2620.1.30.4',
  'msVersionStr' => '1.3.6.1.4.1.2620.1.30.5',
  'msSpam' => '1.3.6.1.4.1.2620.1.30.6',
  'msSpamNumScannedEmails' => '1.3.6.1.4.1.2620.1.30.6.1',
  'msSpamNumSpamEmails' => '1.3.6.1.4.1.2620.1.30.6.2',
  'msSpamNumHandledSpamEmails' => '1.3.6.1.4.1.2620.1.30.6.3',
  'msSpamControls' => '1.3.6.1.4.1.2620.1.30.6.4',
  'msSpamControlsSpamEngine' => '1.3.6.1.4.1.2620.1.30.6.4.1',
  'msSpamControlsIpRepuatation' => '1.3.6.1.4.1.2620.1.30.6.4.2',
  'msSpamControlsSPF' => '1.3.6.1.4.1.2620.1.30.6.4.3',
  'msSpamControlsDomainKeys' => '1.3.6.1.4.1.2620.1.30.6.4.4',
  'msSpamControlsRDNS' => '1.3.6.1.4.1.2620.1.30.6.4.5',
  'msSpamControlsRBL' => '1.3.6.1.4.1.2620.1.30.6.4.6',
  'msExpirationDate' => '1.3.6.1.4.1.2620.1.30.7',
  'msEngineVer' => '1.3.6.1.4.1.2620.1.30.8',
  'msEngineDate' => '1.3.6.1.4.1.2620.1.30.9',
  'msStatCode' => '1.3.6.1.4.1.2620.1.30.101',
  'msStatShortDescr' => '1.3.6.1.4.1.2620.1.30.102',
  'msStatLongDescr' => '1.3.6.1.4.1.2620.1.30.103',
  'msServicePack' => '1.3.6.1.4.1.2620.1.30.999',
  'voip' => '1.3.6.1.4.1.2620.1.31',
  'voipProductName' => '1.3.6.1.4.1.2620.1.31.1',
  'voipMajorVersion' => '1.3.6.1.4.1.2620.1.31.2',
  'voipMinorVersion' => '1.3.6.1.4.1.2620.1.31.3',
  'voipBuildNumber' => '1.3.6.1.4.1.2620.1.31.4',
  'voipVersionStr' => '1.3.6.1.4.1.2620.1.31.5',
  'voipDOS' => '1.3.6.1.4.1.2620.1.31.6',
  'voipDOSSip' => '1.3.6.1.4.1.2620.1.31.6.1',
  'voipDOSSipNetwork' => '1.3.6.1.4.1.2620.1.31.6.1.1',
  'voipDOSSipNetworkReqInterval' => '1.3.6.1.4.1.2620.1.31.6.1.1.1',
  'voipDOSSipNetworkReqConfThreshold' => '1.3.6.1.4.1.2620.1.31.6.1.1.2',
  'voipDOSSipNetworkReqCurrentVal' => '1.3.6.1.4.1.2620.1.31.6.1.1.3',
  'voipDOSSipNetworkRegInterval' => '1.3.6.1.4.1.2620.1.31.6.1.1.4',
  'voipDOSSipNetworkRegConfThreshold' => '1.3.6.1.4.1.2620.1.31.6.1.1.5',
  'voipDOSSipNetworkRegCurrentVal' => '1.3.6.1.4.1.2620.1.31.6.1.1.6',
  'voipDOSSipNetworkCallInitInterval' => '1.3.6.1.4.1.2620.1.31.6.1.1.7',
  'voipDOSSipNetworkCallInitConfThreshold' => '1.3.6.1.4.1.2620.1.31.6.1.1.8',
  'voipDOSSipNetworkCallInitICurrentVal' => '1.3.6.1.4.1.2620.1.31.6.1.1.9',
  'voipDOSSipRateLimitingTable' => '1.3.6.1.4.1.2620.1.31.6.1.2',
  'voipDOSSipRateLimitingEntry' => '1.3.6.1.4.1.2620.1.31.6.1.2.1',
  'voipDOSSipRateLimitingTableIndex' => '1.3.6.1.4.1.2620.1.31.6.1.2.1.1',
  'voipDOSSipRateLimitingTableIpAddress' => '1.3.6.1.4.1.2620.1.31.6.1.2.1.2',
  'voipDOSSipRateLimitingTableInterval' => '1.3.6.1.4.1.2620.1.31.6.1.2.1.3',
  'voipDOSSipRateLimitingTableConfThreshold' => '1.3.6.1.4.1.2620.1.31.6.1.2.1.4',
  'voipDOSSipRateLimitingTableNumDOSSipRequests' => '1.3.6.1.4.1.2620.1.31.6.1.2.1.5',
  'voipDOSSipRateLimitingTableNumTrustedRequests' => '1.3.6.1.4.1.2620.1.31.6.1.2.1.6',
  'voipDOSSipRateLimitingTableNumNonTrustedRequests' => '1.3.6.1.4.1.2620.1.31.6.1.2.1.7',
  'voipDOSSipRateLimitingTableNumRequestsfromServers' => '1.3.6.1.4.1.2620.1.31.6.1.2.1.8',
  'voipCAC' => '1.3.6.1.4.1.2620.1.31.7',
  'voipCACConcurrentCalls' => '1.3.6.1.4.1.2620.1.31.7.1',
  'voipCACConcurrentCallsConfThreshold' => '1.3.6.1.4.1.2620.1.31.7.1.1',
  'voipCACConcurrentCallsCurrentVal' => '1.3.6.1.4.1.2620.1.31.7.1.2',
  'voipStatCode' => '1.3.6.1.4.1.2620.1.31.101',
  'voipStatShortDescr' => '1.3.6.1.4.1.2620.1.31.102',
  'voipStatLongDescr' => '1.3.6.1.4.1.2620.1.31.103',
  'voipServicePack' => '1.3.6.1.4.1.2620.1.31.999',
  'sxl' => '1.3.6.1.4.1.2620.1.36',
  'fwSXLGroup' => '1.3.6.1.4.1.2620.1.36.1',
  'fwSXLStatus' => '1.3.6.1.4.1.2620.1.36.1.1',
  'fwSXLStatusDefinition' => 'CHECKPOINT-MIB::fwSXLStatus',
  'fwSXLConnsExisting' => '1.3.6.1.4.1.2620.1.36.1.2',
  'fwSXLConnsAdded' => '1.3.6.1.4.1.2620.1.36.1.3',
  'fwSXLConnsDeleted' => '1.3.6.1.4.1.2620.1.36.1.4',
  'identityAwareness' => '1.3.6.1.4.1.2620.1.38',
  'identityAwarenessProductName' => '1.3.6.1.4.1.2620.1.38.1',
  'identityAwarenessAuthUsers' => '1.3.6.1.4.1.2620.1.38.2',
  'identityAwarenessUnAuthUsers' => '1.3.6.1.4.1.2620.1.38.3',
  'identityAwarenessAuthUsersKerberos' => '1.3.6.1.4.1.2620.1.38.4',
  'identityAwarenessAuthMachKerberos' => '1.3.6.1.4.1.2620.1.38.5',
  'identityAwarenessAuthUsersPass' => '1.3.6.1.4.1.2620.1.38.6',
  'identityAwarenessAuthUsersADQuery' => '1.3.6.1.4.1.2620.1.38.7',
  'identityAwarenessAuthMachADQuery' => '1.3.6.1.4.1.2620.1.38.8',
  'identityAwarenessLoggedInAgent' => '1.3.6.1.4.1.2620.1.38.9',
  'identityAwarenessLoggedInCaptivePortal' => '1.3.6.1.4.1.2620.1.38.10',
  'identityAwarenessLoggedInADQuery' => '1.3.6.1.4.1.2620.1.38.11',
  'identityAwarenessAntiSpoffProtection' => '1.3.6.1.4.1.2620.1.38.12',
  'identityAwarenessSuccUserLoginKerberos' => '1.3.6.1.4.1.2620.1.38.13',
  'identityAwarenessSuccMachLoginKerberos' => '1.3.6.1.4.1.2620.1.38.14',
  'identityAwarenessSuccUserLoginPass' => '1.3.6.1.4.1.2620.1.38.15',
  'identityAwarenessSuccUserLoginADQuery' => '1.3.6.1.4.1.2620.1.38.16',
  'identityAwarenessSuccMachLoginADQuery' => '1.3.6.1.4.1.2620.1.38.17',
  'identityAwarenessUnSuccUserLoginKerberos' => '1.3.6.1.4.1.2620.1.38.18',
  'identityAwarenessUnSuccMachLoginKerberos' => '1.3.6.1.4.1.2620.1.38.19',
  'identityAwarenessUnSuccUserLoginPass' => '1.3.6.1.4.1.2620.1.38.20',
  'identityAwarenessSuccUserLDAP' => '1.3.6.1.4.1.2620.1.38.21',
  'identityAwarenessUnSuccUserLDAP' => '1.3.6.1.4.1.2620.1.38.22',
  'identityAwarenessDataTrans' => '1.3.6.1.4.1.2620.1.38.23',
  'identityAwarenessDistributedEnvTable' => '1.3.6.1.4.1.2620.1.38.24',
  'identityAwarenessDistributedEnvEntry' => '1.3.6.1.4.1.2620.1.38.24.1',
  'identityAwarenessDistributedEnvTableIndex' => '1.3.6.1.4.1.2620.1.38.24.1.1',
  'identityAwarenessDistributedEnvTableGwName' => '1.3.6.1.4.1.2620.1.38.24.1.2',
  'identityAwarenessDistributedEnvTableDisconnections' => '1.3.6.1.4.1.2620.1.38.24.1.3',
  'identityAwarenessDistributedEnvTableBruteForceAtt' => '1.3.6.1.4.1.2620.1.38.24.1.4',
  'identityAwarenessDistributedEnvTableStatus' => '1.3.6.1.4.1.2620.1.38.24.1.5',
  'identityAwarenessDistributedEnvTableIsLocal' => '1.3.6.1.4.1.2620.1.38.24.1.6',
  'identityAwarenessADQueryStatusTable' => '1.3.6.1.4.1.2620.1.38.25',
  'identityAwarenessADQueryStatusEntry' => '1.3.6.1.4.1.2620.1.38.25.1',
  'identityAwarenessADQueryStatusTableIndex' => '1.3.6.1.4.1.2620.1.38.25.1.1',
  'identityAwarenessADQueryStatusCurrStatus' => '1.3.6.1.4.1.2620.1.38.25.1.2',
  'identityAwarenessADQueryStatusDomainName' => '1.3.6.1.4.1.2620.1.38.25.1.3',
  'identityAwarenessADQueryStatusDomainIP' => '1.3.6.1.4.1.2620.1.38.25.1.4',
  'identityAwarenessADQueryStatusEvents' => '1.3.6.1.4.1.2620.1.38.25.1.5',
  'identityAwarenessStatus' => '1.3.6.1.4.1.2620.1.38.101',
  'identityAwarenessStatusShortDesc' => '1.3.6.1.4.1.2620.1.38.102',
  'identityAwarenessStatusLongDesc' => '1.3.6.1.4.1.2620.1.38.103',
  'applicationControl' => '1.3.6.1.4.1.2620.1.39',
  'applicationControlSubscription' => '1.3.6.1.4.1.2620.1.39.1',
  'applicationControlSubscriptionStatus' => '1.3.6.1.4.1.2620.1.39.1.1',
  'applicationControlSubscriptionExpDate' => '1.3.6.1.4.1.2620.1.39.1.2',
  'applicationControlSubscriptionDesc' => '1.3.6.1.4.1.2620.1.39.1.3',
  'applicationControlUpdate' => '1.3.6.1.4.1.2620.1.39.2',
  'applicationControlUpdateStatus' => '1.3.6.1.4.1.2620.1.39.2.1',
  'applicationControlUpdateDesc' => '1.3.6.1.4.1.2620.1.39.2.2',
  'applicationControlNextUpdate' => '1.3.6.1.4.1.2620.1.39.2.3',
  'applicationControlVersion' => '1.3.6.1.4.1.2620.1.39.2.4',
  'applicationControlStatusCode' => '1.3.6.1.4.1.2620.1.39.101',
  'applicationControlStatusShortDesc' => '1.3.6.1.4.1.2620.1.39.102',
  'applicationControlStatusLongDesc' => '1.3.6.1.4.1.2620.1.39.103',
  'thresholds' => '1.3.6.1.4.1.2620.1.42',
  'thresholdPolicy' => '1.3.6.1.4.1.2620.1.42.1',
  'thresholdState' => '1.3.6.1.4.1.2620.1.42.2',
  'thresholdStateDesc' => '1.3.6.1.4.1.2620.1.42.3',
  'thresholdEnabled' => '1.3.6.1.4.1.2620.1.42.4',
  'thresholdActive' => '1.3.6.1.4.1.2620.1.42.5',
  'thresholdEventsSinceStartup' => '1.3.6.1.4.1.2620.1.42.6',
  'thresholdActiveEventsTable' => '1.3.6.1.4.1.2620.1.42.7',
  'thresholdActiveEventsEntry' => '1.3.6.1.4.1.2620.1.42.7.1',
  'thresholdActiveEventsIndex' => '1.3.6.1.4.1.2620.1.42.7.1.1',
  'thresholdActiveEventName' => '1.3.6.1.4.1.2620.1.42.7.1.2',
  'thresholdActiveEventCategory' => '1.3.6.1.4.1.2620.1.42.7.1.3',
  'thresholdActiveEventSeverity' => '1.3.6.1.4.1.2620.1.42.7.1.4',
  'thresholdActiveEventSubject' => '1.3.6.1.4.1.2620.1.42.7.1.5',
  'thresholdActiveEventSubjectValue' => '1.3.6.1.4.1.2620.1.42.7.1.6',
  'thresholdActiveEventActivationTime' => '1.3.6.1.4.1.2620.1.42.7.1.7',
  'thresholdActiveEventState' => '1.3.6.1.4.1.2620.1.42.7.1.8',
  'thresholdDestinationsTable' => '1.3.6.1.4.1.2620.1.42.8',
  'thresholdDestinationsEntry' => '1.3.6.1.4.1.2620.1.42.8.1',
  'thresholdDestinationIndex' => '1.3.6.1.4.1.2620.1.42.8.1.1',
  'thresholdDestinationName' => '1.3.6.1.4.1.2620.1.42.8.1.2',
  'thresholdDestinationType' => '1.3.6.1.4.1.2620.1.42.8.1.3',
  'thresholdSendingState' => '1.3.6.1.4.1.2620.1.42.8.1.4',
  'thresholdSendingStateDesc' => '1.3.6.1.4.1.2620.1.42.8.1.5',
  'thresholdAlertCount' => '1.3.6.1.4.1.2620.1.42.8.1.6',
  'thresholdErrorsTable' => '1.3.6.1.4.1.2620.1.42.9',
  'thresholdErrorsEntry' => '1.3.6.1.4.1.2620.1.42.9.1',
  'thresholdErrorIndex' => '1.3.6.1.4.1.2620.1.42.9.1.1',
  'thresholdName' => '1.3.6.1.4.1.2620.1.42.9.1.2',
  'thresholdThresholdOID' => '1.3.6.1.4.1.2620.1.42.9.1.3',
  'thresholdErrorDesc' => '1.3.6.1.4.1.2620.1.42.9.1.4',
  'thresholdErrorTime' => '1.3.6.1.4.1.2620.1.42.9.1.5',
  'advancedUrlFiltering' => '1.3.6.1.4.1.2620.1.43',
  'advancedUrlFilteringSubscription' => '1.3.6.1.4.1.2620.1.43.1',
  'advancedUrlFilteringSubscriptionStatus' => '1.3.6.1.4.1.2620.1.43.1.1',
  'advancedUrlFilteringSubscriptionExpDate' => '1.3.6.1.4.1.2620.1.43.1.2',
  'advancedUrlFilteringSubscriptionDesc' => '1.3.6.1.4.1.2620.1.43.1.3',
  'advancedUrlFilteringUpdate' => '1.3.6.1.4.1.2620.1.43.2',
  'advancedUrlFilteringUpdateStatus' => '1.3.6.1.4.1.2620.1.43.2.1',
  'advancedUrlFilteringUpdateDesc' => '1.3.6.1.4.1.2620.1.43.2.2',
  'advancedUrlFilteringNextUpdate' => '1.3.6.1.4.1.2620.1.43.2.3',
  'advancedUrlFilteringVersion' => '1.3.6.1.4.1.2620.1.43.2.4',
  'advancedUrlFilteringRADStatus' => '1.3.6.1.4.1.2620.1.43.3',
  'advancedUrlFilteringRADStatusCode' => '1.3.6.1.4.1.2620.1.43.3.1',
  'advancedUrlFilteringRADStatusDesc' => '1.3.6.1.4.1.2620.1.43.3.2',
  'advancedUrlFilteringStatusCode' => '1.3.6.1.4.1.2620.1.43.101',
  'advancedUrlFilteringStatusShortDesc' => '1.3.6.1.4.1.2620.1.43.102',
  'advancedUrlFilteringStatusLongDesc' => '1.3.6.1.4.1.2620.1.43.103',
  'dlp' => '1.3.6.1.4.1.2620.1.44',
  'exchangeAgents' => '1.3.6.1.4.1.2620.1.44.1',
  #'exchangeAgentsTable' => '1.3.6.1.4.1.2620.1.44.1.1',
  'exchangeAgentsStatusTable' => '1.3.6.1.4.1.2620.1.44.1.1',
  'exchangeAgentsStatusEntry' => '1.3.6.1.4.1.2620.1.44.1.1.1',
  'exchangeAgentsStatusTableIndex' => '1.3.6.1.4.1.2620.1.44.1.1.1.1',
  'exchangeAgentName' => '1.3.6.1.4.1.2620.1.44.1.1.1.2',
  'exchangeAgentStatus' => '1.3.6.1.4.1.2620.1.44.1.1.1.3',
  'exchangeAgentTotalMsg' => '1.3.6.1.4.1.2620.1.44.1.1.1.4',
  'exchangeAgentTotalScannedMsg' => '1.3.6.1.4.1.2620.1.44.1.1.1.5',
  'exchangeAgentDroppedMsg' => '1.3.6.1.4.1.2620.1.44.1.1.1.6',
  'exchangeAgentUpTime' => '1.3.6.1.4.1.2620.1.44.1.1.1.7',
  'exchangeAgentTimeSinceLastMsg' => '1.3.6.1.4.1.2620.1.44.1.1.1.8',
  'exchangeAgentQueueLen' => '1.3.6.1.4.1.2620.1.44.1.1.1.9',
  'exchangeQueueLen' => '1.3.6.1.4.1.2620.1.44.1.1.1.10',
  'exchangeAgentAvgTimePerMsg' => '1.3.6.1.4.1.2620.1.44.1.1.1.11',
  'exchangeAgentAvgTimePerScannedMsg' => '1.3.6.1.4.1.2620.1.44.1.1.1.12',
  'exchangeAgentVersion' => '1.3.6.1.4.1.2620.1.44.1.1.1.13',
  'exchangeCPUUsage' => '1.3.6.1.4.1.2620.1.44.1.1.1.14',
  'exchangeMemoryUsage' => '1.3.6.1.4.1.2620.1.44.1.1.1.15',
  'exchangeAgentPolicyTimeStamp' => '1.3.6.1.4.1.2620.1.44.1.1.1.16',
  'dlpVersionString' => '1.3.6.1.4.1.2620.1.44.11',
  'dlpLicenseStatus' => '1.3.6.1.4.1.2620.1.44.12',
  'dlpLdapStatus' => '1.3.6.1.4.1.2620.1.44.13',
  'dlpTotalScans' => '1.3.6.1.4.1.2620.1.44.14',
  'dlpSMTPScans' => '1.3.6.1.4.1.2620.1.44.15',
  'dlpSMTPIncidents' => '1.3.6.1.4.1.2620.1.44.16',
  'dlpLastSMTPScan' => '1.3.6.1.4.1.2620.1.44.17',
  'dlpNumQuarantined' => '1.3.6.1.4.1.2620.1.44.18',
  'dlpQrntMsgsSize' => '1.3.6.1.4.1.2620.1.44.19',
  'dlpSentEMails' => '1.3.6.1.4.1.2620.1.44.20',
  'dlpExpiredEMails' => '1.3.6.1.4.1.2620.1.44.21',
  'dlpDiscardEMails' => '1.3.6.1.4.1.2620.1.44.22',
  'dlpPostfixQLen' => '1.3.6.1.4.1.2620.1.44.23',
  'dlpPostfixErrors' => '1.3.6.1.4.1.2620.1.44.24',
  'dlpPostfixQOldMsg' => '1.3.6.1.4.1.2620.1.44.25',
  'dlpPostfixQMsgsSz' => '1.3.6.1.4.1.2620.1.44.26',
  'dlpPostfixQFreeSp' => '1.3.6.1.4.1.2620.1.44.27',
  'dlpQrntFreeSpace' => '1.3.6.1.4.1.2620.1.44.28',
  'dlpQrntStatus' => '1.3.6.1.4.1.2620.1.44.29',
  'dlpHttpScans' => '1.3.6.1.4.1.2620.1.44.30',
  'dlpHttpIncidents' => '1.3.6.1.4.1.2620.1.44.31',
  'dlpHttpLastScan' => '1.3.6.1.4.1.2620.1.44.32',
  'dlpFtpScans' => '1.3.6.1.4.1.2620.1.44.33',
  'dlpFtpIncidents' => '1.3.6.1.4.1.2620.1.44.34',
  'dlpFtpLastScan' => '1.3.6.1.4.1.2620.1.44.35',
  'dlpBypassStatus' => '1.3.6.1.4.1.2620.1.44.36',
  'dlpUserCheckClnts' => '1.3.6.1.4.1.2620.1.44.37',
  'dlpLastPolStatus' => '1.3.6.1.4.1.2620.1.44.38',
  'dlpStatusCode' => '1.3.6.1.4.1.2620.1.44.101',
  'dlpStatusShortDesc' => '1.3.6.1.4.1.2620.1.44.102',
  'dlpStatusLongDesc' => '1.3.6.1.4.1.2620.1.44.103',
  'amw' => '1.3.6.1.4.1.2620.1.46',
  'amwABUpdate' => '1.3.6.1.4.1.2620.1.46.1',
  'amwABUpdateStatus' => '1.3.6.1.4.1.2620.1.46.1.1',
  'amwABUpdateDesc' => '1.3.6.1.4.1.2620.1.46.1.2',
  'amwABNextUpdate' => '1.3.6.1.4.1.2620.1.46.1.3',
  'amwABVersion' => '1.3.6.1.4.1.2620.1.46.1.4',
  'antiBotSubscription' => '1.3.6.1.4.1.2620.1.46.2',
  'antiBotSubscriptionStatus' => '1.3.6.1.4.1.2620.1.46.2.1',
  'antiBotSubscriptionExpDate' => '1.3.6.1.4.1.2620.1.46.2.2',
  'antiBotSubscriptionDesc' => '1.3.6.1.4.1.2620.1.46.2.3',
  'antiVirusSubscription' => '1.3.6.1.4.1.2620.1.46.3',
  'antiVirusSubscriptionStatus' => '1.3.6.1.4.1.2620.1.46.3.1',
  'antiVirusSubscriptionExpDate' => '1.3.6.1.4.1.2620.1.46.3.2',
  'antiVirusSubscriptionDesc' => '1.3.6.1.4.1.2620.1.46.3.3',
  'antiSpamSubscription' => '1.3.6.1.4.1.2620.1.46.4',
  'antiSpamSubscriptionStatus' => '1.3.6.1.4.1.2620.1.46.4.1',
  'antiSpamSubscriptionExpDate' => '1.3.6.1.4.1.2620.1.46.4.2',
  'antiSpamSubscriptionDesc' => '1.3.6.1.4.1.2620.1.46.4.3',
  'amwAVUpdate' => '1.3.6.1.4.1.2620.1.46.5',
  'amwAVUpdateStatus' => '1.3.6.1.4.1.2620.1.46.5.1',
  'amwAVUpdateDesc' => '1.3.6.1.4.1.2620.1.46.5.2',
  'amwAVNextUpdate' => '1.3.6.1.4.1.2620.1.46.5.3',
  'amwAVVersion' => '1.3.6.1.4.1.2620.1.46.5.4',
  'amwStatusCode' => '1.3.6.1.4.1.2620.1.46.101',
  'amwStatusShortDesc' => '1.3.6.1.4.1.2620.1.46.102',
  'amwStatusLongDesc' => '1.3.6.1.4.1.2620.1.46.103',
  'te' => '1.3.6.1.4.1.2620.1.49',
  'teUpdateStatus' => '1.3.6.1.4.1.2620.1.49.16',
  'teUpdateDesc' => '1.3.6.1.4.1.2620.1.49.17',
  'teSubscriptionExpDate' => '1.3.6.1.4.1.2620.1.49.20',
  'teSubscriptionStatus' => '1.3.6.1.4.1.2620.1.49.25',
  'teCloudSubscriptionStatus' => '1.3.6.1.4.1.2620.1.49.26',
  'teSubscriptionDesc' => '1.3.6.1.4.1.2620.1.49.27',
  'teStatusCode' => '1.3.6.1.4.1.2620.1.49.101',
  'teStatusShortDesc' => '1.3.6.1.4.1.2620.1.49.102',
  'teStatusLongDesc' => '1.3.6.1.4.1.2620.1.49.103',
  'tables' => '1.3.6.1.4.1.2620.500',
  'raUsersTable' => '1.3.6.1.4.1.2620.500.9000',
  'raUsersEntry' => '1.3.6.1.4.1.2620.500.9000.1',
  'raInternalIpAddr' => '1.3.6.1.4.1.2620.500.9000.1.1',
  'raExternalIpAddr' => '1.3.6.1.4.1.2620.500.9000.1.19',
  'raUserState' => '1.3.6.1.4.1.2620.500.9000.1.20',
  'raUserStateDefinition' => 'CHECKPOINT-MIB::raUserState',
  'raOfficeMode' => '1.3.6.1.4.1.2620.500.9000.1.21',
  'raIkeOverTCP' => '1.3.6.1.4.1.2620.500.9000.1.22',
  'raUseUDPEncap' => '1.3.6.1.4.1.2620.500.9000.1.23',
  'raVisitorMode' => '1.3.6.1.4.1.2620.500.9000.1.24',
  'raRouteTraffic' => '1.3.6.1.4.1.2620.500.9000.1.25',
  'raCommunity' => '1.3.6.1.4.1.2620.500.9000.1.26',
  'raTunnelEncAlgorithm' => '1.3.6.1.4.1.2620.500.9000.1.27',
  'raTunnelEncAlgorithmDefinition' => 'CHECKPOINT-MIB::raTunnelEncAlgorithm',
  'raTunnelAuthMethod' => '1.3.6.1.4.1.2620.500.9000.1.28',
  'raTunnelAuthMethodDefinition' => 'CHECKPOINT-MIB::raTunnelAuthMethod',
  'raLogonTime' => '1.3.6.1.4.1.2620.500.9000.1.29',
  'tunnelTable' => '1.3.6.1.4.1.2620.500.9002',
  'tunnelEntry' => '1.3.6.1.4.1.2620.500.9002.1',
  'tunnelPeerIpAddr' => '1.3.6.1.4.1.2620.500.9002.1.1',
  'tunnelPeerObjName' => '1.3.6.1.4.1.2620.500.9002.1.2',
  'tunnelState' => '1.3.6.1.4.1.2620.500.9002.1.3',
  'tunnelStateDefinition' => 'CHECKPOINT-MIB::tunnelState',
  'tunnelCommunity' => '1.3.6.1.4.1.2620.500.9002.1.4',
  'tunnelNextHop' => '1.3.6.1.4.1.2620.500.9002.1.5',
  'tunnelInterface' => '1.3.6.1.4.1.2620.500.9002.1.6',
  'tunnelSourceIpAddr' => '1.3.6.1.4.1.2620.500.9002.1.7',
  'tunnelLinkPriority' => '1.3.6.1.4.1.2620.500.9002.1.8',
  'tunnelLinkPriorityDefinition' => 'CHECKPOINT-MIB::tunnelLinkPriority',
  'tunnelProbState' => '1.3.6.1.4.1.2620.500.9002.1.9',
  'tunnelProbStateDefinition' => 'CHECKPOINT-MIB::tunnelProbState',
  'tunnelPeerType' => '1.3.6.1.4.1.2620.500.9002.1.10',
  'tunnelPeerTypeDefinition' => 'CHECKPOINT-MIB::tunnelPeerType',
  'tunnelType' => '1.3.6.1.4.1.2620.500.9002.1.11',
  'tunnelTypeDefinition' => 'CHECKPOINT-MIB::tunnelType',
  'permanentTunnelTable' => '1.3.6.1.4.1.2620.500.9003',
  'permanentTunnelEntry' => '1.3.6.1.4.1.2620.500.9003.1',
  'permanentTunnelPeerIpAddr' => '1.3.6.1.4.1.2620.500.9003.1.1',
  'permanentTunnelPeerObjName' => '1.3.6.1.4.1.2620.500.9003.1.2',
  'permanentTunnelState' => '1.3.6.1.4.1.2620.500.9003.1.3',
  'permanentTunnelStateDefinition' => 'CHECKPOINT-MIB::permanentTunnelState',
  'permanentTunnelCommunity' => '1.3.6.1.4.1.2620.500.9003.1.4',
  'permanentTunnelNextHop' => '1.3.6.1.4.1.2620.500.9003.1.5',
  'permanentTunnelInterface' => '1.3.6.1.4.1.2620.500.9003.1.6',
  'permanentTunnelSourceIpAddr' => '1.3.6.1.4.1.2620.500.9003.1.7',
  'permanentTunnelLinkPriority' => '1.3.6.1.4.1.2620.500.9003.1.8',
  'permanentTunnelLinkPriorityDefinition' => 'CHECKPOINT-MIB::permanentTunnelLinkPriority',
  'permanentTunnelProbState' => '1.3.6.1.4.1.2620.500.9003.1.9',
  'permanentTunnelProbStateDefinition' => 'CHECKPOINT-MIB::permanentTunnelProbState',
  'permanentTunnelPeerType' => '1.3.6.1.4.1.2620.500.9003.1.10',
  'permanentTunnelPeerTypeDefinition' => 'CHECKPOINT-MIB::permanentTunnelPeerType',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CHECKPOINT-MIB'} = {
  raTunnelAuthMethod => {
    '1' => 'preshared-key',
    '2' => 'dss-signature',
    '3' => 'rsa-signature',
    '4' => 'rsa-encryption',
    '5' => 'rev-rsa-encryption',
    '129' => 'xauth',
    '130' => 'crack',
  },
  tunnelType => {
    '1' => 'regular',
    '2' => 'permanent',
  },
  permanentTunnelPeerType => {
    '1' => 'regular',
    '2' => 'daip',
    '3' => 'robo',
  },
  permanentTunnelProbState => {
    '0' => 'unknown',
    '1' => 'alive',
    '2' => 'dead',
  },
  raTunnelEncAlgorithm => {
    '1' => 'espDES',
    '2' => 'esp3DES',
    '5' => 'espCAST',
    '7' => 'esp3IDEA',
    '9' => 'espNULL',
    '129' => 'espAES128',
    '130' => 'espAES256',
  },
  tunnelLinkPriority => {
    '0' => 'primary',
    '1' => 'backup',
    '2' => 'on-demand',
  },
  raUserState => {
    '3' => 'active',
    '4' => 'destroy',
    '129' => 'idle',
    '130' => 'phase1',
    '131' => 'down',
    '132' => 'init',
  },
  permanentTunnelLinkPriority => {
    '0' => 'primary',
    '1' => 'backup',
    '2' => 'on-demand',
  },
  fwSXLStatus => {
    '0' => 'disabled',
    '1' => 'enabled',
  },
  tunnelPeerType => {
    '1' => 'regular',
    '2' => 'daip',
    '3' => 'robo',
  },
  tunnelState => {
    '3' => 'active',
    '4' => 'destroy',
    '129' => 'idle',
    '130' => 'phase1',
    '131' => 'down',
    '132' => 'init',
  },
  permanentTunnelState => {
    '3' => 'active',
    '4' => 'destroy',
    '129' => 'idle',
    '130' => 'phase1',
    '131' => 'down',
    '132' => 'init',
  },
  tunnelProbState => {
    '0' => 'unknown',
    '1' => 'alive',
    '2' => 'dead',
  },
};
package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOBGP4MIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-BGP4-MIB'} = {
  url => '',
  name => 'CISCO-BGP4-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-BGP4-MIB'} = {
  'cbgpPeerAddrFamilyPrefixTable' => '1.3.6.1.4.1.9.9.187.1.2.4',
  'cbgpPeerAddrFamilyPrefixEntry' => '1.3.6.1.4.1.9.9.187.1.2.4.1',
  'cbgpPeerAddrAcceptedPrefixes' => '1.3.6.1.4.1.9.9.187.1.2.4.1.1',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOCCMMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-CCM-MIB'} = {
  url => '',
  name => 'CISCO-CCM-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-CCM-MIB'} = {
  'org' => '1.3',
  'dod' => '1.3.6',
  'internet' => '1.3.6.1',
  'directory' => '1.3.6.1.1',
  'mgmt' => '1.3.6.1.2',
  'experimental' => '1.3.6.1.3',
  'private' => '1.3.6.1.4',
  'enterprises' => '1.3.6.1.4.1',
  'cisco' => '1.3.6.1.4.1.9',
  'ciscoMgmt' => '1.3.6.1.4.1.9.9',
  'ciscoCcmMIB' => '1.3.6.1.4.1.9.9.156',
  'ciscoCcmMIBObjects' => '1.3.6.1.4.1.9.9.156.1',
  'ccmGeneralInfo' => '1.3.6.1.4.1.9.9.156.1.1',
  'ccmGroupTable' => '1.3.6.1.4.1.9.9.156.1.1.1',
  'ccmGroupEntry' => '1.3.6.1.4.1.9.9.156.1.1.1.1',
  'ccmGroupIndex' => '1.3.6.1.4.1.9.9.156.1.1.1.1.1',
  'ccmGroupName' => '1.3.6.1.4.1.9.9.156.1.1.1.1.2',
  'ccmGroupTftpDefault' => '1.3.6.1.4.1.9.9.156.1.1.1.1.3',
  'ccmTable' => '1.3.6.1.4.1.9.9.156.1.1.2',
  'ccmEntry' => '1.3.6.1.4.1.9.9.156.1.1.2.1',
  'ccmIndex' => '1.3.6.1.4.1.9.9.156.1.1.2.1.1',
  'ccmName' => '1.3.6.1.4.1.9.9.156.1.1.2.1.2',
  'ccmDescription' => '1.3.6.1.4.1.9.9.156.1.1.2.1.3',
  'ccmVersion' => '1.3.6.1.4.1.9.9.156.1.1.2.1.4',
  'ccmStatus' => '1.3.6.1.4.1.9.9.156.1.1.2.1.5',
  'ccmStatusDefinition' => {
    '1' => 'unknown',
    '2' => 'up',
    '3' => 'down',
  },
  'ccmInetAddressType' => '1.3.6.1.4.1.9.9.156.1.1.2.1.6',
  'ccmInetAddress' => '1.3.6.1.4.1.9.9.156.1.1.2.1.7',
  'ccmClusterId' => '1.3.6.1.4.1.9.9.156.1.1.2.1.8',
  'ccmInetAddress2Type' => '1.3.6.1.4.1.9.9.156.1.1.2.1.9',
  'ccmInetAddress2' => '1.3.6.1.4.1.9.9.156.1.1.2.1.10',
  'ccmGroupMappingTable' => '1.3.6.1.4.1.9.9.156.1.1.3',
  'ccmGroupMappingEntry' => '1.3.6.1.4.1.9.9.156.1.1.3.1',
  'ccmCMGroupMappingCMPriority' => '1.3.6.1.4.1.9.9.156.1.1.3.1.1',
  'ccmRegionTable' => '1.3.6.1.4.1.9.9.156.1.1.4',
  'ccmRegionEntry' => '1.3.6.1.4.1.9.9.156.1.1.4.1',
  'ccmRegionIndex' => '1.3.6.1.4.1.9.9.156.1.1.4.1.1',
  'ccmRegionName' => '1.3.6.1.4.1.9.9.156.1.1.4.1.2',
  'ccmRegionPairTable' => '1.3.6.1.4.1.9.9.156.1.1.5',
  'ccmRegionPairEntry' => '1.3.6.1.4.1.9.9.156.1.1.5.1',
  'ccmRegionSrcIndex' => '1.3.6.1.4.1.9.9.156.1.1.5.1.1',
  'ccmRegionDestIndex' => '1.3.6.1.4.1.9.9.156.1.1.5.1.2',
  'ccmRegionAvailableBandWidth' => '1.3.6.1.4.1.9.9.156.1.1.5.1.3',
  'ccmTimeZoneTable' => '1.3.6.1.4.1.9.9.156.1.1.6',
  'ccmTimeZoneEntry' => '1.3.6.1.4.1.9.9.156.1.1.6.1',
  'ccmTimeZoneIndex' => '1.3.6.1.4.1.9.9.156.1.1.6.1.1',
  'ccmTimeZoneName' => '1.3.6.1.4.1.9.9.156.1.1.6.1.2',
  'ccmTimeZoneOffset' => '1.3.6.1.4.1.9.9.156.1.1.6.1.3',
  'ccmTimeZoneOffsetHours' => '1.3.6.1.4.1.9.9.156.1.1.6.1.4',
  'ccmTimeZoneOffsetMinutes' => '1.3.6.1.4.1.9.9.156.1.1.6.1.5',
  'ccmDevicePoolTable' => '1.3.6.1.4.1.9.9.156.1.1.7',
  'ccmDevicePoolEntry' => '1.3.6.1.4.1.9.9.156.1.1.7.1',
  'ccmDevicePoolIndex' => '1.3.6.1.4.1.9.9.156.1.1.7.1.1',
  'ccmDevicePoolName' => '1.3.6.1.4.1.9.9.156.1.1.7.1.2',
  'ccmDevicePoolRegionIndex' => '1.3.6.1.4.1.9.9.156.1.1.7.1.3',
  'ccmDevicePoolTimeZoneIndex' => '1.3.6.1.4.1.9.9.156.1.1.7.1.4',
  'ccmDevicePoolGroupIndex' => '1.3.6.1.4.1.9.9.156.1.1.7.1.5',
  'ccmProductTypeTable' => '1.3.6.1.4.1.9.9.156.1.1.8',
  'ccmProductTypeEntry' => '1.3.6.1.4.1.9.9.156.1.1.8.1',
  'ccmProductTypeIndex' => '1.3.6.1.4.1.9.9.156.1.1.8.1.1',
  'ccmProductType' => '1.3.6.1.4.1.9.9.156.1.1.8.1.2',
  'ccmProductName' => '1.3.6.1.4.1.9.9.156.1.1.8.1.3',
  'ccmProductCategory' => '1.3.6.1.4.1.9.9.156.1.1.8.1.4',
  'ccmPhoneInfo' => '1.3.6.1.4.1.9.9.156.1.2',
  'ccmPhoneTable' => '1.3.6.1.4.1.9.9.156.1.2.1',
  'ccmPhoneEntry' => '1.3.6.1.4.1.9.9.156.1.2.1.1',
  'ccmPhoneIndex' => '1.3.6.1.4.1.9.9.156.1.2.1.1.1',
  'ccmPhonePhysicalAddress' => '1.3.6.1.4.1.9.9.156.1.2.1.1.2',
  'ccmPhoneType' => '1.3.6.1.4.1.9.9.156.1.2.1.1.3',
  'ccmPhoneDescription' => '1.3.6.1.4.1.9.9.156.1.2.1.1.4',
  'ccmPhoneUserName' => '1.3.6.1.4.1.9.9.156.1.2.1.1.5',
  'ccmPhoneIpAddress' => '1.3.6.1.4.1.9.9.156.1.2.1.1.6',
  'ccmPhoneStatus' => '1.3.6.1.4.1.9.9.156.1.2.1.1.7',
  'ccmPhoneTimeLastRegistered' => '1.3.6.1.4.1.9.9.156.1.2.1.1.8',
  'ccmPhoneE911Location' => '1.3.6.1.4.1.9.9.156.1.2.1.1.9',
  'ccmPhoneLoadID' => '1.3.6.1.4.1.9.9.156.1.2.1.1.10',
  'ccmPhoneLastError' => '1.3.6.1.4.1.9.9.156.1.2.1.1.11',
  'ccmPhoneTimeLastError' => '1.3.6.1.4.1.9.9.156.1.2.1.1.12',
  'ccmPhoneDevicePoolIndex' => '1.3.6.1.4.1.9.9.156.1.2.1.1.13',
  'ccmPhoneInetAddressType' => '1.3.6.1.4.1.9.9.156.1.2.1.1.14',
  'ccmPhoneInetAddress' => '1.3.6.1.4.1.9.9.156.1.2.1.1.15',
  'ccmPhoneStatusReason' => '1.3.6.1.4.1.9.9.156.1.2.1.1.16',
  'ccmPhoneTimeLastStatusUpdt' => '1.3.6.1.4.1.9.9.156.1.2.1.1.17',
  'ccmPhoneProductTypeIndex' => '1.3.6.1.4.1.9.9.156.1.2.1.1.18',
  'ccmPhoneProtocol' => '1.3.6.1.4.1.9.9.156.1.2.1.1.19',
  'ccmPhoneName' => '1.3.6.1.4.1.9.9.156.1.2.1.1.20',
  'ccmPhoneInetAddressIPv4' => '1.3.6.1.4.1.9.9.156.1.2.1.1.21',
  'ccmPhoneInetAddressIPv6' => '1.3.6.1.4.1.9.9.156.1.2.1.1.22',
  'ccmPhoneIPv4Attribute' => '1.3.6.1.4.1.9.9.156.1.2.1.1.23',
  'ccmPhoneIPv6Attribute' => '1.3.6.1.4.1.9.9.156.1.2.1.1.24',
  'ccmPhoneActiveLoadID' => '1.3.6.1.4.1.9.9.156.1.2.1.1.25',
  'ccmPhoneUnregReason' => '1.3.6.1.4.1.9.9.156.1.2.1.1.26',
  'ccmPhoneRegFailReason' => '1.3.6.1.4.1.9.9.156.1.2.1.1.27',
  'ccmPhoneExtensionTable' => '1.3.6.1.4.1.9.9.156.1.2.2',
  'ccmPhoneExtensionEntry' => '1.3.6.1.4.1.9.9.156.1.2.2.1',
  'ccmPhoneExtensionIndex' => '1.3.6.1.4.1.9.9.156.1.2.2.1.1',
  'ccmPhoneExtension' => '1.3.6.1.4.1.9.9.156.1.2.2.1.2',
  'ccmPhoneExtensionIpAddress' => '1.3.6.1.4.1.9.9.156.1.2.2.1.3',
  'ccmPhoneExtensionMultiLines' => '1.3.6.1.4.1.9.9.156.1.2.2.1.4',
  'ccmPhoneExtensionInetAddressType' => '1.3.6.1.4.1.9.9.156.1.2.2.1.5',
  'ccmPhoneExtensionInetAddress' => '1.3.6.1.4.1.9.9.156.1.2.2.1.6',
  'ccmPhoneFailedTable' => '1.3.6.1.4.1.9.9.156.1.2.3',
  'ccmPhoneFailedEntry' => '1.3.6.1.4.1.9.9.156.1.2.3.1',
  'ccmPhoneFailedIndex' => '1.3.6.1.4.1.9.9.156.1.2.3.1.1',
  'ccmPhoneFailedTime' => '1.3.6.1.4.1.9.9.156.1.2.3.1.2',
  'ccmPhoneFailedName' => '1.3.6.1.4.1.9.9.156.1.2.3.1.3',
  'ccmPhoneFailedInetAddressType' => '1.3.6.1.4.1.9.9.156.1.2.3.1.4',
  'ccmPhoneFailedInetAddress' => '1.3.6.1.4.1.9.9.156.1.2.3.1.5',
  'ccmPhoneFailCauseCode' => '1.3.6.1.4.1.9.9.156.1.2.3.1.6',
  'ccmPhoneFailedMacAddress' => '1.3.6.1.4.1.9.9.156.1.2.3.1.7',
  'ccmPhoneFailedInetAddressIPv4' => '1.3.6.1.4.1.9.9.156.1.2.3.1.8',
  'ccmPhoneFailedInetAddressIPv6' => '1.3.6.1.4.1.9.9.156.1.2.3.1.9',
  'ccmPhoneFailedIPv4Attribute' => '1.3.6.1.4.1.9.9.156.1.2.3.1.10',
  'ccmPhoneFailedIPv6Attribute' => '1.3.6.1.4.1.9.9.156.1.2.3.1.11',
  'ccmPhoneFailedRegFailReason' => '1.3.6.1.4.1.9.9.156.1.2.3.1.12',
  'ccmPhoneStatusUpdateTable' => '1.3.6.1.4.1.9.9.156.1.2.4',
  'ccmPhoneStatusUpdateEntry' => '1.3.6.1.4.1.9.9.156.1.2.4.1',
  'ccmPhoneStatusUpdateIndex' => '1.3.6.1.4.1.9.9.156.1.2.4.1.1',
  'ccmPhoneStatusPhoneIndex' => '1.3.6.1.4.1.9.9.156.1.2.4.1.2',
  'ccmPhoneStatusUpdateTime' => '1.3.6.1.4.1.9.9.156.1.2.4.1.3',
  'ccmPhoneStatusUpdateType' => '1.3.6.1.4.1.9.9.156.1.2.4.1.4',
  'ccmPhoneStatusUpdateReason' => '1.3.6.1.4.1.9.9.156.1.2.4.1.5',
  'ccmPhoneStatusUnregReason' => '1.3.6.1.4.1.9.9.156.1.2.4.1.6',
  'ccmPhoneStatusRegFailReason' => '1.3.6.1.4.1.9.9.156.1.2.4.1.7',
  'ccmPhoneExtnTable' => '1.3.6.1.4.1.9.9.156.1.2.5',
  'ccmPhoneExtnEntry' => '1.3.6.1.4.1.9.9.156.1.2.5.1',
  'ccmPhoneExtnIndex' => '1.3.6.1.4.1.9.9.156.1.2.5.1.1',
  'ccmPhoneExtn' => '1.3.6.1.4.1.9.9.156.1.2.5.1.2',
  'ccmPhoneExtnMultiLines' => '1.3.6.1.4.1.9.9.156.1.2.5.1.3',
  'ccmPhoneExtnInetAddressType' => '1.3.6.1.4.1.9.9.156.1.2.5.1.4',
  'ccmPhoneExtnInetAddress' => '1.3.6.1.4.1.9.9.156.1.2.5.1.5',
  'ccmPhoneExtnStatus' => '1.3.6.1.4.1.9.9.156.1.2.5.1.6',
  'ccmGatewayInfo' => '1.3.6.1.4.1.9.9.156.1.3',
  'ccmGatewayTable' => '1.3.6.1.4.1.9.9.156.1.3.1',
  'ccmGatewayEntry' => '1.3.6.1.4.1.9.9.156.1.3.1.1',
  'ccmGatewayIndex' => '1.3.6.1.4.1.9.9.156.1.3.1.1.1',
  'ccmGatewayName' => '1.3.6.1.4.1.9.9.156.1.3.1.1.2',
  'ccmGatewayType' => '1.3.6.1.4.1.9.9.156.1.3.1.1.3',
  'ccmGatewayDescription' => '1.3.6.1.4.1.9.9.156.1.3.1.1.4',
  'ccmGatewayStatus' => '1.3.6.1.4.1.9.9.156.1.3.1.1.5',
  'ccmGatewayDevicePoolIndex' => '1.3.6.1.4.1.9.9.156.1.3.1.1.6',
  'ccmGatewayInetAddressType' => '1.3.6.1.4.1.9.9.156.1.3.1.1.7',
  'ccmGatewayInetAddress' => '1.3.6.1.4.1.9.9.156.1.3.1.1.8',
  'ccmGatewayProductId' => '1.3.6.1.4.1.9.9.156.1.3.1.1.9',
  'ccmGatewayStatusReason' => '1.3.6.1.4.1.9.9.156.1.3.1.1.10',
  'ccmGatewayTimeLastStatusUpdt' => '1.3.6.1.4.1.9.9.156.1.3.1.1.11',
  'ccmGatewayTimeLastRegistered' => '1.3.6.1.4.1.9.9.156.1.3.1.1.12',
  'ccmGatewayDChannelStatus' => '1.3.6.1.4.1.9.9.156.1.3.1.1.13',
  'ccmGatewayDChannelNumber' => '1.3.6.1.4.1.9.9.156.1.3.1.1.14',
  'ccmGatewayProductTypeIndex' => '1.3.6.1.4.1.9.9.156.1.3.1.1.15',
  'ccmGatewayUnregReason' => '1.3.6.1.4.1.9.9.156.1.3.1.1.16',
  'ccmGatewayRegFailReason' => '1.3.6.1.4.1.9.9.156.1.3.1.1.17',
  'ccmGatewayTrunkInfo' => '1.3.6.1.4.1.9.9.156.1.4',
  'ccmGatewayTrunkTable' => '1.3.6.1.4.1.9.9.156.1.4.1',
  'ccmGatewayTrunkEntry' => '1.3.6.1.4.1.9.9.156.1.4.1.1',
  'ccmGatewayTrunkIndex' => '1.3.6.1.4.1.9.9.156.1.4.1.1.1',
  'ccmGatewayTrunkType' => '1.3.6.1.4.1.9.9.156.1.4.1.1.2',
  'ccmGatewayTrunkName' => '1.3.6.1.4.1.9.9.156.1.4.1.1.3',
  'ccmTrunkGatewayIndex' => '1.3.6.1.4.1.9.9.156.1.4.1.1.4',
  'ccmGatewayTrunkStatus' => '1.3.6.1.4.1.9.9.156.1.4.1.1.5',
  'ccmGlobalInfo' => '1.3.6.1.4.1.9.9.156.1.5',
  'ccmActivePhones' => '1.3.6.1.4.1.9.9.156.1.5.1',
  'ccmInActivePhones' => '1.3.6.1.4.1.9.9.156.1.5.2',
  'ccmActiveGateways' => '1.3.6.1.4.1.9.9.156.1.5.3',
  'ccmInActiveGateways' => '1.3.6.1.4.1.9.9.156.1.5.4',
  'ccmRegisteredPhones' => '1.3.6.1.4.1.9.9.156.1.5.5',
  'ccmUnregisteredPhones' => '1.3.6.1.4.1.9.9.156.1.5.6',
  'ccmRejectedPhones' => '1.3.6.1.4.1.9.9.156.1.5.7',
  'ccmRegisteredGateways' => '1.3.6.1.4.1.9.9.156.1.5.8',
  'ccmUnregisteredGateways' => '1.3.6.1.4.1.9.9.156.1.5.9',
  'ccmRejectedGateways' => '1.3.6.1.4.1.9.9.156.1.5.10',
  'ccmRegisteredMediaDevices' => '1.3.6.1.4.1.9.9.156.1.5.11',
  'ccmUnregisteredMediaDevices' => '1.3.6.1.4.1.9.9.156.1.5.12',
  'ccmRejectedMediaDevices' => '1.3.6.1.4.1.9.9.156.1.5.13',
  'ccmRegisteredCTIDevices' => '1.3.6.1.4.1.9.9.156.1.5.14',
  'ccmUnregisteredCTIDevices' => '1.3.6.1.4.1.9.9.156.1.5.15',
  'ccmRejectedCTIDevices' => '1.3.6.1.4.1.9.9.156.1.5.16',
  'ccmRegisteredVoiceMailDevices' => '1.3.6.1.4.1.9.9.156.1.5.17',
  'ccmUnregisteredVoiceMailDevices' => '1.3.6.1.4.1.9.9.156.1.5.18',
  'ccmRejectedVoiceMailDevices' => '1.3.6.1.4.1.9.9.156.1.5.19',
  'ccmCallManagerStartTime' => '1.3.6.1.4.1.9.9.156.1.5.20',
  'ccmPhoneTableStateId' => '1.3.6.1.4.1.9.9.156.1.5.21',
  'ccmPhoneExtensionTableStateId' => '1.3.6.1.4.1.9.9.156.1.5.22',
  'ccmPhoneStatusUpdateTableStateId' => '1.3.6.1.4.1.9.9.156.1.5.23',
  'ccmGatewayTableStateId' => '1.3.6.1.4.1.9.9.156.1.5.24',
  'ccmCTIDeviceTableStateId' => '1.3.6.1.4.1.9.9.156.1.5.25',
  'ccmCTIDeviceDirNumTableStateId' => '1.3.6.1.4.1.9.9.156.1.5.26',
  'ccmPhStatUpdtTblLastAddedIndex' => '1.3.6.1.4.1.9.9.156.1.5.27',
  'ccmPhFailedTblLastAddedIndex' => '1.3.6.1.4.1.9.9.156.1.5.28',
  'ccmSystemVersion' => '1.3.6.1.4.1.9.9.156.1.5.29',
  'ccmInstallationId' => '1.3.6.1.4.1.9.9.156.1.5.30',
  'ccmPartiallyRegisteredPhones' => '1.3.6.1.4.1.9.9.156.1.5.31',
  'ccmH323TableEntries' => '1.3.6.1.4.1.9.9.156.1.5.32',
  'ccmSIPTableEntries' => '1.3.6.1.4.1.9.9.156.1.5.33',
  'ccmMediaDeviceInfo' => '1.3.6.1.4.1.9.9.156.1.6',
  'ccmMediaDeviceTable' => '1.3.6.1.4.1.9.9.156.1.6.1',
  'ccmMediaDeviceEntry' => '1.3.6.1.4.1.9.9.156.1.6.1.1',
  'ccmMediaDeviceIndex' => '1.3.6.1.4.1.9.9.156.1.6.1.1.1',
  'ccmMediaDeviceName' => '1.3.6.1.4.1.9.9.156.1.6.1.1.2',
  'ccmMediaDeviceType' => '1.3.6.1.4.1.9.9.156.1.6.1.1.3',
  'ccmMediaDeviceDescription' => '1.3.6.1.4.1.9.9.156.1.6.1.1.4',
  'ccmMediaDeviceStatus' => '1.3.6.1.4.1.9.9.156.1.6.1.1.5',
  'ccmMediaDeviceDevicePoolIndex' => '1.3.6.1.4.1.9.9.156.1.6.1.1.6',
  'ccmMediaDeviceInetAddressType' => '1.3.6.1.4.1.9.9.156.1.6.1.1.7',
  'ccmMediaDeviceInetAddress' => '1.3.6.1.4.1.9.9.156.1.6.1.1.8',
  'ccmMediaDeviceStatusReason' => '1.3.6.1.4.1.9.9.156.1.6.1.1.9',
  'ccmMediaDeviceTimeLastStatusUpdt' => '1.3.6.1.4.1.9.9.156.1.6.1.1.10',
  'ccmMediaDeviceTimeLastRegistered' => '1.3.6.1.4.1.9.9.156.1.6.1.1.11',
  'ccmMediaDeviceProductTypeIndex' => '1.3.6.1.4.1.9.9.156.1.6.1.1.12',
  'ccmMediaDeviceInetAddressIPv4' => '1.3.6.1.4.1.9.9.156.1.6.1.1.13',
  'ccmMediaDeviceInetAddressIPv6' => '1.3.6.1.4.1.9.9.156.1.6.1.1.14',
  'ccmMediaDeviceUnregReason' => '1.3.6.1.4.1.9.9.156.1.6.1.1.15',
  'ccmMediaDeviceRegFailReason' => '1.3.6.1.4.1.9.9.156.1.6.1.1.16',
  'ccmGatekeeperInfo' => '1.3.6.1.4.1.9.9.156.1.7',
  'ccmGatekeeperTable' => '1.3.6.1.4.1.9.9.156.1.7.1',
  'ccmGatekeeperEntry' => '1.3.6.1.4.1.9.9.156.1.7.1.1',
  'ccmGatekeeperIndex' => '1.3.6.1.4.1.9.9.156.1.7.1.1.1',
  'ccmGatekeeperName' => '1.3.6.1.4.1.9.9.156.1.7.1.1.2',
  'ccmGatekeeperType' => '1.3.6.1.4.1.9.9.156.1.7.1.1.3',
  'ccmGatekeeperDescription' => '1.3.6.1.4.1.9.9.156.1.7.1.1.4',
  'ccmGatekeeperStatus' => '1.3.6.1.4.1.9.9.156.1.7.1.1.5',
  'ccmGatekeeperDevicePoolIndex' => '1.3.6.1.4.1.9.9.156.1.7.1.1.6',
  'ccmGatekeeperInetAddressType' => '1.3.6.1.4.1.9.9.156.1.7.1.1.7',
  'ccmGatekeeperInetAddress' => '1.3.6.1.4.1.9.9.156.1.7.1.1.8',
  'ccmCTIDeviceInfo' => '1.3.6.1.4.1.9.9.156.1.8',
  'ccmCTIDeviceTable' => '1.3.6.1.4.1.9.9.156.1.8.1',
  'ccmCTIDeviceEntry' => '1.3.6.1.4.1.9.9.156.1.8.1.1',
  'ccmCTIDeviceIndex' => '1.3.6.1.4.1.9.9.156.1.8.1.1.1',
  'ccmCTIDeviceName' => '1.3.6.1.4.1.9.9.156.1.8.1.1.2',
  'ccmCTIDeviceType' => '1.3.6.1.4.1.9.9.156.1.8.1.1.3',
  'ccmCTIDeviceDescription' => '1.3.6.1.4.1.9.9.156.1.8.1.1.4',
  'ccmCTIDeviceStatus' => '1.3.6.1.4.1.9.9.156.1.8.1.1.5',
  'ccmCTIDevicePoolIndex' => '1.3.6.1.4.1.9.9.156.1.8.1.1.6',
  'ccmCTIDeviceInetAddressType' => '1.3.6.1.4.1.9.9.156.1.8.1.1.7',
  'ccmCTIDeviceInetAddress' => '1.3.6.1.4.1.9.9.156.1.8.1.1.8',
  'ccmCTIDeviceAppInfo' => '1.3.6.1.4.1.9.9.156.1.8.1.1.9',
  'ccmCTIDeviceStatusReason' => '1.3.6.1.4.1.9.9.156.1.8.1.1.10',
  'ccmCTIDeviceTimeLastStatusUpdt' => '1.3.6.1.4.1.9.9.156.1.8.1.1.11',
  'ccmCTIDeviceTimeLastRegistered' => '1.3.6.1.4.1.9.9.156.1.8.1.1.12',
  'ccmCTIDeviceProductTypeIndex' => '1.3.6.1.4.1.9.9.156.1.8.1.1.13',
  'ccmCTIDeviceInetAddressIPv4' => '1.3.6.1.4.1.9.9.156.1.8.1.1.14',
  'ccmCTIDeviceInetAddressIPv6' => '1.3.6.1.4.1.9.9.156.1.8.1.1.15',
  'ccmCTIDeviceUnregReason' => '1.3.6.1.4.1.9.9.156.1.8.1.1.16',
  'ccmCTIDeviceRegFailReason' => '1.3.6.1.4.1.9.9.156.1.8.1.1.17',
  'ccmCTIDeviceDirNumTable' => '1.3.6.1.4.1.9.9.156.1.8.2',
  'ccmCTIDeviceDirNumEntry' => '1.3.6.1.4.1.9.9.156.1.8.2.1',
  'ccmCTIDeviceDirNumIndex' => '1.3.6.1.4.1.9.9.156.1.8.2.1.1',
  'ccmCTIDeviceDirNum' => '1.3.6.1.4.1.9.9.156.1.8.2.1.2',
  'ccmAlarmConfigInfo' => '1.3.6.1.4.1.9.9.156.1.9',
  'ccmCallManagerAlarmEnable' => '1.3.6.1.4.1.9.9.156.1.9.1',
  'ccmPhoneFailedAlarmInterval' => '1.3.6.1.4.1.9.9.156.1.9.2',
  'ccmPhoneFailedStorePeriod' => '1.3.6.1.4.1.9.9.156.1.9.3',
  'ccmPhoneStatusUpdateAlarmInterv' => '1.3.6.1.4.1.9.9.156.1.9.4',
  'ccmPhoneStatusUpdateStorePeriod' => '1.3.6.1.4.1.9.9.156.1.9.5',
  'ccmGatewayAlarmEnable' => '1.3.6.1.4.1.9.9.156.1.9.6',
  'ccmMaliciousCallAlarmEnable' => '1.3.6.1.4.1.9.9.156.1.9.7',
  'ccmNotificationsInfo' => '1.3.6.1.4.1.9.9.156.1.10',
  'ccmAlarmSeverity' => '1.3.6.1.4.1.9.9.156.1.10.1',
  'ccmFailCauseCode' => '1.3.6.1.4.1.9.9.156.1.10.2',
  'ccmPhoneFailures' => '1.3.6.1.4.1.9.9.156.1.10.3',
  'ccmPhoneUpdates' => '1.3.6.1.4.1.9.9.156.1.10.4',
  'ccmGatewayFailCauseCode' => '1.3.6.1.4.1.9.9.156.1.10.5',
  'ccmMediaResourceType' => '1.3.6.1.4.1.9.9.156.1.10.6',
  'ccmMediaResourceListName' => '1.3.6.1.4.1.9.9.156.1.10.7',
  'ccmRouteListName' => '1.3.6.1.4.1.9.9.156.1.10.8',
  'ccmGatewayPhysIfIndex' => '1.3.6.1.4.1.9.9.156.1.10.9',
  'ccmGatewayPhysIfL2Status' => '1.3.6.1.4.1.9.9.156.1.10.10',
  'ccmMaliCallCalledPartyName' => '1.3.6.1.4.1.9.9.156.1.10.11',
  'ccmMaliCallCalledPartyNumber' => '1.3.6.1.4.1.9.9.156.1.10.12',
  'ccmMaliCallCalledDeviceName' => '1.3.6.1.4.1.9.9.156.1.10.13',
  'ccmMaliCallCallingPartyName' => '1.3.6.1.4.1.9.9.156.1.10.14',
  'ccmMaliCallCallingPartyNumber' => '1.3.6.1.4.1.9.9.156.1.10.15',
  'ccmMaliCallCallingDeviceName' => '1.3.6.1.4.1.9.9.156.1.10.16',
  'ccmMaliCallTime' => '1.3.6.1.4.1.9.9.156.1.10.17',
  'ccmQualityRprtSourceDevName' => '1.3.6.1.4.1.9.9.156.1.10.18',
  'ccmQualityRprtClusterId' => '1.3.6.1.4.1.9.9.156.1.10.19',
  'ccmQualityRprtCategory' => '1.3.6.1.4.1.9.9.156.1.10.20',
  'ccmQualityRprtReasonCode' => '1.3.6.1.4.1.9.9.156.1.10.21',
  'ccmQualityRprtTime' => '1.3.6.1.4.1.9.9.156.1.10.22',
  'ccmTLSDevName' => '1.3.6.1.4.1.9.9.156.1.10.23',
  'ccmTLSDevInetAddressType' => '1.3.6.1.4.1.9.9.156.1.10.24',
  'ccmTLSDevInetAddress' => '1.3.6.1.4.1.9.9.156.1.10.25',
  'ccmTLSConnFailTime' => '1.3.6.1.4.1.9.9.156.1.10.26',
  'ccmTLSConnectionFailReasonCode' => '1.3.6.1.4.1.9.9.156.1.10.27',
  'ccmGatewayRegFailCauseCode' => '1.3.6.1.4.1.9.9.156.1.10.28',
  'ccmH323DeviceInfo' => '1.3.6.1.4.1.9.9.156.1.11',
  'ccmH323DeviceTable' => '1.3.6.1.4.1.9.9.156.1.11.1',
  'ccmH323DeviceEntry' => '1.3.6.1.4.1.9.9.156.1.11.1.1',
  'ccmH323DevIndex' => '1.3.6.1.4.1.9.9.156.1.11.1.1.1',
  'ccmH323DevName' => '1.3.6.1.4.1.9.9.156.1.11.1.1.2',
  'ccmH323DevProductId' => '1.3.6.1.4.1.9.9.156.1.11.1.1.3',
  'ccmH323DevDescription' => '1.3.6.1.4.1.9.9.156.1.11.1.1.4',
  'ccmH323DevInetAddressType' => '1.3.6.1.4.1.9.9.156.1.11.1.1.5',
  'ccmH323DevInetAddress' => '1.3.6.1.4.1.9.9.156.1.11.1.1.6',
  'ccmH323DevCnfgGKInetAddressType' => '1.3.6.1.4.1.9.9.156.1.11.1.1.7',
  'ccmH323DevCnfgGKInetAddress' => '1.3.6.1.4.1.9.9.156.1.11.1.1.8',
  'ccmH323DevAltGK1InetAddressType' => '1.3.6.1.4.1.9.9.156.1.11.1.1.9',
  'ccmH323DevAltGK1InetAddress' => '1.3.6.1.4.1.9.9.156.1.11.1.1.10',
  'ccmH323DevAltGK2InetAddressType' => '1.3.6.1.4.1.9.9.156.1.11.1.1.11',
  'ccmH323DevAltGK2InetAddress' => '1.3.6.1.4.1.9.9.156.1.11.1.1.12',
  'ccmH323DevAltGK3InetAddressType' => '1.3.6.1.4.1.9.9.156.1.11.1.1.13',
  'ccmH323DevAltGK3InetAddress' => '1.3.6.1.4.1.9.9.156.1.11.1.1.14',
  'ccmH323DevAltGK4InetAddressType' => '1.3.6.1.4.1.9.9.156.1.11.1.1.15',
  'ccmH323DevAltGK4InetAddress' => '1.3.6.1.4.1.9.9.156.1.11.1.1.16',
  'ccmH323DevAltGK5InetAddressType' => '1.3.6.1.4.1.9.9.156.1.11.1.1.17',
  'ccmH323DevAltGK5InetAddress' => '1.3.6.1.4.1.9.9.156.1.11.1.1.18',
  'ccmH323DevActGKInetAddressType' => '1.3.6.1.4.1.9.9.156.1.11.1.1.19',
  'ccmH323DevActGKInetAddress' => '1.3.6.1.4.1.9.9.156.1.11.1.1.20',
  'ccmH323DevStatus' => '1.3.6.1.4.1.9.9.156.1.11.1.1.21',
  'ccmH323DevStatusReason' => '1.3.6.1.4.1.9.9.156.1.11.1.1.22',
  'ccmH323DevTimeLastStatusUpdt' => '1.3.6.1.4.1.9.9.156.1.11.1.1.23',
  'ccmH323DevTimeLastRegistered' => '1.3.6.1.4.1.9.9.156.1.11.1.1.24',
  'ccmH323DevRmtCM1InetAddressType' => '1.3.6.1.4.1.9.9.156.1.11.1.1.25',
  'ccmH323DevRmtCM1InetAddress' => '1.3.6.1.4.1.9.9.156.1.11.1.1.26',
  'ccmH323DevRmtCM2InetAddressType' => '1.3.6.1.4.1.9.9.156.1.11.1.1.27',
  'ccmH323DevRmtCM2InetAddress' => '1.3.6.1.4.1.9.9.156.1.11.1.1.28',
  'ccmH323DevRmtCM3InetAddressType' => '1.3.6.1.4.1.9.9.156.1.11.1.1.29',
  'ccmH323DevRmtCM3InetAddress' => '1.3.6.1.4.1.9.9.156.1.11.1.1.30',
  'ccmH323DevProductTypeIndex' => '1.3.6.1.4.1.9.9.156.1.11.1.1.31',
  'ccmH323DevUnregReason' => '1.3.6.1.4.1.9.9.156.1.11.1.1.32',
  'ccmH323DevRegFailReason' => '1.3.6.1.4.1.9.9.156.1.11.1.1.33',
  'ccmVoiceMailDeviceInfo' => '1.3.6.1.4.1.9.9.156.1.12',
  'ccmVoiceMailDeviceTable' => '1.3.6.1.4.1.9.9.156.1.12.1',
  'ccmVoiceMailDeviceEntry' => '1.3.6.1.4.1.9.9.156.1.12.1.1',
  'ccmVMailDevIndex' => '1.3.6.1.4.1.9.9.156.1.12.1.1.1',
  'ccmVMailDevName' => '1.3.6.1.4.1.9.9.156.1.12.1.1.2',
  'ccmVMailDevProductId' => '1.3.6.1.4.1.9.9.156.1.12.1.1.3',
  'ccmVMailDevDescription' => '1.3.6.1.4.1.9.9.156.1.12.1.1.4',
  'ccmVMailDevStatus' => '1.3.6.1.4.1.9.9.156.1.12.1.1.5',
  'ccmVMailDevInetAddressType' => '1.3.6.1.4.1.9.9.156.1.12.1.1.6',
  'ccmVMailDevInetAddress' => '1.3.6.1.4.1.9.9.156.1.12.1.1.7',
  'ccmVMailDevStatusReason' => '1.3.6.1.4.1.9.9.156.1.12.1.1.8',
  'ccmVMailDevTimeLastStatusUpdt' => '1.3.6.1.4.1.9.9.156.1.12.1.1.9',
  'ccmVMailDevTimeLastRegistered' => '1.3.6.1.4.1.9.9.156.1.12.1.1.10',
  'ccmVMailDevProductTypeIndex' => '1.3.6.1.4.1.9.9.156.1.12.1.1.11',
  'ccmVMailDevUnregReason' => '1.3.6.1.4.1.9.9.156.1.12.1.1.12',
  'ccmVMailDevRegFailReason' => '1.3.6.1.4.1.9.9.156.1.12.1.1.13',
  'ccmVoiceMailDeviceDirNumTable' => '1.3.6.1.4.1.9.9.156.1.12.2',
  'ccmVoiceMailDeviceDirNumEntry' => '1.3.6.1.4.1.9.9.156.1.12.2.1',
  'ccmVMailDevDirNumIndex' => '1.3.6.1.4.1.9.9.156.1.12.2.1.1',
  'ccmVMailDevDirNum' => '1.3.6.1.4.1.9.9.156.1.12.2.1.2',
  'ccmQualityReportAlarmConfigInfo' => '1.3.6.1.4.1.9.9.156.1.13',
  'ccmQualityReportAlarmEnable' => '1.3.6.1.4.1.9.9.156.1.13.1',
  'ccmSIPDeviceInfo' => '1.3.6.1.4.1.9.9.156.1.14',
  'ccmSIPDeviceTable' => '1.3.6.1.4.1.9.9.156.1.14.1',
  'ccmSIPDeviceEntry' => '1.3.6.1.4.1.9.9.156.1.14.1.1',
  'ccmSIPDevIndex' => '1.3.6.1.4.1.9.9.156.1.14.1.1.1',
  'ccmSIPDevName' => '1.3.6.1.4.1.9.9.156.1.14.1.1.2',
  'ccmSIPDevProductTypeIndex' => '1.3.6.1.4.1.9.9.156.1.14.1.1.3',
  'ccmSIPDevDescription' => '1.3.6.1.4.1.9.9.156.1.14.1.1.4',
  'ccmSIPDevInetAddressType' => '1.3.6.1.4.1.9.9.156.1.14.1.1.5',
  'ccmSIPDevInetAddress' => '1.3.6.1.4.1.9.9.156.1.14.1.1.6',
  'ccmSIPInTransportProtocolType' => '1.3.6.1.4.1.9.9.156.1.14.1.1.7',
  'ccmSIPInPortNumber' => '1.3.6.1.4.1.9.9.156.1.14.1.1.8',
  'ccmSIPOutTransportProtocolType' => '1.3.6.1.4.1.9.9.156.1.14.1.1.9',
  'ccmSIPOutPortNumber' => '1.3.6.1.4.1.9.9.156.1.14.1.1.10',
  'ccmSIPDevInetAddressIPv4' => '1.3.6.1.4.1.9.9.156.1.14.1.1.11',
  'ccmSIPDevInetAddressIPv6' => '1.3.6.1.4.1.9.9.156.1.14.1.1.12',
  'ccmMIBNotificationPrefix' => '1.3.6.1.4.1.9.9.156.2',
  'ccmMIBNotifications' => '1.3.6.1.4.1.9.9.156.2',
  'ciscoCcmMIBConformance' => '1.3.6.1.4.1.9.9.156.3',
  'ciscoCcmMIBCompliances' => '1.3.6.1.4.1.9.9.156.3.1',
  'ciscoCcmMIBCompliance' => '1.3.6.1.4.1.9.9.156.3.1.1',
  'ciscoCcmMIBComplianceRev1' => '1.3.6.1.4.1.9.9.156.3.1.2',
  'ciscoCcmMIBComplianceRev2' => '1.3.6.1.4.1.9.9.156.3.1.3',
  'ciscoCcmMIBComplianceRev3' => '1.3.6.1.4.1.9.9.156.3.1.4',
  'ciscoCcmMIBComplianceRev4' => '1.3.6.1.4.1.9.9.156.3.1.5',
  'ciscoCcmMIBComplianceRev5' => '1.3.6.1.4.1.9.9.156.3.1.6',
  'ciscoCcmMIBComplianceRev6' => '1.3.6.1.4.1.9.9.156.3.1.7',
  'ciscoCcmMIBComplianceRev7' => '1.3.6.1.4.1.9.9.156.3.1.8',
  'ciscoCcmMIBGroups' => '1.3.6.1.4.1.9.9.156.3.2',
  'ccmInfoGroup' => '1.3.6.1.4.1.9.9.156.3.2.1',
  'ccmPhoneInfoGroup' => '1.3.6.1.4.1.9.9.156.3.2.2',
  'ccmGatewayInfoGroup' => '1.3.6.1.4.1.9.9.156.3.2.3',
  'ccmInfoGroupRev1' => '1.3.6.1.4.1.9.9.156.3.2.4',
  'ccmPhoneInfoGroupRev1' => '1.3.6.1.4.1.9.9.156.3.2.5',
  'ccmGatewayInfoGroupRev1' => '1.3.6.1.4.1.9.9.156.3.2.6',
  'ccmMediaDeviceInfoGroup' => '1.3.6.1.4.1.9.9.156.3.2.7',
  'ccmGatekeeperInfoGroup' => '1.3.6.1.4.1.9.9.156.3.2.8',
  'ccmCTIDeviceInfoGroup' => '1.3.6.1.4.1.9.9.156.3.2.9',
  'ccmNotificationsInfoGroup' => '1.3.6.1.4.1.9.9.156.3.2.10',
  'ccmNotificationsGroup' => '1.3.6.1.4.1.9.9.156.3.2.11',
  'ccmInfoGroupRev2' => '1.3.6.1.4.1.9.9.156.3.2.12',
  'ccmPhoneInfoGroupRev2' => '1.3.6.1.4.1.9.9.156.3.2.13',
  'ccmGatewayInfoGroupRev2' => '1.3.6.1.4.1.9.9.156.3.2.14',
  'ccmMediaDeviceInfoGroupRev1' => '1.3.6.1.4.1.9.9.156.3.2.15',
  'ccmCTIDeviceInfoGroupRev1' => '1.3.6.1.4.1.9.9.156.3.2.16',
  'ccmH323DeviceInfoGroup' => '1.3.6.1.4.1.9.9.156.3.2.17',
  'ccmVoiceMailDeviceInfoGroup' => '1.3.6.1.4.1.9.9.156.3.2.18',
  'ccmNotificationsInfoGroupRev1' => '1.3.6.1.4.1.9.9.156.3.2.19',
  'ccmInfoGroupRev3' => '1.3.6.1.4.1.9.9.156.3.2.20',
  'ccmNotificationsInfoGroupRev2' => '1.3.6.1.4.1.9.9.156.3.2.21',
  'ccmNotificationsGroupRev1' => '1.3.6.1.4.1.9.9.156.3.2.22',
  'ccmSIPDeviceInfoGroup' => '1.3.6.1.4.1.9.9.156.3.2.23',
  'ccmPhoneInfoGroupRev3' => '1.3.6.1.4.1.9.9.156.3.2.24',
  'ccmGatewayInfoGroupRev3' => '1.3.6.1.4.1.9.9.156.3.2.25',
  'ccmMediaDeviceInfoGroupRev2' => '1.3.6.1.4.1.9.9.156.3.2.26',
  'ccmCTIDeviceInfoGroupRev2' => '1.3.6.1.4.1.9.9.156.3.2.27',
  'ccmH323DeviceInfoGroupRev1' => '1.3.6.1.4.1.9.9.156.3.2.28',
  'ccmVoiceMailDeviceInfoGroupRev1' => '1.3.6.1.4.1.9.9.156.3.2.29',
  'ccmPhoneInfoGroupRev4' => '1.3.6.1.4.1.9.9.156.3.2.30',
  'ccmSIPDeviceInfoGroupRev1' => '1.3.6.1.4.1.9.9.156.3.2.31',
  'ccmNotificationsInfoGroupRev3' => '1.3.6.1.4.1.9.9.156.3.2.32',
  'ccmNotificationsGroupRev2' => '1.3.6.1.4.1.9.9.156.3.2.33',
  'ccmInfoGroupRev4' => '1.3.6.1.4.1.9.9.156.3.2.34',
  'ccmPhoneInfoGroupRev5' => '1.3.6.1.4.1.9.9.156.3.2.35',
  'ccmMediaDeviceInfoGroupRev3' => '1.3.6.1.4.1.9.9.156.3.2.36',
  'ccmSIPDeviceInfoGroupRev2' => '1.3.6.1.4.1.9.9.156.3.2.37',
  'ccmNotificationsInfoGroupRev4' => '1.3.6.1.4.1.9.9.156.3.2.38',
  'ccmH323DeviceInfoGroupRev2' => '1.3.6.1.4.1.9.9.156.3.2.39',
  'ccmCTIDeviceInfoGroupRev3' => '1.3.6.1.4.1.9.9.156.3.2.40',
  'ccmPhoneInfoGroupRev6' => '1.3.6.1.4.1.9.9.156.3.2.41',
  'ccmNotificationsInfoGroupRev5' => '1.3.6.1.4.1.9.9.156.3.2.42',
  'ccmGatewayInfoGroupRev4' => '1.3.6.1.4.1.9.9.156.3.2.43',
  'ccmMediaDeviceInfoGroupRev4' => '1.3.6.1.4.1.9.9.156.3.2.44',
  'ccmCTIDeviceInfoGroupRev4' => '1.3.6.1.4.1.9.9.156.3.2.45',
  'ccmH323DeviceInfoGroupRev3' => '1.3.6.1.4.1.9.9.156.3.2.46',
  'ccmVoiceMailDeviceInfoGroupRev2' => '1.3.6.1.4.1.9.9.156.3.2.47',
  'ccmNotificationsGroupRev3' => '1.3.6.1.4.1.9.9.156.3.2.48',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOCONFIGMANMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-CONFIG-MAN-MIB'} = {
  url => '',
  name => 'CISCO-CONFIG-MAN-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-CONFIG-MAN-MIB'} = {
  'ciscoConfigManMIBObjects' => '1.3.6.1.4.1.9.9.43.1',
  'ccmHistory' => '1.3.6.1.4.1.9.9.43.1.1',
  'ccmHistoryRunningLastChanged' => '1.3.6.1.4.1.9.9.43.1.1.1.0',
  'ccmHistoryRunningLastSaved' => '1.3.6.1.4.1.9.9.43.1.1.2.0',
  'ccmHistoryStartupLastChanged' => '1.3.6.1.4.1.9.9.43.1.1.3.0',
  'ccmHistoryMaxEventEntries' => '1.3.6.1.4.1.9.9.43.1.1.4.0',
  'ccmHistoryEventEntriesBumped' => '1.3.6.1.4.1.9.9.43.1.1.5.0',
  'ccmCLIHistory' => '1.3.6.1.4.1.9.9.43.1.2',
  'ccmCLICfg' => '1.3.6.1.4.1.9.9.43.1.3',
  'ccmCTIDObjects' => '1.3.6.1.4.1.9.9.43.1.4',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOENHANCEDMEMPOOLMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-ENHANCED-MEMPOOL-MIB'} = {
  url => '',
  name => 'CISCO-ENHANCED-MEMPOOL-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'CISCO-ENHANCED-MEMPOOL-MIB'} =
  '1.3.6.1.4.1.9.9.221';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-ENHANCED-MEMPOOL-MIB'} = {
  ciscoEnhancedMemPoolMIB => '1.3.6.1.4.1.9.9.221',
  cempMIBNotifications => '1.3.6.1.4.1.9.9.221.0',
  cempMIBObjects => '1.3.6.1.4.1.9.9.221.1',
  cempMemPool => '1.3.6.1.4.1.9.9.221.1.1',
  cempMemPoolTable => '1.3.6.1.4.1.9.9.221.1.1.1',
  cempMemPoolEntry => '1.3.6.1.4.1.9.9.221.1.1.1.1',
  cempMemPoolIndex => '1.3.6.1.4.1.9.9.221.1.1.1.1.1',
  cempMemPoolType => '1.3.6.1.4.1.9.9.221.1.1.1.1.2',
  cempMemPoolTypeDefinition => 'CISCO-ENHANCED-MEMPOOL-MIB::CempMemPoolTypes',
  cempMemPoolName => '1.3.6.1.4.1.9.9.221.1.1.1.1.3',
  cempMemPoolPlatformMemory => '1.3.6.1.4.1.9.9.221.1.1.1.1.4',
  cempMemPoolAlternate => '1.3.6.1.4.1.9.9.221.1.1.1.1.5',
  cempMemPoolValid => '1.3.6.1.4.1.9.9.221.1.1.1.1.6',
  cempMemPoolUsed => '1.3.6.1.4.1.9.9.221.1.1.1.1.7',
  cempMemPoolFree => '1.3.6.1.4.1.9.9.221.1.1.1.1.8',
  cempMemPoolLargestFree => '1.3.6.1.4.1.9.9.221.1.1.1.1.9',
  cempMemPoolLowestFree => '1.3.6.1.4.1.9.9.221.1.1.1.1.10',
  cempMemPoolUsedLowWaterMark => '1.3.6.1.4.1.9.9.221.1.1.1.1.11',
  cempMemPoolAllocHit => '1.3.6.1.4.1.9.9.221.1.1.1.1.12',
  cempMemPoolAllocMiss => '1.3.6.1.4.1.9.9.221.1.1.1.1.13',
  cempMemPoolFreeHit => '1.3.6.1.4.1.9.9.221.1.1.1.1.14',
  cempMemPoolFreeMiss => '1.3.6.1.4.1.9.9.221.1.1.1.1.15',
  cempMemPoolShared => '1.3.6.1.4.1.9.9.221.1.1.1.1.16',
  cempMemPoolUsedOvrflw => '1.3.6.1.4.1.9.9.221.1.1.1.1.17',
  cempMemPoolHCUsed => '1.3.6.1.4.1.9.9.221.1.1.1.1.18',
  cempMemPoolFreeOvrflw => '1.3.6.1.4.1.9.9.221.1.1.1.1.19',
  cempMemPoolHCFree => '1.3.6.1.4.1.9.9.221.1.1.1.1.20',
  cempMemPoolLargestFreeOvrflw => '1.3.6.1.4.1.9.9.221.1.1.1.1.21',
  cempMemPoolHCLargestFree => '1.3.6.1.4.1.9.9.221.1.1.1.1.22',
  cempMemPoolLowestFreeOvrflw => '1.3.6.1.4.1.9.9.221.1.1.1.1.23',
  cempMemPoolHCLowestFree => '1.3.6.1.4.1.9.9.221.1.1.1.1.24',
  cempMemPoolUsedLowWaterMarkOvrflw => '1.3.6.1.4.1.9.9.221.1.1.1.1.25',
  cempMemPoolHCUsedLowWaterMark => '1.3.6.1.4.1.9.9.221.1.1.1.1.26',
  cempMemPoolSharedOvrflw => '1.3.6.1.4.1.9.9.221.1.1.1.1.27',
  cempMemPoolHCShared => '1.3.6.1.4.1.9.9.221.1.1.1.1.28',
  cempMemBufferPoolTable => '1.3.6.1.4.1.9.9.221.1.1.2',
  cempMemBufferPoolEntry => '1.3.6.1.4.1.9.9.221.1.1.2.1',
  cempMemBufferPoolIndex => '1.3.6.1.4.1.9.9.221.1.1.2.1.1',
  cempMemBufferMemPoolIndex => '1.3.6.1.4.1.9.9.221.1.1.2.1.2',
  cempMemBufferName => '1.3.6.1.4.1.9.9.221.1.1.2.1.3',
  cempMemBufferDynamic => '1.3.6.1.4.1.9.9.221.1.1.2.1.4',
  cempMemBufferSize => '1.3.6.1.4.1.9.9.221.1.1.2.1.5',
  cempMemBufferMin => '1.3.6.1.4.1.9.9.221.1.1.2.1.6',
  cempMemBufferMax => '1.3.6.1.4.1.9.9.221.1.1.2.1.7',
  cempMemBufferPermanent => '1.3.6.1.4.1.9.9.221.1.1.2.1.8',
  cempMemBufferTransient => '1.3.6.1.4.1.9.9.221.1.1.2.1.9',
  cempMemBufferTotal => '1.3.6.1.4.1.9.9.221.1.1.2.1.10',
  cempMemBufferFree => '1.3.6.1.4.1.9.9.221.1.1.2.1.11',
  cempMemBufferHit => '1.3.6.1.4.1.9.9.221.1.1.2.1.12',
  cempMemBufferMiss => '1.3.6.1.4.1.9.9.221.1.1.2.1.13',
  cempMemBufferFreeHit => '1.3.6.1.4.1.9.9.221.1.1.2.1.14',
  cempMemBufferFreeMiss => '1.3.6.1.4.1.9.9.221.1.1.2.1.15',
  cempMemBufferPermChange => '1.3.6.1.4.1.9.9.221.1.1.2.1.16',
  cempMemBufferPeak => '1.3.6.1.4.1.9.9.221.1.1.2.1.17',
  cempMemBufferPeakTime => '1.3.6.1.4.1.9.9.221.1.1.2.1.18',
  cempMemBufferTrim => '1.3.6.1.4.1.9.9.221.1.1.2.1.19',
  cempMemBufferGrow => '1.3.6.1.4.1.9.9.221.1.1.2.1.20',
  cempMemBufferFailures => '1.3.6.1.4.1.9.9.221.1.1.2.1.21',
  cempMemBufferNoStorage => '1.3.6.1.4.1.9.9.221.1.1.2.1.22',
  cempMemBufferCachePoolTable => '1.3.6.1.4.1.9.9.221.1.1.3',
  cempMemBufferCachePoolEntry => '1.3.6.1.4.1.9.9.221.1.1.3.1',
  cempMemBufferCacheSize => '1.3.6.1.4.1.9.9.221.1.1.3.1.1',
  cempMemBufferCacheTotal => '1.3.6.1.4.1.9.9.221.1.1.3.1.2',
  cempMemBufferCacheUsed => '1.3.6.1.4.1.9.9.221.1.1.3.1.3',
  cempMemBufferCacheHit => '1.3.6.1.4.1.9.9.221.1.1.3.1.4',
  cempMemBufferCacheMiss => '1.3.6.1.4.1.9.9.221.1.1.3.1.5',
  cempMemBufferCacheThreshold => '1.3.6.1.4.1.9.9.221.1.1.3.1.6',
  cempMemBufferCacheThresholdCount => '1.3.6.1.4.1.9.9.221.1.1.3.1.7',
  cempNotificationConfig => '1.3.6.1.4.1.9.9.221.1.2',
  cempMemBufferNotifyEnabled => '1.3.6.1.4.1.9.9.221.1.2.1',
  cempMIBConformance => '1.3.6.1.4.1.9.9.221.3',
  cempMIBCompliances => '1.3.6.1.4.1.9.9.221.3.1',
  cempMIBGroups => '1.3.6.1.4.1.9.9.221.3.2',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCO-ENHANCED-MEMPOOL-MIB'} = {
  CempMemPoolTypes => {
    '1' => 'other',
    '2' => 'processorMemory',
    '3' => 'ioMemory',
    '4' => 'pciMemory',
    '5' => 'fastMemory',
    '6' => 'multibusMemory',
    '7' => 'interruptStackMemory',
    '8' => 'processStackMemory',
    '9' => 'localExceptionMemory',
    '10' => 'virtualMemory',
    '11' => 'reservedMemory',
    '12' => 'imageMemory',
    '13' => 'asicMemory',
    '14' => 'posixMemory',
  },
};
package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOENTITYALARMMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-ENTITY-ALARM-MIB'} = {
  url => '',
  name => 'CISCO-ENTITY-ALARM-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'CISCO-ENTITY-ALARM-MIB'} = 
  '1.3.6.1.4.1.9.9.138.1';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-ENTITY-ALARM-MIB'} = {
  'ciscoEntityAlarmMIBObjects' => '1.3.6.1.4.1.9.9.138.1',
  'ceAlarmDescription' => '1.3.6.1.4.1.9.9.138.1.1',
  'ceAlarmDescrMapTable' => '1.3.6.1.4.1.9.9.138.1.1.1',
  'ceAlarmDescrMapEntry' => '1.3.6.1.4.1.9.9.138.1.1.1.1',
  'ceAlarmDescrIndex' => '1.3.6.1.4.1.9.9.138.1.1.1.1.1',
  'ceAlarmDescrVendorType' => '1.3.6.1.4.1.9.9.138.1.1.1.1.2',
  'ceAlarmDescrTable' => '1.3.6.1.4.1.9.9.138.1.1.2',
  'ceAlarmDescrEntry' => '1.3.6.1.4.1.9.9.138.1.1.2.1',
  'ceAlarmDescrAlarmType' => '1.3.6.1.4.1.9.9.138.1.1.2.1.1',
  'ceAlarmDescrSeverity' => '1.3.6.1.4.1.9.9.138.1.1.2.1.2',
  'ceAlarmDescrSeverityDefinition' => 'CISCO-ENTITY-ALARM-MIB::AlarmSeverityOrZero',
  'ceAlarmDescrText' => '1.3.6.1.4.1.9.9.138.1.1.2.1.3',
  'ceAlarmMonitoring' => '1.3.6.1.4.1.9.9.138.1.2',
  'ceAlarmCriticalCount' => '1.3.6.1.4.1.9.9.138.1.2.1.0',
  'ceAlarmMajorCount' => '1.3.6.1.4.1.9.9.138.1.2.2.0',
  'ceAlarmMinorCount' => '1.3.6.1.4.1.9.9.138.1.2.3.0',
  'ceAlarmCutOff' => '1.3.6.1.4.1.9.9.138.1.2.4.0',
  'ceAlarmTable' => '1.3.6.1.4.1.9.9.138.1.2.5',
  'ceAlarmEntry' => '1.3.6.1.4.1.9.9.138.1.2.5.1',
  'ceAlarmFilterProfile' => '1.3.6.1.4.1.9.9.138.1.2.5.1.1',
  'ceAlarmSeverity' => '1.3.6.1.4.1.9.9.138.1.2.5.1.2',
  'ceAlarmSeverityDefinition' => 'CISCO-ENTITY-ALARM-MIB::AlarmSeverityOrZero',
  'ceAlarmList' => '1.3.6.1.4.1.9.9.138.1.2.5.1.3',
  'ceAlarmHistory' => '1.3.6.1.4.1.9.9.138.1.3',
  'ceAlarmHistTableSize' => '1.3.6.1.4.1.9.9.138.1.3.1.0',
  'ceAlarmHistLastIndex' => '1.3.6.1.4.1.9.9.138.1.3.2.0',
  'ceAlarmHistTable' => '1.3.6.1.4.1.9.9.138.1.3.3',
  'ceAlarmHistEntry' => '1.3.6.1.4.1.9.9.138.1.3.3.1',
  'ceAlarmHistIndex' => '1.3.6.1.4.1.9.9.138.1.3.3.1.1',
  'ceAlarmHistType' => '1.3.6.1.4.1.9.9.138.1.3.3.1.2',
  'ceAlarmHistTypeDefinition' => {
    '1' => 'asserted',
    '2' => 'cleared',
  },
  'ceAlarmHistEntPhysicalIndex' => '1.3.6.1.4.1.9.9.138.1.3.3.1.3',
  'ceAlarmHistAlarmType' => '1.3.6.1.4.1.9.9.138.1.3.3.1.4',
  'ceAlarmHistSeverity' => '1.3.6.1.4.1.9.9.138.1.3.3.1.5',
  'ceAlarmHistSeverityDefinition' => 'CISCO-ENTITY-ALARM-MIB::AlarmSeverityOrZero',
  'ceAlarmHistTimeStamp' => '1.3.6.1.4.1.9.9.138.1.3.3.1.6',
  'ceAlarmFiltering' => '1.3.6.1.4.1.9.9.138.1.4',
  'ceAlarmNotifiesEnable' => '1.3.6.1.4.1.9.9.138.1.4.1.0',
  'ceAlarmSyslogEnable' => '1.3.6.1.4.1.9.9.138.1.4.2.0',
  'ceAlarmFilterProfileIndexNext' => '1.3.6.1.4.1.9.9.138.1.4.3.0',
  'ceAlarmFilterProfileTable' => '1.3.6.1.4.1.9.9.138.1.4.4',
  'ceAlarmFilterProfileEntry' => '1.3.6.1.4.1.9.9.138.1.4.4.1',
  'ceAlarmFilterIndex' => '1.3.6.1.4.1.9.9.138.1.4.4.1.1',
  'ceAlarmFilterStatus' => '1.3.6.1.4.1.9.9.138.1.4.4.1.2',
  'ceAlarmFilterAlias' => '1.3.6.1.4.1.9.9.138.1.4.4.1.3',
  'ceAlarmFilterAlarmsEnabled' => '1.3.6.1.4.1.9.9.138.1.4.4.1.4',
  'ceAlarmFilterNotifiesEnabled' => '1.3.6.1.4.1.9.9.138.1.4.4.1.5',
  'ceAlarmFilterSyslogEnabled' => '1.3.6.1.4.1.9.9.138.1.4.4.1.6',
  'ciscoEntityAlarmMIBNotificationsPrefix' => '1.3.6.1.4.1.9.9.138.2',
  'ciscoEntityAlarmMIBNotifications' => '1.3.6.1.4.1.9.9.138.2.0',
  'ceAlarmAsserted' => '1.3.6.1.4.1.9.9.138.2.0.1',
  'ceAlarmCleared' => '1.3.6.1.4.1.9.9.138.2.0.2',
  'ciscoEntityAlarmMIBConformance' => '1.3.6.1.4.1.9.9.138.3',
  'ciscoEntityAlarmMIBCompliances' => '1.3.6.1.4.1.9.9.138.3.1',
  'ciscoEntityAlarmMIBGroups' => '1.3.6.1.4.1.9.9.138.3.2',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCO-ENTITY-ALARM-MIB'} = {
  'AlarmSeverity' => {
    '1' => 'critical',
    '2' => 'major',
    '3' => 'minor',
    '4' => 'info',
  },
  'AlarmSeverityOrZero' => {
    '0' => 'none',
    '1' => 'critical',
    '2' => 'major',
    '3' => 'minor',
    '4' => 'info',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOENTITYFRUCONTROLMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-ENTITY-FRU-CONTROL-MIB'} = {
  url => '',
  name => 'CISCO-ENTITY-FRU-CONTROL-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'CISCO-ENTITY-FRU-CONTROL-MIB'} = 
  '1.3.6.1.4.1.9.9.117.1';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-ENTITY-FRU-CONTROL-MIB'} = {
  'cefcMIBObjects' => '1.3.6.1.4.1.9.9.117.1',
  'cefcFRUPower' => '1.3.6.1.4.1.9.9.117.1.1',
  'cefcFRUPowerSupplyGroupTable' => '1.3.6.1.4.1.9.9.117.1.1.1',
  'cefcFRUPowerSupplyGroupEntry' => '1.3.6.1.4.1.9.9.117.1.1.1.1',
  'cefcPowerRedundancyMode' => '1.3.6.1.4.1.9.9.117.1.1.1.1.1',
  'cefcPowerRedundancyModeDefinition' => 'CISCO-ENTITY-FRU-CONTROL-MIB::PowerRedundancyType',
  'cefcPowerUnits' => '1.3.6.1.4.1.9.9.117.1.1.1.1.2',
  'cefcTotalAvailableCurrent' => '1.3.6.1.4.1.9.9.117.1.1.1.1.3',
  'cefcTotalDrawnCurrent' => '1.3.6.1.4.1.9.9.117.1.1.1.1.4',
  'cefcPowerRedundancyOperMode' => '1.3.6.1.4.1.9.9.117.1.1.1.1.5',
  'cefcPowerRedundancyOperModeDefinition' => 'CISCO-ENTITY-FRU-CONTROL-MIB::PowerRedundancyType',
  'cefcPowerNonRedundantReason' => '1.3.6.1.4.1.9.9.117.1.1.1.1.6',
  'cefcPowerNonRedundantReasonDefinition' => 'CISCO-ENTITY-FRU-CONTROL-MIB::PowerRedundancyType',
  'cefcTotalDrawnInlineCurrent' => '1.3.6.1.4.1.9.9.117.1.1.1.1.7',
  'cefcFRUPowerStatusTable' => '1.3.6.1.4.1.9.9.117.1.1.2',
  'cefcFRUPowerStatusEntry' => '1.3.6.1.4.1.9.9.117.1.1.2.1',
  'cefcFRUPowerAdminStatus' => '1.3.6.1.4.1.9.9.117.1.1.2.1.1',
  'cefcFRUPowerAdminStatusDefinition' => 'CISCO-ENTITY-FRU-CONTROL-MIB::PowerAdminType',
  'cefcFRUPowerOperStatus' => '1.3.6.1.4.1.9.9.117.1.1.2.1.2',
  'cefcFRUPowerOperStatusDefinition' => 'CISCO-ENTITY-FRU-CONTROL-MIB::PowerOperType',
  'cefcFRUCurrent' => '1.3.6.1.4.1.9.9.117.1.1.2.1.3',
  'cefcFRUPowerCapability' => '1.3.6.1.4.1.9.9.117.1.1.2.1.4',
  'cefcFRURealTimeCurrent' => '1.3.6.1.4.1.9.9.117.1.1.2.1.5',
  'cefcMaxDefaultInLinePower' => '1.3.6.1.4.1.9.9.117.1.1.3.0',
  'cefcFRUPowerSupplyValueTable' => '1.3.6.1.4.1.9.9.117.1.1.4',
  'cefcFRUPowerSupplyValueEntry' => '1.3.6.1.4.1.9.9.117.1.1.4.1',
  'cefcFRUTotalSystemCurrent' => '1.3.6.1.4.1.9.9.117.1.1.4.1.1',
  'cefcFRUDrawnSystemCurrent' => '1.3.6.1.4.1.9.9.117.1.1.4.1.2',
  'cefcFRUTotalInlineCurrent' => '1.3.6.1.4.1.9.9.117.1.1.4.1.3',
  'cefcFRUDrawnInlineCurrent' => '1.3.6.1.4.1.9.9.117.1.1.4.1.4',
  'cefcMaxDefaultHighInLinePower' => '1.3.6.1.4.1.9.9.117.1.1.5.0',
  'cefcModule' => '1.3.6.1.4.1.9.9.117.1.2',
  'cefcModuleTable' => '1.3.6.1.4.1.9.9.117.1.2.1',
  'cefcModuleEntry' => '1.3.6.1.4.1.9.9.117.1.2.1.1',
  'cefcModuleAdminStatus' => '1.3.6.1.4.1.9.9.117.1.2.1.1.1',
  'cefcModuleAdminStatusDefinition' => 'CISCO-ENTITY-FRU-CONTROL-MIB::ModuleAdminType',
  'cefcModuleOperStatus' => '1.3.6.1.4.1.9.9.117.1.2.1.1.2',
  'cefcModuleOperStatusDefinition' => 'CISCO-ENTITY-FRU-CONTROL-MIB::ModuleOperType',
  'cefcModuleResetReason' => '1.3.6.1.4.1.9.9.117.1.2.1.1.3',
  'cefcModuleStatusLastChangeTime' => '1.3.6.1.4.1.9.9.117.1.2.1.1.4',
  'cefcModuleLastClearConfigTime' => '1.3.6.1.4.1.9.9.117.1.2.1.1.5',
  'cefcModuleResetReasonDescription' => '1.3.6.1.4.1.9.9.117.1.2.1.1.6',
  'cefcModuleStateChangeReasonDescr' => '1.3.6.1.4.1.9.9.117.1.2.1.1.7',
  'cefcModuleUpTime' => '1.3.6.1.4.1.9.9.117.1.2.1.1.8',
  'cefcIntelliModuleTable' => '1.3.6.1.4.1.9.9.117.1.2.2',
  'cefcIntelliModuleEntry' => '1.3.6.1.4.1.9.9.117.1.2.2.1',
  'cefcIntelliModuleIPAddrType' => '1.3.6.1.4.1.9.9.117.1.2.2.1.1',
  'cefcIntelliModuleIPAddr' => '1.3.6.1.4.1.9.9.117.1.2.2.1.2',
  'cefcModuleLocalSwitchingTable' => '1.3.6.1.4.1.9.9.117.1.2.3',
  'cefcModuleLocalSwitchingEntry' => '1.3.6.1.4.1.9.9.117.1.2.3.1',
  'cefcModuleLocalSwitchingMode' => '1.3.6.1.4.1.9.9.117.1.2.3.1.1',
  'cefcMIBNotificationEnables' => '1.3.6.1.4.1.9.9.117.1.3',
  'cefcMIBEnableStatusNotification' => '1.3.6.1.4.1.9.9.117.1.3.1.0',
  'cefcEnablePSOutputChangeNotif' => '1.3.6.1.4.1.9.9.117.1.3.2.0',
  'cefcFRUFan' => '1.3.6.1.4.1.9.9.117.1.4',
  'cefcFanTrayStatusTable' => '1.3.6.1.4.1.9.9.117.1.4.1',
  'cefcFanTrayStatusEntry' => '1.3.6.1.4.1.9.9.117.1.4.1.1',
  'cefcFanTrayOperStatus' => '1.3.6.1.4.1.9.9.117.1.4.1.1.1',
  'cefcFanTrayOperStatusDefinition' => {
    '1' => 'unknown',
    '2' => 'up',
    '3' => 'down',
    '4' => 'warning',
  },
  'cefcPhysical' => '1.3.6.1.4.1.9.9.117.1.5',
  'cefcPhysicalTable' => '1.3.6.1.4.1.9.9.117.1.5.1',
  'cefcPhysicalEntry' => '1.3.6.1.4.1.9.9.117.1.5.1.1',
  'cefcPhysicalStatus' => '1.3.6.1.4.1.9.9.117.1.5.1.1.1',
  'cefcPowerCapacity' => '1.3.6.1.4.1.9.9.117.1.6',
  'cefcPowerSupplyInputTable' => '1.3.6.1.4.1.9.9.117.1.6.1',
  'cefcPowerSupplyInputEntry' => '1.3.6.1.4.1.9.9.117.1.6.1.1',
  'cefcPowerSupplyInputIndex' => '1.3.6.1.4.1.9.9.117.1.6.1.1.1',
  'cefcPowerSupplyInputType' => '1.3.6.1.4.1.9.9.117.1.6.1.1.2',
  'cefcPowerSupplyOutputTable' => '1.3.6.1.4.1.9.9.117.1.6.2',
  'cefcPowerSupplyOutputEntry' => '1.3.6.1.4.1.9.9.117.1.6.2.1',
  'cefcPSOutputModeIndex' => '1.3.6.1.4.1.9.9.117.1.6.2.1.1',
  'cefcPSOutputModeCurrent' => '1.3.6.1.4.1.9.9.117.1.6.2.1.2',
  'cefcPSOutputModeInOperation' => '1.3.6.1.4.1.9.9.117.1.6.2.1.3',
  'cefcCooling' => '1.3.6.1.4.1.9.9.117.1.7',
  'cefcChassisCoolingTable' => '1.3.6.1.4.1.9.9.117.1.7.1',
  'cefcChassisCoolingEntry' => '1.3.6.1.4.1.9.9.117.1.7.1.1',
  'cefcChassisPerSlotCoolingCap' => '1.3.6.1.4.1.9.9.117.1.7.1.1.1',
  'cefcChassisPerSlotCoolingUnit' => '1.3.6.1.4.1.9.9.117.1.7.1.1.2',
  'cefcFanCoolingTable' => '1.3.6.1.4.1.9.9.117.1.7.2',
  'cefcFanCoolingEntry' => '1.3.6.1.4.1.9.9.117.1.7.2.1',
  'cefcFanCoolingCapacity' => '1.3.6.1.4.1.9.9.117.1.7.2.1.1',
  'cefcFanCoolingCapacityUnit' => '1.3.6.1.4.1.9.9.117.1.7.2.1.2',
  'cefcModuleCoolingTable' => '1.3.6.1.4.1.9.9.117.1.7.3',
  'cefcModuleCoolingEntry' => '1.3.6.1.4.1.9.9.117.1.7.3.1',
  'cefcModuleCooling' => '1.3.6.1.4.1.9.9.117.1.7.3.1.1',
  'cefcModuleCoolingUnit' => '1.3.6.1.4.1.9.9.117.1.7.3.1.2',
  'cefcFanCoolingCapTable' => '1.3.6.1.4.1.9.9.117.1.7.4',
  'cefcFanCoolingCapEntry' => '1.3.6.1.4.1.9.9.117.1.7.4.1',
  'cefcFanCoolingCapIndex' => '1.3.6.1.4.1.9.9.117.1.7.4.1.1',
  'cefcFanCoolingCapModeDescr' => '1.3.6.1.4.1.9.9.117.1.7.4.1.2',
  'cefcFanCoolingCapCapacity' => '1.3.6.1.4.1.9.9.117.1.7.4.1.3',
  'cefcFanCoolingCapCurrent' => '1.3.6.1.4.1.9.9.117.1.7.4.1.4',
  'cefcFanCoolingCapCapacityUnit' => '1.3.6.1.4.1.9.9.117.1.7.4.1.5',
  'cefcConnector' => '1.3.6.1.4.1.9.9.117.1.8',
  'cefcConnectorRatingTable' => '1.3.6.1.4.1.9.9.117.1.8.1',
  'cefcConnectorRatingEntry' => '1.3.6.1.4.1.9.9.117.1.8.1.1',
  'cefcConnectorRating' => '1.3.6.1.4.1.9.9.117.1.8.1.1.1',
  'cefcModulePowerConsumptionTable' => '1.3.6.1.4.1.9.9.117.1.8.2',
  'cefcModulePowerConsumptionEntry' => '1.3.6.1.4.1.9.9.117.1.8.2.1',
  'cefcModulePowerConsumption' => '1.3.6.1.4.1.9.9.117.1.8.2.1.1',
  'cefcFRUMIBNotificationPrefix' => '1.3.6.1.4.1.9.9.117.2',
  'cefcMIBConformance' => '1.3.6.1.4.1.9.9.117.3',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCO-ENTITY-FRU-CONTROL-MIB'} = {
  'ModuleOperType' => {
    '1' => 'unknown',
    '2' => 'ok',
    '3' => 'disabled',
    '4' => 'okButDiagFailed',
    '5' => 'boot',
    '6' => 'selfTest',
    '7' => 'failed',
    '8' => 'missing',
    '9' => 'mismatchWithParent',
    '10' => 'mismatchConfig',
    '11' => 'diagFailed',
    '12' => 'dormant',
    '13' => 'outOfServiceAdmin',
    '14' => 'outOfServiceEnvTemp',
    '15' => 'poweredDown',
    '16' => 'poweredUp',
    '17' => 'powerDenied',
    '18' => 'powerCycled',
    '19' => 'okButPowerOverWarning',
    '20' => 'okButPowerOverCritical',
    '21' => 'syncInProgress',
    '22' => 'upgrading',
    '23' => 'okButAuthFailed',
  },
  'ModuleAdminType' => {
    '1' => 'enabled',
    '2' => 'disabled',
    '3' => 'reset',
    '4' => 'outOfServiceAdmin',
  },
  'PowerOperType' => {
    '1' => 'offEnvOther',
    '2' => 'on',
    '3' => 'offAdmin',
    '4' => 'offDenied',
    '5' => 'offEnvPower',
    '6' => 'offEnvTemp',
    '7' => 'offEnvFan',
    '8' => 'failed',
    '9' => 'onButFanFail',
    '10' => 'offCooling',
    '11' => 'offConnectorRating',
    '12' => 'onButInlinePowerFail',
  },
  'PowerRedundancyType' => {
    '1' => 'notsupported',
    '2' => 'redundant',
    '3' => 'combined',
    '4' => 'nonRedundant',
    '5' => 'psRedundant',
    '6' => 'inPwrSrcRedundant',
    '7' => 'psRedundantSingleInput',
  },
  'PowerAdminType' => {
    '1' => 'on',
    '2' => 'off',
    '3' => 'inlineAuto',
    '4' => 'inlineOn',
    '5' => 'powerCycle',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOENTITYSENSORMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-ENTITY-SENSOR-MIB'} = {
  url => '',
  name => 'CISCO-ENTITY-SENSOR-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::requirements->{'CISCO-ENTITY-SENSOR-MIB'} = [
  'SNMPv2-TC-v1-MIB',
];

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'CISCO-ENTITY-SENSOR-MIB'} = 
  '1.3.6.1.4.1.9.9.91';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-ENTITY-SENSOR-MIB'} = {
  'entSensorValueTable' => '1.3.6.1.4.1.9.9.91.1.1.1',
  'entSensorValueEntry' => '1.3.6.1.4.1.9.9.91.1.1.1.1',
  'entSensorType' => '1.3.6.1.4.1.9.9.91.1.1.1.1.1',
  'entSensorTypeDefinition' => 'CISCO-ENTITY-SENSOR-MIB::SensorDataType',
  'entSensorScale' => '1.3.6.1.4.1.9.9.91.1.1.1.1.2',
  'entSensorScaleDefinition' => 'CISCO-ENTITY-SENSOR-MIB::SensorDataScale',
  'entSensorPrecision' => '1.3.6.1.4.1.9.9.91.1.1.1.1.3',
  'entSensorValue' => '1.3.6.1.4.1.9.9.91.1.1.1.1.4',
  'entSensorStatus' => '1.3.6.1.4.1.9.9.91.1.1.1.1.5',
  'entSensorStatusDefinition' => 'CISCO-ENTITY-SENSOR-MIB::SensorStatus',
  'entSensorValueTimeStamp' => '1.3.6.1.4.1.9.9.91.1.1.1.1.6',
  'entSensorValueUpdateRate' => '1.3.6.1.4.1.9.9.91.1.1.1.1.7',
  'entSensorMeasuredEntity' => '1.3.6.1.4.1.9.9.91.1.1.1.1.8',
  'entSensorThresholdTable' => '1.3.6.1.4.1.9.9.91.1.2.1',
  'entSensorThresholdEntry' => '1.3.6.1.4.1.9.9.91.1.2.1.1',
  'entSensorThresholdIndex' => '1.3.6.1.4.1.9.9.91.1.2.1.1.1',
  'entSensorThresholdSeverity' => '1.3.6.1.4.1.9.9.91.1.2.1.1.2',
  'entSensorThresholdSeverityDefinition' => 'CISCO-ENTITY-SENSOR-MIB::SensorThresholdSeverity',
  'entSensorThresholdRelation' => '1.3.6.1.4.1.9.9.91.1.2.1.1.3',
  'entSensorThresholdRelationDefinition' => 'CISCO-ENTITY-SENSOR-MIB::SensorThresholdRelation',
  'entSensorThresholdValue' => '1.3.6.1.4.1.9.9.91.1.2.1.1.4',
  'entSensorThresholdEvaluation' => '1.3.6.1.4.1.9.9.91.1.2.1.1.5',
  'entSensorThresholdEvaluationDefinition' => 'SNMPv2-TC-v1-MIB::TruthValue',
  'entSensorThresholdNotificationEnable' => '1.3.6.1.4.1.9.9.91.1.2.1.1.6',
  'entSensorThresholdNotificationEnableDefinition' => 'SNMPv2-TC-v1-MIB::TruthValue',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCO-ENTITY-SENSOR-MIB'} = {
  'SensorStatus' => {
    '1' => 'ok',
    '2' => 'unavailable',
    '3' => 'nonoperational',
  },
  'SensorThresholdSeverity' => {
    '1' => 'other',
    '10' => 'minor',
    '20' => 'major',
    '30' => 'critical',
  },
  'SensorThresholdRelation' => {
    '1' => 'lessThan',
    '2' => 'lessOrEqual',
    '3' => 'greaterThan',
    '4' => 'greaterOrEqual',
    '5' => 'equalTo',
    '6' => 'notEqualTo',
  },
  'SensorDataType' => {
    '1' => 'other',
    '2' => 'unknown',
    '3' => 'voltsAC',
    '4' => 'voltsDC',
    '5' => 'amperes',
    '6' => 'watts',
    '7' => 'hertz',
    '8' => 'celsius',
    '9' => 'percentRH',
    '10' => 'rpm',
    '11' => 'cmm',
    '12' => 'truthvalue',
    '13' => 'specialEnum',
    '14' => 'dBm',
  },
  'SensorDataScale' => {
    '1' => 'yocto',
    '2' => 'zepto',
    '3' => 'atto',
    '4' => 'femto',
    '5' => 'pico',
    '6' => 'nano',
    '7' => 'micro',
    '8' => 'milli',
    '9' => 'units',
    '10' => 'kilo',
    '11' => 'mega',
    '12' => 'giga',
    '13' => 'tera',
    '14' => 'exa',
    '15' => 'peta',
    '16' => 'zetta',
    '17' => 'yotta',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOENVMONMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-ENVMON-MIB'} = {
  url => '',
  name => 'CISCO-ENVMON-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'CISCO-ENVMON-MIB'} = 
  '1.3.6.1.4.1.9.9.13';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-ENVMON-MIB'} = {
  'ciscoEnvMonPresent' => '1.3.6.1.4.1.9.9.13.1.1.0',
  'ciscoEnvMonPresentDefinition' => {
    '1' => 'oldAgs',
    '2' => 'ags',
    '3' => 'c7000',
    '4' => 'ci',
    '6' => 'cAccessMon',
    '7' => 'cat6000',
    '8' => 'ubr7200',
    '9' => 'cat4000',
    '10' => 'c10000',
    '11' => 'osr7600',
    '12' => 'c7600',
    '13' => 'c37xx',
    '14' => 'other',
  },
  'ciscoEnvMonVoltageStatusTable' => '1.3.6.1.4.1.9.9.13.1.2',
  'ciscoEnvMonVoltageStatusEntry' => '1.3.6.1.4.1.9.9.13.1.2.1',
  'ciscoEnvMonVoltageStatusIndex' => '1.3.6.1.4.1.9.9.13.1.2.1.1',
  'ciscoEnvMonVoltageStatusDescr' => '1.3.6.1.4.1.9.9.13.1.2.1.2',
  'ciscoEnvMonVoltageStatusValue' => '1.3.6.1.4.1.9.9.13.1.2.1.3',
  'ciscoEnvMonVoltageThresholdLow' => '1.3.6.1.4.1.9.9.13.1.2.1.4',
  'ciscoEnvMonVoltageThresholdHigh' => '1.3.6.1.4.1.9.9.13.1.2.1.5',
  'ciscoEnvMonVoltageLastShutdown' => '1.3.6.1.4.1.9.9.13.1.2.1.6',
  'ciscoEnvMonVoltageState' => '1.3.6.1.4.1.9.9.13.1.2.1.7',
  'ciscoEnvMonVoltageStateDefinition' => 'CISCO-ENVMON-MIB::ciscoEnvMonState',
  'ciscoEnvMonTemperatureStatusTable' => '1.3.6.1.4.1.9.9.13.1.3',
  'ciscoEnvMonTemperatureStatusEntry' => '1.3.6.1.4.1.9.9.13.1.3.1',
  'ciscoEnvMonTemperatureStatusIndex' => '1.3.6.1.4.1.9.9.13.1.3.1.1',
  'ciscoEnvMonTemperatureStatusDescr' => '1.3.6.1.4.1.9.9.13.1.3.1.2',
  'ciscoEnvMonTemperatureStatusValue' => '1.3.6.1.4.1.9.9.13.1.3.1.3',
  'ciscoEnvMonTemperatureThreshold' => '1.3.6.1.4.1.9.9.13.1.3.1.4',
  'ciscoEnvMonTemperatureLastShutdown' => '1.3.6.1.4.1.9.9.13.1.3.1.5',
  'ciscoEnvMonTemperatureState' => '1.3.6.1.4.1.9.9.13.1.3.1.6',
  'ciscoEnvMonTemperatureStateDefinition' => 'CISCO-ENVMON-MIB::ciscoEnvMonState',
  'ciscoEnvMonFanStatusTable' => '1.3.6.1.4.1.9.9.13.1.4',
  'ciscoEnvMonFanStatusEntry' => '1.3.6.1.4.1.9.9.13.1.4.1',
  'ciscoEnvMonFanStatusIndex' => '1.3.6.1.4.1.9.9.13.1.4.1.1',
  'ciscoEnvMonFanStatusDescr' => '1.3.6.1.4.1.9.9.13.1.4.1.2',
  'ciscoEnvMonFanState' => '1.3.6.1.4.1.9.9.13.1.4.1.3',
  'ciscoEnvMonFanStateDefinition' => 'CISCO-ENVMON-MIB::ciscoEnvMonState',
  'ciscoEnvMonSupplyStatusTable' => '1.3.6.1.4.1.9.9.13.1.5',
  'ciscoEnvMonSupplyStatusEntry' => '1.3.6.1.4.1.9.9.13.1.5.1',
  'ciscoEnvMonSupplyStatusIndex' => '1.3.6.1.4.1.9.9.13.1.5.1.1',
  'ciscoEnvMonSupplyStatusDescr' => '1.3.6.1.4.1.9.9.13.1.5.1.2',
  'ciscoEnvMonSupplyState' => '1.3.6.1.4.1.9.9.13.1.5.1.3',
  'ciscoEnvMonSupplyStateDefinition' => 'CISCO-ENVMON-MIB::ciscoEnvMonState',
  'ciscoEnvMonSupplySource' => '1.3.6.1.4.1.9.9.13.1.5.1.4',
  'ciscoEnvMonSupplySourceDefinition' => 'CISCO-ENVMON-MIB::ciscoEnvMonSupplySource',
  'ciscoEnvMonAlarmContacts' => '1.3.6.1.4.1.9.9.13.1.6.0',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCO-ENVMON-MIB'} = {
  'ciscoEnvMonState' => {
    '1' => 'normal',
    '2' => 'warning',
    '3' => 'critical',
    '4' => 'shutdown',
    '5' => 'notPresent',
    '6' => 'notFunctioning',
  },
  'ciscoEnvMonSupplySource' => {
    '1' => 'unknown',
    '2' => 'ac',
    '3' => 'dc',
    '4' => 'externalPowerSupply',
    '5' => 'internalRedundant',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOETHERNETFABRICEXTENDERMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-ETHERNET-FABRIC-EXTENDER-MIB'} = {
  url => '',
  name => 'CISCO-ETHERNET-FABRIC-EXTENDER-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::requirements->{'CISCO-ETHERNET-FABRIC-EXTENDER-MIB'} = [
  'SNMPv2-TC-v1-MIB',
];

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-ETHERNET-FABRIC-EXTENDER-MIB'} = {
  'enterprises' => '1.3.6.1.4.1',
  'cisco' => '1.3.6.1.4.1.9',
  'ciscoEthernetFabricExtenderMIB' => '1.3.6.1.4.1.9.9.691',
  'ciscoEthernetFabricExtenderMIBNotifs' => '1.3.6.1.4.1.9.9.691.0',
  'ciscoEthernetFabricExtenderObjects' => '1.3.6.1.4.1.9.9.691.1',
  'cefexConfig' => '1.3.6.1.4.1.9.9.691.1.1',
  'cefexConfigDefinition' => {
    '1' => 'static',
  },
  'cefexBindingTable' => '1.3.6.1.4.1.9.9.691.1.1.1',
  'cefexBindingEntry' => '1.3.6.1.4.1.9.9.691.1.1.1.1',
  'cefexBindingInterfaceOnCoreSwitch' => '1.3.6.1.4.1.9.9.691.1.1.1.1.1',
  'cefexBindingExtenderIndex' => '1.3.6.1.4.1.9.9.691.1.1.1.1.2',
  'cefexBindingCreationTime' => '1.3.6.1.4.1.9.9.691.1.1.1.1.3',
  'cefexBindingRowStatus' => '1.3.6.1.4.1.9.9.691.1.1.1.1.4',
  'cefexBindingRowStatusDefinition' => 'SNMPv2-TC-v1-MIB::RowStatus',
  'cefexConfigTable' => '1.3.6.1.4.1.9.9.691.1.1.2',
  'cefexConfigEntry' => '1.3.6.1.4.1.9.9.691.1.1.2.1',
  'cefexConfigExtenderName' => '1.3.6.1.4.1.9.9.691.1.1.2.1.1',
  'cefexConfigSerialNumCheck' => '1.3.6.1.4.1.9.9.691.1.1.2.1.2',
  'cefexConfigSerialNum' => '1.3.6.1.4.1.9.9.691.1.1.2.1.3',
  'cefexConfigPinningFailOverMode' => '1.3.6.1.4.1.9.9.691.1.1.2.1.4',
  'cefexConfigPinningFailOverModeDefinition' => 'CISCO-ETHERNET-FABRIC-EXTENDER-MIB::CiscoPortPinningMode',
  'cefexConfigPinningMaxLinks' => '1.3.6.1.4.1.9.9.691.1.1.2.1.5',
  'cefexConfigCreationTime' => '1.3.6.1.4.1.9.9.691.1.1.2.1.6',
  'cefexConfigRowStatus' => '1.3.6.1.4.1.9.9.691.1.1.2.1.7',
  'cefexConfigRowStatusDefinition' => 'SNMPv2-TC-v1-MIB::RowStatus',
  'ciscoEthernetFabricExtenderMIBConformance' => '1.3.6.1.4.1.9.9.691.2',
  'cEthernetFabricExtenderMIBCompliances' => '1.3.6.1.4.1.9.9.691.2.1',
  'cEthernetFabricExtenderMIBGroups' => '1.3.6.1.4.1.9.9.691.2.1.1.1',
  'hardware' => '1.3.6.1.4.1.3764.1.1.200',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCO-ETHERNET-FABRIC-EXTENDER-MIB'} = {
  'CiscoPortPinningMode' => {
    '1' => 'static',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOFEATURECONTROLMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-FEATURE-CONTROL-MIB'} = {
  url => '',
  name => 'CISCO-FEATURE-CONTROL-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-FEATURE-CONTROL-MIB'} = {
  'cfcFeatureCtrlOpStatus' => 'CISCO-FEATURE-CONTROL-MIB::CiscoFeatureStatus',
  'cfcFeatureCtrlLastActionResult' => 'CISCO-FEATURE-CONTROL-MIB::CiscoFeatureActionResult',
  'cfcFeatureCtrlAction' => 'CISCO-FEATURE-CONTROL-MIB::CiscoFeatureAction',
  'cfcFeatureCtrlIndex' => 'CISCO-FEATURE-CONTROL-MIB::CiscoOptionalFeature',
  'cfcFeatureCtrlLastAction' => 'CISCO-FEATURE-CONTROL-MIB::CiscoFeatureAction',
  'cfcFeatureCtrlTable' => '1.3.6.1.4.1.9.9.377.1.1.1',
  'cfcFeatureCtrlEntry' => '1.3.6.1.4.1.9.9.377.1.1.1.1',
  'cfcFeatureCtrlName' => '1.3.6.1.4.1.9.9.377.1.1.1.1.2',
  'cfcFeatureCtrlLastFailureReason' => '1.3.6.1.4.1.9.9.377.1.1.1.1.6',
  'cfcFeatureCtrlOpStatusReason' => '1.3.6.1.4.1.9.9.377.1.1.1.1.8',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCO-FEATURE-CONTROL-MIB'} = {
  'CiscoOptionalFeature' => {
    '1' => 'ivr',
    '2' => 'fcip',
    '3' => 'fcsp',
    '4' => 'ficon',
    '5' => 'iscsi',
    '6' => 'tacacs',
    '7' => 'qosManager',
    '8' => 'portSecurity',
    '9' => 'fabricBinding',
    '10' => 'iscsiInterfaceVsanMembership',
    '11' => 'ike',
    '12' => 'isns',
    '13' => 'ipSec',
    '14' => 'portTracker',
    '15' => 'scheduler',
    '16' => 'npiv',
    '17' => 'sanExtTuner',
    '18' => 'dpvm',
    '19' => 'extenedCredit',
  },
  'CiscoFeatureStatus' => {
    '1' => 'unknown',
    '2' => 'enabled',
    '3' => 'disabled',
  },
  'CiscoFeatureActionResult' => {
    '1' => 'none',
    '2' => 'actionSuccess',
    '3' => 'actionFailed',
    '4' => 'actionInProgress',
  },
  'CiscoFeatureAction' => {
    '1' => 'noOp',
    '2' => 'enable',
    '3' => 'disable',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOFIREWALLMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-FIREWALL-MIB'} = {
  url => '',
  name => 'CISCO-FIREWALL-MIB',
};

#$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'CISCO-FIREWALL-MIB'} = 

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-FIREWALL-MIB'} = {
  ciscoFirewallMIB => '1.3.6.1.4.1.9.9.147',
  ciscoFirewallMIBObjects => '1.3.6.1.4.1.9.9.147.1',
  cfwEvents => '1.3.6.1.4.1.9.9.147.1.1',
  cfwBasicEvents => '1.3.6.1.4.1.9.9.147.1.1.1',
  cfwBasicEventsTableLastRow => '1.3.6.1.4.1.9.9.147.1.1.1.1',
  cfwBasicEventsTable => '1.3.6.1.4.1.9.9.147.1.1.1.2',
  cfwBasicEventsEntry => '1.3.6.1.4.1.9.9.147.1.1.1.2.1',
  cfwBasicEventIndex => '1.3.6.1.4.1.9.9.147.1.1.1.2.1.1',
  cfwBasicEventTime => '1.3.6.1.4.1.9.9.147.1.1.1.2.1.2',
  cfwBasicSecurityEventType => '1.3.6.1.4.1.9.9.147.1.1.1.2.1.3',
  cfwBasicSecurityEventTypeDefinition => 'CISCO-FIREWALL-MIB::SecurityEvent',
  cfwBasicContentInspEventType => '1.3.6.1.4.1.9.9.147.1.1.1.2.1.4',
  cfwBasicContentInspEventTypeDefinition => 'CISCO-FIREWALL-MIB::ContentInspectionEvent',
  cfwBasicConnectionEventType => '1.3.6.1.4.1.9.9.147.1.1.1.2.1.5',
  cfwBasicConnectionEventTypeDefinition => 'CISCO-FIREWALL-MIB::ConnectionEvent',
  cfwBasicAccessEventType => '1.3.6.1.4.1.9.9.147.1.1.1.2.1.6',
  cfwBasicAccessEventTypeDefinition => 'CISCO-FIREWALL-MIB::AccessEvent',
  cfwBasicAuthenticationEventType => '1.3.6.1.4.1.9.9.147.1.1.1.2.1.7',
  cfwBasicAuthenticationEventTypeDefinition => 'CISCO-FIREWALL-MIB::AuthenticationEvent',
  cfwBasicGenericEventType => '1.3.6.1.4.1.9.9.147.1.1.1.2.1.8',
  cfwBasicGenericEventTypeDefinition => 'CISCO-FIREWALL-MIB::GenericEvent',
  cfwBasicEventDescription => '1.3.6.1.4.1.9.9.147.1.1.1.2.1.9',
  cfwBasicEventDetailsTableRow => '1.3.6.1.4.1.9.9.147.1.1.1.2.1.10',
  cfwNetEvents => '1.3.6.1.4.1.9.9.147.1.1.2',
  cfwNetEventsTableLastRow => '1.3.6.1.4.1.9.9.147.1.1.2.1',
  cfwNetEventsTable => '1.3.6.1.4.1.9.9.147.1.1.2.2',
  cfwNetEventsEntry => '1.3.6.1.4.1.9.9.147.1.1.2.2.1',
  cfwNetEventIndex => '1.3.6.1.4.1.9.9.147.1.1.2.2.1.1',
  cfwNetEventInterface => '1.3.6.1.4.1.9.9.147.1.1.2.2.1.2',
  cfwNetEventSrcIpAddress => '1.3.6.1.4.1.9.9.147.1.1.2.2.1.3',
  cfwNetEventInsideSrcIpAddress => '1.3.6.1.4.1.9.9.147.1.1.2.2.1.4',
  cfwNetEventDstIpAddress => '1.3.6.1.4.1.9.9.147.1.1.2.2.1.5',
  cfwNetEventInsideDstIpAddress => '1.3.6.1.4.1.9.9.147.1.1.2.2.1.6',
  cfwNetEventSrcIpPort => '1.3.6.1.4.1.9.9.147.1.1.2.2.1.7',
  cfwNetEventInsideSrcIpPort => '1.3.6.1.4.1.9.9.147.1.1.2.2.1.8',
  cfwNetEventDstIpPort => '1.3.6.1.4.1.9.9.147.1.1.2.2.1.9',
  cfwNetEventInsideDstIpPort => '1.3.6.1.4.1.9.9.147.1.1.2.2.1.10',
  cfwNetEventService => '1.3.6.1.4.1.9.9.147.1.1.2.2.1.11',
  cfwNetEventServiceDefinition => 'CISCO-FIREWALL-MIB::Services',
  cfwNetEventServiceInformation => '1.3.6.1.4.1.9.9.147.1.1.2.2.1.12',
  cfwNetEventIdentity => '1.3.6.1.4.1.9.9.147.1.1.2.2.1.13',
  cfwNetEventDescription => '1.3.6.1.4.1.9.9.147.1.1.2.2.1.14',
  cfwSystem => '1.3.6.1.4.1.9.9.147.1.2',
  cfwStatus => '1.3.6.1.4.1.9.9.147.1.2.1',
  cfwHardwareStatusTable => '1.3.6.1.4.1.9.9.147.1.2.1.1',
  cfwHardwareStatusEntry => '1.3.6.1.4.1.9.9.147.1.2.1.1.1',
  cfwHardwareType => '1.3.6.1.4.1.9.9.147.1.2.1.1.1.1',
  cfwHardwareTypeDefinition => 'CISCO-FIREWALL-MIB::Hardware',
  cfwHardwareInformation => '1.3.6.1.4.1.9.9.147.1.2.1.1.1.2',
  cfwHardwareStatusValue => '1.3.6.1.4.1.9.9.147.1.2.1.1.1.3',
  cfwHardwareStatusValueDefinition => 'CISCO-FIREWALL-MIB::HardwareStatus',
  cfwHardwareStatusDetail => '1.3.6.1.4.1.9.9.147.1.2.1.1.1.4',
  cfwStatistics => '1.3.6.1.4.1.9.9.147.1.2.2',
  cfwBufferStatsTable => '1.3.6.1.4.1.9.9.147.1.2.2.1',
  cfwBufferStatsEntry => '1.3.6.1.4.1.9.9.147.1.2.2.1.1',
  cfwBufferStatSize => '1.3.6.1.4.1.9.9.147.1.2.2.1.1.1',
  cfwBufferStatType => '1.3.6.1.4.1.9.9.147.1.2.2.1.1.2',
  cfwBufferStatTypeDefinition => 'CISCO-FIREWALL-MIB::ResourceStatistics',
  cfwBufferStatInformation => '1.3.6.1.4.1.9.9.147.1.2.2.1.1.3',
  cfwBufferStatValue => '1.3.6.1.4.1.9.9.147.1.2.2.1.1.4',
  cfwConnectionStatTable => '1.3.6.1.4.1.9.9.147.1.2.2.2',
  cfwConnectionStatEntry => '1.3.6.1.4.1.9.9.147.1.2.2.2.1',
  cfwConnectionStatService => '1.3.6.1.4.1.9.9.147.1.2.2.2.1.1',
  cfwConnectionStatServiceDefinition => 'CISCO-FIREWALL-MIB::Services',
  cfwConnectionStatType => '1.3.6.1.4.1.9.9.147.1.2.2.2.1.2',
  cfwConnectionStatTypeDefinition => 'CISCO-FIREWALL-MIB::ConnectionStat',
  cfwConnectionStatDescription => '1.3.6.1.4.1.9.9.147.1.2.2.2.1.3',
  cfwConnectionStatCount => '1.3.6.1.4.1.9.9.147.1.2.2.2.1.4',
  cfwConnectionStatValue => '1.3.6.1.4.1.9.9.147.1.2.2.2.1.5',
  ciscoFirewallMIBNotificationPrefix => '1.3.6.1.4.1.9.9.147.2',
  ciscoFirewallMIBNotifications => '1.3.6.1.4.1.9.9.147.2.0',
  ciscoFirewallMIBConformance => '1.3.6.1.4.1.9.9.147.3',
  ciscoFirewallMIBCompliances => '1.3.6.1.4.1.9.9.147.3.1',
  ciscoFirewallMIBGroups => '1.3.6.1.4.1.9.9.147.3.2',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCO-FIREWALL-MIB'} = {
  AccessEvent => {
    '1' => 'other',
    '2' => 'grant',
    '3' => 'deny',
    '4' => 'denyMult',
    '5' => 'error',
  },
  GenericEvent => {
    '1' => 'abnormal',
    '2' => 'okay',
    '3' => 'error',
  },
  ResourceStatistics => {
    '1' => 'highUse',
    '2' => 'highLoad',
    '3' => 'maximum',
    '4' => 'minimum',
    '5' => 'low',
    '6' => 'high',
    '7' => 'average',
    '8' => 'free',
    '9' => 'inUse',
  },
  ConnectionEvent => {
    '1' => 'other',
    '2' => 'accept',
    '3' => 'error',
    '4' => 'drop',
    '5' => 'close',
    '6' => 'timeout',
    '7' => 'refused',
    '8' => 'reset',
    '9' => 'noResp',
  },
  AuthenticationEvent => {
    '1' => 'other',
    '2' => 'succ',
    '3' => 'error',
    '4' => 'fail',
    '5' => 'succPriv',
    '6' => 'failPriv',
    '7' => 'failMult',
  },
  ContentInspectionEvent => {
    '1' => 'other',
    '2' => 'okay',
    '3' => 'error',
    '4' => 'found',
    '5' => 'clean',
    '6' => 'reject',
    '7' => 'saved',
  },
  HardwareStatus => {
    '1' => 'other',
    '2' => 'up',
    '3' => 'down',
    '4' => 'error',
    '5' => 'overTemp',
    '6' => 'busy',
    '7' => 'noMedia',
    '8' => 'backup',
    '9' => 'active',
    '10' => 'standby',
  },
  Hardware => {
    '1' => 'memory',
    '2' => 'disk',
    '3' => 'power',
    '4' => 'netInterface',
    '5' => 'cpu',
    '6' => 'primaryUnit',
    '7' => 'secondaryUnit',
    '8' => 'other',
  },
  ConnectionStat => {
    '1' => 'other',
    '2' => 'totalOpen',
    '3' => 'currentOpen',
    '4' => 'currentClosing',
    '5' => 'currentHalfOpen',
    '6' => 'currentInUse',
    '7' => 'high',
  },
  Services => {
    '1' => 'otherFWService',
    '2' => 'fileXferFtp',
    '3' => 'fileXferTftp',
    '4' => 'fileXferFtps',
    '5' => 'loginTelnet',
    '6' => 'loginRlogin',
    '7' => 'loginTelnets',
    '8' => 'remoteExecSunRPC',
    '9' => 'remoteExecMSRPC',
    '10' => 'remoteExecRsh',
    '11' => 'remoteExecXserver',
    '12' => 'webHttp',
    '13' => 'webHttps',
    '14' => 'mailSmtp',
    '15' => 'multimediaStreamworks',
    '16' => 'multimediaH323',
    '17' => 'multimediaNetShow',
    '18' => 'multimediaVDOLive',
    '19' => 'multimediaRealAV',
    '20' => 'multimediaRTSP',
    '21' => 'dbOracle',
    '22' => 'dbMSsql',
    '23' => 'contInspProgLang',
    '24' => 'contInspUrl',
    '25' => 'directoryNis',
    '26' => 'directoryDns',
    '27' => 'directoryNetbiosns',
    '28' => 'directoryNetbiosdgm',
    '29' => 'directoryNetbiosssn',
    '30' => 'directoryWins',
    '31' => 'qryWhois',
    '32' => 'qryFinger',
    '33' => 'qryIdent',
    '34' => 'fsNfsStatus',
    '35' => 'fsNfs',
    '36' => 'fsCifs',
    '37' => 'protoIcmp',
    '38' => 'protoTcp',
    '39' => 'protoUdp',
    '40' => 'protoIp',
    '41' => 'protoSnmp',
  },
  SecurityEvent => {
    '1' => 'other',
    '2' => 'none',
    '3' => 'dos',
    '4' => 'recon',
    '5' => 'pakFwd',
    '6' => 'addrSpoof',
    '7' => 'svcSpoof',
    '8' => 'thirdParty',
    '9' => 'complete',
    '10' => 'invalPak',
    '11' => 'illegCom',
    '12' => 'policy',
  },
};
package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOHSRPMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-HSRP-MIB'} = {
  url => '',
  name => 'CISCO-HSRP-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::requirements->{'CISCO-HSRP-MIB'} = [
  'SNMPv2-TC-v1-MIB',
];

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-HSRP-MIB'} = {
  'cHsrpGrpTable' => '1.3.6.1.4.1.9.9.106.1.2.1',
  'cHsrpGrpEntry' => '1.3.6.1.4.1.9.9.106.1.2.1.1',
  'cHsrpGrpNumber' => '1.3.6.1.4.1.9.9.106.1.2.1.1.1',
  'cHsrpGrpAuth' => '1.3.6.1.4.1.9.9.106.1.2.1.1.2',
  'cHsrpGrpPriority' => '1.3.6.1.4.1.9.9.106.1.2.1.1.3',
  'cHsrpGrpPreempt' => '1.3.6.1.4.1.9.9.106.1.2.1.1.4',
  'cHsrpGrpPreemptDelay' => '1.3.6.1.4.1.9.9.106.1.2.1.1.5',
  'cHsrpGrpUseConfiguredTimers' => '1.3.6.1.4.1.9.9.106.1.2.1.1.6',
  'cHsrpGrpConfiguredHelloTime' => '1.3.6.1.4.1.9.9.106.1.2.1.1.7',
  'cHsrpGrpConfiguredHoldTime' => '1.3.6.1.4.1.9.9.106.1.2.1.1.8',
  'cHsrpGrpLearnedHelloTime' => '1.3.6.1.4.1.9.9.106.1.2.1.1.9',
  'cHsrpGrpLearnedHoldTime' => '1.3.6.1.4.1.9.9.106.1.2.1.1.10',
  'cHsrpGrpVirtualIpAddr' => '1.3.6.1.4.1.9.9.106.1.2.1.1.11',
  'cHsrpGrpUseConfigVirtualIpAddr' => '1.3.6.1.4.1.9.9.106.1.2.1.1.12',
  'cHsrpGrpActiveRouter' => '1.3.6.1.4.1.9.9.106.1.2.1.1.13',
  'cHsrpGrpStandbyRouter' => '1.3.6.1.4.1.9.9.106.1.2.1.1.14',
  'cHsrpGrpStandbyState' => '1.3.6.1.4.1.9.9.106.1.2.1.1.15',
  'cHsrpGrpStandbyStateDefinition' => 'CISCO-HSRP-MIB::HsrpState',
  'cHsrpGrpVirtualMacAddr' => '1.3.6.1.4.1.9.9.106.1.2.1.1.16',
  'cHsrpGrpEntryRowStatus' => '1.3.6.1.4.1.9.9.106.1.2.1.1.17',
  'cHsrpGrpEntryRowStatusDefinition' => 'SNMPv2-TC-v1-MIB::RowStatus',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCO-HSRP-MIB'} = {
  'HsrpState' => {
    '1' => 'initial',
    '2' => 'learn',
    '3' => 'listen',
    '4' => 'speak',
    '5' => 'standby',
    '6' => 'active',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOIETFNATMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-IETF-NAT-MIB'} = {
  url => '',
  name => 'CISCO-IETF-NAT-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-IETF-NAT-MIB'} = {
  'ciscoNatMIBObjects' => '1.3.6.1.4.1.9.10.77.1',
  'cnatConfig' => '1.3.6.1.4.1.9.10.77.1.1',
  'cnatConfTable' => '1.3.6.1.4.1.9.10.77.1.1.1',
  'cnatConfEntry' => '1.3.6.1.4.1.9.10.77.1.1.1.1',
  'cnatConfName' => '1.3.6.1.4.1.9.10.77.1.1.1.1.1',
  'cnatConfServiceType' => '1.3.6.1.4.1.9.10.77.1.1.1.1.2',
  'cnatConfTimeoutIcmpIdle' => '1.3.6.1.4.1.9.10.77.1.1.1.1.3',
  'cnatConfTimeoutUdpIdle' => '1.3.6.1.4.1.9.10.77.1.1.1.1.4',
  'cnatConfTimeoutTcpIdle' => '1.3.6.1.4.1.9.10.77.1.1.1.1.5',
  'cnatConfTimeoutTcpNeg' => '1.3.6.1.4.1.9.10.77.1.1.1.1.6',
  'cnatConfTimeoutOther' => '1.3.6.1.4.1.9.10.77.1.1.1.1.7',
  'cnatConfMaxBindLeaseTime' => '1.3.6.1.4.1.9.10.77.1.1.1.1.8',
  'cnatConfMaxBindIdleTime' => '1.3.6.1.4.1.9.10.77.1.1.1.1.9',
  'cnatConfStorageType' => '1.3.6.1.4.1.9.10.77.1.1.1.1.10',
  'cnatConfStatus' => '1.3.6.1.4.1.9.10.77.1.1.1.1.11',
  'cnatConfStaticAddrMapTable' => '1.3.6.1.4.1.9.10.77.1.1.2',
  'cnatConfStaticAddrMapEntry' => '1.3.6.1.4.1.9.10.77.1.1.2.1',
  'cnatConfStaticAddrMapName' => '1.3.6.1.4.1.9.10.77.1.1.2.1.1',
  'cnatConfStaticAddrMapType' => '1.3.6.1.4.1.9.10.77.1.1.2.1.2',
  'cnatConfStaticLocalAddrFrom' => '1.3.6.1.4.1.9.10.77.1.1.2.1.3',
  'cnatConfStaticLocalAddrTo' => '1.3.6.1.4.1.9.10.77.1.1.2.1.4',
  'cnatConfStaticLocalPortFrom' => '1.3.6.1.4.1.9.10.77.1.1.2.1.5',
  'cnatConfStaticLocalPortTo' => '1.3.6.1.4.1.9.10.77.1.1.2.1.6',
  'cnatConfStaticGlobalAddrFrom' => '1.3.6.1.4.1.9.10.77.1.1.2.1.7',
  'cnatConfStaticGlobalAddrTo' => '1.3.6.1.4.1.9.10.77.1.1.2.1.8',
  'cnatConfStaticGlobalPortFrom' => '1.3.6.1.4.1.9.10.77.1.1.2.1.9',
  'cnatConfStaticGlobalPortTo' => '1.3.6.1.4.1.9.10.77.1.1.2.1.10',
  'cnatConfStaticProtocol' => '1.3.6.1.4.1.9.10.77.1.1.2.1.11',
  'cnatConfStaticAddrMapStorageType' => '1.3.6.1.4.1.9.10.77.1.1.2.1.12',
  'cnatConfStaticAddrMapStatus' => '1.3.6.1.4.1.9.10.77.1.1.2.1.13',
  'cnatConfDynAddrMapTable' => '1.3.6.1.4.1.9.10.77.1.1.3',
  'cnatConfDynAddrMapEntry' => '1.3.6.1.4.1.9.10.77.1.1.3.1',
  'cnatConfDynAddrMapName' => '1.3.6.1.4.1.9.10.77.1.1.3.1.1',
  'cnatConfDynAddressMapType' => '1.3.6.1.4.1.9.10.77.1.1.3.1.2',
  'cnatConfDynLocalAddrFrom' => '1.3.6.1.4.1.9.10.77.1.1.3.1.3',
  'cnatConfDynLocalAddrTo' => '1.3.6.1.4.1.9.10.77.1.1.3.1.4',
  'cnatConfDynLocalPortFrom' => '1.3.6.1.4.1.9.10.77.1.1.3.1.5',
  'cnatConfDynLocalPortTo' => '1.3.6.1.4.1.9.10.77.1.1.3.1.6',
  'cnatConfDynGlobalAddrFrom' => '1.3.6.1.4.1.9.10.77.1.1.3.1.7',
  'cnatConfDynGlobalAddrTo' => '1.3.6.1.4.1.9.10.77.1.1.3.1.8',
  'cnatConfDynGlobalPortFrom' => '1.3.6.1.4.1.9.10.77.1.1.3.1.9',
  'cnatConfDynGlobalPortTo' => '1.3.6.1.4.1.9.10.77.1.1.3.1.10',
  'cnatConfDynProtocol' => '1.3.6.1.4.1.9.10.77.1.1.3.1.11',
  'cnatConfDynAddrMapStorageType' => '1.3.6.1.4.1.9.10.77.1.1.3.1.12',
  'cnatConfDynAddrMapStatus' => '1.3.6.1.4.1.9.10.77.1.1.3.1.13',
  'cnatInterfaceTable' => '1.3.6.1.4.1.9.10.77.1.1.4',
  'cnatInterfaceEntry' => '1.3.6.1.4.1.9.10.77.1.1.4.1',
  'cnatInterfaceIndex' => '1.3.6.1.4.1.9.10.77.1.1.4.1.1',
  'cnatInterfaceRealm' => '1.3.6.1.4.1.9.10.77.1.1.4.1.2',
  'cnatInterfaceStorageType' => '1.3.6.1.4.1.9.10.77.1.1.4.1.3',
  'cnatInterfaceStatus' => '1.3.6.1.4.1.9.10.77.1.1.4.1.4',
  'cnatBind' => '1.3.6.1.4.1.9.10.77.1.2',
  'cnatAddrBindNumberOfEntries' => '1.3.6.1.4.1.9.10.77.1.2.1.0',
  'cnatAddrBindTable' => '1.3.6.1.4.1.9.10.77.1.2.2',
  'cnatAddrBindEntry' => '1.3.6.1.4.1.9.10.77.1.2.2.1',
  'cnatAddrBindLocalAddr' => '1.3.6.1.4.1.9.10.77.1.2.2.1.1',
  'cnatAddrBindGlobalAddr' => '1.3.6.1.4.1.9.10.77.1.2.2.1.2',
  'cnatAddrBindId' => '1.3.6.1.4.1.9.10.77.1.2.2.1.3',
  'cnatAddrBindDirection' => '1.3.6.1.4.1.9.10.77.1.2.2.1.4',
  'cnatAddrBindType' => '1.3.6.1.4.1.9.10.77.1.2.2.1.5',
  'cnatAddrBindConfName' => '1.3.6.1.4.1.9.10.77.1.2.2.1.6',
  'cnatAddrBindSessionCount' => '1.3.6.1.4.1.9.10.77.1.2.2.1.7',
  'cnatAddrBindCurrentIdleTime' => '1.3.6.1.4.1.9.10.77.1.2.2.1.8',
  'cnatAddrBindInTranslate' => '1.3.6.1.4.1.9.10.77.1.2.2.1.9',
  'cnatAddrBindOutTranslate' => '1.3.6.1.4.1.9.10.77.1.2.2.1.10',
  'cnatAddrPortBindNumberOfEntries' => '1.3.6.1.4.1.9.10.77.1.2.3.0',
  'cnatAddrPortBindTable' => '1.3.6.1.4.1.9.10.77.1.2.4',
  'cnatAddrPortBindEntry' => '1.3.6.1.4.1.9.10.77.1.2.4.1',
  'cnatAddrPortBindLocalAddr' => '1.3.6.1.4.1.9.10.77.1.2.4.1.1',
  'cnatAddrPortBindLocalPort' => '1.3.6.1.4.1.9.10.77.1.2.4.1.2',
  'cnatAddrPortBindProtocol' => '1.3.6.1.4.1.9.10.77.1.2.4.1.3',
  'cnatAddrPortBindGlobalAddr' => '1.3.6.1.4.1.9.10.77.1.2.4.1.4',
  'cnatAddrPortBindGlobalPort' => '1.3.6.1.4.1.9.10.77.1.2.4.1.5',
  'cnatAddrPortBindId' => '1.3.6.1.4.1.9.10.77.1.2.4.1.6',
  'cnatAddrPortBindDirection' => '1.3.6.1.4.1.9.10.77.1.2.4.1.7',
  'cnatAddrPortBindType' => '1.3.6.1.4.1.9.10.77.1.2.4.1.8',
  'cnatAddrPortBindConfName' => '1.3.6.1.4.1.9.10.77.1.2.4.1.9',
  'cnatAddrPortBindSessionCount' => '1.3.6.1.4.1.9.10.77.1.2.4.1.10',
  'cnatAddrPortBindCurrentIdleTime' => '1.3.6.1.4.1.9.10.77.1.2.4.1.11',
  'cnatAddrPortBindInTranslate' => '1.3.6.1.4.1.9.10.77.1.2.4.1.12',
  'cnatAddrPortBindOutTranslate' => '1.3.6.1.4.1.9.10.77.1.2.4.1.13',
  'cnatSessionTable' => '1.3.6.1.4.1.9.10.77.1.2.5',
  'cnatSessionEntry' => '1.3.6.1.4.1.9.10.77.1.2.5.1',
  'cnatSessionBindId' => '1.3.6.1.4.1.9.10.77.1.2.5.1.1',
  'cnatSessionId' => '1.3.6.1.4.1.9.10.77.1.2.5.1.2',
  'cnatSessionDirection' => '1.3.6.1.4.1.9.10.77.1.2.5.1.3',
  'cnatSessionUpTime' => '1.3.6.1.4.1.9.10.77.1.2.5.1.4',
  'cnatSessionProtocolType' => '1.3.6.1.4.1.9.10.77.1.2.5.1.5',
  'cnatSessionOrigPrivateAddr' => '1.3.6.1.4.1.9.10.77.1.2.5.1.6',
  'cnatSessionTransPrivateAddr' => '1.3.6.1.4.1.9.10.77.1.2.5.1.7',
  'cnatSessionOrigPrivatePort' => '1.3.6.1.4.1.9.10.77.1.2.5.1.8',
  'cnatSessionTransPrivatePort' => '1.3.6.1.4.1.9.10.77.1.2.5.1.9',
  'cnatSessionOrigPublicAddr' => '1.3.6.1.4.1.9.10.77.1.2.5.1.10',
  'cnatSessionTransPublicAddr' => '1.3.6.1.4.1.9.10.77.1.2.5.1.11',
  'cnatSessionOrigPublicPort' => '1.3.6.1.4.1.9.10.77.1.2.5.1.12',
  'cnatSessionTransPublicPort' => '1.3.6.1.4.1.9.10.77.1.2.5.1.13',
  'cnatSessionCurrentIdletime' => '1.3.6.1.4.1.9.10.77.1.2.5.1.14',
  'cnatSessionSecondBindId' => '1.3.6.1.4.1.9.10.77.1.2.5.1.15',
  'cnatSessionInTranslate' => '1.3.6.1.4.1.9.10.77.1.2.5.1.16',
  'cnatSessionOutTranslate' => '1.3.6.1.4.1.9.10.77.1.2.5.1.17',
  'cnatStatistics' => '1.3.6.1.4.1.9.10.77.1.3',
  'cnatProtocolStatsTable' => '1.3.6.1.4.1.9.10.77.1.3.1',
  'cnatProtocolStatsEntry' => '1.3.6.1.4.1.9.10.77.1.3.1.1',
  'cnatProtocolStatsName' => '1.3.6.1.4.1.9.10.77.1.3.1.1.1',
  'cnatProtocolStatsNameDefinition' => 'CISCO-IETF-NAT-MIB::NATProtocolType',
  'cnatProtocolStatsInTranslate' => '1.3.6.1.4.1.9.10.77.1.3.1.1.2',
  'cnatProtocolStatsOutTranslate' => '1.3.6.1.4.1.9.10.77.1.3.1.1.3',
  'cnatProtocolStatsRejectCount' => '1.3.6.1.4.1.9.10.77.1.3.1.1.4',
  'cnatAddrMapStatsTable' => '1.3.6.1.4.1.9.10.77.1.3.2',
  'cnatAddrMapStatsEntry' => '1.3.6.1.4.1.9.10.77.1.3.2.1',
  'cnatAddrMapStatsConfName' => '1.3.6.1.4.1.9.10.77.1.3.2.1.1',
  'cnatAddrMapStatsMapName' => '1.3.6.1.4.1.9.10.77.1.3.2.1.2',
  'cnatAddrMapStatsInTranslate' => '1.3.6.1.4.1.9.10.77.1.3.2.1.3',
  'cnatAddrMapStatsOutTranslate' => '1.3.6.1.4.1.9.10.77.1.3.2.1.4',
  'cnatAddrMapStatsNoResource' => '1.3.6.1.4.1.9.10.77.1.3.2.1.5',
  'cnatAddrMapStatsAddrUsed' => '1.3.6.1.4.1.9.10.77.1.3.2.1.6',
  'cnatInterfaceStatsTable' => '1.3.6.1.4.1.9.10.77.1.3.3',
  'cnatInterfaceStatsEntry' => '1.3.6.1.4.1.9.10.77.1.3.3.1',
  'cnatInterfacePktsIn' => '1.3.6.1.4.1.9.10.77.1.3.3.1.1',
  'cnatInterfacePktsOut' => '1.3.6.1.4.1.9.10.77.1.3.3.1.2',
  'ciscoNatMIBNotificationPrefix' => '1.3.6.1.4.1.9.10.77.2',
  'ciscoNatMIBNotifications' => '1.3.6.1.4.1.9.10.77.2.0',
  'ciscoNatMIBConformance' => '1.3.6.1.4.1.9.10.77.3',
  'ciscoNatMIBCompliances' => '1.3.6.1.4.1.9.10.77.3.1',
  'ciscoNatMIBGroups' => '1.3.6.1.4.1.9.10.77.3.2',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCO-IETF-NAT-MIB'} = {
  'NATProtocolType' => {
    '1' => 'other',
    '2' => 'icmp',
    '3' => 'udp',
    '4' => 'tcp',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOIPSECFLOWMONITORMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-IPSEC-FLOW-MONITOR-MIB'} = {
  url => '',
  name => 'CISCO-IPSEC-FLOW-MONITOR-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-IPSEC-FLOW-MONITOR-MIB'} = {
  'enterprises' => '1.3.6.1.4.1',
  'cisco' => '1.3.6.1.4.1.9',
  'ciscoMgmt' => '1.3.6.1.4.1.9.9',
  'ciscoIpSecFlowMonitorMIB' => '1.3.6.1.4.1.9.9.171',
  'ciscoIpSecFlowMonitorMIBDefinition' => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  'cipSecMIBObjects' => '1.3.6.1.4.1.9.9.171.1',
  'cipSecLevels' => '1.3.6.1.4.1.9.9.171.1.1',
  'cipSecMibLevel' => '1.3.6.1.4.1.9.9.171.1.1.1',
  'cipSecPhaseOne' => '1.3.6.1.4.1.9.9.171.1.2',
  'cikeGlobalStats' => '1.3.6.1.4.1.9.9.171.1.2.1',
  'cikeGlobalActiveTunnels' => '1.3.6.1.4.1.9.9.171.1.2.1.1',
  'cikeGlobalPreviousTunnels' => '1.3.6.1.4.1.9.9.171.1.2.1.2',
  'cikeGlobalInOctets' => '1.3.6.1.4.1.9.9.171.1.2.1.3',
  'cikeGlobalInPkts' => '1.3.6.1.4.1.9.9.171.1.2.1.4',
  'cikeGlobalInDropPkts' => '1.3.6.1.4.1.9.9.171.1.2.1.5',
  'cikeGlobalInNotifys' => '1.3.6.1.4.1.9.9.171.1.2.1.6',
  'cikeGlobalInP2Exchgs' => '1.3.6.1.4.1.9.9.171.1.2.1.7',
  'cikeGlobalInP2ExchgInvalids' => '1.3.6.1.4.1.9.9.171.1.2.1.8',
  'cikeGlobalInP2ExchgRejects' => '1.3.6.1.4.1.9.9.171.1.2.1.9',
  'cikeGlobalInP2SaDelRequests' => '1.3.6.1.4.1.9.9.171.1.2.1.10',
  'cikeGlobalOutOctets' => '1.3.6.1.4.1.9.9.171.1.2.1.11',
  'cikeGlobalOutPkts' => '1.3.6.1.4.1.9.9.171.1.2.1.12',
  'cikeGlobalOutDropPkts' => '1.3.6.1.4.1.9.9.171.1.2.1.13',
  'cikeGlobalOutNotifys' => '1.3.6.1.4.1.9.9.171.1.2.1.14',
  'cikeGlobalOutP2Exchgs' => '1.3.6.1.4.1.9.9.171.1.2.1.15',
  'cikeGlobalOutP2ExchgInvalids' => '1.3.6.1.4.1.9.9.171.1.2.1.16',
  'cikeGlobalOutP2ExchgRejects' => '1.3.6.1.4.1.9.9.171.1.2.1.17',
  'cikeGlobalOutP2SaDelRequests' => '1.3.6.1.4.1.9.9.171.1.2.1.18',
  'cikeGlobalInitTunnels' => '1.3.6.1.4.1.9.9.171.1.2.1.19',
  'cikeGlobalInitTunnelFails' => '1.3.6.1.4.1.9.9.171.1.2.1.20',
  'cikeGlobalRespTunnelFails' => '1.3.6.1.4.1.9.9.171.1.2.1.21',
  'cikeGlobalSysCapFails' => '1.3.6.1.4.1.9.9.171.1.2.1.22',
  'cikeGlobalAuthFails' => '1.3.6.1.4.1.9.9.171.1.2.1.23',
  'cikeGlobalDecryptFails' => '1.3.6.1.4.1.9.9.171.1.2.1.24',
  'cikeGlobalHashValidFails' => '1.3.6.1.4.1.9.9.171.1.2.1.25',
  'cikeGlobalNoSaFails' => '1.3.6.1.4.1.9.9.171.1.2.1.26',
  'cikePeerTable' => '1.3.6.1.4.1.9.9.171.1.2.2',
  'cikePeerEntry' => '1.3.6.1.4.1.9.9.171.1.2.2.1',
  'cikePeerLocalType' => '1.3.6.1.4.1.9.9.171.1.2.2.1.1',
  'cikePeerLocalTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkePeerType',
  'cikePeerLocalValue' => '1.3.6.1.4.1.9.9.171.1.2.2.1.2',
  'cikePeerRemoteType' => '1.3.6.1.4.1.9.9.171.1.2.2.1.3',
  'cikePeerRemoteTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkePeerType',
  'cikePeerRemoteValue' => '1.3.6.1.4.1.9.9.171.1.2.2.1.4',
  'cikePeerIntIndex' => '1.3.6.1.4.1.9.9.171.1.2.2.1.5',
  'cikePeerLocalAddr' => '1.3.6.1.4.1.9.9.171.1.2.2.1.6',
  'cikePeerRemoteAddr' => '1.3.6.1.4.1.9.9.171.1.2.2.1.7',
  'cikePeerActiveTime' => '1.3.6.1.4.1.9.9.171.1.2.2.1.8',
  'cikePeerActiveTunnelIndex' => '1.3.6.1.4.1.9.9.171.1.2.2.1.9',
  'cikeTunnelTable' => '1.3.6.1.4.1.9.9.171.1.2.3',
  'cikeTunnelEntry' => '1.3.6.1.4.1.9.9.171.1.2.3.1',
  'cikeTunIndex' => '1.3.6.1.4.1.9.9.171.1.2.3.1.1',
  'cikeTunLocalType' => '1.3.6.1.4.1.9.9.171.1.2.3.1.2',
  'cikeTunLocalTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkePeerType',
  'cikeTunLocalValue' => '1.3.6.1.4.1.9.9.171.1.2.3.1.3',
  'cikeTunLocalAddr' => '1.3.6.1.4.1.9.9.171.1.2.3.1.4',
  'cikeTunLocalName' => '1.3.6.1.4.1.9.9.171.1.2.3.1.5',
  'cikeTunRemoteType' => '1.3.6.1.4.1.9.9.171.1.2.3.1.6',
  'cikeTunRemoteTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkePeerType',
  'cikeTunRemoteValue' => '1.3.6.1.4.1.9.9.171.1.2.3.1.7',
  'cikeTunRemoteAddr' => '1.3.6.1.4.1.9.9.171.1.2.3.1.8',
  'cikeTunRemoteName' => '1.3.6.1.4.1.9.9.171.1.2.3.1.9',
  'cikeTunNegoMode' => '1.3.6.1.4.1.9.9.171.1.2.3.1.10',
  'cikeTunNegoModeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkeNegoMode',
  'cikeTunDiffHellmanGrp' => '1.3.6.1.4.1.9.9.171.1.2.3.1.11',
  'cikeTunDiffHellmanGrpDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::DiffHellmanGrp',
  'cikeTunEncryptAlgo' => '1.3.6.1.4.1.9.9.171.1.2.3.1.12',
  'cikeTunEncryptAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::EncryptAlgo',
  'cikeTunHashAlgo' => '1.3.6.1.4.1.9.9.171.1.2.3.1.13',
  'cikeTunHashAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkeHashAlgo',
  'cikeTunAuthMethod' => '1.3.6.1.4.1.9.9.171.1.2.3.1.14',
  'cikeTunAuthMethodDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkeAuthMethod',
  'cikeTunLifeTime' => '1.3.6.1.4.1.9.9.171.1.2.3.1.15',
  'cikeTunActiveTime' => '1.3.6.1.4.1.9.9.171.1.2.3.1.16',
  'cikeTunSaRefreshThreshold' => '1.3.6.1.4.1.9.9.171.1.2.3.1.17',
  'cikeTunTotalRefreshes' => '1.3.6.1.4.1.9.9.171.1.2.3.1.18',
  'cikeTunInOctets' => '1.3.6.1.4.1.9.9.171.1.2.3.1.19',
  'cikeTunInPkts' => '1.3.6.1.4.1.9.9.171.1.2.3.1.20',
  'cikeTunInDropPkts' => '1.3.6.1.4.1.9.9.171.1.2.3.1.21',
  'cikeTunInNotifys' => '1.3.6.1.4.1.9.9.171.1.2.3.1.22',
  'cikeTunInP2Exchgs' => '1.3.6.1.4.1.9.9.171.1.2.3.1.23',
  'cikeTunInP2ExchgInvalids' => '1.3.6.1.4.1.9.9.171.1.2.3.1.24',
  'cikeTunInP2ExchgRejects' => '1.3.6.1.4.1.9.9.171.1.2.3.1.25',
  'cikeTunInP2SaDelRequests' => '1.3.6.1.4.1.9.9.171.1.2.3.1.26',
  'cikeTunOutOctets' => '1.3.6.1.4.1.9.9.171.1.2.3.1.27',
  'cikeTunOutPkts' => '1.3.6.1.4.1.9.9.171.1.2.3.1.28',
  'cikeTunOutDropPkts' => '1.3.6.1.4.1.9.9.171.1.2.3.1.29',
  'cikeTunOutNotifys' => '1.3.6.1.4.1.9.9.171.1.2.3.1.30',
  'cikeTunOutP2Exchgs' => '1.3.6.1.4.1.9.9.171.1.2.3.1.31',
  'cikeTunOutP2ExchgInvalids' => '1.3.6.1.4.1.9.9.171.1.2.3.1.32',
  'cikeTunOutP2ExchgRejects' => '1.3.6.1.4.1.9.9.171.1.2.3.1.33',
  'cikeTunOutP2SaDelRequests' => '1.3.6.1.4.1.9.9.171.1.2.3.1.34',
  'cikeTunStatus' => '1.3.6.1.4.1.9.9.171.1.2.3.1.35',
  'cikeTunStatusDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::TunnelStatus',
  'cikePeerCorrTable' => '1.3.6.1.4.1.9.9.171.1.2.4',
  'cikePeerCorrEntry' => '1.3.6.1.4.1.9.9.171.1.2.4.1',
  'cikePeerCorrLocalType' => '1.3.6.1.4.1.9.9.171.1.2.4.1.1',
  'cikePeerCorrLocalTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkePeerType',
  'cikePeerCorrLocalValue' => '1.3.6.1.4.1.9.9.171.1.2.4.1.2',
  'cikePeerCorrRemoteType' => '1.3.6.1.4.1.9.9.171.1.2.4.1.3',
  'cikePeerCorrRemoteTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkePeerType',
  'cikePeerCorrRemoteValue' => '1.3.6.1.4.1.9.9.171.1.2.4.1.4',
  'cikePeerCorrIntIndex' => '1.3.6.1.4.1.9.9.171.1.2.4.1.5',
  'cikePeerCorrSeqNum' => '1.3.6.1.4.1.9.9.171.1.2.4.1.6',
  'cikePeerCorrIpSecTunIndex' => '1.3.6.1.4.1.9.9.171.1.2.4.1.7',
  'cikePhase1GWStatsTable' => '1.3.6.1.4.1.9.9.171.1.2.5',
  'cikePhase1GWStatsEntry' => '1.3.6.1.4.1.9.9.171.1.2.5.1',
  'cikePhase1GWActiveTunnels' => '1.3.6.1.4.1.9.9.171.1.2.5.1.1',
  'cikePhase1GWPreviousTunnels' => '1.3.6.1.4.1.9.9.171.1.2.5.1.2',
  'cikePhase1GWInOctets' => '1.3.6.1.4.1.9.9.171.1.2.5.1.3',
  'cikePhase1GWInPkts' => '1.3.6.1.4.1.9.9.171.1.2.5.1.4',
  'cikePhase1GWInDropPkts' => '1.3.6.1.4.1.9.9.171.1.2.5.1.5',
  'cikePhase1GWInNotifys' => '1.3.6.1.4.1.9.9.171.1.2.5.1.6',
  'cikePhase1GWInP2Exchgs' => '1.3.6.1.4.1.9.9.171.1.2.5.1.7',
  'cikePhase1GWInP2ExchgInvalids' => '1.3.6.1.4.1.9.9.171.1.2.5.1.8',
  'cikePhase1GWInP2ExchgRejects' => '1.3.6.1.4.1.9.9.171.1.2.5.1.9',
  'cikePhase1GWInP2SaDelRequests' => '1.3.6.1.4.1.9.9.171.1.2.5.1.10',
  'cikePhase1GWOutOctets' => '1.3.6.1.4.1.9.9.171.1.2.5.1.11',
  'cikePhase1GWOutPkts' => '1.3.6.1.4.1.9.9.171.1.2.5.1.12',
  'cikePhase1GWOutDropPkts' => '1.3.6.1.4.1.9.9.171.1.2.5.1.13',
  'cikePhase1GWOutNotifys' => '1.3.6.1.4.1.9.9.171.1.2.5.1.14',
  'cikePhase1GWOutP2Exchgs' => '1.3.6.1.4.1.9.9.171.1.2.5.1.15',
  'cikePhase1GWOutP2ExchgInvalids' => '1.3.6.1.4.1.9.9.171.1.2.5.1.16',
  'cikePhase1GWOutP2ExchgRejects' => '1.3.6.1.4.1.9.9.171.1.2.5.1.17',
  'cikePhase1GWOutP2SaDelRequests' => '1.3.6.1.4.1.9.9.171.1.2.5.1.18',
  'cikePhase1GWInitTunnels' => '1.3.6.1.4.1.9.9.171.1.2.5.1.19',
  'cikePhase1GWInitTunnelFails' => '1.3.6.1.4.1.9.9.171.1.2.5.1.20',
  'cikePhase1GWRespTunnelFails' => '1.3.6.1.4.1.9.9.171.1.2.5.1.21',
  'cikePhase1GWSysCapFails' => '1.3.6.1.4.1.9.9.171.1.2.5.1.22',
  'cikePhase1GWAuthFails' => '1.3.6.1.4.1.9.9.171.1.2.5.1.23',
  'cikePhase1GWDecryptFails' => '1.3.6.1.4.1.9.9.171.1.2.5.1.24',
  'cikePhase1GWHashValidFails' => '1.3.6.1.4.1.9.9.171.1.2.5.1.25',
  'cikePhase1GWNoSaFails' => '1.3.6.1.4.1.9.9.171.1.2.5.1.26',
  'cipSecPhaseTwo' => '1.3.6.1.4.1.9.9.171.1.3',
  'cipSecGlobalStats' => '1.3.6.1.4.1.9.9.171.1.3.1',
  'cipSecGlobalActiveTunnels' => '1.3.6.1.4.1.9.9.171.1.3.1.1',
  'cipSecGlobalPreviousTunnels' => '1.3.6.1.4.1.9.9.171.1.3.1.2',
  'cipSecGlobalInOctets' => '1.3.6.1.4.1.9.9.171.1.3.1.3',
  'cipSecGlobalHcInOctets' => '1.3.6.1.4.1.9.9.171.1.3.1.4',
  'cipSecGlobalInOctWraps' => '1.3.6.1.4.1.9.9.171.1.3.1.5',
  'cipSecGlobalInDecompOctets' => '1.3.6.1.4.1.9.9.171.1.3.1.6',
  'cipSecGlobalHcInDecompOctets' => '1.3.6.1.4.1.9.9.171.1.3.1.7',
  'cipSecGlobalInDecompOctWraps' => '1.3.6.1.4.1.9.9.171.1.3.1.8',
  'cipSecGlobalInPkts' => '1.3.6.1.4.1.9.9.171.1.3.1.9',
  'cipSecGlobalInDrops' => '1.3.6.1.4.1.9.9.171.1.3.1.10',
  'cipSecGlobalInReplayDrops' => '1.3.6.1.4.1.9.9.171.1.3.1.11',
  'cipSecGlobalInAuths' => '1.3.6.1.4.1.9.9.171.1.3.1.12',
  'cipSecGlobalInAuthFails' => '1.3.6.1.4.1.9.9.171.1.3.1.13',
  'cipSecGlobalInDecrypts' => '1.3.6.1.4.1.9.9.171.1.3.1.14',
  'cipSecGlobalInDecryptFails' => '1.3.6.1.4.1.9.9.171.1.3.1.15',
  'cipSecGlobalOutOctets' => '1.3.6.1.4.1.9.9.171.1.3.1.16',
  'cipSecGlobalHcOutOctets' => '1.3.6.1.4.1.9.9.171.1.3.1.17',
  'cipSecGlobalOutOctWraps' => '1.3.6.1.4.1.9.9.171.1.3.1.18',
  'cipSecGlobalOutUncompOctets' => '1.3.6.1.4.1.9.9.171.1.3.1.19',
  'cipSecGlobalHcOutUncompOctets' => '1.3.6.1.4.1.9.9.171.1.3.1.20',
  'cipSecGlobalOutUncompOctWraps' => '1.3.6.1.4.1.9.9.171.1.3.1.21',
  'cipSecGlobalOutPkts' => '1.3.6.1.4.1.9.9.171.1.3.1.22',
  'cipSecGlobalOutDrops' => '1.3.6.1.4.1.9.9.171.1.3.1.23',
  'cipSecGlobalOutAuths' => '1.3.6.1.4.1.9.9.171.1.3.1.24',
  'cipSecGlobalOutAuthFails' => '1.3.6.1.4.1.9.9.171.1.3.1.25',
  'cipSecGlobalOutEncrypts' => '1.3.6.1.4.1.9.9.171.1.3.1.26',
  'cipSecGlobalOutEncryptFails' => '1.3.6.1.4.1.9.9.171.1.3.1.27',
  'cipSecGlobalProtocolUseFails' => '1.3.6.1.4.1.9.9.171.1.3.1.28',
  'cipSecGlobalNoSaFails' => '1.3.6.1.4.1.9.9.171.1.3.1.29',
  'cipSecGlobalSysCapFails' => '1.3.6.1.4.1.9.9.171.1.3.1.30',
  'cipSecTunnelTable' => '1.3.6.1.4.1.9.9.171.1.3.2',
  'cipSecTunnelEntry' => '1.3.6.1.4.1.9.9.171.1.3.2.1',
  'cipSecTunIndex' => '1.3.6.1.4.1.9.9.171.1.3.2.1.1',
  'cipSecTunIkeTunnelIndex' => '1.3.6.1.4.1.9.9.171.1.3.2.1.2',
  'cipSecTunIkeTunnelAlive' => '1.3.6.1.4.1.9.9.171.1.3.2.1.3',
  'cipSecTunLocalAddr' => '1.3.6.1.4.1.9.9.171.1.3.2.1.4',
  'cipSecTunRemoteAddr' => '1.3.6.1.4.1.9.9.171.1.3.2.1.5',
  'cipSecTunKeyType' => '1.3.6.1.4.1.9.9.171.1.3.2.1.6',
  'cipSecTunKeyTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::KeyType',
  'cipSecTunEncapMode' => '1.3.6.1.4.1.9.9.171.1.3.2.1.7',
  'cipSecTunEncapModeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::EncapMode',
  'cipSecTunLifeSize' => '1.3.6.1.4.1.9.9.171.1.3.2.1.8',
  'cipSecTunLifeTime' => '1.3.6.1.4.1.9.9.171.1.3.2.1.9',
  'cipSecTunActiveTime' => '1.3.6.1.4.1.9.9.171.1.3.2.1.10',
  'cipSecTunSaLifeSizeThreshold' => '1.3.6.1.4.1.9.9.171.1.3.2.1.11',
  'cipSecTunSaLifeTimeThreshold' => '1.3.6.1.4.1.9.9.171.1.3.2.1.12',
  'cipSecTunTotalRefreshes' => '1.3.6.1.4.1.9.9.171.1.3.2.1.13',
  'cipSecTunExpiredSaInstances' => '1.3.6.1.4.1.9.9.171.1.3.2.1.14',
  'cipSecTunCurrentSaInstances' => '1.3.6.1.4.1.9.9.171.1.3.2.1.15',
  'cipSecTunInSaDiffHellmanGrp' => '1.3.6.1.4.1.9.9.171.1.3.2.1.16',
  'cipSecTunInSaDiffHellmanGrpDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::DiffHellmanGrp',
  'cipSecTunInSaEncryptAlgo' => '1.3.6.1.4.1.9.9.171.1.3.2.1.17',
  'cipSecTunInSaEncryptAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::EncryptAlgo',
  'cipSecTunInSaAhAuthAlgo' => '1.3.6.1.4.1.9.9.171.1.3.2.1.18',
  'cipSecTunInSaAhAuthAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::AuthAlgo',
  'cipSecTunInSaEspAuthAlgo' => '1.3.6.1.4.1.9.9.171.1.3.2.1.19',
  'cipSecTunInSaEspAuthAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::AuthAlgo',
  'cipSecTunInSaDecompAlgo' => '1.3.6.1.4.1.9.9.171.1.3.2.1.20',
  'cipSecTunInSaDecompAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::CompAlgo',
  'cipSecTunOutSaDiffHellmanGrp' => '1.3.6.1.4.1.9.9.171.1.3.2.1.21',
  'cipSecTunOutSaDiffHellmanGrpDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::DiffHellmanGrp',
  'cipSecTunOutSaEncryptAlgo' => '1.3.6.1.4.1.9.9.171.1.3.2.1.22',
  'cipSecTunOutSaEncryptAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::EncryptAlgo',
  'cipSecTunOutSaAhAuthAlgo' => '1.3.6.1.4.1.9.9.171.1.3.2.1.23',
  'cipSecTunOutSaAhAuthAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::AuthAlgo',
  'cipSecTunOutSaEspAuthAlgo' => '1.3.6.1.4.1.9.9.171.1.3.2.1.24',
  'cipSecTunOutSaEspAuthAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::AuthAlgo',
  'cipSecTunOutSaCompAlgo' => '1.3.6.1.4.1.9.9.171.1.3.2.1.25',
  'cipSecTunOutSaCompAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::CompAlgo',
  'cipSecTunInOctets' => '1.3.6.1.4.1.9.9.171.1.3.2.1.26',
  'cipSecTunHcInOctets' => '1.3.6.1.4.1.9.9.171.1.3.2.1.27',
  'cipSecTunInOctWraps' => '1.3.6.1.4.1.9.9.171.1.3.2.1.28',
  'cipSecTunInDecompOctets' => '1.3.6.1.4.1.9.9.171.1.3.2.1.29',
  'cipSecTunHcInDecompOctets' => '1.3.6.1.4.1.9.9.171.1.3.2.1.30',
  'cipSecTunInDecompOctWraps' => '1.3.6.1.4.1.9.9.171.1.3.2.1.31',
  'cipSecTunInPkts' => '1.3.6.1.4.1.9.9.171.1.3.2.1.32',
  'cipSecTunInDropPkts' => '1.3.6.1.4.1.9.9.171.1.3.2.1.33',
  'cipSecTunInReplayDropPkts' => '1.3.6.1.4.1.9.9.171.1.3.2.1.34',
  'cipSecTunInAuths' => '1.3.6.1.4.1.9.9.171.1.3.2.1.35',
  'cipSecTunInAuthFails' => '1.3.6.1.4.1.9.9.171.1.3.2.1.36',
  'cipSecTunInDecrypts' => '1.3.6.1.4.1.9.9.171.1.3.2.1.37',
  'cipSecTunInDecryptFails' => '1.3.6.1.4.1.9.9.171.1.3.2.1.38',
  'cipSecTunOutOctets' => '1.3.6.1.4.1.9.9.171.1.3.2.1.39',
  'cipSecTunHcOutOctets' => '1.3.6.1.4.1.9.9.171.1.3.2.1.40',
  'cipSecTunOutOctWraps' => '1.3.6.1.4.1.9.9.171.1.3.2.1.41',
  'cipSecTunOutUncompOctets' => '1.3.6.1.4.1.9.9.171.1.3.2.1.42',
  'cipSecTunHcOutUncompOctets' => '1.3.6.1.4.1.9.9.171.1.3.2.1.43',
  'cipSecTunOutUncompOctWraps' => '1.3.6.1.4.1.9.9.171.1.3.2.1.44',
  'cipSecTunOutPkts' => '1.3.6.1.4.1.9.9.171.1.3.2.1.45',
  'cipSecTunOutDropPkts' => '1.3.6.1.4.1.9.9.171.1.3.2.1.46',
  'cipSecTunOutAuths' => '1.3.6.1.4.1.9.9.171.1.3.2.1.47',
  'cipSecTunOutAuthFails' => '1.3.6.1.4.1.9.9.171.1.3.2.1.48',
  'cipSecTunOutEncrypts' => '1.3.6.1.4.1.9.9.171.1.3.2.1.49',
  'cipSecTunOutEncryptFails' => '1.3.6.1.4.1.9.9.171.1.3.2.1.50',
  'cipSecTunStatus' => '1.3.6.1.4.1.9.9.171.1.3.2.1.51',
  'cipSecTunStatusDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::TunnelStatus',
  'cipSecEndPtTable' => '1.3.6.1.4.1.9.9.171.1.3.3',
  'cipSecEndPtEntry' => '1.3.6.1.4.1.9.9.171.1.3.3.1',
  'cipSecEndPtIndex' => '1.3.6.1.4.1.9.9.171.1.3.3.1.1',
  'cipSecEndPtLocalName' => '1.3.6.1.4.1.9.9.171.1.3.3.1.2',
  'cipSecEndPtLocalType' => '1.3.6.1.4.1.9.9.171.1.3.3.1.3',
  'cipSecEndPtLocalTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::EndPtType',
  'cipSecEndPtLocalAddr1' => '1.3.6.1.4.1.9.9.171.1.3.3.1.4',
  'cipSecEndPtLocalAddr2' => '1.3.6.1.4.1.9.9.171.1.3.3.1.5',
  'cipSecEndPtLocalProtocol' => '1.3.6.1.4.1.9.9.171.1.3.3.1.6',
  'cipSecEndPtLocalPort' => '1.3.6.1.4.1.9.9.171.1.3.3.1.7',
  'cipSecEndPtRemoteName' => '1.3.6.1.4.1.9.9.171.1.3.3.1.8',
  'cipSecEndPtRemoteType' => '1.3.6.1.4.1.9.9.171.1.3.3.1.9',
  'cipSecEndPtRemoteTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::EndPtType',
  'cipSecEndPtRemoteAddr1' => '1.3.6.1.4.1.9.9.171.1.3.3.1.10',
  'cipSecEndPtRemoteAddr2' => '1.3.6.1.4.1.9.9.171.1.3.3.1.11',
  'cipSecEndPtRemoteProtocol' => '1.3.6.1.4.1.9.9.171.1.3.3.1.12',
  'cipSecEndPtRemotePort' => '1.3.6.1.4.1.9.9.171.1.3.3.1.13',
  'cipSecSpiTable' => '1.3.6.1.4.1.9.9.171.1.3.4',
  'cipSecSpiEntry' => '1.3.6.1.4.1.9.9.171.1.3.4.1',
  'cipSecSpiIndex' => '1.3.6.1.4.1.9.9.171.1.3.4.1.1',
  'cipSecSpiDirection' => '1.3.6.1.4.1.9.9.171.1.3.4.1.2',
  'cipSecSpiDirectionDefinition' => {
    '1' => 'in',
    '2' => 'out',
  },
  'cipSecSpiValue' => '1.3.6.1.4.1.9.9.171.1.3.4.1.3',
  'cipSecSpiProtocol' => '1.3.6.1.4.1.9.9.171.1.3.4.1.4',
  'cipSecSpiProtocolDefinition' => {
    '1' => 'ah',
    '2' => 'esp',
    '3' => 'ipcomp',
  },
  'cipSecSpiStatus' => '1.3.6.1.4.1.9.9.171.1.3.4.1.5',
  'cipSecSpiStatusDefinition' => {
    '1' => 'active',
    '2' => 'expiring',
  },
  'cipSecPhase2GWStatsTable' => '1.3.6.1.4.1.9.9.171.1.3.5',
  'cipSecPhase2GWStatsEntry' => '1.3.6.1.4.1.9.9.171.1.3.5.1',
  'cipSecPhase2GWActiveTunnels' => '1.3.6.1.4.1.9.9.171.1.3.5.1.1',
  'cipSecPhase2GWPreviousTunnels' => '1.3.6.1.4.1.9.9.171.1.3.5.1.2',
  'cipSecPhase2GWInOctets' => '1.3.6.1.4.1.9.9.171.1.3.5.1.3',
  'cipSecPhase2GWInOctWraps' => '1.3.6.1.4.1.9.9.171.1.3.5.1.4',
  'cipSecPhase2GWInDecompOctets' => '1.3.6.1.4.1.9.9.171.1.3.5.1.5',
  'cipSecPhase2GWInDecompOctWraps' => '1.3.6.1.4.1.9.9.171.1.3.5.1.6',
  'cipSecPhase2GWInPkts' => '1.3.6.1.4.1.9.9.171.1.3.5.1.7',
  'cipSecPhase2GWInDrops' => '1.3.6.1.4.1.9.9.171.1.3.5.1.8',
  'cipSecPhase2GWInReplayDrops' => '1.3.6.1.4.1.9.9.171.1.3.5.1.9',
  'cipSecPhase2GWInAuths' => '1.3.6.1.4.1.9.9.171.1.3.5.1.10',
  'cipSecPhase2GWInAuthFails' => '1.3.6.1.4.1.9.9.171.1.3.5.1.11',
  'cipSecPhase2GWInDecrypts' => '1.3.6.1.4.1.9.9.171.1.3.5.1.12',
  'cipSecPhase2GWInDecryptFails' => '1.3.6.1.4.1.9.9.171.1.3.5.1.13',
  'cipSecPhase2GWOutOctets' => '1.3.6.1.4.1.9.9.171.1.3.5.1.14',
  'cipSecPhase2GWOutOctWraps' => '1.3.6.1.4.1.9.9.171.1.3.5.1.15',
  'cipSecPhase2GWOutUncompOctets' => '1.3.6.1.4.1.9.9.171.1.3.5.1.16',
  'cipSecPhase2GWOutUncompOctWraps' => '1.3.6.1.4.1.9.9.171.1.3.5.1.17',
  'cipSecPhase2GWOutPkts' => '1.3.6.1.4.1.9.9.171.1.3.5.1.18',
  'cipSecPhase2GWOutDrops' => '1.3.6.1.4.1.9.9.171.1.3.5.1.19',
  'cipSecPhase2GWOutAuths' => '1.3.6.1.4.1.9.9.171.1.3.5.1.20',
  'cipSecPhase2GWOutAuthFails' => '1.3.6.1.4.1.9.9.171.1.3.5.1.21',
  'cipSecPhase2GWOutEncrypts' => '1.3.6.1.4.1.9.9.171.1.3.5.1.22',
  'cipSecPhase2GWOutEncryptFails' => '1.3.6.1.4.1.9.9.171.1.3.5.1.23',
  'cipSecPhase2GWProtocolUseFails' => '1.3.6.1.4.1.9.9.171.1.3.5.1.24',
  'cipSecPhase2GWNoSaFails' => '1.3.6.1.4.1.9.9.171.1.3.5.1.25',
  'cipSecPhase2GWSysCapFails' => '1.3.6.1.4.1.9.9.171.1.3.5.1.26',
  'cipSecHistory' => '1.3.6.1.4.1.9.9.171.1.4',
  'cipSecHistGlobal' => '1.3.6.1.4.1.9.9.171.1.4.1',
  'cipSecHistGlobalCntl' => '1.3.6.1.4.1.9.9.171.1.4.1.1',
  'cipSecHistTableSize' => '1.3.6.1.4.1.9.9.171.1.4.1.1.1',
  'cipSecHistCheckPoint' => '1.3.6.1.4.1.9.9.171.1.4.1.1.2',
  'cipSecHistCheckPointDefinition' => {
    '1' => 'ready',
    '2' => 'checkPoint',
  },
  'cipSecHistPhaseOne' => '1.3.6.1.4.1.9.9.171.1.4.2',
  'cikeTunnelHistTable' => '1.3.6.1.4.1.9.9.171.1.4.2.1',
  'cikeTunnelHistEntry' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1',
  'cikeTunHistIndex' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.1',
  'cikeTunHistTermReason' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.2',
  'cikeTunHistTermReasonDefinition' => {
    '1' => 'other',
    '2' => 'normal',
    '3' => 'operRequest',
    '4' => 'peerDelRequest',
    '5' => 'peerLost',
    '6' => 'localFailure',
    '7' => 'checkPointReg',
  },
  'cikeTunHistActiveIndex' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.3',
  'cikeTunHistPeerLocalType' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.4',
  'cikeTunHistPeerLocalTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkePeerType',
  'cikeTunHistPeerLocalValue' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.5',
  'cikeTunHistPeerIntIndex' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.6',
  'cikeTunHistPeerRemoteType' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.7',
  'cikeTunHistPeerRemoteTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkePeerType',
  'cikeTunHistPeerRemoteValue' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.8',
  'cikeTunHistLocalAddr' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.9',
  'cikeTunHistLocalName' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.10',
  'cikeTunHistRemoteAddr' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.11',
  'cikeTunHistRemoteName' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.12',
  'cikeTunHistNegoMode' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.13',
  'cikeTunHistNegoModeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkeNegoMode',
  'cikeTunHistDiffHellmanGrp' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.14',
  'cikeTunHistDiffHellmanGrpDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::DiffHellmanGrp',
  'cikeTunHistEncryptAlgo' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.15',
  'cikeTunHistEncryptAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::EncryptAlgo',
  'cikeTunHistHashAlgo' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.16',
  'cikeTunHistHashAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkeHashAlgo',
  'cikeTunHistAuthMethod' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.17',
  'cikeTunHistAuthMethodDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkeAuthMethod',
  'cikeTunHistLifeTime' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.18',
  'cikeTunHistStartTime' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.19',
  'cikeTunHistActiveTime' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.20',
  'cikeTunHistTotalRefreshes' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.21',
  'cikeTunHistTotalSas' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.22',
  'cikeTunHistInOctets' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.23',
  'cikeTunHistInPkts' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.24',
  'cikeTunHistInDropPkts' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.25',
  'cikeTunHistInNotifys' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.26',
  'cikeTunHistInP2Exchgs' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.27',
  'cikeTunHistInP2ExchgInvalids' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.28',
  'cikeTunHistInP2ExchgRejects' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.29',
  'cikeTunHistInP2SaDelRequests' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.30',
  'cikeTunHistOutOctets' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.31',
  'cikeTunHistOutPkts' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.32',
  'cikeTunHistOutDropPkts' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.33',
  'cikeTunHistOutNotifys' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.34',
  'cikeTunHistOutP2Exchgs' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.35',
  'cikeTunHistOutP2ExchgInvalids' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.36',
  'cikeTunHistOutP2ExchgRejects' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.37',
  'cikeTunHistOutP2SaDelRequests' => '1.3.6.1.4.1.9.9.171.1.4.2.1.1.38',
  'cipSecHistPhaseTwo' => '1.3.6.1.4.1.9.9.171.1.4.3',
  'cipSecTunnelHistTable' => '1.3.6.1.4.1.9.9.171.1.4.3.1',
  'cipSecTunnelHistEntry' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1',
  'cipSecTunHistIndex' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.1',
  'cipSecTunHistTermReason' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.2',
  'cipSecTunHistTermReasonDefinition' => {
    '1' => 'other',
    '2' => 'normal',
    '3' => 'operRequest',
    '4' => 'peerDelRequest',
    '5' => 'peerLost',
    '6' => 'seqNumRollOver',
    '7' => 'checkPointReq',
  },
  'cipSecTunHistActiveIndex' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.3',
  'cipSecTunHistLocalAddr' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.5',
  'cipSecTunHistRemoteAddr' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.6',
  'cipSecTunHistKeyType' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.7',
  'cipSecTunHistKeyTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::KeyType',
  'cipSecTunHistEncapMode' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.8',
  'cipSecTunHistEncapModeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::EncapMode',
  'cipSecTunHistLifeSize' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.9',
  'cipSecTunHistLifeTime' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.10',
  'cipSecTunHistStartTime' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.11',
  'cipSecTunHistActiveTime' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.12',
  'cipSecTunHistTotalRefreshes' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.13',
  'cipSecTunHistTotalSas' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.14',
  'cipSecTunHistInSaDiffHellmanGrp' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.15',
  'cipSecTunHistInSaDiffHellmanGrpDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::DiffHellmanGrp',
  'cipSecTunHistInSaEncryptAlgo' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.16',
  'cipSecTunHistInSaEncryptAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::EncryptAlgo',
  'cipSecTunHistInSaAhAuthAlgo' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.17',
  'cipSecTunHistInSaAhAuthAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::AuthAlgo',
  'cipSecTunHistInSaEspAuthAlgo' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.18',
  'cipSecTunHistInSaEspAuthAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::AuthAlgo',
  'cipSecTunHistInSaDecompAlgo' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.19',
  'cipSecTunHistInSaDecompAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::CompAlgo',
  'cipSecTunHistOutSaDiffHellmanGrp' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.20',
  'cipSecTunHistOutSaDiffHellmanGrpDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::DiffHellmanGrp',
  'cipSecTunHistOutSaEncryptAlgo' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.21',
  'cipSecTunHistOutSaEncryptAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::EncryptAlgo',
  'cipSecTunHistOutSaAhAuthAlgo' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.22',
  'cipSecTunHistOutSaAhAuthAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::AuthAlgo',
  'cipSecTunHistOutSaEspAuthAlgo' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.23',
  'cipSecTunHistOutSaEspAuthAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::AuthAlgo',
  'cipSecTunHistOutSaCompAlgo' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.24',
  'cipSecTunHistOutSaCompAlgoDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::CompAlgo',
  'cipSecTunHistInOctets' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.25',
  'cipSecTunHistHcInOctets' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.26',
  'cipSecTunHistInOctWraps' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.27',
  'cipSecTunHistInDecompOctets' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.28',
  'cipSecTunHistHcInDecompOctets' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.29',
  'cipSecTunHistInDecompOctWraps' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.30',
  'cipSecTunHistInPkts' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.31',
  'cipSecTunHistInDropPkts' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.32',
  'cipSecTunHistInReplayDropPkts' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.33',
  'cipSecTunHistInAuths' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.34',
  'cipSecTunHistInAuthFails' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.35',
  'cipSecTunHistInDecrypts' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.36',
  'cipSecTunHistInDecryptFails' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.37',
  'cipSecTunHistOutOctets' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.38',
  'cipSecTunHistHcOutOctets' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.39',
  'cipSecTunHistOutOctWraps' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.40',
  'cipSecTunHistOutUncompOctets' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.41',
  'cipSecTunHistHcOutUncompOctets' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.42',
  'cipSecTunHistOutUncompOctWraps' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.43',
  'cipSecTunHistOutPkts' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.44',
  'cipSecTunHistOutDropPkts' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.45',
  'cipSecTunHistOutAuths' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.46',
  'cipSecTunHistOutAuthFails' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.47',
  'cipSecTunHistOutEncrypts' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.48',
  'cipSecTunHistOutEncryptFails' => '1.3.6.1.4.1.9.9.171.1.4.3.1.1.49',
  'cipSecEndPtHistTable' => '1.3.6.1.4.1.9.9.171.1.4.3.2',
  'cipSecEndPtHistEntry' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1',
  'cipSecEndPtHistIndex' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1.1',
  'cipSecEndPtHistTunIndex' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1.2',
  'cipSecEndPtHistActiveIndex' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1.3',
  'cipSecEndPtHistLocalName' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1.4',
  'cipSecEndPtHistLocalType' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1.5',
  'cipSecEndPtHistLocalTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::EndPtType',
  'cipSecEndPtHistLocalAddr1' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1.6',
  'cipSecEndPtHistLocalAddr2' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1.7',
  'cipSecEndPtHistLocalProtocol' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1.8',
  'cipSecEndPtHistLocalPort' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1.9',
  'cipSecEndPtHistRemoteName' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1.10',
  'cipSecEndPtHistRemoteType' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1.11',
  'cipSecEndPtHistRemoteTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::EndPtType',
  'cipSecEndPtHistRemoteAddr1' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1.12',
  'cipSecEndPtHistRemoteAddr2' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1.13',
  'cipSecEndPtHistRemoteProtocol' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1.14',
  'cipSecEndPtHistRemotePort' => '1.3.6.1.4.1.9.9.171.1.4.3.2.1.15',
  'cipSecFailures' => '1.3.6.1.4.1.9.9.171.1.5',
  'cipSecFailGlobal' => '1.3.6.1.4.1.9.9.171.1.5.1',
  'cipSecFailGlobalCntl' => '1.3.6.1.4.1.9.9.171.1.5.1.1',
  'cipSecFailTableSize' => '1.3.6.1.4.1.9.9.171.1.5.1.1.1',
  'cipSecFailPhaseOne' => '1.3.6.1.4.1.9.9.171.1.5.2',
  'cikeFailTable' => '1.3.6.1.4.1.9.9.171.1.5.2.1',
  'cikeFailEntry' => '1.3.6.1.4.1.9.9.171.1.5.2.1.1',
  'cikeFailIndex' => '1.3.6.1.4.1.9.9.171.1.5.2.1.1.1',
  'cikeFailReason' => '1.3.6.1.4.1.9.9.171.1.5.2.1.1.2',
  'cikeFailReasonDefinition' => {
    '1' => 'other',
    '2' => 'peerDelRequest',
    '3' => 'peerLost',
    '4' => 'localFailure',
    '5' => 'authFailure',
    '6' => 'hashValidation',
    '7' => 'encryptFailure',
    '8' => 'internalError',
    '9' => 'sysCapExceeded',
    '10' => 'proposalFailure',
    '11' => 'peerCertUnavailable',
    '12' => 'peerCertNotValid',
    '13' => 'localCertExpired',
    '14' => 'crlFailure',
    '15' => 'peerEncodingError',
    '16' => 'nonExistentSa',
    '17' => 'operRequest',
  },
  'cikeFailTime' => '1.3.6.1.4.1.9.9.171.1.5.2.1.1.3',
  'cikeFailLocalType' => '1.3.6.1.4.1.9.9.171.1.5.2.1.1.4',
  'cikeFailLocalTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkePeerType',
  'cikeFailLocalValue' => '1.3.6.1.4.1.9.9.171.1.5.2.1.1.5',
  'cikeFailRemoteType' => '1.3.6.1.4.1.9.9.171.1.5.2.1.1.6',
  'cikeFailRemoteTypeDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::IkePeerType',
  'cikeFailRemoteValue' => '1.3.6.1.4.1.9.9.171.1.5.2.1.1.7',
  'cikeFailLocalAddr' => '1.3.6.1.4.1.9.9.171.1.5.2.1.1.8',
  'cikeFailRemoteAddr' => '1.3.6.1.4.1.9.9.171.1.5.2.1.1.9',
  'cipSecFailPhaseTwo' => '1.3.6.1.4.1.9.9.171.1.5.3',
  'cipSecFailTable' => '1.3.6.1.4.1.9.9.171.1.5.3.1',
  'cipSecFailEntry' => '1.3.6.1.4.1.9.9.171.1.5.3.1.1',
  'cipSecFailIndex' => '1.3.6.1.4.1.9.9.171.1.5.3.1.1.1',
  'cipSecFailReason' => '1.3.6.1.4.1.9.9.171.1.5.3.1.1.2',
  'cipSecFailReasonDefinition' => {
    '1' => 'other',
    '2' => 'internalError',
    '3' => 'peerEncodingError',
    '4' => 'proposalFailure',
    '5' => 'protocolUseFail',
    '6' => 'nonExistentSa',
    '7' => 'decryptFailure',
    '8' => 'encryptFailure',
    '9' => 'inAuthFailure',
    '10' => 'outAuthFailure',
    '11' => 'compression',
    '12' => 'sysCapExceeded',
    '13' => 'peerDelRequest',
    '14' => 'peerLost',
    '15' => 'seqNumRollOver',
    '16' => 'operRequest',
  },
  'cipSecFailTime' => '1.3.6.1.4.1.9.9.171.1.5.3.1.1.3',
  'cipSecFailTunnelIndex' => '1.3.6.1.4.1.9.9.171.1.5.3.1.1.4',
  'cipSecFailSaSpi' => '1.3.6.1.4.1.9.9.171.1.5.3.1.1.5',
  'cipSecFailPktSrcAddr' => '1.3.6.1.4.1.9.9.171.1.5.3.1.1.6',
  'cipSecFailPktDstAddr' => '1.3.6.1.4.1.9.9.171.1.5.3.1.1.7',
  'cipSecTrapCntl' => '1.3.6.1.4.1.9.9.171.1.6',
  'cipSecTrapCntlIkeTunnelStart' => '1.3.6.1.4.1.9.9.171.1.6.1',
  'cipSecTrapCntlIkeTunnelStartDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::TrapStatus',
  'cipSecTrapCntlIkeTunnelStop' => '1.3.6.1.4.1.9.9.171.1.6.2',
  'cipSecTrapCntlIkeTunnelStopDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::TrapStatus',
  'cipSecTrapCntlIkeSysFailure' => '1.3.6.1.4.1.9.9.171.1.6.3',
  'cipSecTrapCntlIkeSysFailureDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::TrapStatus',
  'cipSecTrapCntlIkeCertCrlFailure' => '1.3.6.1.4.1.9.9.171.1.6.4',
  'cipSecTrapCntlIkeCertCrlFailureDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::TrapStatus',
  'cipSecTrapCntlIkeProtocolFail' => '1.3.6.1.4.1.9.9.171.1.6.5',
  'cipSecTrapCntlIkeProtocolFailDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::TrapStatus',
  'cipSecTrapCntlIkeNoSa' => '1.3.6.1.4.1.9.9.171.1.6.6',
  'cipSecTrapCntlIkeNoSaDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::TrapStatus',
  'cipSecTrapCntlIpSecTunnelStart' => '1.3.6.1.4.1.9.9.171.1.6.7',
  'cipSecTrapCntlIpSecTunnelStartDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::TrapStatus',
  'cipSecTrapCntlIpSecTunnelStop' => '1.3.6.1.4.1.9.9.171.1.6.8',
  'cipSecTrapCntlIpSecTunnelStopDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::TrapStatus',
  'cipSecTrapCntlIpSecSysFailure' => '1.3.6.1.4.1.9.9.171.1.6.9',
  'cipSecTrapCntlIpSecSysFailureDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::TrapStatus',
  'cipSecTrapCntlIpSecSetUpFailure' => '1.3.6.1.4.1.9.9.171.1.6.10',
  'cipSecTrapCntlIpSecSetUpFailureDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::TrapStatus',
  'cipSecTrapCntlIpSecEarlyTunTerm' => '1.3.6.1.4.1.9.9.171.1.6.11',
  'cipSecTrapCntlIpSecEarlyTunTermDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::TrapStatus',
  'cipSecTrapCntlIpSecProtocolFail' => '1.3.6.1.4.1.9.9.171.1.6.12',
  'cipSecTrapCntlIpSecProtocolFailDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::TrapStatus',
  'cipSecTrapCntlIpSecNoSa' => '1.3.6.1.4.1.9.9.171.1.6.13',
  'cipSecTrapCntlIpSecNoSaDefinition' => 'CISCO-IPSEC-FLOW-MONITOR-MIB::TrapStatus',
  'cipSecMIBNotificationPrefix' => '1.3.6.1.4.1.9.9.171.2',
  'cipSecMIBNotifications' => '1.3.6.1.4.1.9.9.171.2.0.1.2.3.4.5.6.7.8.9.10.11.12.13',
  'cipSecMIBConformance' => '1.3.6.1.4.1.9.9.171.3',
  'cipSecMIBGroups' => '1.3.6.1.4.1.9.9.171.3.1',
  'cipSecMIBCompliances' => '1.3.6.1.4.1.9.9.171.3.1.8',
  'hardware' => '1.3.6.1.4.1.3764.1.1.200',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCO-IPSEC-FLOW-MONITOR-MIB'} = {
  'IkeNegoMode' => {
    '1' => 'main',
    '2' => 'aggressive',
  },
  'DiffHellmanGrp' => {
    '1' => 'none',
    '2' => 'dhGroup1',
    '3' => 'dhGroup2',
  },
  'cipSecHistCheckPoint' => {
    '1' => 'ready',
    '2' => 'checkPoint',
  },
  'AuthAlgo' => {
    '1' => 'none',
    '2' => 'hmacMd5',
    '3' => 'hmacSha',
  },
  'EncryptAlgo' => {
    '1' => 'none',
    '2' => 'des',
    '3' => 'des3',
  },
  'CompAlgo' => {
    '1' => 'none',
    '2' => 'ldf',
  },
  'cipSecSpiStatus' => {
    '1' => 'active',
    '2' => 'expiring',
  },
  'cipSecTunHistTermReason' => {
    '1' => 'other',
    '2' => 'normal',
    '3' => 'operRequest',
    '4' => 'peerDelRequest',
    '5' => 'peerLost',
    '6' => 'seqNumRollOver',
    '7' => 'checkPointReq',
  },
  'cikeTunHistTermReason' => {
    '1' => 'other',
    '2' => 'normal',
    '3' => 'operRequest',
    '4' => 'peerDelRequest',
    '5' => 'peerLost',
    '6' => 'localFailure',
    '7' => 'checkPointReg',
  },
  'TunnelStatus' => {
    '1' => 'active',
    '2' => 'destroy',
  },
  'EndPtType' => {
    '1' => 'singleIpAddr',
    '2' => 'ipAddrRange',
    '3' => 'ipSubnet',
  },
  'IkePeerType' => {
    '1' => 'ipAddrPeer',
    '2' => 'namePeer',
  },
  'IkeAuthMethod' => {
    '1' => 'none',
    '2' => 'preSharedKey',
    '3' => 'rsaSig',
    '4' => 'rsaEncrypt',
    '5' => 'revPublicKey',
  },
  'EncapMode' => {
    '1' => 'tunnel',
    '2' => 'transport',
  },
  'cipSecSpiProtocol' => {
    '1' => 'ah',
    '2' => 'esp',
    '3' => 'ipcomp',
  },
  'IkeHashAlgo' => {
    '1' => 'none',
    '2' => 'md5',
    '3' => 'sha',
  },
  'cipSecSpiDirection' => {
    '1' => 'in',
    '2' => 'out',
  },
  'KeyType' => {
    '1' => 'ike',
    '2' => 'manual',
  },
  'cikeFailReason' => {
    '1' => 'other',
    '2' => 'peerDelRequest',
    '3' => 'peerLost',
    '4' => 'localFailure',
    '5' => 'authFailure',
    '6' => 'hashValidation',
    '7' => 'encryptFailure',
    '8' => 'internalError',
    '9' => 'sysCapExceeded',
    '10' => 'proposalFailure',
    '11' => 'peerCertUnavailable',
    '12' => 'peerCertNotValid',
    '13' => 'localCertExpired',
    '14' => 'crlFailure',
    '15' => 'peerEncodingError',
    '16' => 'nonExistentSa',
    '17' => 'operRequest',
  },
  'TrapStatus' => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  'cipSecFailReason' => {
    '1' => 'other',
    '2' => 'internalError',
    '3' => 'peerEncodingError',
    '4' => 'proposalFailure',
    '5' => 'protocolUseFail',
    '6' => 'nonExistentSa',
    '7' => 'decryptFailure',
    '8' => 'encryptFailure',
    '9' => 'inAuthFailure',
    '10' => 'outAuthFailure',
    '11' => 'compression',
    '12' => 'sysCapExceeded',
    '13' => 'peerDelRequest',
    '14' => 'peerLost',
    '15' => 'seqNumRollOver',
    '16' => 'operRequest',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOL2L3INTERFACECONFIGMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-L2L3-INTERFACE-CONFIG-MIB'} = {
  url => '',
  name => 'CISCO-L2L3-INTERFACE-CONFIG-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-L2L3-INTERFACE-CONFIG-MIB'} = {
  'cL2L3IfTable' => '1.3.6.1.4.1.9.9.151.1.1.1',
  'cL2L3IfEntry' => '1.3.6.1.4.1.9.9.151.1.1.1.1',
  'cL2L3IfModeAdmin' => '1.3.6.1.4.1.9.9.151.1.1.1.1.1',
  'cL2L3IfModeAdminDefinition' => 'CISCO-L2L3-INTERFACE-CONFIG-MIB::CL2L3InterfaceMode',
  'cL2L3IfModeOper' => '1.3.6.1.4.1.9.9.151.1.1.1.1.2',
  'cL2L3IfModeOperDefinition' => 'CISCO-L2L3-INTERFACE-CONFIG-MIB::CL2L3InterfaceMode',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCO-L2L3-INTERFACE-CONFIG-MIB'} = {
  'CL2L3InterfaceMode' => {
    '1' => 'routed',
    '2' => 'switchport',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOMEMORYPOOLMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-MEMORY-POOL-MIB'} = {
  url => '',
  name => 'CISCO-MEMORY-POOL-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-MEMORY-POOL-MIB'} = {
  'ciscoMemoryPoolTable' => '1.3.6.1.4.1.9.9.48.1.1',
  'ciscoMemoryPoolEntry' => '1.3.6.1.4.1.9.9.48.1.1.1',
  'ciscoMemoryPoolType' => '1.3.6.1.4.1.9.9.48.1.1.1.1',
  'ciscoMemoryPoolTypeDefinition' => {
    '1' => 'processor memory',
    '2' => 'i/o memory',
    '3' => 'pci memory',
    '4' => 'fast memory',
    '5' => 'multibus memory',
  },
  'ciscoMemoryPoolName' => '1.3.6.1.4.1.9.9.48.1.1.1.2',
  'ciscoMemoryPoolAlternate' => '1.3.6.1.4.1.9.9.48.1.1.1.3',
  'ciscoMemoryPoolValid' => '1.3.6.1.4.1.9.9.48.1.1.1.4',
  'ciscoMemoryPoolUsed' => '1.3.6.1.4.1.9.9.48.1.1.1.5',
  'ciscoMemoryPoolFree' => '1.3.6.1.4.1.9.9.48.1.1.1.6',
  'ciscoMemoryPoolLargestFree' => '1.3.6.1.4.1.9.9.48.1.1.1.7',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOPROCESSMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-PROCESS-MIB'} = {
  url => '',
  name => 'CISCO-PROCESS-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-PROCESS-MIB'} = {
  'cpmCPUTotalTable' => '1.3.6.1.4.1.9.9.109.1.1.1',
  'cpmCPUTotalEntry' => '1.3.6.1.4.1.9.9.109.1.1.1.1',
  'cpmCPUTotalIndex' => '1.3.6.1.4.1.9.9.109.1.1.1.1.1',
  'cpmCPUTotalPhysicalIndex' => '1.3.6.1.4.1.9.9.109.1.1.1.1.2',
  'cpmCPUTotal5sec' => '1.3.6.1.4.1.9.9.109.1.1.1.1.3',
  'cpmCPUTotal1min' => '1.3.6.1.4.1.9.9.109.1.1.1.1.4',
  'cpmCPUTotal5min' => '1.3.6.1.4.1.9.9.109.1.1.1.1.5',
  'cpmCPUTotal5secRev' => '1.3.6.1.4.1.9.9.109.1.1.1.1.6',
  'cpmCPUTotal1minRev' => '1.3.6.1.4.1.9.9.109.1.1.1.1.7',
  'cpmCPUTotal5minRev' => '1.3.6.1.4.1.9.9.109.1.1.1.1.8',
  'cpmCPUMonInterval' => '1.3.6.1.4.1.9.9.109.1.1.1.1.9',
  'cpmCPUTotalMonIntervalDefinition' => '1.3.6.1.4.1.9.9.109.1.1.1.1.10',
  'cpmCPUInterruptMonIntervalDefinition' => '1.3.6.1.4.1.9.9.109.1.1.1.1.11',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOSBHWENVIROMENT;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCOSB-HWENVIROMENT'} = {
  url => '',
  name => 'CISCOSB-HWENVIROMENT',
};

#$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'CISCOSB-HWENVIROMENT'} = 

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCOSB-HWENVIROMENT'} = {
  rlEnv => '1.3.6.1.4.1.9.6.1.101.83',
  rlEnvPhysicalDescription => '1.3.6.1.4.1.9.6.1.101.83.1',
  rlEnvMonFanStatusTable => '1.3.6.1.4.1.9.6.1.101.83.1.1',
  rlEnvMonFanStatusEntry => '1.3.6.1.4.1.9.6.1.101.83.1.1.1',
  rlEnvMonFanStatusIndex => '1.3.6.1.4.1.9.6.1.101.83.1.1.1.1',
  rlEnvMonFanStatusDescr => '1.3.6.1.4.1.9.6.1.101.83.1.1.1.2',
  rlEnvMonFanState => '1.3.6.1.4.1.9.6.1.101.83.1.1.1.3',
  rlEnvMonFanStateDefinition => 'CISCOSB-HWENVIROMENT::RlEnvMonState',
  rlEnvMonSupplyStatusTable => '1.3.6.1.4.1.9.6.1.101.83.1.2',
  rlEnvMonSupplyStatusEntry => '1.3.6.1.4.1.9.6.1.101.83.1.2.1',
  rlEnvMonSupplyStatusIndex => '1.3.6.1.4.1.9.6.1.101.83.1.2.1.1',
  rlEnvMonSupplyStatusDescr => '1.3.6.1.4.1.9.6.1.101.83.1.2.1.2',
  rlEnvMonSupplyState => '1.3.6.1.4.1.9.6.1.101.83.1.2.1.3',
  rlEnvMonSupplyStateDefinition => 'CISCOSB-HWENVIROMENT::RlEnvMonState',
  rlEnvMonSupplySource => '1.3.6.1.4.1.9.6.1.101.83.1.2.1.4',
  rlEnvMonSupplySourceDefinition => 'CISCOSB-HWENVIROMENT::rlEnvMonSupplySource',
  rlEnvMonSupplyFanDirection => '1.3.6.1.4.1.9.6.1.101.83.1.2.1.5',
  rlEnvMonSupplyFanDirectionDefinition => 'CISCOSB-HWENVIROMENT::RlEnvMonDirection',
  rlEnvFanData => '1.3.6.1.4.1.9.6.1.101.83.5',
  rlEnvFanDataTable => '1.3.6.1.4.1.9.6.1.101.83.5.1',
  rlEnvFanDataEntry => '1.3.6.1.4.1.9.6.1.101.83.5.1.1',
  rlEnvFanDataStackUnit => '1.3.6.1.4.1.9.6.1.101.83.5.1.1.1',
  rlEnvFanDataTemp => '1.3.6.1.4.1.9.6.1.101.83.5.1.1.2',
  rlEnvFanDataSpeed => '1.3.6.1.4.1.9.6.1.101.83.5.1.1.3',
  rlEnvFanDataOperLevel => '1.3.6.1.4.1.9.6.1.101.83.5.1.1.4',
  rlEnvFanDataAdminLevel => '1.3.6.1.4.1.9.6.1.101.83.5.1.1.5',
  rlEnvFanDataDirection => '1.3.6.1.4.1.9.6.1.101.83.5.1.1.6',
  rlEnvFanDataDirectionDefinition => 'CISCOSB-HWENVIROMENT::RlEnvMonDirection',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCOSB-HWENVIROMENT'} = {
  rlEnvMonSupplySource => {
    '1' => 'unknown',
    '2' => 'ac',
    '3' => 'dc',
    '4' => 'externalPowerSupply',
    '5' => 'internalRedundant',
  },
  RlEnvMonDirection => {
    '1' => 'unKnown',
    '2' => 'frontToBack',
    '3' => 'backToFront',
    '4' => 'clockwise',
    '5' => 'unClockwise',
    '6' => 'insideOut',
    '7' => 'outsideIn',
    '8' => 'rightToLeft',
    '9' => 'leftToRight',
  },
  RlEnvMonState => {
    '1' => 'normal',
    '2' => 'warning',
    '3' => 'critical',
    '4' => 'shutdown',
    '5' => 'notPresent',
    '6' => 'notFunctioning',
  },
};
package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOSBRNDMNG;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCOSB-RNDMNG'} = {
  url => '',
  name => 'CISCOSB-RNDMNG',
};

#$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'CISCOSB-RNDMNG'} = 

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCOSB-RNDMNG'} = {
  rndMng => '1.3.6.1.4.1.9.6.1.101.1',
  rndSysId => '1.3.6.1.4.1.9.6.1.101.1.1',
  rndAction => '1.3.6.1.4.1.9.6.1.101.1.2',
  rndActionDefinition => 'CISCOSB-rndMng::rndAction',
  rndFileName => '1.3.6.1.4.1.9.6.1.101.1.3',
  rlSnmpVersionSupported => '1.3.6.1.4.1.9.6.1.101.1.4',
  rlSnmpMibVersion => '1.3.6.1.4.1.9.6.1.101.1.5',
  rlCpuUtilEnable => '1.3.6.1.4.1.9.6.1.101.1.6',
  rlCpuUtilDuringLastSecond => '1.3.6.1.4.1.9.6.1.101.1.7',
  rlCpuUtilDuringLastMinute => '1.3.6.1.4.1.9.6.1.101.1.8',
  rlCpuUtilDuringLast5Minutes => '1.3.6.1.4.1.9.6.1.101.1.9',
  rlRebootDelay => '1.3.6.1.4.1.9.6.1.101.1.10',
  rlGroupManagement => '1.3.6.1.4.1.9.6.1.101.1.11',
  rlGroupMngQuery => '1.3.6.1.4.1.9.6.1.101.1.11.1',
  rlGroupMngQueryDefinition => 'CISCOSB-rndMng::rlGroupMngQuery',
  rlGroupMngQueryPeriod => '1.3.6.1.4.1.9.6.1.101.1.11.2',
  rlGroupMngLastUpdate => '1.3.6.1.4.1.9.6.1.101.1.11.3',
  rlGroupMngDevicesTable => '1.3.6.1.4.1.9.6.1.101.1.11.4',
  rlGroupMngDeviceEntry => '1.3.6.1.4.1.9.6.1.101.1.11.4.1',
  rlGroupMngDeviceIdType => '1.3.6.1.4.1.9.6.1.101.1.11.4.1.1',
  rlGroupMngDeviceId => '1.3.6.1.4.1.9.6.1.101.1.11.4.1.2',
  rlGroupMngSubdevice => '1.3.6.1.4.1.9.6.1.101.1.11.4.1.3',
  rlGroupMngDeviceDescription => '1.3.6.1.4.1.9.6.1.101.1.11.4.1.4',
  rlGroupMngGroupMngEnabled => '1.3.6.1.4.1.9.6.1.101.1.11.4.1.5',
  rlGroupMngGroupLLDPDeviceId => '1.3.6.1.4.1.9.6.1.101.1.11.4.1.6',
  rlGroupMngDeviceVendor => '1.3.6.1.4.1.9.6.1.101.1.11.4.1.7',
  rlGroupMngDeviceAdvertisedCachingTime => '1.3.6.1.4.1.9.6.1.101.1.11.4.1.8',
  rlGroupMngDeviceLocationURL => '1.3.6.1.4.1.9.6.1.101.1.11.4.1.9',
  rlGroupMngDeviceLastSeen => '1.3.6.1.4.1.9.6.1.101.1.11.4.1.10',
  rlRunningCDBequalToStartupCDB => '1.3.6.1.4.1.9.6.1.101.1.13',
  rlClearMib => '1.3.6.1.4.1.9.6.1.101.1.14',
  rlScheduledReload => '1.3.6.1.4.1.9.6.1.101.1.15',
  rlScheduledReloadPendingDate => '1.3.6.1.4.1.9.6.1.101.1.16',
  rlScheduledReloadApprovedDate => '1.3.6.1.4.1.9.6.1.101.1.17',
  rlScheduledReloadCommit => '1.3.6.1.4.1.9.6.1.101.1.18',
  rlSysNameTable => '1.3.6.1.4.1.9.6.1.101.1.19',
  rlSysNameEntry => '1.3.6.1.4.1.9.6.1.101.1.19.1',
  rlSysNameSource => '1.3.6.1.4.1.9.6.1.101.1.19.1.1',
  rlSysNameSourceDefinition => 'CISCOSB-rndMng::rlSysNameSource',
  rlSysNameIfIndex => '1.3.6.1.4.1.9.6.1.101.1.19.1.2',
  rlSysNameName => '1.3.6.1.4.1.9.6.1.101.1.19.1.3',
  rlSysNameRowStatus => '1.3.6.1.4.1.9.6.1.101.1.19.1.4',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCOSB-RNDMNG'} = {
  rlSysNameSource => {
    '1' => 'dhcpv6',
    '2' => 'dhcpv4',
    '3' => 'static',
  },
  rlGroupMngQuery => {
    '1' => 'query',
    '2' => 'idle',
  },
  rndAction => {
    '1' => 'reset',
    '2' => 'sendNetworkTab',
    '3' => 'deleteNetworkTab',
    '4' => 'sendRoutingTab',
    '5' => 'deleteRoutingTab',
    '6' => 'sendLanTab',
    '7' => 'deleteLanTab',
    '8' => 'deleteArpTab',
    '9' => 'sendArpTab',
    '10' => 'deleteRouteTab',
    '11' => 'sendRouteTab',
    '12' => 'backupSPFRoutingTab',
    '13' => 'backupIPRoutingTab',
    '14' => 'backupNetworkTab',
    '15' => 'backupLanTab',
    '16' => 'backupArpTab',
    '17' => 'backupIPXRipTab',
    '18' => 'backupIPXSAPTab',
    '19' => 'resetStartupCDB',
    '20' => 'eraseStartupCDB',
    '21' => 'deleteZeroHopRoutingAllocTab',
    '22' => 'slipDisconnect',
    '23' => 'deleteDynamicLanTab',
    '24' => 'eraseRunningCDB',
    '25' => 'copyStartupToRunning',
    '26' => 'none',
    '27' => 'resetToFactoryDefaults',
  },
};
package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOSBSYSMNGMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCOSB-SYSMNG-MIB'} = {
  url => '',
  name => 'CISCOSB-SYSMNG-MIB',
};

#$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'CISCOSB-SYSMNG-MIB'} = 

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCOSB-SYSMNG-MIB'} = {
  rlSysmngMib => '1.3.6.1.4.1.9.6.1.101.204',
  rlSysmngTcamAllocations => '1.3.6.1.4.1.9.6.1.101.204.1',
  rlSysmngTcamAllocationsTable => '1.3.6.1.4.1.9.6.1.101.204.1.1',
  rlSysmngTcamAllocationsEntry => '1.3.6.1.4.1.9.6.1.101.204.1.1.1',
  rlSysmngTcamAllocProfileName => '1.3.6.1.4.1.9.6.1.101.204.1.1.1.1',
  rlSysmngTcamAllocPoolType => '1.3.6.1.4.1.9.6.1.101.204.1.1.1.2',
  rlSysmngTcamAllocPoolTypeDefinition => 'CISCOSB-SYSMNG-MIB::SysmngPoolType',
  rlSysmngTcamAllocMinRequiredEntries => '1.3.6.1.4.1.9.6.1.101.204.1.1.1.3',
  rlSysmngTcamAllocStaticConfigEntries => '1.3.6.1.4.1.9.6.1.101.204.1.1.1.4',
  rlSysmngTcamAllocInUseEntries => '1.3.6.1.4.1.9.6.1.101.204.1.1.1.5',
  rlSysmngTcamAllocPoolSize => '1.3.6.1.4.1.9.6.1.101.204.1.1.1.6',
  rlSysmngResource => '1.3.6.1.4.1.9.6.1.101.204.2',
  rlSysmngResourceTable => '1.3.6.1.4.1.9.6.1.101.204.2.1',
  rlSysmngResourceEntry => '1.3.6.1.4.1.9.6.1.101.204.2.1.1',
  rlSysmngResourceRouteType => '1.3.6.1.4.1.9.6.1.101.204.2.1.1.1',
  rlSysmngResourceRouteTypeDefinition => 'CISCOSB-SYSMNG-MIB::SysmngResourceRouteType',
  rlSysmngResourceCurrentUse => '1.3.6.1.4.1.9.6.1.101.204.2.1.1.2',
  rlSysmngResourceCurrentUseHw => '1.3.6.1.4.1.9.6.1.101.204.2.1.1.3',
  rlSysmngResourceCurrentMax => '1.3.6.1.4.1.9.6.1.101.204.2.1.1.4',
  rlSysmngResourceCurrentMaxHw => '1.3.6.1.4.1.9.6.1.101.204.2.1.1.5',
  rlSysmngResourceTemporaryMax => '1.3.6.1.4.1.9.6.1.101.204.2.1.1.6',
  rlSysmngResourceTemporaryMaxHw => '1.3.6.1.4.1.9.6.1.101.204.2.1.1.7',
  rlSysmngResourceCurrentNexthopMax => '1.3.6.1.4.1.9.6.1.101.204.2.1.1.8',
  rlSysmngResourceCurrentNexthopMaxHw => '1.3.6.1.4.1.9.6.1.101.204.2.1.1.9',
  rlSysmngResourceCurrentNexthopUse => '1.3.6.1.4.1.9.6.1.101.204.2.1.1.10',
  rlSysmngResourceCurrentNexthopUseHw => '1.3.6.1.4.1.9.6.1.101.204.2.1.1.11',
  rlSysmngRouterResourceAction => '1.3.6.1.4.1.9.6.1.101.204.3',
  rlSysmngResourceUsage => '1.3.6.1.4.1.9.6.1.101.204.4',
  rlSysmngResourceUsageTable => '1.3.6.1.4.1.9.6.1.101.204.4.1',
  rlSysmngResourceUsageEntry => '1.3.6.1.4.1.9.6.1.101.204.4.1.1',
  rlSysmngResourceUsageType => '1.3.6.1.4.1.9.6.1.101.204.4.1.1.1',
  rlSysmngResourceUsageTypeDefinition => 'CISCOSB-SYSMNG-MIB::SysmngResourceRouteUsageType',
  rlSysmngResourceUsageNum => '1.3.6.1.4.1.9.6.1.101.204.4.1.1.2',
  rlSysmngResourcePerUnit => '1.3.6.1.4.1.9.6.1.101.204.5',
  rlSysmngResourcePerUnitTable => '1.3.6.1.4.1.9.6.1.101.204.5.1',
  rlSysmngResourcePerUnitEntry => '1.3.6.1.4.1.9.6.1.101.204.5.1.1',
  rlSysmngResourcePerUnitRouteType => '1.3.6.1.4.1.9.6.1.101.204.5.1.1.1',
  rlSysmngResourcePerUnitRouteTypeDefinition => 'CISCOSB-SYSMNG-MIB::SysmngResourceRouteType',
  rlSysmngResourcePerUnitUnitId => '1.3.6.1.4.1.9.6.1.101.204.5.1.1.2',
  rlSysmngResourcePerUnitCurrentUse => '1.3.6.1.4.1.9.6.1.101.204.5.1.1.3',
  rlSysmngResourcePerUnitCurrentUseHw => '1.3.6.1.4.1.9.6.1.101.204.5.1.1.4',
  rlSysmngResourcePerUnitCurrentMax => '1.3.6.1.4.1.9.6.1.101.204.5.1.1.5',
  rlSysmngResourcePerUnitCurrentMaxHw => '1.3.6.1.4.1.9.6.1.101.204.5.1.1.6',
  rlSysmngResourcePerUnitTemporaryMax => '1.3.6.1.4.1.9.6.1.101.204.5.1.1.7',
  rlSysmngResourcePerUnitTemporaryMaxHw => '1.3.6.1.4.1.9.6.1.101.204.5.1.1.8',
  rlSysmngResourcePerUnitCurrentNexthopMax => '1.3.6.1.4.1.9.6.1.101.204.5.1.1.9',
  rlSysmngResourcePerUnitCurrentNexthopMaxHw => '1.3.6.1.4.1.9.6.1.101.204.5.1.1.10',
  rlSysmngResourcePerUnitCurrentNexthopUse => '1.3.6.1.4.1.9.6.1.101.204.5.1.1.11',
  rlSysmngResourcePerUnitCurrentNexthopUseHw => '1.3.6.1.4.1.9.6.1.101.204.5.1.1.12',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCOSB-SYSMNG-MIB'} = {
  SysmngPoolType => {
    '1' => 'router',
    '2' => 'iscsi',
    '3' => 'voip',
    '4' => 'misc',
  },
  SysmngResourceRouteUsageType => {
    '1' => 'ipv4Neighbor',
    '2' => 'ipv4Address',
    '3' => 'ipv4Route',
    '4' => 'ipv6Neighbor',
    '5' => 'ipv6Address',
    '6' => 'ipv6OnlinkPrefix',
    '7' => 'ipv6Route',
    '8' => 'ipmv4Route',
    '9' => 'ipmv4RouteStarG',
    '10' => 'ipmv6Route',
    '11' => 'ipmv6RouteStarG',
  },
  SysmngResourceRouteType => {
    '1' => 'ipv4',
    '2' => 'ipv6',
    '3' => 'ipmv4',
    '4' => 'ipmv6',
    '5' => 'nonIp',
  },
};
package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOSBTUNING;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCOSB-TUNING'} = {
  url => '',
  name => 'CISCOSB-TUNING',
};

#$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'CISCOSB-TUNING'} = 

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCOSB-TUNING'} = {
  rsTunning => '1.3.6.1.4.1.9.6.1.101.29',
  rsHighPriority => '1.3.6.1.4.1.9.6.1.101.29.1',
  rsLowPriority => '1.3.6.1.4.1.9.6.1.101.29.2',
  rsDbgLevel => '1.3.6.1.4.1.9.6.1.101.29.3',
  rsDiagnosticsTable => '1.3.6.1.4.1.9.6.1.101.29.4',
  rsDiagnosticsEntry => '1.3.6.1.4.1.9.6.1.101.29.4.1',
  rsDiagnosticsRequestId => '1.3.6.1.4.1.9.6.1.101.29.4.1.1',
  rsDiagnosticsCode => '1.3.6.1.4.1.9.6.1.101.29.4.1.2',
  rsDiagnosticsLocation => '1.3.6.1.4.1.9.6.1.101.29.4.1.3',
  rsDiagnosticsText => '1.3.6.1.4.1.9.6.1.101.29.4.1.4',
  rsConfirmMessagTab => '1.3.6.1.4.1.9.6.1.101.29.5',
  eventMessageTable => '1.3.6.1.4.1.9.6.1.101.29.6',
  eventMessageEntry => '1.3.6.1.4.1.9.6.1.101.29.6.1',
  eventNum => '1.3.6.1.4.1.9.6.1.101.29.6.1.1',
  eventDesc => '1.3.6.1.4.1.9.6.1.101.29.6.1.2',
  reaTunning => '1.3.6.1.4.1.9.6.1.101.29.7',
  reaIpForwardEnable => '1.3.6.1.4.1.9.6.1.101.29.7.4',
  reaIpForwardEnableDefinition => 'CISCOSB-Tuning::reaIpForwardEnable',
  reaIpxForwardEnable => '1.3.6.1.4.1.9.6.1.101.29.7.5',
  reaIpxForwardEnableDefinition => 'CISCOSB-Tuning::reaIpxForwardEnable',
  rsMaxEntriesTuning => '1.3.6.1.4.1.9.6.1.101.29.8',
  rsMaxBridgeForwardingEntriesTuning => '1.3.6.1.4.1.9.6.1.101.29.8.1',
  rsMaxBrgFrwEntries => '1.3.6.1.4.1.9.6.1.101.29.8.1.1',
  rsMaxBrgFrwEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.1.2',
  rsMaxIpForwardingEntriesTuning => '1.3.6.1.4.1.9.6.1.101.29.8.2',
  rsMaxIpFrwEntries => '1.3.6.1.4.1.9.6.1.101.29.8.2.1',
  rsMaxIpFrwEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.2.2',
  rsMaxArpEntriesTuning => '1.3.6.1.4.1.9.6.1.101.29.8.3',
  rsMaxArpEntries => '1.3.6.1.4.1.9.6.1.101.29.8.3.1',
  rsMaxArpEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.3.2',
  rsMaxIpxForwardingEntriesTuning => '1.3.6.1.4.1.9.6.1.101.29.8.4',
  rsMaxIpxFrwEntries => '1.3.6.1.4.1.9.6.1.101.29.8.4.1',
  rsMaxIpxFrwEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.4.2',
  rsMaxIpxSapEntriesTuning => '1.3.6.1.4.1.9.6.1.101.29.8.5',
  rsMaxIpxSapEntries => '1.3.6.1.4.1.9.6.1.101.29.8.5.1',
  rsMaxIpxSapEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.5.2',
  rsMaxDspClntEntriesTuning => '1.3.6.1.4.1.9.6.1.101.29.8.6',
  rsMaxDspClntEntries => '1.3.6.1.4.1.9.6.1.101.29.8.6.1',
  rsMaxDspClntEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.6.2',
  rsMaxIpFftEntriesTuning => '1.3.6.1.4.1.9.6.1.101.29.8.9',
  rsMaxIpSFftEntries => '1.3.6.1.4.1.9.6.1.101.29.8.9.1',
  rsMaxIpSFftEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.9.2',
  rsMaxIpNFftEntries => '1.3.6.1.4.1.9.6.1.101.29.8.9.3',
  rsMaxIpNFftEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.9.4',
  rsMaxIpSFftSysEntries => '1.3.6.1.4.1.9.6.1.101.29.8.9.5',
  rsMaxIpSFftSysEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.9.6',
  rsMaxIpNFftSysEntries => '1.3.6.1.4.1.9.6.1.101.29.8.9.7',
  rsMaxIpNFftSysEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.9.8',
  rsMaxIpNextHopEntries => '1.3.6.1.4.1.9.6.1.101.29.8.9.9',
  rsMaxIpNextHopEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.9.10',
  rsMaxIpxFftEntriesTuning => '1.3.6.1.4.1.9.6.1.101.29.8.10',
  rsMaxIpxSFftEntries => '1.3.6.1.4.1.9.6.1.101.29.8.10.1',
  rsMaxIpxSFftEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.10.2',
  rsMaxIpxNFftEntries => '1.3.6.1.4.1.9.6.1.101.29.8.10.3',
  rsMaxIpxNFftEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.10.4',
  rsMaxIpxSFftSysEntries => '1.3.6.1.4.1.9.6.1.101.29.8.10.5',
  rsMaxIpxSFftSysEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.10.6',
  rsMaxIpxNFftSysEntries => '1.3.6.1.4.1.9.6.1.101.29.8.10.7',
  rsMaxIpxNFftSysEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.10.8',
  rsMaxDhcpTuning => '1.3.6.1.4.1.9.6.1.101.29.8.11',
  rsMaxDhcpConns => '1.3.6.1.4.1.9.6.1.101.29.8.11.1',
  rsMaxDhcpConnsAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.11.2',
  rsMaxIpmTuning => '1.3.6.1.4.1.9.6.1.101.29.8.12',
  rsMaxIpmFftEntriesTuning => '1.3.6.1.4.1.9.6.1.101.29.8.12.1',
  rsMaxIpmFftEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.1.1',
  rsMaxIpmFftEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.1.2',
  rsIpmFftAging => '1.3.6.1.4.1.9.6.1.101.29.8.12.1.3',
  rsMaxIgmpTuning => '1.3.6.1.4.1.9.6.1.101.29.8.12.2',
  rsMaxIgmpInterfaceEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.2.1',
  rsMaxIgmpInterfaceEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.2.2',
  rsMaxIgmpCacheEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.2.3',
  rsMaxIgmpCacheEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.2.4',
  rsMaxPimTuning => '1.3.6.1.4.1.9.6.1.101.29.8.12.3',
  rsMaxPimNeighborEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.3.1',
  rsMaxPimNeighborEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.3.2',
  rsMaxPimRouteEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.3.3',
  rsMaxPimRouteEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.3.4',
  rsMaxPimRouteNextHopEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.3.5',
  rsMaxPimRouteNextHopEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.3.6',
  rsMaxPimInterfaceEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.3.7',
  rsMaxPimInterfaceEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.3.8',
  rsMaxDvmrpTuning => '1.3.6.1.4.1.9.6.1.101.29.8.12.4',
  rsMaxDvmrpNeighborEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.4.1',
  rsMaxDvmrpNeighborEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.4.2',
  rsMaxDvmrpRouteEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.4.3',
  rsMaxDvmrpRouteEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.4.4',
  rsMaxDvmrpMRouteEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.4.5',
  rsMaxDvmrpMRouteEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.4.6',
  rsMaxDvmrpInterfaceEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.4.7',
  rsMaxDvmrpInterfaceEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.4.8',
  rsMaxPigmpTuning => '1.3.6.1.4.1.9.6.1.101.29.8.12.5',
  rsMaxPigmpRouteEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.5.1',
  rsMaxPigmpRouteEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.5.2',
  rsMaxPimSmTuning => '1.3.6.1.4.1.9.6.1.101.29.8.12.6',
  rsMaxPimSmNeighborEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.6.1',
  rsMaxPimSmNeighborEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.6.2',
  rsMaxPimSmRouteEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.6.3',
  rsMaxPimSmRouteEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.6.4',
  rsMaxPimSmInterfaceEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.6.5',
  rsMaxPimSmInterfaceEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.6.6',
  rsMaxPimSmRPSetEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.6.7',
  rsMaxPimSmRPSetEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.6.8',
  rsMaxPimSmCRPEntries => '1.3.6.1.4.1.9.6.1.101.29.8.12.6.9',
  rsMaxPimSmCRPEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.6.10',
  rsMaxNumberRpAddresesInGroupRange => '1.3.6.1.4.1.9.6.1.101.29.8.12.6.11',
  rsMaxNumberRpAddresesInGroupRangeAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.12.6.12',
  rsMaxRmonTuning => '1.3.6.1.4.1.9.6.1.101.29.8.13',
  rsMaxRmonLogEntries => '1.3.6.1.4.1.9.6.1.101.29.8.13.1',
  rsMaxRmonLogEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.13.2',
  rsMaxRmonEtherHistoryEntries => '1.3.6.1.4.1.9.6.1.101.29.8.13.3',
  rsMaxRmonEtherHistoryEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.13.4',
  rsMaxIgmpSnoopTuning => '1.3.6.1.4.1.9.6.1.101.29.8.14',
  rsMaxIgmpSnoopGroupEntries => '1.3.6.1.4.1.9.6.1.101.29.8.14.1',
  rsMaxIgmpSnoopGroupEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.14.2',
  rsMaxVlansTuning => '1.3.6.1.4.1.9.6.1.101.29.8.15',
  rsMaxVlansEntries => '1.3.6.1.4.1.9.6.1.101.29.8.15.1',
  rsMaxVlansEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.15.2',
  rsMaxPolicyTuning => '1.3.6.1.4.1.9.6.1.101.29.8.16',
  rsMaxPolicyMaxRulesEntries => '1.3.6.1.4.1.9.6.1.101.29.8.16.1',
  rsMaxPolicyMaxRulesEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.16.2',
  rsMaxPolicySimpleMibMaxRulesEntries => '1.3.6.1.4.1.9.6.1.101.29.8.16.3',
  rsMaxPolicySimpleMibMaxRulesEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.16.4',
  rsMaxPolicySimpleMibMaxProfilesEntries => '1.3.6.1.4.1.9.6.1.101.29.8.16.5',
  rsMaxPolicySimpleMibMaxProfilesEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.16.6',
  rsMaxGvrpVlansTuning => '1.3.6.1.4.1.9.6.1.101.29.8.17',
  rsMaxGvrpVlans => '1.3.6.1.4.1.9.6.1.101.29.8.17.1',
  rsMaxGvrpVlansAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.17.2',
  rsMaxTraceRouteTuning => '1.3.6.1.4.1.9.6.1.101.29.8.18',
  rsMaxTraceRouteControlEntries => '1.3.6.1.4.1.9.6.1.101.29.8.18.1',
  rsMaxTraceRouteControlEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.18.2',
  rsMaxTraceRouteProbeHistoryEntries => '1.3.6.1.4.1.9.6.1.101.29.8.18.3',
  rsMaxTraceRouteProbeHistoryEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.18.4',
  rsMaxSnmpTuning => '1.3.6.1.4.1.9.6.1.101.29.8.19',
  rsMaxSnmpCommunityEntries => '1.3.6.1.4.1.9.6.1.101.29.8.19.1',
  rsMaxSnmpCommunityEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.19.2',
  rsMaxSocketTuning => '1.3.6.1.4.1.9.6.1.101.29.8.20',
  rsMaxNumberOfSockets => '1.3.6.1.4.1.9.6.1.101.29.8.20.1',
  rsMaxNumberOfSocketsAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.20.2',
  rsMaxSizeOfSocketDataPool => '1.3.6.1.4.1.9.6.1.101.29.8.20.3',
  rsMaxSizeOfSocketDataPoolAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.20.4',
  rsMaxIpRouteTuning => '1.3.6.1.4.1.9.6.1.101.29.8.21',
  rsMaxIpPrefixes => '1.3.6.1.4.1.9.6.1.101.29.8.21.1',
  rsMaxIpPrefixesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.21.2',
  rsMaxIpNextHopSetTuning => '1.3.6.1.4.1.9.6.1.101.29.8.22',
  rsMaxIpNextHopSetEntries => '1.3.6.1.4.1.9.6.1.101.29.8.22.1',
  rsMaxIpNextHopSetEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.22.2',
  rsMaxIpEcmpTuning => '1.3.6.1.4.1.9.6.1.101.29.8.23',
  rsMaxIpEcmpEntrySize => '1.3.6.1.4.1.9.6.1.101.29.8.23.1',
  rsMaxIpEcmpEntrySizeAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.23.2',
  rsMaxdot1xEapRequestTuning => '1.3.6.1.4.1.9.6.1.101.29.8.24',
  rsMaxdot1xEapRequestEntries => '1.3.6.1.4.1.9.6.1.101.29.8.24.1',
  rsMaxdot1xEapRequestEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.24.2',
  rsMaxIpInterfaceTuning => '1.3.6.1.4.1.9.6.1.101.29.8.25',
  rsMaxIpInterfaces => '1.3.6.1.4.1.9.6.1.101.29.8.25.1',
  rsMaxIpInterfacesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.25.2',
  rsMaxIpv6FftEntriesTuning => '1.3.6.1.4.1.9.6.1.101.29.8.26',
  rsMaxIpv6SFftEntries => '1.3.6.1.4.1.9.6.1.101.29.8.26.1',
  rsMaxIpv6SFftEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.26.2',
  rsMaxIpv6SFftSysEntries => '1.3.6.1.4.1.9.6.1.101.29.8.26.3',
  rsMaxIpv6SFftSysEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.26.4',
  rsMaxIpv6Prefixes => '1.3.6.1.4.1.9.6.1.101.29.8.26.5',
  rsMaxIpv6PrefixesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.26.6',
  rsMaxIpv6NextHopEntries => '1.3.6.1.4.1.9.6.1.101.29.8.26.7',
  rsMaxIpv6NextHopEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.26.8',
  rsMaxIpv6NextHopSetEntries => '1.3.6.1.4.1.9.6.1.101.29.8.26.9',
  rsMaxIpv6NextHopSetEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.26.10',
  rsMaxIpv6GlobalAddresses => '1.3.6.1.4.1.9.6.1.101.29.8.26.11',
  rsMaxIpv6GlobalAddressesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.26.12',
  rsMaxArpTunnelStartEntries => '1.3.6.1.4.1.9.6.1.101.29.8.26.13',
  rsMaxArpTunnelStartEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.26.14',
  rsMaxIpv6InterfaceTuning => '1.3.6.1.4.1.9.6.1.101.29.8.27',
  rsMaxIpv6Interfaces => '1.3.6.1.4.1.9.6.1.101.29.8.27.1',
  rsMaxIpv6InterfacesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.27.2',
  rsMaxIpv6AddrPerInterfaces => '1.3.6.1.4.1.9.6.1.101.29.8.27.3',
  rsMaxIpv6AddrPerInterfacesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.27.4',
  rsMaxIpRoutesTuning => '1.3.6.1.4.1.9.6.1.101.29.8.28',
  rsMaxIpv4Routes => '1.3.6.1.4.1.9.6.1.101.29.8.28.1',
  rsMaxIpv4RoutesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.28.2',
  rsMaxIpv6Routes => '1.3.6.1.4.1.9.6.1.101.29.8.28.3',
  rsMaxIpv6RoutesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.28.4',
  rsMaxIpmv4Routes => '1.3.6.1.4.1.9.6.1.101.29.8.28.5',
  rsMaxIpmv4RoutesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.28.6',
  rsMaxIpmv6Routes => '1.3.6.1.4.1.9.6.1.101.29.8.28.7',
  rsMaxIpmv6RoutesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.8.28.8',
  rsTcpTuning => '1.3.6.1.4.1.9.6.1.101.29.11',
  rsTcpMemoryPoolSizeAfterReset => '1.3.6.1.4.1.9.6.1.101.29.11.1',
  rsTcpMemoryPoolSize => '1.3.6.1.4.1.9.6.1.101.29.11.2',
  rsRadiusTuning => '1.3.6.1.4.1.9.6.1.101.29.12',
  rsRadiusMemoryPoolSizeAfterReset => '1.3.6.1.4.1.9.6.1.101.29.12.1',
  rsRadiusMemoryPoolSize => '1.3.6.1.4.1.9.6.1.101.29.12.2',
  rlSyslogTuning => '1.3.6.1.4.1.9.6.1.101.29.13',
  rlSyslogFilePercentToDeleteWhenCompacting => '1.3.6.1.4.1.9.6.1.101.29.13.3',
  rlSyslogFilePercentToDeleteWhenCompactingAfterReset => '1.3.6.1.4.1.9.6.1.101.29.13.4',
  rlSyslogCacheSize => '1.3.6.1.4.1.9.6.1.101.29.13.5',
  rlSyslogCacheSizeAfterReset => '1.3.6.1.4.1.9.6.1.101.29.13.6',
  rlMngInfTuning => '1.3.6.1.4.1.9.6.1.101.29.14',
  rlMaxNumberOfAccessRules => '1.3.6.1.4.1.9.6.1.101.29.14.1',
  rlMaxNumberOfAccessRulesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.14.2',
  rsDiagnosticTextSource => '1.3.6.1.4.1.9.6.1.101.29.16',
  rsDiagnosticTextSourceDefinition => 'CISCOSB-Tuning::rsDiagnosticTextSource',
  rsMultiSession => '1.3.6.1.4.1.9.6.1.101.29.17',
  rsMultiSessionMaxSessionsAfterReset => '1.3.6.1.4.1.9.6.1.101.29.17.1',
  rsMultiSessionMaxSessions => '1.3.6.1.4.1.9.6.1.101.29.17.2',
  rlDnsClTuning => '1.3.6.1.4.1.9.6.1.101.29.18',
  rlMaxDnsClCacheRREntries => '1.3.6.1.4.1.9.6.1.101.29.18.1',
  rlMaxDnsClCacheRREntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.18.2',
  rlMaxDnsClNCacheErrEntries => '1.3.6.1.4.1.9.6.1.101.29.18.3',
  rlMaxDnsClNCacheErrEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.18.4',
  rlMaxDnsClNamesEntries => '1.3.6.1.4.1.9.6.1.101.29.18.5',
  rlMaxDnsClNamesEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.18.6',
  rlTuningParamsTable => '1.3.6.1.4.1.9.6.1.101.29.19',
  rlTuningParamsEntry => '1.3.6.1.4.1.9.6.1.101.29.19.1',
  rlTuningParamsName => '1.3.6.1.4.1.9.6.1.101.29.19.1.1',
  rlTuningParamsCurrentValue => '1.3.6.1.4.1.9.6.1.101.29.19.1.2',
  rlTuningParamsAfterResetValue => '1.3.6.1.4.1.9.6.1.101.29.19.1.3',
  rlTuningParamsDefaultValue => '1.3.6.1.4.1.9.6.1.101.29.19.1.4',
  rlTuningParamsMinimalValue => '1.3.6.1.4.1.9.6.1.101.29.19.1.5',
  rlTuningParamsMaximalValue => '1.3.6.1.4.1.9.6.1.101.29.19.1.6',
  rlHostParamTable => '1.3.6.1.4.1.9.6.1.101.29.20',
  rlHostParamEntry => '1.3.6.1.4.1.9.6.1.101.29.20.1',
  rlHostParamName => '1.3.6.1.4.1.9.6.1.101.29.20.1.1',
  rlHostParamValue => '1.3.6.1.4.1.9.6.1.101.29.20.1.2',
  rlHostParamType => '1.3.6.1.4.1.9.6.1.101.29.20.1.3',
  rlHostParamTypeDefinition => 'CISCOSB-Tuning::rlHostParamType',
  rlHostParamUINT => '1.3.6.1.4.1.9.6.1.101.29.20.1.4',
  rlHostParamOctetString => '1.3.6.1.4.1.9.6.1.101.29.20.1.5',
  rlHostParamIpAddress => '1.3.6.1.4.1.9.6.1.101.29.20.1.6',
  rlHostParamObjectId => '1.3.6.1.4.1.9.6.1.101.29.20.1.7',
  rlOspfTuning => '1.3.6.1.4.1.9.6.1.101.29.21',
  rlMaxOspfInterfaces => '1.3.6.1.4.1.9.6.1.101.29.21.1',
  rlMaxOspfInterfacesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.21.2',
  rlMaxOspfAreas => '1.3.6.1.4.1.9.6.1.101.29.21.3',
  rlMaxOspfAreasAfterReset => '1.3.6.1.4.1.9.6.1.101.29.21.4',
  rlMaxOspfNeighbors => '1.3.6.1.4.1.9.6.1.101.29.21.5',
  rlMaxOspfNeighborsAfterReset => '1.3.6.1.4.1.9.6.1.101.29.21.6',
  rlMaxOspfAbrPerArea => '1.3.6.1.4.1.9.6.1.101.29.21.7',
  rlMaxOspfAbrPerAreaAfterReset => '1.3.6.1.4.1.9.6.1.101.29.21.8',
  rlMaxOspfNetsInAs => '1.3.6.1.4.1.9.6.1.101.29.21.9',
  rlMaxOspfNetsInAsAfterReset => '1.3.6.1.4.1.9.6.1.101.29.21.10',
  rlVlanTuning => '1.3.6.1.4.1.9.6.1.101.29.22',
  rlVlanDefaultVID => '1.3.6.1.4.1.9.6.1.101.29.22.1',
  rlVlanDefaultVIDAfterReset => '1.3.6.1.4.1.9.6.1.101.29.22.2',
  rlVlanUsageForbiddenListTable => '1.3.6.1.4.1.9.6.1.101.29.22.3',
  rlVlanUsageForbiddenListEntry => '1.3.6.1.4.1.9.6.1.101.29.22.3.1',
  rlVlanUsageForbiddenListIndex => '1.3.6.1.4.1.9.6.1.101.29.22.3.1.1',
  rlVlanUsageForbiddenList1to1024 => '1.3.6.1.4.1.9.6.1.101.29.22.3.1.2',
  rlVlanUsageForbiddenList1025to2048 => '1.3.6.1.4.1.9.6.1.101.29.22.3.1.3',
  rlVlanUsageForbiddenList2049to3072 => '1.3.6.1.4.1.9.6.1.101.29.22.3.1.4',
  rlVlanUsageForbiddenList3073to4094 => '1.3.6.1.4.1.9.6.1.101.29.22.3.1.5',
  rlVlanUsageForbiddenListAfterResetTable => '1.3.6.1.4.1.9.6.1.101.29.22.4',
  rlVlanUsageForbiddenListAfterResetEntry => '1.3.6.1.4.1.9.6.1.101.29.22.4.1',
  rlVlanUsageForbiddenListAfterResetIndex => '1.3.6.1.4.1.9.6.1.101.29.22.4.1.1',
  rlVlanUsageForbiddenListAfterReset1to1024 => '1.3.6.1.4.1.9.6.1.101.29.22.4.1.2',
  rlVlanUsageForbiddenListAfterReset1025to2048 => '1.3.6.1.4.1.9.6.1.101.29.22.4.1.3',
  rlVlanUsageForbiddenListAfterReset2049to3072 => '1.3.6.1.4.1.9.6.1.101.29.22.4.1.4',
  rlVlanUsageForbiddenListAfterReset3073to4094 => '1.3.6.1.4.1.9.6.1.101.29.22.4.1.5',
  rlDependendFeaturesEnableTuning => '1.3.6.1.4.1.9.6.1.101.29.23',
  rlDependendFeaturesEnabled => '1.3.6.1.4.1.9.6.1.101.29.23.1',
  rlDependendFeaturesEnabledAfterReset => '1.3.6.1.4.1.9.6.1.101.29.23.2',
  rlIpDhcpSnoopingTuning => '1.3.6.1.4.1.9.6.1.101.29.24',
  rlMaxIpDhcpSnoopingEntries => '1.3.6.1.4.1.9.6.1.101.29.24.1',
  rlMaxIpDhcpSnoopingEntriesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.24.2',
  rlIscsiSnoopTuning => '1.3.6.1.4.1.9.6.1.101.29.25',
  rlIscsiSnoopMaxNumOfConnections => '1.3.6.1.4.1.9.6.1.101.29.25.1',
  rlIscsiSnoopMaxNumOfConnectionsAfterReset => '1.3.6.1.4.1.9.6.1.101.29.25.2',
  rlDhcpServerTuning => '1.3.6.1.4.1.9.6.1.101.29.26',
  rlDhcpSrvMaxAllocatedAddresses => '1.3.6.1.4.1.9.6.1.101.29.26.1',
  rlDhcpSrvMaxAllocatedAddressesAfterReset => '1.3.6.1.4.1.9.6.1.101.29.26.2',
  rlBrgMacHashChainLen => '1.3.6.1.4.1.9.6.1.101.29.27',
  rlBrgMacHashChainLenAfterReset => '1.3.6.1.4.1.9.6.1.101.29.28',
  rlBrgMacHashFunction => '1.3.6.1.4.1.9.6.1.101.29.29',
  rlBrgMacHashFunctionDefinition => 'CISCOSB-Tuning::rlBrgMacHashFunction',
  rlBrgMacHashFunctionAfterReset => '1.3.6.1.4.1.9.6.1.101.29.30',
  rlBrgMacHashFunctionAfterResetDefinition => 'CISCOSB-Tuning::rlBrgMacHashFunctionAfterReset',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCOSB-TUNING'} = {
  rlBrgMacHashFunctionAfterReset => {
    '0' => 'macSqnVlanSqn',
    '1' => 'macRndVlanSqn',
    '2' => 'macSqnVlanRnd',
    '3' => 'macRndVlanRnd',
  },
  rlBrgMacHashFunction => {
    '0' => 'macSqnVlanSqn',
    '1' => 'macRndVlanSqn',
    '2' => 'macSqnVlanRnd',
    '3' => 'macRndVlanRnd',
  },
  reaIpxForwardEnable => {
    '1' => 'enable',
    '2' => 'disable',
  },
  rlHostParamType => {
    '1' => 'int',
    '2' => 'uint',
    '3' => 'octetString',
    '4' => 'ipV4address',
    '5' => 'ipV6address',
    '6' => 'ipV6zAddress',
    '7' => 'inetAddress',
    '8' => 'macAddress',
    '9' => 'objectIdentifier',
    '10' => 'displayString',
    '11' => 'truthValue',
    '12' => 'portlist',
  },
  rsDiagnosticTextSource => {
    '1' => 'fromCLI',
    '2' => 'fromDiagnosticsTable',
  },
  reaIpForwardEnable => {
    '1' => 'enable',
    '2' => 'disable',
  },
};
package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOSTACKIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-STACK-MIB'} = {
  url => '',
  name => 'CISCO-STACK-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'CISCO-STACK-MIB'} = 
    '1.3.6.1.4.1.9.5.1';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-STACK-MIB'} = {
  ciscoStackNotificationsPrefix => '1.3.6.1.4.1.9.5.0',
  ciscoStackMIB => '1.3.6.1.4.1.9.5.1',
  systemGrp => '1.3.6.1.4.1.9.5.1.1',
  sysMgmtType => '1.3.6.1.4.1.9.5.1.1.1',
  sysMgmtTypeDefinition => 'CISCO-STACK-MIB::sysMgmtType',
  sysIpAddr => '1.3.6.1.4.1.9.5.1.1.2',
  sysNetMask => '1.3.6.1.4.1.9.5.1.1.3',
  sysBroadcast => '1.3.6.1.4.1.9.5.1.1.4',
  sysTrapReceiverTable => '1.3.6.1.4.1.9.5.1.1.5',
  sysTrapReceiverEntry => '1.3.6.1.4.1.9.5.1.1.5.1',
  sysTrapReceiverType => '1.3.6.1.4.1.9.5.1.1.5.1.1',
  sysTrapReceiverTypeDefinition => 'CISCO-STACK-MIB::sysTrapReceiverType',
  sysTrapReceiverAddr => '1.3.6.1.4.1.9.5.1.1.5.1.2',
  sysTrapReceiverComm => '1.3.6.1.4.1.9.5.1.1.5.1.3',
  sysCommunityTable => '1.3.6.1.4.1.9.5.1.1.6',
  sysCommunityEntry => '1.3.6.1.4.1.9.5.1.1.6.1',
  sysCommunityAccess => '1.3.6.1.4.1.9.5.1.1.6.1.1',
  sysCommunityAccessDefinition => 'CISCO-STACK-MIB::sysCommunityAccess',
  sysCommunityString => '1.3.6.1.4.1.9.5.1.1.6.1.2',
  sysAttachType => '1.3.6.1.4.1.9.5.1.1.7',
  sysAttachTypeDefinition => 'CISCO-STACK-MIB::sysAttachType',
  sysTraffic => '1.3.6.1.4.1.9.5.1.1.8',
  sysReset => '1.3.6.1.4.1.9.5.1.1.9',
  sysResetDefinition => 'CISCO-STACK-MIB::sysReset',
  sysBaudRate => '1.3.6.1.4.1.9.5.1.1.10',
  sysBaudRateDefinition => 'CISCO-STACK-MIB::sysBaudRate',
  sysInsertMode => '1.3.6.1.4.1.9.5.1.1.11',
  sysInsertModeDefinition => 'CISCO-STACK-MIB::sysInsertMode',
  sysClearMacTime => '1.3.6.1.4.1.9.5.1.1.12',
  sysClearPortTime => '1.3.6.1.4.1.9.5.1.1.13',
  sysFddiRingTable => '1.3.6.1.4.1.9.5.1.1.14',
  sysFddiRingEntry => '1.3.6.1.4.1.9.5.1.1.14.1',
  sysFddiRingSMTIndex => '1.3.6.1.4.1.9.5.1.1.14.1.1',
  sysFddiRingAddress => '1.3.6.1.4.1.9.5.1.1.14.1.2',
  sysFddiRingNext => '1.3.6.1.4.1.9.5.1.1.14.1.3',
  sysEnableModem => '1.3.6.1.4.1.9.5.1.1.15',
  sysEnableModemDefinition => 'CISCO-STACK-MIB::sysEnableModem',
  sysEnableRedirects => '1.3.6.1.4.1.9.5.1.1.16',
  sysEnableRedirectsDefinition => 'CISCO-STACK-MIB::sysEnableRedirects',
  sysEnableRmon => '1.3.6.1.4.1.9.5.1.1.17',
  sysEnableRmonDefinition => 'CISCO-STACK-MIB::sysEnableRmon',
  sysArpAgingTime => '1.3.6.1.4.1.9.5.1.1.18',
  sysTrafficPeak => '1.3.6.1.4.1.9.5.1.1.19',
  sysTrafficPeakTime => '1.3.6.1.4.1.9.5.1.1.20',
  sysCommunityRwa => '1.3.6.1.4.1.9.5.1.1.21',
  sysCommunityRw => '1.3.6.1.4.1.9.5.1.1.22',
  sysCommunityRo => '1.3.6.1.4.1.9.5.1.1.23',
  sysEnableChassisTraps => '1.3.6.1.4.1.9.5.1.1.24',
  sysEnableChassisTrapsDefinition => 'CISCO-STACK-MIB::sysEnableChassisTraps',
  sysEnableModuleTraps => '1.3.6.1.4.1.9.5.1.1.25',
  sysEnableModuleTrapsDefinition => 'CISCO-STACK-MIB::sysEnableModuleTraps',
  sysEnableBridgeTraps => '1.3.6.1.4.1.9.5.1.1.26',
  sysEnableBridgeTrapsDefinition => 'CISCO-STACK-MIB::sysEnableBridgeTraps',
  sysIpVlan => '1.3.6.1.4.1.9.5.1.1.27',
  sysConfigChangeTime => '1.3.6.1.4.1.9.5.1.1.28',
  sysEnableRepeaterTraps => '1.3.6.1.4.1.9.5.1.1.29',
  sysEnableRepeaterTrapsDefinition => 'CISCO-STACK-MIB::sysEnableRepeaterTraps',
  sysBannerMotd => '1.3.6.1.4.1.9.5.1.1.30',
  sysEnableIpPermitTraps => '1.3.6.1.4.1.9.5.1.1.31',
  sysEnableIpPermitTrapsDefinition => 'CISCO-STACK-MIB::sysEnableIpPermitTraps',
  sysTrafficMeterTable => '1.3.6.1.4.1.9.5.1.1.32',
  sysTrafficMeterEntry => '1.3.6.1.4.1.9.5.1.1.32.1',
  sysTrafficMeterType => '1.3.6.1.4.1.9.5.1.1.32.1.1',
  sysTrafficMeterTypeDefinition => 'CISCO-STACK-MIB::sysTrafficMeterType',
  sysTrafficMeter => '1.3.6.1.4.1.9.5.1.1.32.1.2',
  sysTrafficMeterPeak => '1.3.6.1.4.1.9.5.1.1.32.1.3',
  sysTrafficMeterPeakTime => '1.3.6.1.4.1.9.5.1.1.32.1.4',
  sysEnableVmpsTraps => '1.3.6.1.4.1.9.5.1.1.33',
  sysEnableVmpsTrapsDefinition => 'CISCO-STACK-MIB::sysEnableVmpsTraps',
  sysConfigChangeInfo => '1.3.6.1.4.1.9.5.1.1.34',
  sysEnableConfigTraps => '1.3.6.1.4.1.9.5.1.1.35',
  sysEnableConfigTrapsDefinition => 'CISCO-STACK-MIB::sysEnableConfigTraps',
  sysConfigRegister => '1.3.6.1.4.1.9.5.1.1.36',
  sysBootVariable => '1.3.6.1.4.1.9.5.1.1.37',
  sysBootedImage => '1.3.6.1.4.1.9.5.1.1.38',
  sysEnableEntityTrap => '1.3.6.1.4.1.9.5.1.1.39',
  sysEnableEntityTrapDefinition => 'CISCO-STACK-MIB::sysEnableEntityTrap',
  sysEnableStpxTrap => '1.3.6.1.4.1.9.5.1.1.40',
  sysEnableStpxTrapDefinition => 'CISCO-STACK-MIB::sysEnableStpxTrap',
  sysExtendedRmonVlanModeEnable => '1.3.6.1.4.1.9.5.1.1.41',
  sysExtendedRmonVlanModeEnableDefinition => 'CISCO-STACK-MIB::sysExtendedRmonVlanModeEnable',
  sysExtendedRmonNetflowPassword => '1.3.6.1.4.1.9.5.1.1.42',
  sysExtendedRmonNetflowEnable => '1.3.6.1.4.1.9.5.1.1.43',
  sysExtendedRmonNetflowEnableDefinition => 'CISCO-STACK-MIB::sysExtendedRmonNetflowEnable',
  sysExtendedRmonVlanAgentEnable => '1.3.6.1.4.1.9.5.1.1.44',
  sysExtendedRmonVlanAgentEnableDefinition => 'CISCO-STACK-MIB::sysExtendedRmonVlanAgentEnable',
  sysExtendedRmonEnable => '1.3.6.1.4.1.9.5.1.1.45',
  sysExtendedRmonEnableDefinition => 'CISCO-STACK-MIB::sysExtendedRmonEnable',
  sysConsolePrimaryLoginAuthentication => '1.3.6.1.4.1.9.5.1.1.46',
  sysConsolePrimaryLoginAuthenticationDefinition => 'CISCO-STACK-MIB::sysConsolePrimaryLoginAuthentication',
  sysConsolePrimaryEnableAuthentication => '1.3.6.1.4.1.9.5.1.1.47',
  sysConsolePrimaryEnableAuthenticationDefinition => 'CISCO-STACK-MIB::sysConsolePrimaryEnableAuthentication',
  sysTelnetPrimaryLoginAuthentication => '1.3.6.1.4.1.9.5.1.1.48',
  sysTelnetPrimaryLoginAuthenticationDefinition => 'CISCO-STACK-MIB::sysTelnetPrimaryLoginAuthentication',
  sysTelnetPrimaryEnableAuthentication => '1.3.6.1.4.1.9.5.1.1.49',
  sysTelnetPrimaryEnableAuthenticationDefinition => 'CISCO-STACK-MIB::sysTelnetPrimaryEnableAuthentication',
  sysStartupConfigSource => '1.3.6.1.4.1.9.5.1.1.50',
  sysStartupConfigSourceDefinition => 'CISCO-STACK-MIB::sysStartupConfigSource',
  sysStartupConfigSourceFile => '1.3.6.1.4.1.9.5.1.1.51',
  sysConfigSupervisorModuleNo => '1.3.6.1.4.1.9.5.1.1.52',
  sysStandbyPortEnable => '1.3.6.1.4.1.9.5.1.1.53',
  sysStandbyPortEnableDefinition => 'CISCO-STACK-MIB::sysStandbyPortEnable',
  sysPortFastBpduGuard => '1.3.6.1.4.1.9.5.1.1.54',
  sysPortFastBpduGuardDefinition => 'CISCO-STACK-MIB::sysPortFastBpduGuard',
  sysErrDisableTimeoutEnable => '1.3.6.1.4.1.9.5.1.1.55',
  sysErrDisableTimeoutInterval => '1.3.6.1.4.1.9.5.1.1.56',
  sysTrafficMonitorHighWaterMark => '1.3.6.1.4.1.9.5.1.1.57',
  sysHighAvailabilityEnable => '1.3.6.1.4.1.9.5.1.1.58',
  sysHighAvailabilityVersioningEnable => '1.3.6.1.4.1.9.5.1.1.59',
  sysHighAvailabilityOperStatus => '1.3.6.1.4.1.9.5.1.1.60',
  sysHighAvailabilityOperStatusDefinition => 'CISCO-STACK-MIB::sysHighAvailabilityOperStatus',
  sysHighAvailabilityNotRunningReason => '1.3.6.1.4.1.9.5.1.1.61',
  sysExtendedRmonNetflowModuleMask => '1.3.6.1.4.1.9.5.1.1.62',
  sshPublicKeySize => '1.3.6.1.4.1.9.5.1.1.63',
  sysMaxRmonMemory => '1.3.6.1.4.1.9.5.1.1.64',
  sysMacReductionAdminEnable => '1.3.6.1.4.1.9.5.1.1.65',
  sysMacReductionOperEnable => '1.3.6.1.4.1.9.5.1.1.66',
  sysStatus => '1.3.6.1.4.1.9.5.1.1.67',
  sysStatusDefinition => 'CISCO-STACK-MIB::sysStatus',
  chassisGrp => '1.3.6.1.4.1.9.5.1.2',
  chassisSysType => '1.3.6.1.4.1.9.5.1.2.1',
  chassisSysTypeDefinition => 'CISCO-STACK-MIB::chassisSysType',
  chassisBkplType => '1.3.6.1.4.1.9.5.1.2.2',
  chassisBkplTypeDefinition => 'CISCO-STACK-MIB::chassisBkplType',
  chassisPs1Type => '1.3.6.1.4.1.9.5.1.2.3',
  chassisPs1TypeDefinition => 'CISCO-STACK-MIB::chassisPs1Type',
  chassisPs1Status => '1.3.6.1.4.1.9.5.1.2.4',
  chassisPs1StatusDefinition => 'CISCO-STACK-MIB::chassisPs1Status',
  chassisPs1TestResult => '1.3.6.1.4.1.9.5.1.2.5',
  chassisPs2Type => '1.3.6.1.4.1.9.5.1.2.6',
  chassisPs2TypeDefinition => 'CISCO-STACK-MIB::chassisPs2Type',
  chassisPs2Status => '1.3.6.1.4.1.9.5.1.2.7',
  chassisPs2StatusDefinition => 'CISCO-STACK-MIB::chassisPs2Status',
  chassisPs2TestResult => '1.3.6.1.4.1.9.5.1.2.8',
  chassisFanStatus => '1.3.6.1.4.1.9.5.1.2.9',
  chassisFanStatusDefinition => 'CISCO-STACK-MIB::chassisFanStatus',
  chassisFanTestResult => '1.3.6.1.4.1.9.5.1.2.10',
  chassisMinorAlarm => '1.3.6.1.4.1.9.5.1.2.11',
  chassisMinorAlarmDefinition => 'CISCO-STACK-MIB::chassisMinorAlarm',
  chassisMajorAlarm => '1.3.6.1.4.1.9.5.1.2.12',
  chassisMajorAlarmDefinition => 'CISCO-STACK-MIB::chassisMajorAlarm',
  chassisTempAlarm => '1.3.6.1.4.1.9.5.1.2.13',
  chassisTempAlarmDefinition => 'CISCO-STACK-MIB::chassisTempAlarm',
  chassisNumSlots => '1.3.6.1.4.1.9.5.1.2.14',
  chassisSlotConfig => '1.3.6.1.4.1.9.5.1.2.15',
  chassisModel => '1.3.6.1.4.1.9.5.1.2.16',
  chassisSerialNumber => '1.3.6.1.4.1.9.5.1.2.17',
  chassisComponentTable => '1.3.6.1.4.1.9.5.1.2.18',
  chassisComponentEntry => '1.3.6.1.4.1.9.5.1.2.18.1',
  chassisComponentIndex => '1.3.6.1.4.1.9.5.1.2.18.1.1',
  chassisComponentType => '1.3.6.1.4.1.9.5.1.2.18.1.2',
  chassisComponentTypeDefinition => 'CISCO-STACK-MIB::chassisComponentType',
  chassisComponentSerialNumber => '1.3.6.1.4.1.9.5.1.2.18.1.3',
  chassisComponentHwVersion => '1.3.6.1.4.1.9.5.1.2.18.1.4',
  chassisComponentModel => '1.3.6.1.4.1.9.5.1.2.18.1.5',
  chassisSerialNumberString => '1.3.6.1.4.1.9.5.1.2.19',
  chassisPs3Type => '1.3.6.1.4.1.9.5.1.2.20',
  chassisPs3TypeDefinition => 'CISCO-STACK-MIB::chassisPs3Type',
  chassisPs3Status => '1.3.6.1.4.1.9.5.1.2.21',
  chassisPs3StatusDefinition => 'CISCO-STACK-MIB::chassisPs3Status',
  chassisPs3TestResult => '1.3.6.1.4.1.9.5.1.2.22',
  chassisPEMInstalled => '1.3.6.1.4.1.9.5.1.2.23',
  moduleGrp => '1.3.6.1.4.1.9.5.1.3',
  moduleTable => '1.3.6.1.4.1.9.5.1.3.1',
  moduleEntry => '1.3.6.1.4.1.9.5.1.3.1.1',
  moduleIndex => '1.3.6.1.4.1.9.5.1.3.1.1.1',
  moduleType => '1.3.6.1.4.1.9.5.1.3.1.1.2',
  moduleTypeDefinition => 'CISCO-STACK-MIB::moduleType',
  moduleSerialNumber => '1.3.6.1.4.1.9.5.1.3.1.1.3',
  moduleHwHiVersion => '1.3.6.1.4.1.9.5.1.3.1.1.4',
  moduleHwLoVersion => '1.3.6.1.4.1.9.5.1.3.1.1.5',
  moduleFwHiVersion => '1.3.6.1.4.1.9.5.1.3.1.1.6',
  moduleFwLoVersion => '1.3.6.1.4.1.9.5.1.3.1.1.7',
  moduleSwHiVersion => '1.3.6.1.4.1.9.5.1.3.1.1.8',
  moduleSwLoVersion => '1.3.6.1.4.1.9.5.1.3.1.1.9',
  moduleStatus => '1.3.6.1.4.1.9.5.1.3.1.1.10',
  moduleStatusDefinition => 'CISCO-STACK-MIB::moduleStatus',
  moduleTestResult => '1.3.6.1.4.1.9.5.1.3.1.1.11',
  moduleAction => '1.3.6.1.4.1.9.5.1.3.1.1.12',
  moduleActionDefinition => 'CISCO-STACK-MIB::moduleAction',
  moduleName => '1.3.6.1.4.1.9.5.1.3.1.1.13',
  moduleNumPorts => '1.3.6.1.4.1.9.5.1.3.1.1.14',
  modulePortStatus => '1.3.6.1.4.1.9.5.1.3.1.1.15',
  moduleSubType => '1.3.6.1.4.1.9.5.1.3.1.1.16',
  moduleSubTypeDefinition => 'CISCO-STACK-MIB::moduleSubType',
  moduleModel => '1.3.6.1.4.1.9.5.1.3.1.1.17',
  moduleHwVersion => '1.3.6.1.4.1.9.5.1.3.1.1.18',
  moduleFwVersion => '1.3.6.1.4.1.9.5.1.3.1.1.19',
  moduleSwVersion => '1.3.6.1.4.1.9.5.1.3.1.1.20',
  moduleStandbyStatus => '1.3.6.1.4.1.9.5.1.3.1.1.21',
  moduleStandbyStatusDefinition => 'CISCO-STACK-MIB::moduleStandbyStatus',
  moduleIPAddress => '1.3.6.1.4.1.9.5.1.3.1.1.22',
  moduleIPAddressVlan => '1.3.6.1.4.1.9.5.1.3.1.1.23',
  moduleSubType2 => '1.3.6.1.4.1.9.5.1.3.1.1.24',
  moduleSubType2Definition => 'CISCO-STACK-MIB::moduleSubType2',
  moduleSlotNum => '1.3.6.1.4.1.9.5.1.3.1.1.25',
  moduleSerialNumberString => '1.3.6.1.4.1.9.5.1.3.1.1.26',
  moduleEntPhysicalIndex => '1.3.6.1.4.1.9.5.1.3.1.1.27',
  moduleAdditionalStatus => '1.3.6.1.4.1.9.5.1.3.1.1.28',
  portGrp => '1.3.6.1.4.1.9.5.1.4',
  portTable => '1.3.6.1.4.1.9.5.1.4.1',
  portEntry => '1.3.6.1.4.1.9.5.1.4.1.1',
  portModuleIndex => '1.3.6.1.4.1.9.5.1.4.1.1.1',
  portIndex => '1.3.6.1.4.1.9.5.1.4.1.1.2',
  portCrossIndex => '1.3.6.1.4.1.9.5.1.4.1.1.3',
  portName => '1.3.6.1.4.1.9.5.1.4.1.1.4',
  portType => '1.3.6.1.4.1.9.5.1.4.1.1.5',
  portTypeDefinition => 'CISCO-STACK-MIB::portType',
  portOperStatus => '1.3.6.1.4.1.9.5.1.4.1.1.6',
  portOperStatusDefinition => 'CISCO-STACK-MIB::portOperStatus',
  portCrossGroupIndex => '1.3.6.1.4.1.9.5.1.4.1.1.7',
  portAdditionalStatus => '1.3.6.1.4.1.9.5.1.4.1.1.8',
  portAdminSpeed => '1.3.6.1.4.1.9.5.1.4.1.1.9',
  portAdminSpeedDefinition => 'CISCO-STACK-MIB::portAdminSpeed',
  portDuplex => '1.3.6.1.4.1.9.5.1.4.1.1.10',
  portDuplexDefinition => 'CISCO-STACK-MIB::portDuplex',
  portIfIndex => '1.3.6.1.4.1.9.5.1.4.1.1.11',
  portSpantreeFastStart => '1.3.6.1.4.1.9.5.1.4.1.1.12',
  portSpantreeFastStartDefinition => 'CISCO-STACK-MIB::portSpantreeFastStart',
  portAdminRxFlowControl => '1.3.6.1.4.1.9.5.1.4.1.1.13',
  portAdminRxFlowControlDefinition => 'CISCO-STACK-MIB::portAdminRxFlowControl',
  portOperRxFlowControl => '1.3.6.1.4.1.9.5.1.4.1.1.14',
  portOperRxFlowControlDefinition => 'CISCO-STACK-MIB::portOperRxFlowControl',
  portAdminTxFlowControl => '1.3.6.1.4.1.9.5.1.4.1.1.15',
  portAdminTxFlowControlDefinition => 'CISCO-STACK-MIB::portAdminTxFlowControl',
  portOperTxFlowControl => '1.3.6.1.4.1.9.5.1.4.1.1.16',
  portOperTxFlowControlDefinition => 'CISCO-STACK-MIB::portOperTxFlowControl',
  portMacControlTransmitFrames => '1.3.6.1.4.1.9.5.1.4.1.1.17',
  portMacControlReceiveFrames => '1.3.6.1.4.1.9.5.1.4.1.1.18',
  portMacControlPauseTransmitFrames => '1.3.6.1.4.1.9.5.1.4.1.1.19',
  portMacControlPauseReceiveFrames => '1.3.6.1.4.1.9.5.1.4.1.1.20',
  portMacControlUnknownProtocolFrames => '1.3.6.1.4.1.9.5.1.4.1.1.21',
  portLinkFaultStatus => '1.3.6.1.4.1.9.5.1.4.1.1.22',
  portLinkFaultStatusDefinition => 'CISCO-STACK-MIB::portLinkFaultStatus',
  portAdditionalOperStatus => '1.3.6.1.4.1.9.5.1.4.1.1.23',
  portInlinePowerDetect => '1.3.6.1.4.1.9.5.1.4.1.1.24',
  portEntPhysicalIndex => '1.3.6.1.4.1.9.5.1.4.1.1.25',
  portErrDisableTimeOutEnable => '1.3.6.1.4.1.9.5.1.4.1.1.26',
  portErrDisableTimeOutEnableDefinition => 'CISCO-STACK-MIB::portErrDisableTimeOutEnable',
  tftpGrp => '1.3.6.1.4.1.9.5.1.5',
  tftpHost => '1.3.6.1.4.1.9.5.1.5.1',
  tftpFile => '1.3.6.1.4.1.9.5.1.5.2',
  tftpModule => '1.3.6.1.4.1.9.5.1.5.3',
  tftpAction => '1.3.6.1.4.1.9.5.1.5.4',
  tftpActionDefinition => 'CISCO-STACK-MIB::tftpAction',
  tftpResult => '1.3.6.1.4.1.9.5.1.5.5',
  tftpResultDefinition => 'CISCO-STACK-MIB::tftpResult',
  brouterGrp => '1.3.6.1.4.1.9.5.1.6',
  brouterEnableRip => '1.3.6.1.4.1.9.5.1.6.1',
  brouterEnableRipDefinition => 'CISCO-STACK-MIB::brouterEnableRip',
  brouterEnableSpantree => '1.3.6.1.4.1.9.5.1.6.2',
  brouterEnableSpantreeDefinition => 'CISCO-STACK-MIB::brouterEnableSpantree',
  brouterEnableGiantCheck => '1.3.6.1.4.1.9.5.1.6.3',
  brouterEnableGiantCheckDefinition => 'CISCO-STACK-MIB::brouterEnableGiantCheck',
  brouterEnableIpFragmentation => '1.3.6.1.4.1.9.5.1.6.4',
  brouterEnableIpFragmentationDefinition => 'CISCO-STACK-MIB::brouterEnableIpFragmentation',
  brouterEnableUnreachables => '1.3.6.1.4.1.9.5.1.6.5',
  brouterEnableUnreachablesDefinition => 'CISCO-STACK-MIB::brouterEnableUnreachables',
  brouterCamAgingTime => '1.3.6.1.4.1.9.5.1.6.6',
  brouterCamMode => '1.3.6.1.4.1.9.5.1.6.7',
  brouterCamModeDefinition => 'CISCO-STACK-MIB::brouterCamMode',
  brouterIpxSnapToEther => '1.3.6.1.4.1.9.5.1.6.8',
  brouterIpxSnapToEtherDefinition => 'CISCO-STACK-MIB::brouterIpxSnapToEther',
  brouterIpx8023RawToFddi => '1.3.6.1.4.1.9.5.1.6.9',
  brouterIpx8023RawToFddiDefinition => 'CISCO-STACK-MIB::brouterIpx8023RawToFddi',
  brouterEthernetReceiveMax => '1.3.6.1.4.1.9.5.1.6.10',
  brouterEthernetTransmitMax => '1.3.6.1.4.1.9.5.1.6.11',
  brouterFddiReceiveMax => '1.3.6.1.4.1.9.5.1.6.12',
  brouterFddiTransmitMax => '1.3.6.1.4.1.9.5.1.6.13',
  brouterPortTable => '1.3.6.1.4.1.9.5.1.6.14',
  brouterPortEntry => '1.3.6.1.4.1.9.5.1.6.14.1',
  brouterPortModule => '1.3.6.1.4.1.9.5.1.6.14.1.1',
  brouterPort => '1.3.6.1.4.1.9.5.1.6.14.1.2',
  brouterPortIpVlan => '1.3.6.1.4.1.9.5.1.6.14.1.3',
  brouterPortIpAddr => '1.3.6.1.4.1.9.5.1.6.14.1.4',
  brouterPortNetMask => '1.3.6.1.4.1.9.5.1.6.14.1.5',
  brouterPortBroadcast => '1.3.6.1.4.1.9.5.1.6.14.1.6',
  brouterPortBridgeVlan => '1.3.6.1.4.1.9.5.1.6.14.1.7',
  brouterPortIpHelpers => '1.3.6.1.4.1.9.5.1.6.14.1.8',
  brouterIpx8022ToEther => '1.3.6.1.4.1.9.5.1.6.15',
  brouterIpx8022ToEtherDefinition => 'CISCO-STACK-MIB::brouterIpx8022ToEther',
  brouterEnableTransitEncapsulation => '1.3.6.1.4.1.9.5.1.6.16',
  brouterEnableTransitEncapsulationDefinition => 'CISCO-STACK-MIB::brouterEnableTransitEncapsulation',
  brouterEnableFddiCheck => '1.3.6.1.4.1.9.5.1.6.17',
  brouterEnableFddiCheckDefinition => 'CISCO-STACK-MIB::brouterEnableFddiCheck',
  brouterEnableAPaRT => '1.3.6.1.4.1.9.5.1.6.18',
  brouterEnableAPaRTDefinition => 'CISCO-STACK-MIB::brouterEnableAPaRT',
  filterGrp => '1.3.6.1.4.1.9.5.1.7',
  filterMacTable => '1.3.6.1.4.1.9.5.1.7.1',
  filterMacEntry => '1.3.6.1.4.1.9.5.1.7.1.1',
  filterMacModule => '1.3.6.1.4.1.9.5.1.7.1.1.1',
  filterMacPort => '1.3.6.1.4.1.9.5.1.7.1.1.2',
  filterMacAddress => '1.3.6.1.4.1.9.5.1.7.1.1.3',
  filterMacType => '1.3.6.1.4.1.9.5.1.7.1.1.4',
  filterMacTypeDefinition => 'CISCO-STACK-MIB::filterMacType',
  filterVendorTable => '1.3.6.1.4.1.9.5.1.7.2',
  filterVendorEntry => '1.3.6.1.4.1.9.5.1.7.2.1',
  filterVendorModule => '1.3.6.1.4.1.9.5.1.7.2.1.1',
  filterVendorPort => '1.3.6.1.4.1.9.5.1.7.2.1.2',
  filterVendorId => '1.3.6.1.4.1.9.5.1.7.2.1.3',
  filterVendorType => '1.3.6.1.4.1.9.5.1.7.2.1.4',
  filterVendorTypeDefinition => 'CISCO-STACK-MIB::filterVendorType',
  filterProtocolTable => '1.3.6.1.4.1.9.5.1.7.3',
  filterProtocolEntry => '1.3.6.1.4.1.9.5.1.7.3.1',
  filterProtocolModule => '1.3.6.1.4.1.9.5.1.7.3.1.1',
  filterProtocolPort => '1.3.6.1.4.1.9.5.1.7.3.1.2',
  filterProtocolValue => '1.3.6.1.4.1.9.5.1.7.3.1.3',
  filterProtocolType => '1.3.6.1.4.1.9.5.1.7.3.1.4',
  filterProtocolTypeDefinition => 'CISCO-STACK-MIB::filterProtocolType',
  filterTestTable => '1.3.6.1.4.1.9.5.1.7.4',
  filterTestEntry => '1.3.6.1.4.1.9.5.1.7.4.1',
  filterTestModule => '1.3.6.1.4.1.9.5.1.7.4.1.1',
  filterTestPort => '1.3.6.1.4.1.9.5.1.7.4.1.2',
  filterTestIndex => '1.3.6.1.4.1.9.5.1.7.4.1.3',
  filterTestType => '1.3.6.1.4.1.9.5.1.7.4.1.4',
  filterTestTypeDefinition => 'CISCO-STACK-MIB::filterTestType',
  filterTestOffset => '1.3.6.1.4.1.9.5.1.7.4.1.5',
  filterTestValue => '1.3.6.1.4.1.9.5.1.7.4.1.6',
  filterTestMask => '1.3.6.1.4.1.9.5.1.7.4.1.7',
  filterPortTable => '1.3.6.1.4.1.9.5.1.7.5',
  filterPortEntry => '1.3.6.1.4.1.9.5.1.7.5.1',
  filterPortModule => '1.3.6.1.4.1.9.5.1.7.5.1.1',
  filterPort => '1.3.6.1.4.1.9.5.1.7.5.1.2',
  filterPortComplex => '1.3.6.1.4.1.9.5.1.7.5.1.3',
  filterPortBroadcastThrottle => '1.3.6.1.4.1.9.5.1.7.5.1.4',
  filterPortBroadcastThreshold => '1.3.6.1.4.1.9.5.1.7.5.1.5',
  filterPortBroadcastDiscards => '1.3.6.1.4.1.9.5.1.7.5.1.6',
  filterPortBroadcastThresholdFraction => '1.3.6.1.4.1.9.5.1.7.5.1.7',
  filterPortSuppressionOption => '1.3.6.1.4.1.9.5.1.7.5.1.8',
  filterPortSuppressionViolation => '1.3.6.1.4.1.9.5.1.7.5.1.9',
  filterPortSuppressionViolationDefinition => 'CISCO-STACK-MIB::filterPortSuppressionViolation',
  monitorGrp => '1.3.6.1.4.1.9.5.1.8',
  monitorSourceModule => '1.3.6.1.4.1.9.5.1.8.1',
  monitorSourcePort => '1.3.6.1.4.1.9.5.1.8.2',
  monitorDestinationModule => '1.3.6.1.4.1.9.5.1.8.3',
  monitorDestinationPort => '1.3.6.1.4.1.9.5.1.8.4',
  monitorDirection => '1.3.6.1.4.1.9.5.1.8.5',
  monitorDirectionDefinition => 'CISCO-STACK-MIB::monitorDirection',
  monitorEnable => '1.3.6.1.4.1.9.5.1.8.6',
  monitorEnableDefinition => 'CISCO-STACK-MIB::monitorEnable',
  monitorAdminSourcePorts => '1.3.6.1.4.1.9.5.1.8.7',
  monitorOperSourcePorts => '1.3.6.1.4.1.9.5.1.8.8',
  vlanGrp => '1.3.6.1.4.1.9.5.1.9',
  vlanTable => '1.3.6.1.4.1.9.5.1.9.2',
  vlanEntry => '1.3.6.1.4.1.9.5.1.9.2.1',
  vlanIndex => '1.3.6.1.4.1.9.5.1.9.2.1.1',
  vlanSpantreeEnable => '1.3.6.1.4.1.9.5.1.9.2.1.2',
  vlanSpantreeEnableDefinition => 'CISCO-STACK-MIB::vlanSpantreeEnable',
  vlanIfIndex => '1.3.6.1.4.1.9.5.1.9.2.1.3',
  vlanPortTable => '1.3.6.1.4.1.9.5.1.9.3',
  vlanPortEntry => '1.3.6.1.4.1.9.5.1.9.3.1',
  vlanPortModule => '1.3.6.1.4.1.9.5.1.9.3.1.1',
  vlanPort => '1.3.6.1.4.1.9.5.1.9.3.1.2',
  vlanPortVlan => '1.3.6.1.4.1.9.5.1.9.3.1.3',
  vlanPortIslVlansAllowed => '1.3.6.1.4.1.9.5.1.9.3.1.5',
  vlanPortSwitchLevel => '1.3.6.1.4.1.9.5.1.9.3.1.6',
  vlanPortSwitchLevelDefinition => 'CISCO-STACK-MIB::vlanPortSwitchLevel',
  vlanPortIslAdminStatus => '1.3.6.1.4.1.9.5.1.9.3.1.7',
  vlanPortIslAdminStatusDefinition => 'CISCO-STACK-MIB::vlanPortIslAdminStatus',
  vlanPortIslOperStatus => '1.3.6.1.4.1.9.5.1.9.3.1.8',
  vlanPortIslOperStatusDefinition => 'CISCO-STACK-MIB::vlanPortIslOperStatus',
  vlanPortIslPriorityVlans => '1.3.6.1.4.1.9.5.1.9.3.1.9',
  vlanPortAdminStatus => '1.3.6.1.4.1.9.5.1.9.3.1.10',
  vlanPortAdminStatusDefinition => 'CISCO-STACK-MIB::vlanPortAdminStatus',
  vlanPortOperStatus => '1.3.6.1.4.1.9.5.1.9.3.1.11',
  vlanPortOperStatusDefinition => 'CISCO-STACK-MIB::vlanPortOperStatus',
  vlanPortAuxiliaryVlan => '1.3.6.1.4.1.9.5.1.9.3.1.12',
  vmpsTable => '1.3.6.1.4.1.9.5.1.9.4',
  vmpsEntry => '1.3.6.1.4.1.9.5.1.9.4.1',
  vmpsAddr => '1.3.6.1.4.1.9.5.1.9.4.1.1',
  vmpsType => '1.3.6.1.4.1.9.5.1.9.4.1.2',
  vmpsTypeDefinition => 'CISCO-STACK-MIB::vmpsType',
  vmpsAction => '1.3.6.1.4.1.9.5.1.9.5',
  vmpsActionDefinition => 'CISCO-STACK-MIB::vmpsAction',
  vmpsAccessed => '1.3.6.1.4.1.9.5.1.9.6',
  vlanTrunkMappingMax => '1.3.6.1.4.1.9.5.1.9.7',
  vlanTrunkMappingTable => '1.3.6.1.4.1.9.5.1.9.8',
  vlanTrunkMappingEntry => '1.3.6.1.4.1.9.5.1.9.8.1',
  vlanTrunkMappingFromVlan => '1.3.6.1.4.1.9.5.1.9.8.1.1',
  vlanTrunkMappingToVlan => '1.3.6.1.4.1.9.5.1.9.8.1.2',
  vlanTrunkMappingType => '1.3.6.1.4.1.9.5.1.9.8.1.3',
  vlanTrunkMappingTypeDefinition => 'CISCO-STACK-MIB::vlanTrunkMappingType',
  vlanTrunkMappingOper => '1.3.6.1.4.1.9.5.1.9.8.1.4',
  vlanTrunkMappingStatus => '1.3.6.1.4.1.9.5.1.9.8.1.5',
  securityGrp => '1.3.6.1.4.1.9.5.1.10',
  portSecurityTable => '1.3.6.1.4.1.9.5.1.10.1',
  portSecurityEntry => '1.3.6.1.4.1.9.5.1.10.1.1',
  portSecurityModuleIndex => '1.3.6.1.4.1.9.5.1.10.1.1.1',
  portSecurityPortIndex => '1.3.6.1.4.1.9.5.1.10.1.1.2',
  portSecurityAdminStatus => '1.3.6.1.4.1.9.5.1.10.1.1.3',
  portSecurityAdminStatusDefinition => 'CISCO-STACK-MIB::portSecurityAdminStatus',
  portSecurityOperStatus => '1.3.6.1.4.1.9.5.1.10.1.1.4',
  portSecurityOperStatusDefinition => 'CISCO-STACK-MIB::portSecurityOperStatus',
  portSecurityLastSrcAddr => '1.3.6.1.4.1.9.5.1.10.1.1.5',
  portSecuritySecureSrcAddr => '1.3.6.1.4.1.9.5.1.10.1.1.6',
  portSecurityMaxSrcAddr => '1.3.6.1.4.1.9.5.1.10.1.1.7',
  portSecurityAgingTime => '1.3.6.1.4.1.9.5.1.10.1.1.8',
  portSecurityShutdownTimeOut => '1.3.6.1.4.1.9.5.1.10.1.1.9',
  portSecurityViolationPolicy => '1.3.6.1.4.1.9.5.1.10.1.1.10',
  portSecurityViolationPolicyDefinition => 'CISCO-STACK-MIB::portSecurityViolationPolicy',
  portSecurityExtTable => '1.3.6.1.4.1.9.5.1.10.2',
  portSecurityExtEntry => '1.3.6.1.4.1.9.5.1.10.2.1',
  portSecurityExtModuleIndex => '1.3.6.1.4.1.9.5.1.10.2.1.1',
  portSecurityExtPortIndex => '1.3.6.1.4.1.9.5.1.10.2.1.2',
  portSecurityExtSecureSrcAddr => '1.3.6.1.4.1.9.5.1.10.2.1.3',
  portSecurityExtControlStatus => '1.3.6.1.4.1.9.5.1.10.2.1.4',
  portSecurityExtControlStatusDefinition => 'CISCO-STACK-MIB::portSecurityExtControlStatus',
  tokenRingGrp => '1.3.6.1.4.1.9.5.1.11',
  tokenRingPortTable => '1.3.6.1.4.1.9.5.1.11.1',
  tokenRingPortEntry => '1.3.6.1.4.1.9.5.1.11.1.1',
  tokenRingModuleIndex => '1.3.6.1.4.1.9.5.1.11.1.1.1',
  tokenRingPortIndex => '1.3.6.1.4.1.9.5.1.11.1.1.2',
  tokenRingPortSetACbits => '1.3.6.1.4.1.9.5.1.11.1.1.3',
  tokenRingPortSetACbitsDefinition => 'CISCO-STACK-MIB::tokenRingPortSetACbits',
  tokenRingPortMode => '1.3.6.1.4.1.9.5.1.11.1.1.4',
  tokenRingPortModeDefinition => 'CISCO-STACK-MIB::tokenRingPortMode',
  tokenRingPortEarlyTokenRel => '1.3.6.1.4.1.9.5.1.11.1.1.9',
  tokenRingPortEarlyTokenRelDefinition => 'CISCO-STACK-MIB::tokenRingPortEarlyTokenRel',
  tokenRingPortPriorityThresh => '1.3.6.1.4.1.9.5.1.11.1.1.10',
  tokenRingPortPriorityMinXmit => '1.3.6.1.4.1.9.5.1.11.1.1.11',
  tokenRingPortCfgLossThresh => '1.3.6.1.4.1.9.5.1.11.1.1.12',
  tokenRingPortCfgLossInterval => '1.3.6.1.4.1.9.5.1.11.1.1.13',
  tokenRingDripDistCrfMode => '1.3.6.1.4.1.9.5.1.11.2',
  tokenRingDripDistCrfModeDefinition => 'CISCO-STACK-MIB::tokenRingDripDistCrfMode',
  tokenRingDripAreReductionMode => '1.3.6.1.4.1.9.5.1.11.3',
  tokenRingDripAreReductionModeDefinition => 'CISCO-STACK-MIB::tokenRingDripAreReductionMode',
  tokenRingDripLocalNodeID => '1.3.6.1.4.1.9.5.1.11.4',
  tokenRingDripLastRevision => '1.3.6.1.4.1.9.5.1.11.5',
  tokenRingDripLastChangedRevision => '1.3.6.1.4.1.9.5.1.11.6',
  tokenRingDripAdvertsReceived => '1.3.6.1.4.1.9.5.1.11.7',
  tokenRingDripAdvertsTransmitted => '1.3.6.1.4.1.9.5.1.11.8',
  tokenRingDripAdvertsProcessed => '1.3.6.1.4.1.9.5.1.11.9',
  tokenRingDripInputQueueDrops => '1.3.6.1.4.1.9.5.1.11.10',
  tokenRingDripOutputQueueDrops => '1.3.6.1.4.1.9.5.1.11.11',
  tokenRingDripLocalVlanStatusTable => '1.3.6.1.4.1.9.5.1.11.12',
  tokenRingDripLocalVlanStatusEntry => '1.3.6.1.4.1.9.5.1.11.12.1',
  tokenRingDripVlan => '1.3.6.1.4.1.9.5.1.11.12.1.1',
  tokenRingDripLocalPortStatus => '1.3.6.1.4.1.9.5.1.11.12.1.2',
  tokenRingDripLocalPortStatusDefinition => 'CISCO-STACK-MIB::tokenRingDripLocalPortStatus',
  tokenRingDripRemotePortStatus => '1.3.6.1.4.1.9.5.1.11.12.1.3',
  tokenRingDripRemotePortStatusDefinition => 'CISCO-STACK-MIB::tokenRingDripRemotePortStatus',
  tokenRingDripRemotePortConfigured => '1.3.6.1.4.1.9.5.1.11.12.1.4',
  tokenRingDripRemotePortConfiguredDefinition => 'CISCO-STACK-MIB::tokenRingDripRemotePortConfigured',
  tokenRingDripDistributedCrf => '1.3.6.1.4.1.9.5.1.11.12.1.5',
  tokenRingDripDistributedCrfDefinition => 'CISCO-STACK-MIB::tokenRingDripDistributedCrf',
  tokenRingDripBackupCrf => '1.3.6.1.4.1.9.5.1.11.12.1.6',
  tokenRingDripBackupCrfDefinition => 'CISCO-STACK-MIB::tokenRingDripBackupCrf',
  tokenRingDripOwnerNodeID => '1.3.6.1.4.1.9.5.1.11.12.1.7',
  tokenRingPortSoftErrTable => '1.3.6.1.4.1.9.5.1.11.14',
  tokenRingPortSoftErrEntry => '1.3.6.1.4.1.9.5.1.11.14.1',
  tokenRingPortSoftErrThresh => '1.3.6.1.4.1.9.5.1.11.14.1.1',
  tokenRingPortSoftErrReportInterval => '1.3.6.1.4.1.9.5.1.11.14.1.2',
  tokenRingPortSoftErrResetCounters => '1.3.6.1.4.1.9.5.1.11.14.1.3',
  tokenRingPortSoftErrResetCountersDefinition => 'CISCO-STACK-MIB::tokenRingPortSoftErrResetCounters',
  tokenRingPortSoftErrLastCounterReset => '1.3.6.1.4.1.9.5.1.11.14.1.4',
  tokenRingPortSoftErrEnable => '1.3.6.1.4.1.9.5.1.11.14.1.5',
  tokenRingPortSoftErrEnableDefinition => 'CISCO-STACK-MIB::tokenRingPortSoftErrEnable',
  multicastGrp => '1.3.6.1.4.1.9.5.1.12',
  mcastRouterTable => '1.3.6.1.4.1.9.5.1.12.1',
  mcastRouterEntry => '1.3.6.1.4.1.9.5.1.12.1.1',
  mcastRouterModuleIndex => '1.3.6.1.4.1.9.5.1.12.1.1.1',
  mcastRouterPortIndex => '1.3.6.1.4.1.9.5.1.12.1.1.2',
  mcastRouterAdminStatus => '1.3.6.1.4.1.9.5.1.12.1.1.3',
  mcastRouterAdminStatusDefinition => 'CISCO-STACK-MIB::mcastRouterAdminStatus',
  mcastRouterOperStatus => '1.3.6.1.4.1.9.5.1.12.1.1.4',
  mcastRouterOperStatusDefinition => 'CISCO-STACK-MIB::mcastRouterOperStatus',
  mcastEnableCgmp => '1.3.6.1.4.1.9.5.1.12.2',
  mcastEnableCgmpDefinition => 'CISCO-STACK-MIB::mcastEnableCgmp',
  mcastEnableIgmp => '1.3.6.1.4.1.9.5.1.12.3',
  mcastEnableIgmpDefinition => 'CISCO-STACK-MIB::mcastEnableIgmp',
  mcastEnableRgmp => '1.3.6.1.4.1.9.5.1.12.4',
  mcastEnableRgmpDefinition => 'CISCO-STACK-MIB::mcastEnableRgmp',
  dnsGrp => '1.3.6.1.4.1.9.5.1.13',
  dnsEnable => '1.3.6.1.4.1.9.5.1.13.1',
  dnsEnableDefinition => 'CISCO-STACK-MIB::dnsEnable',
  dnsServerTable => '1.3.6.1.4.1.9.5.1.13.2',
  dnsServerEntry => '1.3.6.1.4.1.9.5.1.13.2.1',
  dnsServerAddr => '1.3.6.1.4.1.9.5.1.13.2.1.1',
  dnsServerType => '1.3.6.1.4.1.9.5.1.13.2.1.2',
  dnsServerTypeDefinition => 'CISCO-STACK-MIB::dnsServerType',
  dnsDomainName => '1.3.6.1.4.1.9.5.1.13.3',
  syslogGrp => '1.3.6.1.4.1.9.5.1.14',
  syslogServerTable => '1.3.6.1.4.1.9.5.1.14.1',
  syslogServerEntry => '1.3.6.1.4.1.9.5.1.14.1.1',
  syslogServerAddr => '1.3.6.1.4.1.9.5.1.14.1.1.1',
  syslogServerType => '1.3.6.1.4.1.9.5.1.14.1.1.2',
  syslogServerTypeDefinition => 'CISCO-STACK-MIB::syslogServerType',
  syslogConsoleEnable => '1.3.6.1.4.1.9.5.1.14.2',
  syslogConsoleEnableDefinition => 'CISCO-STACK-MIB::syslogConsoleEnable',
  syslogHostEnable => '1.3.6.1.4.1.9.5.1.14.3',
  syslogHostEnableDefinition => 'CISCO-STACK-MIB::syslogHostEnable',
  syslogMessageControlTable => '1.3.6.1.4.1.9.5.1.14.4',
  syslogMessageControlEntry => '1.3.6.1.4.1.9.5.1.14.4.1',
  syslogMessageFacility => '1.3.6.1.4.1.9.5.1.14.4.1.1',
  syslogMessageFacilityDefinition => 'CISCO-STACK-MIB::syslogMessageFacility',
  syslogMessageSeverity => '1.3.6.1.4.1.9.5.1.14.4.1.2',
  syslogMessageSeverityDefinition => 'CISCO-STACK-MIB::syslogMessageSeverity',
  syslogTimeStampOption => '1.3.6.1.4.1.9.5.1.14.5',
  syslogTimeStampOptionDefinition => 'CISCO-STACK-MIB::syslogTimeStampOption',
  syslogTelnetEnable => '1.3.6.1.4.1.9.5.1.14.6',
  syslogTelnetEnableDefinition => 'CISCO-STACK-MIB::syslogTelnetEnable',
  ntpGrp => '1.3.6.1.4.1.9.5.1.15',
  ntpBcastClient => '1.3.6.1.4.1.9.5.1.15.1',
  ntpBcastClientDefinition => 'CISCO-STACK-MIB::ntpBcastClient',
  ntpBcastDelay => '1.3.6.1.4.1.9.5.1.15.2',
  ntpClient => '1.3.6.1.4.1.9.5.1.15.3',
  ntpClientDefinition => 'CISCO-STACK-MIB::ntpClient',
  ntpServerTable => '1.3.6.1.4.1.9.5.1.15.4',
  ntpServerEntry => '1.3.6.1.4.1.9.5.1.15.4.1',
  ntpServerAddress => '1.3.6.1.4.1.9.5.1.15.4.1.1',
  ntpServerType => '1.3.6.1.4.1.9.5.1.15.4.1.2',
  ntpServerTypeDefinition => 'CISCO-STACK-MIB::ntpServerType',
  ntpServerPublicKey => '1.3.6.1.4.1.9.5.1.15.4.1.3',
  ntpSummertimeStatus => '1.3.6.1.4.1.9.5.1.15.5',
  ntpSummertimeStatusDefinition => 'CISCO-STACK-MIB::ntpSummertimeStatus',
  ntpSummerTimezoneName => '1.3.6.1.4.1.9.5.1.15.6',
  ntpTimezoneName => '1.3.6.1.4.1.9.5.1.15.7',
  ntpTimezoneOffsetHour => '1.3.6.1.4.1.9.5.1.15.8',
  ntpTimezoneOffsetMinute => '1.3.6.1.4.1.9.5.1.15.9',
  ntpAuthenticationEnable => '1.3.6.1.4.1.9.5.1.15.10',
  ntpAuthenticationEnableDefinition => 'CISCO-STACK-MIB::ntpAuthenticationEnable',
  ntpAuthenticationTable => '1.3.6.1.4.1.9.5.1.15.11',
  ntpAuthenticationEntry => '1.3.6.1.4.1.9.5.1.15.11.1',
  ntpAuthenticationPublicKey => '1.3.6.1.4.1.9.5.1.15.11.1.1',
  ntpAuthenticationSecretKey => '1.3.6.1.4.1.9.5.1.15.11.1.2',
  ntpAuthenticationTrustedMode => '1.3.6.1.4.1.9.5.1.15.11.1.3',
  ntpAuthenticationTrustedModeDefinition => 'CISCO-STACK-MIB::ntpAuthenticationTrustedMode',
  ntpAuthenticationType => '1.3.6.1.4.1.9.5.1.15.11.1.4',
  ntpAuthenticationTypeDefinition => 'CISCO-STACK-MIB::ntpAuthenticationType',
  tacacsGrp => '1.3.6.1.4.1.9.5.1.16',
  tacacsLoginAuthentication => '1.3.6.1.4.1.9.5.1.16.1',
  tacacsLoginAuthenticationDefinition => 'CISCO-STACK-MIB::tacacsLoginAuthentication',
  tacacsEnableAuthentication => '1.3.6.1.4.1.9.5.1.16.2',
  tacacsEnableAuthenticationDefinition => 'CISCO-STACK-MIB::tacacsEnableAuthentication',
  tacacsLocalLoginAuthentication => '1.3.6.1.4.1.9.5.1.16.3',
  tacacsLocalLoginAuthenticationDefinition => 'CISCO-STACK-MIB::tacacsLocalLoginAuthentication',
  tacacsLocalEnableAuthentication => '1.3.6.1.4.1.9.5.1.16.4',
  tacacsLocalEnableAuthenticationDefinition => 'CISCO-STACK-MIB::tacacsLocalEnableAuthentication',
  tacacsNumLoginAttempts => '1.3.6.1.4.1.9.5.1.16.5',
  tacacsDirectedRequest => '1.3.6.1.4.1.9.5.1.16.6',
  tacacsDirectedRequestDefinition => 'CISCO-STACK-MIB::tacacsDirectedRequest',
  tacacsTimeout => '1.3.6.1.4.1.9.5.1.16.7',
  tacacsAuthKey => '1.3.6.1.4.1.9.5.1.16.8',
  tacacsServerTable => '1.3.6.1.4.1.9.5.1.16.9',
  tacacsServerEntry => '1.3.6.1.4.1.9.5.1.16.9.1',
  tacacsServerAddr => '1.3.6.1.4.1.9.5.1.16.9.1.1',
  tacacsServerType => '1.3.6.1.4.1.9.5.1.16.9.1.2',
  tacacsServerTypeDefinition => 'CISCO-STACK-MIB::tacacsServerType',
  ipPermitListGrp => '1.3.6.1.4.1.9.5.1.17',
  ipPermitEnable => '1.3.6.1.4.1.9.5.1.17.1',
  ipPermitEnableDefinition => 'CISCO-STACK-MIB::ipPermitEnable',
  ipPermitListTable => '1.3.6.1.4.1.9.5.1.17.2',
  ipPermitListEntry => '1.3.6.1.4.1.9.5.1.17.2.1',
  ipPermitAddress => '1.3.6.1.4.1.9.5.1.17.2.1.1',
  ipPermitMask => '1.3.6.1.4.1.9.5.1.17.2.1.2',
  ipPermitType => '1.3.6.1.4.1.9.5.1.17.2.1.3',
  ipPermitTypeDefinition => 'CISCO-STACK-MIB::ipPermitType',
  ipPermitAccessType => '1.3.6.1.4.1.9.5.1.17.2.1.4',
  ipPermitTelnetConnectLimit => '1.3.6.1.4.1.9.5.1.17.2.1.5',
  ipPermitSshConnectLimit => '1.3.6.1.4.1.9.5.1.17.2.1.6',
  ipPermitDeniedListTable => '1.3.6.1.4.1.9.5.1.17.3',
  ipPermitDeniedListEntry => '1.3.6.1.4.1.9.5.1.17.3.1',
  ipPermitDeniedAddress => '1.3.6.1.4.1.9.5.1.17.3.1.1',
  ipPermitDeniedAccess => '1.3.6.1.4.1.9.5.1.17.3.1.2',
  ipPermitDeniedAccessDefinition => 'CISCO-STACK-MIB::ipPermitDeniedAccess',
  ipPermitDeniedTime => '1.3.6.1.4.1.9.5.1.17.3.1.3',
  ipPermitAccessTypeEnable => '1.3.6.1.4.1.9.5.1.17.4',
  portChannelGrp => '1.3.6.1.4.1.9.5.1.18',
  portChannelTable => '1.3.6.1.4.1.9.5.1.18.1',
  portChannelEntry => '1.3.6.1.4.1.9.5.1.18.1.1',
  portChannelModuleIndex => '1.3.6.1.4.1.9.5.1.18.1.1.1',
  portChannelPortIndex => '1.3.6.1.4.1.9.5.1.18.1.1.2',
  portChannelPorts => '1.3.6.1.4.1.9.5.1.18.1.1.3',
  portChannelAdminStatus => '1.3.6.1.4.1.9.5.1.18.1.1.4',
  portChannelAdminStatusDefinition => 'CISCO-STACK-MIB::portChannelAdminStatus',
  portChannelOperStatus => '1.3.6.1.4.1.9.5.1.18.1.1.5',
  portChannelOperStatusDefinition => 'CISCO-STACK-MIB::portChannelOperStatus',
  portChannelNeighbourDeviceId => '1.3.6.1.4.1.9.5.1.18.1.1.6',
  portChannelNeighbourPortId => '1.3.6.1.4.1.9.5.1.18.1.1.7',
  portChannelProtInPackets => '1.3.6.1.4.1.9.5.1.18.1.1.8',
  portChannelProtOutPackets => '1.3.6.1.4.1.9.5.1.18.1.1.9',
  portChannelIfIndex => '1.3.6.1.4.1.9.5.1.18.1.1.10',
  portCpbGrp => '1.3.6.1.4.1.9.5.1.19',
  portCpbTable => '1.3.6.1.4.1.9.5.1.19.1',
  portCpbEntry => '1.3.6.1.4.1.9.5.1.19.1.1',
  portCpbModuleIndex => '1.3.6.1.4.1.9.5.1.19.1.1.1',
  portCpbPortIndex => '1.3.6.1.4.1.9.5.1.19.1.1.2',
  portCpbSpeed => '1.3.6.1.4.1.9.5.1.19.1.1.3',
  portCpbDuplex => '1.3.6.1.4.1.9.5.1.19.1.1.4',
  portCpbTrunkEncapsulationType => '1.3.6.1.4.1.9.5.1.19.1.1.5',
  portCpbTrunkMode => '1.3.6.1.4.1.9.5.1.19.1.1.6',
  portCpbChannel => '1.3.6.1.4.1.9.5.1.19.1.1.7',
  portCpbBroadcastSuppression => '1.3.6.1.4.1.9.5.1.19.1.1.8',
  portCpbFlowControl => '1.3.6.1.4.1.9.5.1.19.1.1.9',
  portCpbSecurity => '1.3.6.1.4.1.9.5.1.19.1.1.10',
  portCpbSecurityDefinition => 'CISCO-STACK-MIB::portCpbSecurity',
  portCpbVlanMembership => '1.3.6.1.4.1.9.5.1.19.1.1.11',
  portCpbPortfast => '1.3.6.1.4.1.9.5.1.19.1.1.12',
  portCpbPortfastDefinition => 'CISCO-STACK-MIB::portCpbPortfast',
  portCpbUdld => '1.3.6.1.4.1.9.5.1.19.1.1.13',
  portCpbUdldDefinition => 'CISCO-STACK-MIB::portCpbUdld',
  portCpbInlinePower => '1.3.6.1.4.1.9.5.1.19.1.1.14',
  portCpbAuxiliaryVlan => '1.3.6.1.4.1.9.5.1.19.1.1.15',
  portCpbSpan => '1.3.6.1.4.1.9.5.1.19.1.1.16',
  portCpbCosRewrite => '1.3.6.1.4.1.9.5.1.19.1.1.17',
  portCpbCosRewriteDefinition => 'CISCO-STACK-MIB::portCpbCosRewrite',
  portCpbTosRewrite => '1.3.6.1.4.1.9.5.1.19.1.1.18',
  portCpbCopsGrouping => '1.3.6.1.4.1.9.5.1.19.1.1.19',
  portCpbDot1x => '1.3.6.1.4.1.9.5.1.19.1.1.20',
  portCpbDot1xDefinition => 'CISCO-STACK-MIB::portCpbDot1x',
  portCpbIgmpFilter => '1.3.6.1.4.1.9.5.1.19.1.1.21',
  portCpbIgmpFilterDefinition => 'CISCO-STACK-MIB::portCpbIgmpFilter',
  portTopNGrp => '1.3.6.1.4.1.9.5.1.20',
  portTopNControlTable => '1.3.6.1.4.1.9.5.1.20.1',
  portTopNControlEntry => '1.3.6.1.4.1.9.5.1.20.1.1',
  portTopNControlIndex => '1.3.6.1.4.1.9.5.1.20.1.1.1',
  portTopNRateBase => '1.3.6.1.4.1.9.5.1.20.1.1.2',
  portTopNRateBaseDefinition => 'CISCO-STACK-MIB::portTopNRateBase',
  portTopNType => '1.3.6.1.4.1.9.5.1.20.1.1.3',
  portTopNTypeDefinition => 'CISCO-STACK-MIB::portTopNType',
  portTopNMode => '1.3.6.1.4.1.9.5.1.20.1.1.4',
  portTopNModeDefinition => 'CISCO-STACK-MIB::portTopNMode',
  portTopNReportStatus => '1.3.6.1.4.1.9.5.1.20.1.1.5',
  portTopNReportStatusDefinition => 'CISCO-STACK-MIB::portTopNReportStatus',
  portTopNDuration => '1.3.6.1.4.1.9.5.1.20.1.1.6',
  portTopNTimeRemaining => '1.3.6.1.4.1.9.5.1.20.1.1.7',
  portTopNStartTime => '1.3.6.1.4.1.9.5.1.20.1.1.8',
  portTopNRequestedSize => '1.3.6.1.4.1.9.5.1.20.1.1.9',
  portTopNGrantedSize => '1.3.6.1.4.1.9.5.1.20.1.1.10',
  portTopNOwner => '1.3.6.1.4.1.9.5.1.20.1.1.11',
  portTopNStatus => '1.3.6.1.4.1.9.5.1.20.1.1.12',
  portTopNTable => '1.3.6.1.4.1.9.5.1.20.2',
  portTopNEntry => '1.3.6.1.4.1.9.5.1.20.2.1',
  portTopNIndex => '1.3.6.1.4.1.9.5.1.20.2.1.1',
  portTopNModuleNumber => '1.3.6.1.4.1.9.5.1.20.2.1.2',
  portTopNPortNumber => '1.3.6.1.4.1.9.5.1.20.2.1.3',
  portTopNUtilization => '1.3.6.1.4.1.9.5.1.20.2.1.4',
  portTopNIOOctets => '1.3.6.1.4.1.9.5.1.20.2.1.5',
  portTopNIOPkts => '1.3.6.1.4.1.9.5.1.20.2.1.6',
  portTopNIOBroadcast => '1.3.6.1.4.1.9.5.1.20.2.1.7',
  portTopNIOMulticast => '1.3.6.1.4.1.9.5.1.20.2.1.8',
  portTopNInErrors => '1.3.6.1.4.1.9.5.1.20.2.1.9',
  portTopNBufferOverFlow => '1.3.6.1.4.1.9.5.1.20.2.1.10',
  mdgGrp => '1.3.6.1.4.1.9.5.1.21',
  mdgGatewayTable => '1.3.6.1.4.1.9.5.1.21.1',
  mdgGatewayEntry => '1.3.6.1.4.1.9.5.1.21.1.1',
  mdgGatewayAddr => '1.3.6.1.4.1.9.5.1.21.1.1.1',
  mdgGatewayType => '1.3.6.1.4.1.9.5.1.21.1.1.2',
  mdgGatewayTypeDefinition => 'CISCO-STACK-MIB::mdgGatewayType',
  radiusGrp => '1.3.6.1.4.1.9.5.1.22',
  radiusLoginAuthentication => '1.3.6.1.4.1.9.5.1.22.1',
  radiusLoginAuthenticationDefinition => 'CISCO-STACK-MIB::radiusLoginAuthentication',
  radiusEnableAuthentication => '1.3.6.1.4.1.9.5.1.22.2',
  radiusEnableAuthenticationDefinition => 'CISCO-STACK-MIB::radiusEnableAuthentication',
  radiusDeadtime => '1.3.6.1.4.1.9.5.1.22.3',
  radiusAuthKey => '1.3.6.1.4.1.9.5.1.22.4',
  radiusTimeout => '1.3.6.1.4.1.9.5.1.22.5',
  radiusRetransmits => '1.3.6.1.4.1.9.5.1.22.6',
  radiusServerTable => '1.3.6.1.4.1.9.5.1.22.7',
  radiusServerEntry => '1.3.6.1.4.1.9.5.1.22.7.1',
  radiusServerAddr => '1.3.6.1.4.1.9.5.1.22.7.1.1',
  radiusServerAuthPort => '1.3.6.1.4.1.9.5.1.22.7.1.2',
  radiusServerType => '1.3.6.1.4.1.9.5.1.22.7.1.3',
  radiusServerTypeDefinition => 'CISCO-STACK-MIB::radiusServerType',
  traceRouteGrp => '1.3.6.1.4.1.9.5.1.24',
  traceRouteMaxQueries => '1.3.6.1.4.1.9.5.1.24.1',
  traceRouteQueryTable => '1.3.6.1.4.1.9.5.1.24.2',
  traceRouteQueryEntry => '1.3.6.1.4.1.9.5.1.24.2.1',
  traceRouteQueryIndex => '1.3.6.1.4.1.9.5.1.24.2.1.1',
  traceRouteHost => '1.3.6.1.4.1.9.5.1.24.2.1.2',
  traceRouteQueryDNSEnable => '1.3.6.1.4.1.9.5.1.24.2.1.3',
  traceRouteQueryDNSEnableDefinition => 'CISCO-STACK-MIB::traceRouteQueryDNSEnable',
  traceRouteQueryWaitingTime => '1.3.6.1.4.1.9.5.1.24.2.1.4',
  traceRouteQueryInitTTL => '1.3.6.1.4.1.9.5.1.24.2.1.5',
  traceRouteQueryMaxTTL => '1.3.6.1.4.1.9.5.1.24.2.1.6',
  traceRouteQueryUDPPort => '1.3.6.1.4.1.9.5.1.24.2.1.7',
  traceRouteQueryPacketCount => '1.3.6.1.4.1.9.5.1.24.2.1.8',
  traceRouteQueryPacketSize => '1.3.6.1.4.1.9.5.1.24.2.1.9',
  traceRouteQueryTOS => '1.3.6.1.4.1.9.5.1.24.2.1.10',
  traceRouteQueryResult => '1.3.6.1.4.1.9.5.1.24.2.1.21',
  traceRouteQueryTime => '1.3.6.1.4.1.9.5.1.24.2.1.22',
  traceRouteQueryOwner => '1.3.6.1.4.1.9.5.1.24.2.1.23',
  traceRouteQueryStatus => '1.3.6.1.4.1.9.5.1.24.2.1.24',
  traceRouteQueryStatusDefinition => 'CISCO-STACK-MIB::traceRouteQueryStatus',
  traceRouteDataTable => '1.3.6.1.4.1.9.5.1.24.3',
  traceRouteDataEntry => '1.3.6.1.4.1.9.5.1.24.3.1',
  traceRouteDataIndex => '1.3.6.1.4.1.9.5.1.24.3.1.1',
  traceRouteDataGatewayName => '1.3.6.1.4.1.9.5.1.24.3.1.2',
  traceRouteDataGatewayIp => '1.3.6.1.4.1.9.5.1.24.3.1.3',
  traceRouteDataRtt => '1.3.6.1.4.1.9.5.1.24.3.1.4',
  traceRouteDataHopCount => '1.3.6.1.4.1.9.5.1.24.3.1.5',
  traceRouteDataErrors => '1.3.6.1.4.1.9.5.1.24.3.1.6',
  traceRouteDataErrorsDefinition => 'CISCO-STACK-MIB::traceRouteDataErrors',
  fileCopyGrp => '1.3.6.1.4.1.9.5.1.25',
  fileCopyProtocol => '1.3.6.1.4.1.9.5.1.25.1',
  fileCopyProtocolDefinition => 'CISCO-STACK-MIB::fileCopyProtocol',
  fileCopyRemoteServer => '1.3.6.1.4.1.9.5.1.25.2',
  fileCopySrcFileName => '1.3.6.1.4.1.9.5.1.25.3',
  fileCopyDstFileName => '1.3.6.1.4.1.9.5.1.25.4',
  fileCopyModuleNumber => '1.3.6.1.4.1.9.5.1.25.5',
  fileCopyUserName => '1.3.6.1.4.1.9.5.1.25.6',
  fileCopyAction => '1.3.6.1.4.1.9.5.1.25.7',
  fileCopyActionDefinition => 'CISCO-STACK-MIB::fileCopyAction',
  fileCopyResult => '1.3.6.1.4.1.9.5.1.25.8',
  fileCopyResultDefinition => 'CISCO-STACK-MIB::fileCopyResult',
  fileCopyResultRcpErrorMessage => '1.3.6.1.4.1.9.5.1.25.9',
  fileCopyRuntimeConfigPart => '1.3.6.1.4.1.9.5.1.25.10',
  fileCopyRuntimeConfigPartDefinition => 'CISCO-STACK-MIB::fileCopyRuntimeConfigPart',
  voiceGrp => '1.3.6.1.4.1.9.5.1.26',
  voicePortIfConfigTable => '1.3.6.1.4.1.9.5.1.26.1',
  voicePortIfConfigEntry => '1.3.6.1.4.1.9.5.1.26.1.1',
  voicePortIfConfigModuleIndex => '1.3.6.1.4.1.9.5.1.26.1.1.1',
  voicePortIfConfigPortIndex => '1.3.6.1.4.1.9.5.1.26.1.1.2',
  voicePortIfDHCPEnabled => '1.3.6.1.4.1.9.5.1.26.1.1.3',
  voicePortIfIpAddress => '1.3.6.1.4.1.9.5.1.26.1.1.4',
  voicePortIfIpNetMask => '1.3.6.1.4.1.9.5.1.26.1.1.5',
  voicePortIfTftpServerAddress => '1.3.6.1.4.1.9.5.1.26.1.1.6',
  voicePortIfGatewayAddress => '1.3.6.1.4.1.9.5.1.26.1.1.7',
  voicePortIfDnsServerAddress => '1.3.6.1.4.1.9.5.1.26.1.1.8',
  voicePortIfDnsDomain => '1.3.6.1.4.1.9.5.1.26.1.1.9',
  voicePortIfOperDnsDomain => '1.3.6.1.4.1.9.5.1.26.1.1.10',
  voicePortCallManagerTable => '1.3.6.1.4.1.9.5.1.26.2',
  voicePortCallManagerEntry => '1.3.6.1.4.1.9.5.1.26.2.1',
  voicePortModuleIndex => '1.3.6.1.4.1.9.5.1.26.2.1.1',
  voicePortIndex => '1.3.6.1.4.1.9.5.1.26.2.1.2',
  voicePortCallManagerIndex => '1.3.6.1.4.1.9.5.1.26.2.1.3',
  voicePortCallManagerIpAddr => '1.3.6.1.4.1.9.5.1.26.2.1.4',
  voicePortOperDnsServerTable => '1.3.6.1.4.1.9.5.1.26.3',
  voicePortOperDnsServerEntry => '1.3.6.1.4.1.9.5.1.26.3.1',
  voicePortDnsModuleIndex => '1.3.6.1.4.1.9.5.1.26.3.1.1',
  voicePortDnsPortIndex => '1.3.6.1.4.1.9.5.1.26.3.1.2',
  voicePortOperDnsServerIndex => '1.3.6.1.4.1.9.5.1.26.3.1.3',
  voicePortOperDnsServerIpAddr => '1.3.6.1.4.1.9.5.1.26.3.1.4',
  voicePortOperDnsServerSource => '1.3.6.1.4.1.9.5.1.26.3.1.5',
  voicePortOperDnsServerSourceDefinition => 'CISCO-STACK-MIB::voicePortOperDnsServerSource',
  portJumboFrameGrp => '1.3.6.1.4.1.9.5.1.27',
  portJumboFrameTable => '1.3.6.1.4.1.9.5.1.27.1',
  portJumboFrameEntry => '1.3.6.1.4.1.9.5.1.27.1.1',
  portJumboFrameModuleIndex => '1.3.6.1.4.1.9.5.1.27.1.1.1',
  portJumboFramePortIndex => '1.3.6.1.4.1.9.5.1.27.1.1.2',
  portJumboFrameEnable => '1.3.6.1.4.1.9.5.1.27.1.1.3',
  portJumboFrameEnableDefinition => 'CISCO-STACK-MIB::portJumboFrameEnable',
  switchAccelerationGrp => '1.3.6.1.4.1.9.5.1.28',
  switchAccelerationModuleTable => '1.3.6.1.4.1.9.5.1.28.1',
  switchAccelerationModuleEntry => '1.3.6.1.4.1.9.5.1.28.1.1',
  switchAccelerationModuleIndex => '1.3.6.1.4.1.9.5.1.28.1.1.1',
  switchAccelerationModuleEnable => '1.3.6.1.4.1.9.5.1.28.1.1.2',
  configGrp => '1.3.6.1.4.1.9.5.1.29',
  configMode => '1.3.6.1.4.1.9.5.1.29.1',
  configModeDefinition => 'CISCO-STACK-MIB::configMode',
  configTextFileLocation => '1.3.6.1.4.1.9.5.1.29.2',
  configWriteMem => '1.3.6.1.4.1.9.5.1.29.3',
  configWriteMemStatus => '1.3.6.1.4.1.9.5.1.29.4',
  configWriteMemStatusDefinition => 'CISCO-STACK-MIB::configWriteMemStatus',
  ciscoStackMIBConformance => '1.3.6.1.4.1.9.5.1.31',
  ciscoStackMIBCompliances => '1.3.6.1.4.1.9.5.1.31.1',
  ciscoStackMIBGroups => '1.3.6.1.4.1.9.5.1.31.2',
  adapterCard => '1.3.6.1.4.1.9.5.2',
  wsc1000sysID => '1.3.6.1.4.1.9.5.3',
  wsc1100sysID => '1.3.6.1.4.1.9.5.4',
  wsc1200sysID => '1.3.6.1.4.1.9.5.5',
  wsc1400sysID => '1.3.6.1.4.1.9.5.6',
  wsc5000sysID => '1.3.6.1.4.1.9.5.7',
  wsc1600sysID => '1.3.6.1.4.1.9.5.8',
  cpw1600sysID => '1.3.6.1.4.1.9.5.9',
  wsc3000sysID => '1.3.6.1.4.1.9.5.10',
  wsc2900sysID => '1.3.6.1.4.1.9.5.12',
  cpw2200sysID => '1.3.6.1.4.1.9.5.13',
  esStack => '1.3.6.1.4.1.9.5.14',
  wsc3200sysID => '1.3.6.1.4.1.9.5.15',
  cpw1900sysID => '1.3.6.1.4.1.9.5.16',
  wsc5500sysID => '1.3.6.1.4.1.9.5.17',
  wsc1900sysID => '1.3.6.1.4.1.9.5.18',
  cpw1220sysID => '1.3.6.1.4.1.9.5.19',
  wsc2820sysID => '1.3.6.1.4.1.9.5.20',
  cpw1420sysID => '1.3.6.1.4.1.9.5.21',
  dcd => '1.3.6.1.4.1.9.5.22',
  wsc3100sysID => '1.3.6.1.4.1.9.5.23',
  cpw1800sysID => '1.3.6.1.4.1.9.5.24',
  cpw1601sysID => '1.3.6.1.4.1.9.5.25',
  wsc3001sysID => '1.3.6.1.4.1.9.5.26',
  cpw1220csysID => '1.3.6.1.4.1.9.5.27',
  wsc1900csysID => '1.3.6.1.4.1.9.5.28',
  wsc5002sysID => '1.3.6.1.4.1.9.5.29',
  cpw1220isysID => '1.3.6.1.4.1.9.5.30',
  wsc1900isysID => '1.3.6.1.4.1.9.5.31',
  tsStack => '1.3.6.1.4.1.9.5.32',
  wsc3900sysID => '1.3.6.1.4.1.9.5.33',
  wsc5505sysID => '1.3.6.1.4.1.9.5.34',
  wsc2926sysID => '1.3.6.1.4.1.9.5.35',
  wsc5509sysID => '1.3.6.1.4.1.9.5.36',
  wsc3920sysID => '1.3.6.1.4.1.9.5.37',
  wsc6006sysID => '1.3.6.1.4.1.9.5.38',
  wsc6009sysID => '1.3.6.1.4.1.9.5.39',
  wsc4003sysID => '1.3.6.1.4.1.9.5.40',
  wsc4912gsysID => '1.3.6.1.4.1.9.5.41',
  wsc2948gsysID => '1.3.6.1.4.1.9.5.42',
  wsc6509sysID => '1.3.6.1.4.1.9.5.44',
  wsc6506sysID => '1.3.6.1.4.1.9.5.45',
  wsc4006sysID => '1.3.6.1.4.1.9.5.46',
  wsc6509nebsysID => '1.3.6.1.4.1.9.5.47',
  wsc6knamsysID => '1.3.6.1.4.1.9.5.48',
  wsc2980gsysID => '1.3.6.1.4.1.9.5.49',
  wsc6513sysID => '1.3.6.1.4.1.9.5.50',
  wsc2980gasysID => '1.3.6.1.4.1.9.5.51',
  cisco7603sysID => '1.3.6.1.4.1.9.5.53',
  cisco7606sysID => '1.3.6.1.4.1.9.5.54',
  cisco7609sysID => '1.3.6.1.4.1.9.5.55',
  wsc6503sysID => '1.3.6.1.4.1.9.5.56',
  wsc4503sysID => '1.3.6.1.4.1.9.5.58',
  wsc4506sysID => '1.3.6.1.4.1.9.5.59',
  cisco7613sysID => '1.3.6.1.4.1.9.5.60',
  wsc6509nebasysID => '1.3.6.1.4.1.9.5.61',
  wsc2948ggetxsysID => '1.3.6.1.4.1.9.5.62',
  cisco7604sysID => '1.3.6.1.4.1.9.5.63',
  wsc6504esysID => '1.3.6.1.4.1.9.5.64',
  wsc1900LiteFxsysID => '1.3.6.1.4.1.9.5.175',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCO-STACK-MIB'} = {
  vlanTrunkMappingType => {
    '1' => 'reservedToNonReserved',
    '2' => 'dot1qToisl',
  },
  sysConsolePrimaryLoginAuthentication => {
    '1' => 'tacacs',
    '2' => 'radius',
    '3' => 'local',
  },
  chassisMinorAlarm => {
    '1' => 'off',
    '2' => 'on',
  },
  tokenRingDripRemotePortStatus => {
    '1' => 'active',
    '2' => 'inactive',
  },
  syslogHostEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  configWriteMemStatus => {
    '1' => 'inProgress',
    '2' => 'succeeded',
    '3' => 'resourceUnavailable',
    '4' => 'badFileName',
    '5' => 'someOtherError',
  },
  brouterEnableAPaRT => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  brouterIpxSnapToEther => {
    '1' => 'snap',
    '2' => 'ethernetII',
    '3' => 'iso8023',
    '4' => 'raw8023',
  },
  ntpBcastClient => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  portErrDisableTimeOutEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  sysInsertMode => {
    '1' => 'other',
    '2' => 'standard',
    '3' => 'scheduled',
    '4' => 'graceful',
  },
  monitorDirection => {
    '1' => 'transmit',
    '2' => 'receive',
    '3' => 'transmitAndReceive',
  },
  sysMgmtType => {
    '1' => 'other',
    '2' => 'snmpV1',
    '3' => 'smux',
    '4' => 'snmpV2V1',
    '5' => 'snmpV2cV1',
    '6' => 'snmpV3V2cV1',
  },
  portSecurityViolationPolicy => {
    '1' => 'restrict',
    '2' => 'shutdown',
  },
  traceRouteQueryStatus => {
    '1' => 'valid',
    '2' => 'invalid',
  },
  syslogTimeStampOption => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  sysTelnetPrimaryEnableAuthentication => {
    '1' => 'tacacs',
    '2' => 'radius',
    '3' => 'local',
  },
  moduleStandbyStatus => {
    '1' => 'other',
    '2' => 'active',
    '3' => 'standby',
    '4' => 'error',
  },
  chassisComponentType => {
    '1' => 'unknown',
    '2' => 'wsc6000cl',
    '3' => 'wsc6000vtt',
    '4' => 'wsc6000tempSensor',
    '5' => 'wsc6513Clock',
    '6' => 'clk7600',
    '7' => 'ws9SlotFan',
    '8' => 'fanMod9',
    '10' => 'wsc6506eFan',
    '11' => 'wsc6509eFan',
    '13' => 'wsc6503eFan',
    '14' => 'wsc6000vtte',
    '15' => 'fanMod4Hs',
    '16' => 'fan6524',
    '17' => 'fanMod6Shs',
    '18' => 'fanMod9Shs',
    '19' => 'fanMod9St',
    '20' => 'wsc6509veFan',
    '21' => 'fanMod3Hs',
    '25' => 'c6880xFan',
    '26' => 'c6807xlFan',
    '27' => 'c6800xl33vcon',
  },
  portDuplex => {
    '1' => 'half',
    '2' => 'full',
    '3' => 'disagree',
    '4' => 'auto',
  },
  dnsServerType => {
    '1' => 'invalid',
    '2' => 'primary',
    '3' => 'other',
  },
  radiusEnableAuthentication => {
    '1' => 'enabled',
    '2' => 'disabled',
    '3' => 'enabledForTelnetOnly',
    '4' => 'enabledForConsoleOnly',
  },
  sysEnableModuleTraps => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  sysTrapReceiverType => {
    '1' => 'valid',
    '2' => 'invalid',
  },
  sysPortFastBpduGuard => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  ntpAuthenticationType => {
    '1' => 'valid',
    '2' => 'invalid',
  },
  sysEnableRepeaterTraps => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  portSecurityAdminStatus => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  filterPortSuppressionViolation => {
    '1' => 'dropPackets',
    '2' => 'errdisable',
  },
  syslogConsoleEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  portSecurityOperStatus => {
    '1' => 'notShutdown',
    '2' => 'shutdown',
  },
  portAdminRxFlowControl => {
    '1' => 'on',
    '2' => 'off',
    '3' => 'desired',
  },
  moduleType => {
    '1' => 'other',
    '2' => 'empty',
    '3' => 'wsc1000',
    '4' => 'wsc1001',
    '5' => 'wsc1100',
    '11' => 'wsc1200',
    '12' => 'wsc1400',
    '13' => 'wsx1441',
    '14' => 'wsx1444',
    '15' => 'wsx1450',
    '16' => 'wsx1483',
    '17' => 'wsx1454',
    '18' => 'wsx1455',
    '19' => 'wsx1431',
    '20' => 'wsx1465',
    '21' => 'wsx1436',
    '22' => 'wsx1434',
    '23' => 'wsx5009',
    '24' => 'wsx5013',
    '25' => 'wsx5011',
    '26' => 'wsx5010',
    '27' => 'wsx5113',
    '28' => 'wsx5101',
    '29' => 'wsx5103',
    '30' => 'wsx5104',
    '32' => 'wsx5155',
    '33' => 'wsx5154',
    '34' => 'wsx5153',
    '35' => 'wsx5111',
    '36' => 'wsx5213',
    '37' => 'wsx5020',
    '38' => 'wsx5006',
    '39' => 'wsx5005',
    '40' => 'wsx5509',
    '41' => 'wsx5506',
    '42' => 'wsx5505',
    '43' => 'wsx5156',
    '44' => 'wsx5157',
    '45' => 'wsx5158',
    '46' => 'wsx5030',
    '47' => 'wsx5114',
    '48' => 'wsx5223',
    '49' => 'wsx5224',
    '50' => 'wsx5012',
    '52' => 'wsx5302',
    '53' => 'wsx5213a',
    '54' => 'wsx5380',
    '55' => 'wsx5201',
    '56' => 'wsx5203',
    '57' => 'wsx5530',
    '61' => 'wsx5161',
    '62' => 'wsx5162',
    '65' => 'wsx5165',
    '66' => 'wsx5166',
    '67' => 'wsx5031',
    '68' => 'wsx5410',
    '69' => 'wsx5403',
    '73' => 'wsx5201r',
    '74' => 'wsx5225r',
    '75' => 'wsx5014',
    '76' => 'wsx5015',
    '77' => 'wsx5236',
    '78' => 'wsx5540',
    '79' => 'wsx5234',
    '81' => 'wsx5012a',
    '82' => 'wsx5167',
    '83' => 'wsx5239',
    '84' => 'wsx5168',
    '85' => 'wsx5305',
    '87' => 'wsx5550',
    '88' => 'wsf5541',
    '91' => 'wsx5534',
    '92' => 'wsx5536',
    '96' => 'wsx5237',
    '200' => 'wsx6ksup12ge',
    '201' => 'wsx6408gbic',
    '202' => 'wsx6224mmmt',
    '203' => 'wsx6248rj45',
    '204' => 'wsx6248tel',
    '206' => 'wsx6302msm',
    '207' => 'wsf6kmsfc',
    '208' => 'wsx6024flmt',
    '209' => 'wsx6101oc12mmf',
    '210' => 'wsx6101oc12smf',
    '211' => 'wsx6416gemt',
    '212' => 'wsx61822pa',
    '213' => 'osm2oc12AtmMM',
    '214' => 'osm2oc12AtmSI',
    '216' => 'osm4oc12PosMM',
    '217' => 'osm4oc12PosSI',
    '218' => 'osm4oc12PosSL',
    '219' => 'wsx6ksup1a2ge',
    '220' => 'wsx6302amsm',
    '221' => 'wsx6416gbic',
    '222' => 'wsx6224ammmt',
    '223' => 'wsx6380nam',
    '224' => 'wsx6248arj45',
    '225' => 'wsx6248atel',
    '226' => 'wsx6408agbic',
    '229' => 'wsx6608t1',
    '230' => 'wsx6608e1',
    '231' => 'wsx6624fxs',
    '233' => 'wsx6316getx',
    '234' => 'wsf6kmsfc2',
    '235' => 'wsx6324mmmt',
    '236' => 'wsx6348rj45',
    '237' => 'wsx6ksup22ge',
    '238' => 'wsx6324sm',
    '239' => 'wsx6516gbic',
    '240' => 'osm4geWanGbic',
    '241' => 'osm1oc48PosSS',
    '242' => 'osm1oc48PosSI',
    '243' => 'osm1oc48PosSL',
    '244' => 'wsx6381ids',
    '245' => 'wsc6500sfm',
    '246' => 'osm16oc3PosMM',
    '247' => 'osm16oc3PosSI',
    '248' => 'osm16oc3PosSL',
    '249' => 'osm2oc12PosMM',
    '250' => 'osm2oc12PosSI',
    '251' => 'osm2oc12PosSL',
    '252' => 'wsx650210ge',
    '253' => 'osm8oc3PosMM',
    '254' => 'osm8oc3PosSI',
    '255' => 'osm8oc3PosSL',
    '258' => 'wsx6548rj45',
    '259' => 'wsx6524mmmt',
    '260' => 'wsx6066SlbApc',
    '261' => 'wsx6516getx',
    '265' => 'osm2oc48OneDptSS',
    '266' => 'osm2oc48OneDptSI',
    '267' => 'osm2oc48OneDptSL',
    '268' => 'osm2oc48OneDptSSDual',
    '269' => 'osm2oc48OneDptSIDual',
    '270' => 'osm2oc48OneDptSLDual',
    '271' => 'wsx6816gbic',
    '272' => 'osm4choc12T3MM',
    '273' => 'osm4choc12T3SI',
    '274' => 'osm8choc12T3MM',
    '275' => 'osm8choc12T3SI',
    '276' => 'osm1choc48T3SS',
    '277' => 'osm2choc48T3SS',
    '278' => 'wsx6500sfm2',
    '279' => 'osm1choc48T3SI',
    '280' => 'osm2choc48T3SI',
    '281' => 'wsx6348rj21',
    '282' => 'wsx6548rj21',
    '284' => 'wsSvcCmm',
    '285' => 'wsx650110gex4',
    '286' => 'osm4oc3PosSI',
    '289' => 'osm4oc3PosMM',
    '290' => 'wsSvcIdsm2',
    '291' => 'wsSvcNam2',
    '292' => 'wsSvcFwm1',
    '293' => 'wsSvcCe1',
    '294' => 'wsSvcSsl1',
    '295' => 'osm8choc3DS0SI',
    '296' => 'osm4choc3DS0SI',
    '297' => 'osm1choc12T1SI',
    '300' => 'wsx4012',
    '301' => 'wsx4148rj',
    '302' => 'wsx4232gbrj',
    '303' => 'wsx4306gb',
    '304' => 'wsx4418gb',
    '305' => 'wsx44162gbtx',
    '306' => 'wsx4912gb',
    '307' => 'wsx2948gbrj',
    '309' => 'wsx2948',
    '310' => 'wsx4912',
    '311' => 'wsx4424sxmt',
    '312' => 'wsx4232rjxx',
    '313' => 'wsx4148rj21',
    '317' => 'wsx4124fxmt',
    '318' => 'wsx4013',
    '319' => 'wsx4232l3',
    '320' => 'wsx4604gwy',
    '321' => 'wsx44122Gbtx',
    '322' => 'wsx2980',
    '323' => 'wsx2980rj',
    '324' => 'wsx2980gbrj',
    '325' => 'wsx4019',
    '326' => 'wsx4148rj45v',
    '330' => 'wsx4424gbrj45',
    '331' => 'wsx4148fxmt',
    '332' => 'wsx4448gblx',
    '334' => 'wsx4448gbrj45',
    '337' => 'wsx4148lxmt',
    '339' => 'wsx4548gbrj45',
    '340' => 'wsx4548gbrj45v',
    '341' => 'wsx4248rj21v',
    '342' => 'wsx4302gb',
    '343' => 'wsx4248rj45v',
    '345' => 'wsx2948ggetx',
    '346' => 'wsx2948ggetxgbrj',
    '502' => 'wsx6516aGbic',
    '503' => 'wsx6148getx',
    '506' => 'wsx6148x2rj45',
    '507' => 'wsx6196rj21',
    '509' => 'wssup32ge3b',
    '510' => 'wssup3210ge3b',
    '511' => 'mec6524gs8s',
    '512' => 'mec6524gt8s',
    '515' => 'wssup32pge',
    '516' => 'wssup32p10ge',
    '597' => 'wssvcpisa32',
    '598' => 'me6524msfc2a',
    '599' => 'wsf6kmsfc2a',
    '600' => 'osm12ct3T1',
    '601' => 'osm12t3e3',
    '602' => 'osm24t3e3',
    '603' => 'osm4GeWanGbicPlus',
    '604' => 'osm1choc12T3SI',
    '605' => 'osm2choc12T3SI',
    '606' => 'osm2oc12AtmMMPlus',
    '607' => 'osm2oc12AtmSIPlus',
    '608' => 'osm2oc12PosMMPlus',
    '609' => 'osm2oc12PosSIPlus',
    '610' => 'osm16oc3PosSIPlus',
    '611' => 'osm1oc48PosSSPlus',
    '612' => 'osm1oc48PosSIPlus',
    '613' => 'osm1oc48PosSLPlus',
    '614' => 'osm4oc3PosSIPlus',
    '615' => 'osm8oc3PosSLPlus',
    '616' => 'osm8oc3PosSIPlus',
    '617' => 'osm4oc12PosSIPlus',
    '618' => 'c7600Es4Tg3cxl',
    '620' => 'c7600Es2Tg3cxl',
    '625' => 'c76EsXt4Tg3cxl',
    '626' => 'c76EsXt2Tg3cxl',
    '627' => 'c7600Es4Tg3c',
    '629' => 'c7600Es2Tg3c',
    '633' => 'c76EsXt4Tg3c',
    '634' => 'c76EsXt2Tg3c',
    '903' => 'wsSvcIpSec1',
    '910' => 'wsSvcMwam1',
    '911' => 'wsSvcCsg1',
    '912' => 'wsx6148rj45v',
    '913' => 'wsx6148rj21v',
    '914' => 'wsSvcNam1',
    '915' => 'wsx6548getx',
    '919' => 'wsSvcPsd1',
    '920' => 'wsx6066SlbSk9',
    '921' => 'wsx6148agetx',
    '923' => 'wsx6148arj45',
    '924' => 'wsSvcWlan1k9',
    '925' => 'wsSvcAon1k9',
    '926' => 'ace106500k9',
    '927' => 'wsSvcWebVpnk9',
    '928' => 'wsx6148FeSfp',
    '929' => 'wsSvcAdm1k9',
    '930' => 'wsSvcAgm1k9',
    '936' => 'ace046500k9',
    '940' => 'wsSvcSamiBb',
    '946' => 'wsSvcWism2k9',
    '947' => 'wsSvcAsaSm1',
    '949' => 'wsSvcNam3k9',
    '950' => 'wsSvcAsaSm1k7',
    '951' => 'wsSvcVse1k9',
    '1001' => 'wssup720',
    '1002' => 'wssup720base',
    '1004' => 'm7600Sip600',
    '1007' => 'wsx6748getx',
    '1008' => 'wsx670410ge',
    '1009' => 'wsx6748sfp',
    '1010' => 'wsx6724sfp',
    '1016' => 'wsx670810ge',
    '1021' => 'vss72010g',
    '1023' => 'wsx6708a10ge',
    '1027' => 'wsx671610ge',
    '1031' => 'vssup2t10g',
    '1032' => 'wsx6148ege45at',
    '1033' => 'wsx671610t',
    '1034' => 'wsx690810g',
    '1035' => 'wsx690440g',
    '1036' => 'wsx6148egetx',
    '1037' => 'wsx6848tx',
    '1039' => 'wsx6848sfp',
    '1040' => 'wsx6824sfp',
    '1042' => 'wsx681610ge',
    '1043' => 'wsx681610t',
    '1101' => 'wsx65822pa',
    '1102' => 'm7600Sip200',
    '1103' => 'm7600Sip400',
    '1104' => 'c7600ssc400',
    '1105' => 'c7600ssc600',
    '1106' => 'esm2x10ge',
    '1301' => 'c6800ia48td',
    '1304' => 'c6800ia48fpd',
    '1400' => 'c6880x16p10g',
    '1401' => 'c6880x',
    '1402' => 'c6880xle16p10g',
    '1403' => 'c6880xle',
    '1800' => 'rsp720',
    '1801' => 'rsp720base',
    '1805' => 'c7600msfc4',
  },
  sysEnableChassisTraps => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  tokenRingDripLocalPortStatus => {
    '1' => 'active',
    '2' => 'inactive',
  },
  tokenRingPortSoftErrEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  vlanPortSwitchLevel => {
    '1' => 'normal',
    '2' => 'high',
    '3' => 'notApplicable',
  },
  chassisPs2Type => {
    '1' => 'other',
    '2' => 'none',
    '3' => 'w50',
    '4' => 'w200',
    '5' => 'w600',
    '6' => 'w80',
    '7' => 'w130',
    '8' => 'wsc5008',
    '9' => 'wsc5008a',
    '10' => 'w175',
    '11' => 'wsc5068',
    '12' => 'wsc5508',
    '13' => 'wsc5568',
    '14' => 'wsc5508a',
    '15' => 'w155',
    '16' => 'w175pfc',
    '17' => 'w175dc',
    '18' => 'wsc5008b',
    '19' => 'wsc5008c',
    '20' => 'wsc5068b',
    '21' => 'wscac1000',
    '22' => 'wscac1300',
    '23' => 'wscdc1000',
    '24' => 'wscdc1360',
    '25' => 'wsx4008',
    '26' => 'wsc5518',
    '27' => 'wsc5598',
    '28' => 'w120',
    '29' => 'externalPS',
    '30' => 'wscac2500w',
    '31' => 'wscdc2500w',
    '32' => 'wsx4008dc',
    '33' => 'wscac4000w',
    '34' => 'pwr4000dc',
    '35' => 'pwr950ac',
    '36' => 'pwr950dc',
    '37' => 'pwr1900ac',
    '38' => 'pwr1900dc',
    '39' => 'pwr1900ac6',
    '42' => 'wsx4008ac650w',
    '43' => 'wsx4008dc650w',
    '44' => 'wscac3000w',
    '46' => 'pwrc451000ac',
    '47' => 'pwrc452800acv',
    '48' => 'pwrc451300acv',
    '49' => 'pwrc451400dcp',
    '50' => 'wscdc3000w',
    '51' => 'pwr1400ac',
    '52' => 'w156',
    '53' => 'wscac6000w',
    '54' => 'pwr2700ac',
    '55' => 'pwr2700dc',
    '58' => 'wscac8700we',
    '59' => 'pwr2700ac4',
    '60' => 'pwr2700dc4',
    '63' => 'pwr400dc',
    '64' => 'pwr400ac',
    '105' => 'pwr6000dc',
    '106' => 'pwr1500dc',
    '150' => 'c6880x3kwac',
    '151' => 'c6880x3kwdc',
    '152' => 'c6800xl3kwac',
  },
  sysExtendedRmonVlanModeEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  tokenRingPortMode => {
    '1' => 'auto',
    '2' => 'fdxCport',
    '3' => 'fdxStation',
    '4' => 'hdxCport',
    '5' => 'hdxStation',
    '7' => 'riro',
  },
  chassisPs3Type => {
    '1' => 'other',
    '2' => 'none',
    '25' => 'wsx4008',
    '32' => 'wsx4008dc',
    '42' => 'wsx4008ac650w',
    '43' => 'wsx4008dc650w',
  },
  chassisFanStatus => {
    '1' => 'other',
    '2' => 'ok',
    '3' => 'minorFault',
    '4' => 'majorFault',
  },
  vmpsType => {
    '1' => 'invalid',
    '2' => 'primary',
    '3' => 'other',
  },
  tacacsEnableAuthentication => {
    '1' => 'enabled',
    '2' => 'disabled',
    '3' => 'enabledForTelnetOnly',
    '4' => 'enabledForConsoleOnly',
  },
  sysTelnetPrimaryLoginAuthentication => {
    '1' => 'tacacs',
    '2' => 'radius',
    '3' => 'local',
  },
  ipPermitEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
    '3' => 'enabledForTelnetOnly',
    '4' => 'enabledForSnmpOnly',
  },
  traceRouteQueryDNSEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  fileCopyResult => {
    '1' => 'inProgress',
    '2' => 'success',
    '3' => 'noResponse',
    '4' => 'tooManyRetries',
    '5' => 'noBuffers',
    '6' => 'noProcesses',
    '7' => 'badChecksum',
    '8' => 'badLength',
    '9' => 'badFlash',
    '10' => 'serverError',
    '11' => 'userCanceled',
    '12' => 'wrongCode',
    '13' => 'fileNotFound',
    '14' => 'invalidHost',
    '15' => 'invalidModule',
    '16' => 'accessViolation',
    '17' => 'unknownStatus',
    '18' => 'invalidStorageDevice',
    '19' => 'insufficientSpaceOnStorageDevice',
    '20' => 'insufficientDramSize',
    '21' => 'incompatibleImage',
    '22' => 'rcpError',
  },
  brouterEnableIpFragmentation => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  sysBaudRate => {
    '600' => 'b600',
    '1200' => 'b1200',
    '2400' => 'b2400',
    '4800' => 'b4800',
    '9600' => 'b9600',
    '19200' => 'b19200',
    '38400' => 'b38400',
  },
  portSecurityExtControlStatus => {
    '1' => 'valid',
    '2' => 'invalid',
  },
  fileCopyProtocol => {
    '1' => 'tftp',
    '2' => 'rcp',
  },
  sysEnableEntityTrap => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  tokenRingPortSoftErrResetCounters => {
    '1' => 'noop',
    '2' => 'reset',
  },
  tftpResult => {
    '1' => 'inProgress',
    '2' => 'success',
    '3' => 'noResponse',
    '4' => 'tooManyRetries',
    '5' => 'noBuffers',
    '6' => 'noProcesses',
    '7' => 'badChecksum',
    '8' => 'badLength',
    '9' => 'badFlash',
    '10' => 'serverError',
    '11' => 'userCanceled',
    '12' => 'wrongCode',
    '13' => 'fileNotFound',
    '14' => 'invalidTftpHost',
    '15' => 'invalidTftpModule',
    '16' => 'accessViolation',
    '17' => 'unknownStatus',
    '18' => 'invalidStorageDevice',
    '19' => 'insufficientSpaceOnStorageDevice',
    '20' => 'insufficientDramSize',
    '21' => 'incompatibleImage',
  },
  tacacsServerType => {
    '1' => 'invalid',
    '2' => 'primary',
    '3' => 'other',
  },
  sysEnableVmpsTraps => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  filterMacType => {
    '1' => 'deny',
    '2' => 'invalid',
    '3' => 'permit',
    '4' => 'permitSrc',
    '5' => 'permitDst',
    '6' => 'denySrc',
    '7' => 'denyDst',
    '8' => 'denySrcLearn',
  },
  moduleSubType => {
    '1' => 'other',
    '2' => 'empty',
    '3' => 'wsf5510',
    '4' => 'wsf5511',
    '6' => 'wsx5304',
    '7' => 'wsf5520',
    '8' => 'wsf5521',
    '9' => 'wsf5531',
    '100' => 'wsf6020',
    '101' => 'wsf6020a',
    '102' => 'wsf6kpfc',
    '103' => 'wsf6kpfc2',
    '104' => 'wsf6kvpwr',
    '105' => 'wsf6kdfc',
    '106' => 'wsf6kpfc2a',
    '107' => 'wsf6kdfca',
    '200' => 'vsp300dfc',
    '201' => 'wsf6kpfc3a',
    '202' => 'wsf6kdfc3a',
    '203' => 'wsf6700dfc3a',
    '205' => 'wsf6kdfc3bxl',
    '206' => 'wsf6kpfc3bxl',
    '207' => 'wsf6700dfc3bxl',
    '208' => 'wsf6700cfc',
    '213' => 'm7600pfc3c',
    '216' => 'wsf6kpfc3b',
    '217' => 'wsf6700dfc3b',
    '218' => 'wsf6700dfc3c',
    '221' => 'wsf6700dfc3cxl',
    '223' => 'wsf6kdfc3b',
    '224' => 'mec6524pfc3c',
    '225' => 'sip600earl',
    '226' => 'vsf6kpfc3cxl',
    '227' => 'vsf6kpfc3c',
    '228' => 'c7600esmdfc3cxl',
    '229' => 'vsf6kpfc4',
    '230' => 'c7600esmdfc3c',
    '231' => 'wsf6kdfc4exl',
    '232' => 'c7600Es3cxl',
    '233' => 'c7600Es3c',
    '234' => 'wsf6kdfc4e',
    '235' => 'vsf6kpfc4xl',
    '236' => 'wsf6kdfc4axl',
    '237' => 'wsf6kdfc4a',
    '238' => 'c6880xpfc',
    '239' => 'c6880xlepfc',
    '240' => 'c6880xdfc',
    '241' => 'c6880xledfc',
  },
  chassisPs2Status => {
    '1' => 'other',
    '2' => 'ok',
    '3' => 'minorFault',
    '4' => 'majorFault',
  },
  configMode => {
    '1' => 'binary',
    '2' => 'text',
  },
  portTopNRateBase => {
    '1' => 'portTopNUtilization',
    '2' => 'portTopNIOOctets',
    '3' => 'portTopNIOPkts',
    '4' => 'portTopNIOBroadcastPkts',
    '5' => 'portTopNIOMulticastPkts',
    '6' => 'portTopNInErrors',
    '7' => 'portTopNBufferOverflow',
  },
  ipPermitDeniedAccess => {
    '1' => 'telnet',
    '2' => 'snmp',
    '3' => 'ssh',
    '4' => 'http',
  },
  brouterEnableTransitEncapsulation => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  sysHighAvailabilityOperStatus => {
    '1' => 'running',
    '2' => 'notRunning',
  },
  brouterEnableUnreachables => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  mcastEnableCgmp => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  fileCopyAction => {
    '1' => 'other',
    '2' => 'copyConfigFromHostToRuntime',
    '3' => 'copyConfigFromRuntimeToHost',
    '4' => 'copyImageFromHostToFlash',
    '5' => 'copyImageFromFlashToHost',
    '8' => 'copyConfigFromFlashToRuntime',
    '9' => 'copyConfigFromRuntimeToFlash',
    '10' => 'copyConfigFileFromHostToFlash',
    '11' => 'copyConfigFileFromFlashToHost',
    '12' => 'copyTechReportFromRuntimeToHost',
  },
  syslogMessageFacility => {
    '1' => 'cdp',
    '2' => 'mcast',
    '3' => 'dtp',
    '4' => 'dvlan',
    '5' => 'earl',
    '6' => 'fddi',
    '7' => 'ip',
    '8' => 'pruning',
    '9' => 'snmp',
    '10' => 'spantree',
    '11' => 'system',
    '12' => 'tac',
    '13' => 'tcp',
    '14' => 'telnet',
    '15' => 'tftp',
    '16' => 'vtp',
    '17' => 'vmps',
    '18' => 'kernel',
    '19' => 'filesys',
    '20' => 'drip',
    '21' => 'pagp',
    '22' => 'mgmt',
    '23' => 'mls',
    '24' => 'protfilt',
    '25' => 'security',
    '26' => 'radius',
    '27' => 'udld',
    '28' => 'gvrp',
    '29' => 'cops',
    '30' => 'qos',
    '31' => 'acl',
    '32' => 'rsvp',
    '33' => 'ld',
    '34' => 'privatevlan',
    '35' => 'ethc',
    '36' => 'gl2pt',
    '37' => 'callhome',
    '38' => 'dhcpsnooping',
    '40' => 'diags',
    '42' => 'eou',
    '43' => 'backup',
    '44' => 'eoam',
    '45' => 'webauth',
    '46' => 'dom',
    '47' => 'mvrp',
  },
  filterTestType => {
    '1' => 'valid',
    '2' => 'invalid',
  },
  portOperStatus => {
    '1' => 'other',
    '2' => 'ok',
    '3' => 'minorFault',
    '4' => 'majorFault',
  },
  vlanPortOperStatus => {
    '1' => 'inactive',
    '2' => 'active',
    '3' => 'shutdown',
    '4' => 'vlanActiveFault',
  },
  brouterEnableGiantCheck => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  tokenRingDripDistributedCrf => {
    '1' => 'true',
    '2' => 'false',
  },
  brouterIpx8022ToEther => {
    '1' => 'snap',
    '2' => 'ethernetII',
    '3' => 'iso8023',
    '4' => 'raw8023',
  },
  brouterEnableFddiCheck => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  brouterIpx8023RawToFddi => {
    '1' => 'snap',
    '5' => 'iso8022',
    '6' => 'fddiRaw',
  },
  ntpAuthenticationEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  syslogTelnetEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  tokenRingDripDistCrfMode => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  chassisSysType => {
    '1' => 'other',
    '3' => 'wsc1000',
    '4' => 'wsc1001',
    '5' => 'wsc1100',
    '6' => 'wsc5000',
    '7' => 'wsc2900',
    '8' => 'wsc5500',
    '9' => 'wsc5002',
    '10' => 'wsc5505',
    '11' => 'wsc1200',
    '12' => 'wsc1400',
    '13' => 'wsc2926',
    '14' => 'wsc5509',
    '15' => 'wsc6006',
    '16' => 'wsc6009',
    '17' => 'wsc4003',
    '18' => 'wsc5500e',
    '19' => 'wsc4912g',
    '20' => 'wsc2948g',
    '22' => 'wsc6509',
    '23' => 'wsc6506',
    '24' => 'wsc4006',
    '25' => 'wsc6509NEB',
    '26' => 'wsc2980g',
    '27' => 'wsc6513',
    '28' => 'wsc2980ga',
    '30' => 'cisco7603',
    '31' => 'cisco7606',
    '32' => 'cisco7609',
    '33' => 'wsc6503',
    '34' => 'wsc6509NEBA',
    '35' => 'wsc4507',
    '36' => 'wsc4503',
    '37' => 'wsc4506',
    '38' => 'wsc65509',
    '40' => 'cisco7613',
    '41' => 'wsc2948ggetx',
    '42' => 'cisco7604',
    '43' => 'wsc6504e',
    '45' => 'mec6524gs8s',
    '48' => 'mec6524gt8s',
    '51' => 'wsc6509ve',
    '52' => 'cisco7603s',
    '54' => 'c6880xle',
    '55' => 'c6807xl',
    '56' => 'c6880x',
  },
  portAdminSpeed => {
    '1' => 'autoDetect',
    '2' => 'autoDetect10100',
    '10' => 's10G',
    '64000' => 's64000',
    '1544000' => 's1544000',
    '2000000' => 's2000000',
    '2048000' => 's2048000',
    '4000000' => 's4000000',
    '10000000' => 's10000000',
    '16000000' => 's16000000',
    '45000000' => 's45000000',
    '64000000' => 's64000000',
    '100000000' => 's100000000',
    '155000000' => 's155000000',
    '400000000' => 's400000000',
    '622000000' => 's622000000',
    '1000000000' => 's1000000000',
  },
  mdgGatewayType => {
    '1' => 'invalid',
    '2' => 'primary',
    '3' => 'other',
  },
  tokenRingPortEarlyTokenRel => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  sysExtendedRmonVlanAgentEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  vlanPortIslAdminStatus => {
    '1' => 'on',
    '2' => 'off',
    '3' => 'desirable',
    '4' => 'auto',
    '5' => 'onNoNegotiate',
  },
  chassisPs3Status => {
    '1' => 'other',
    '2' => 'ok',
    '3' => 'minorFault',
    '4' => 'majorFault',
  },
  sysEnableBridgeTraps => {
    '1' => 'enabled',
    '2' => 'disabled',
    '3' => 'enabledForNewRootOnly',
    '4' => 'enabledForTopoChangeOnly',
  },
  vlanPortIslOperStatus => {
    '1' => 'trunking',
    '2' => 'notTrunking',
  },
  portJumboFrameEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  filterVendorType => {
    '1' => 'deny',
    '2' => 'invalid',
    '3' => 'permit',
  },
  mcastEnableIgmp => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  vlanSpantreeEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
    '3' => 'notApplicable',
  },
  mcastRouterAdminStatus => {
    '1' => 'routerPresent',
    '3' => 'dynamic',
  },
  vmpsAction => {
    '1' => 'other',
    '2' => 'inProgress',
    '3' => 'success',
    '4' => 'noResponse',
    '5' => 'noPrimaryVmps',
    '6' => 'noDynamicPort',
    '7' => 'noHostConnected',
    '8' => 'reconfirm',
  },
  tokenRingDripAreReductionMode => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  sysEnableRmon => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  portTopNMode => {
    '1' => 'portTopNForeground',
    '2' => 'portTopNBackground',
  },
  monitorEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  syslogMessageSeverity => {
    '1' => 'emergencies',
    '2' => 'alerts',
    '3' => 'critical',
    '4' => 'errors',
    '5' => 'warnings',
    '6' => 'notification',
    '7' => 'informational',
    '8' => 'debugging',
  },
  tokenRingDripRemotePortConfigured => {
    '1' => 'true',
    '2' => 'false',
  },
  portLinkFaultStatus => {
    '1' => 'noFault',
    '2' => 'nearEndFault',
    '3' => 'nearEndConfigFail',
    '4' => 'farEndDisable',
    '5' => 'farEndFault',
    '6' => 'farEndConfigFail',
    '7' => 'notApplicable',
  },
  portCpbIgmpFilter => {
    '1' => 'yes',
    '2' => 'no',
  },
  mcastRouterOperStatus => {
    '1' => 'routerPresent',
    '2' => 'noRouter',
  },
  sysConsolePrimaryEnableAuthentication => {
    '1' => 'tacacs',
    '2' => 'radius',
    '3' => 'local',
  },
  ntpAuthenticationTrustedMode => {
    '1' => 'trusted',
    '2' => 'untrusted',
  },
  sysStatus => {
    '1' => 'other',
    '2' => 'ok',
    '3' => 'minorFault',
    '4' => 'majorFault',
  },
  sysStartupConfigSource => {
    '1' => 'flashFileRecurring',
    '2' => 'flashFileNonRecurring',
  },
  moduleSubType2 => {
    '1' => 'other',
    '2' => 'empty',
    '3' => 'wsu5531',
    '5' => 'wsu5533',
    '6' => 'wsu5534',
    '7' => 'wsu5535',
    '8' => 'wsu5536',
    '9' => 'wsu5537',
    '10' => 'wsu5538',
    '11' => 'wsu5539',
    '102' => 'wsg6488',
    '103' => 'wsg6489',
    '104' => 'wsg6483',
    '105' => 'wsg6485',
    '106' => 'wsf6kFe48af',
    '107' => 'wsf6kGe48af',
    '108' => 'wsf6kVpwrGe',
    '109' => 'wsf6kFe48x2af',
    '207' => 'wsf6kmsfc',
    '234' => 'wsf6kmsfc2',
    '314' => 'wsu4504fxmt',
    '315' => 'wsu4502gb',
    '402' => 'wssvcidsupg',
    '403' => 'wssvccmm6e1',
    '404' => 'wssvccmm6t1',
    '405' => 'wssvccmm24fxs',
    '406' => 'wssvccmmact',
    '410' => 'aceModExpnDc',
    '411' => 'wsSvcAppProc1',
    '597' => 'wssvcpisa32',
    '598' => 'me6524msfc2a',
    '599' => 'wsf6kmsfc2a',
    '618' => 'c7600Es4Tg',
    '620' => 'c7600Es2Tg',
    '625' => 'c7600EsItu4TgLk',
    '626' => 'c7600EsItu2TgLk',
    '1001' => 'wssup720',
    '1005' => 'vsf6kmsfc5',
    '1026' => 'vsf6kmsfc3',
    '1701' => 'esm2x10ge',
    '1805' => 'c7600msfc4',
  },
  voicePortOperDnsServerSource => {
    '1' => 'fromDhcp',
    '2' => 'fromPortConfig',
    '3' => 'fromSystemConfig',
  },
  tacacsDirectedRequest => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  sysStandbyPortEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  portChannelOperStatus => {
    '1' => 'channelling',
    '2' => 'notChannelling',
  },
  moduleAction => {
    '1' => 'other',
    '2' => 'reset',
    '3' => 'enable',
    '4' => 'disable',
  },
  tftpAction => {
    '1' => 'other',
    '2' => 'downloadConfig',
    '3' => 'uploadConfig',
    '4' => 'downloadSw',
    '5' => 'uploadSw',
    '6' => 'downloadFw',
    '7' => 'uploadFw',
  },
  tacacsLoginAuthentication => {
    '1' => 'enabled',
    '2' => 'disabled',
    '3' => 'enabledForTelnetOnly',
    '4' => 'enabledForConsoleOnly',
  },
  sysTrafficMeterType => {
    '1' => 'systemSwitchingBus',
    '2' => 'switchingBusA',
    '3' => 'switchingBusB',
    '4' => 'switchingBusC',
  },
  dnsEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  sysEnableStpxTrap => {
    '1' => 'enabled',
    '2' => 'disabled',
    '3' => 'enabledForInconOnly',
    '4' => 'enabledForRootOnly',
    '5' => 'enabledForLoopOnly',
    '6' => 'enabledForInconRootOnly',
    '7' => 'enabledForInconLoopOnly',
    '8' => 'enabledForRootLoopOnly',
  },
  brouterEnableSpantree => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  portCpbDot1x => {
    '1' => 'yes',
    '2' => 'no',
  },
  tokenRingDripBackupCrf => {
    '1' => 'true',
    '2' => 'false',
  },
  sysReset => {
    '1' => 'other',
    '2' => 'reset',
    '3' => 'resetMinDown',
  },
  brouterEnableRip => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  portAdminTxFlowControl => {
    '1' => 'on',
    '2' => 'off',
    '3' => 'desired',
  },
  chassisBkplType => {
    '1' => 'other',
    '2' => 'fddi',
    '3' => 'fddiEthernet',
    '4' => 'giga',
    '5' => 'giga3',
    '6' => 'giga3E',
    '7' => 'giga12',
    '8' => 'giga16',
    '9' => 'giga40',
  },
  traceRouteDataErrors => {
    '1' => 'icmpUnreachNet',
    '2' => 'icmpUnreachHost',
    '3' => 'icmpUnreachProtocol',
    '4' => 'icmpUnreachPort',
    '5' => 'icmpUnreachNeedFrag',
    '6' => 'icmpUnreachSrcFail',
    '7' => 'icmpUnreachNoNet',
    '8' => 'icmpUnreachNoHost',
    '9' => 'icmpUnreachHostIsolated',
    '10' => 'icmpUnreachNetProhib',
    '11' => 'icmpUnreachProhib',
    '12' => 'icmpUnreachNetTos',
    '13' => 'icmpUnreachHostTos',
    '14' => 'icmpUnreachAdmin',
    '15' => 'icmpUnreachHostPrec',
    '16' => 'icmpUnreachPrecedence',
    '17' => 'icmpUnknown',
    '18' => 'icmpTimeOut',
    '19' => 'icmpTTLExpired',
  },
  portTopNReportStatus => {
    '1' => 'progressing',
    '2' => 'ready',
  },
  portCpbCosRewrite => {
    '1' => 'yes',
    '2' => 'no',
  },
  sysAttachType => {
    '1' => 'other',
    '2' => 'dualAttach',
    '3' => 'singleAttach',
    '4' => 'nullAttach',
    '5' => 'dualPrio',
  },
  chassisPs1Type => {
    '1' => 'other',
    '2' => 'none',
    '3' => 'w50',
    '4' => 'w200',
    '5' => 'w600',
    '6' => 'w80',
    '7' => 'w130',
    '8' => 'wsc5008',
    '9' => 'wsc5008a',
    '10' => 'w175',
    '11' => 'wsc5068',
    '12' => 'wsc5508',
    '13' => 'wsc5568',
    '14' => 'wsc5508a',
    '15' => 'w155',
    '16' => 'w175pfc',
    '17' => 'w175dc',
    '18' => 'wsc5008b',
    '19' => 'wsc5008c',
    '20' => 'wsc5068b',
    '21' => 'wscac1000',
    '22' => 'wscac1300',
    '23' => 'wscdc1000',
    '24' => 'wscdc1360',
    '25' => 'wsx4008',
    '26' => 'wsc5518',
    '27' => 'wsc5598',
    '28' => 'w120',
    '29' => 'externalPS',
    '30' => 'wscac2500w',
    '31' => 'wscdc2500w',
    '32' => 'wsx4008dc',
    '33' => 'wscac4000w',
    '34' => 'pwr4000dc',
    '35' => 'pwr950ac',
    '36' => 'pwr950dc',
    '37' => 'pwr1900ac',
    '38' => 'pwr1900dc',
    '39' => 'pwr1900ac6',
    '42' => 'wsx4008ac650w',
    '43' => 'wsx4008dc650w',
    '44' => 'wscac3000w',
    '46' => 'pwrc451000ac',
    '47' => 'pwrc452800acv',
    '48' => 'pwrc451300acv',
    '49' => 'pwrc451400dcp',
    '50' => 'wscdc3000w',
    '51' => 'pwr1400ac',
    '52' => 'w156',
    '53' => 'wscac6000w',
    '54' => 'pwr2700ac',
    '55' => 'pwr2700dc',
    '58' => 'wscac8700we',
    '59' => 'pwr2700ac4',
    '60' => 'pwr2700dc4',
    '63' => 'pwr400dc',
    '64' => 'pwr400ac',
    '105' => 'pwr6000dc',
    '106' => 'pwr1500dc',
    '150' => 'c6880x3kwac',
    '151' => 'c6880x3kwdc',
    '152' => 'c6800xl3kwac',
  },
  chassisTempAlarm => {
    '1' => 'off',
    '2' => 'on',
    '3' => 'critical',
  },
  portType => {
    '1' => 'other',
    '2' => 'cddi',
    '3' => 'fddi',
    '4' => 'tppmd',
    '5' => 'mlt3',
    '6' => 'sddi',
    '7' => 'smf',
    '8' => 'e10BaseT',
    '9' => 'e10BaseF',
    '10' => 'scf',
    '11' => 'e100BaseTX',
    '12' => 'e100BaseT4',
    '13' => 'e100BaseF',
    '14' => 'atmOc3mmf',
    '15' => 'atmOc3smf',
    '16' => 'atmOc3utp',
    '17' => 'e100BaseFsm',
    '18' => 'e10a100BaseTX',
    '19' => 'mii',
    '20' => 'vlanRouter',
    '21' => 'remoteRouter',
    '22' => 'tokenring',
    '23' => 'atmOc12mmf',
    '24' => 'atmOc12smf',
    '25' => 'atmDs3',
    '26' => 'tokenringMmf',
    '27' => 'e1000BaseLX',
    '28' => 'e1000BaseSX',
    '29' => 'e1000BaseCX',
    '30' => 'networkAnalysis',
    '31' => 'e1000Empty',
    '32' => 'e1000BaseLH',
    '33' => 'e1000BaseT',
    '34' => 'e1000UnsupportedGbic',
    '35' => 'e1000BaseZX',
    '36' => 'depi2',
    '37' => 't1',
    '38' => 'e1',
    '39' => 'fxs',
    '40' => 'fxo',
    '41' => 'transcoding',
    '42' => 'conferencing',
    '43' => 'atmOc12mm',
    '44' => 'atmOc12smi',
    '45' => 'atmOc12sml',
    '46' => 'posOc12mm',
    '47' => 'posOc12smi',
    '48' => 'posOc12sml',
    '49' => 'posOc48sms',
    '50' => 'posOc48smi',
    '51' => 'posOc48sml',
    '52' => 'posOc3mm',
    '53' => 'posOc3smi',
    '54' => 'posOc3sml',
    '55' => 'intrusionDetect',
    '56' => 'e10GBaseCPX',
    '57' => 'e10GBaseLX4',
    '59' => 'e10GBaseEX4',
    '60' => 'e10GEmpty',
    '61' => 'e10a100a1000BaseT',
    '62' => 'dptOc48mm',
    '63' => 'dptOc48smi',
    '64' => 'dptOc48sml',
    '65' => 'e10GBaseLR',
    '66' => 'chOc12smi',
    '67' => 'chOc12mm',
    '68' => 'chOc48ss',
    '69' => 'chOc48smi',
    '70' => 'e10GBaseSX4',
    '71' => 'e10GBaseER',
    '72' => 'contentEngine',
    '73' => 'ssl',
    '74' => 'firewall',
    '75' => 'vpnIpSec',
    '76' => 'ct3',
    '77' => 'e1000BaseCwdm1470',
    '78' => 'e1000BaseCwdm1490',
    '79' => 'e1000BaseCwdm1510',
    '80' => 'e1000BaseCwdm1530',
    '81' => 'e1000BaseCwdm1550',
    '82' => 'e1000BaseCwdm1570',
    '83' => 'e1000BaseCwdm1590',
    '84' => 'e1000BaseCwdm1610',
    '85' => 'e1000BaseBT',
    '86' => 'e1000BaseUnapproved',
    '87' => 'chOc3smi',
    '88' => 'mcr',
    '89' => 'coe',
    '90' => 'mwa',
    '91' => 'psd',
    '92' => 'e100BaseLX',
    '93' => 'e10GBaseSR',
    '94' => 'e10GBaseCX4',
    '95' => 'e10GBaseWdm1550',
    '96' => 'e10GBaseEdc1310',
    '97' => 'e10GBaseSW',
    '98' => 'e10GBaseLW',
    '99' => 'e10GBaseEW',
    '100' => 'lwa',
    '101' => 'aons',
    '102' => 'sslVpn',
    '103' => 'e100BaseEmpty',
    '104' => 'adsm',
    '105' => 'agsm',
    '106' => 'aces',
    '109' => 'intrusionProtect',
    '110' => 'e1000BaseSvc',
    '111' => 'e10GBaseSvc',
    '113' => 'e40GBaseEmpty',
    '1000' => 'e1000BaseUnknown',
    '1001' => 'e10GBaseUnknown',
    '1002' => 'e10GBaseUnapproved',
    '1003' => 'e1000BaseWdmRxOnly',
    '1004' => 'e1000BaseDwdm3033',
    '1005' => 'e1000BaseDwdm3112',
    '1006' => 'e1000BaseDwdm3190',
    '1007' => 'e1000BaseDwdm3268',
    '1008' => 'e1000BaseDwdm3425',
    '1009' => 'e1000BaseDwdm3504',
    '1010' => 'e1000BaseDwdm3582',
    '1011' => 'e1000BaseDwdm3661',
    '1012' => 'e1000BaseDwdm3819',
    '1013' => 'e1000BaseDwdm3898',
    '1014' => 'e1000BaseDwdm3977',
    '1015' => 'e1000BaseDwdm4056',
    '1016' => 'e1000BaseDwdm4214',
    '1017' => 'e1000BaseDwdm4294',
    '1018' => 'e1000BaseDwdm4373',
    '1019' => 'e1000BaseDwdm4453',
    '1020' => 'e1000BaseDwdm4612',
    '1021' => 'e1000BaseDwdm4692',
    '1022' => 'e1000BaseDwdm4772',
    '1023' => 'e1000BaseDwdm4851',
    '1024' => 'e1000BaseDwdm5012',
    '1025' => 'e1000BaseDwdm5092',
    '1026' => 'e1000BaseDwdm5172',
    '1027' => 'e1000BaseDwdm5252',
    '1028' => 'e1000BaseDwdm5413',
    '1029' => 'e1000BaseDwdm5494',
    '1030' => 'e1000BaseDwdm5575',
    '1031' => 'e1000BaseDwdm5655',
    '1032' => 'e1000BaseDwdm5817',
    '1033' => 'e1000BaseDwdm5898',
    '1034' => 'e1000BaseDwdm5979',
    '1035' => 'e1000BaseDwdm6061',
    '1036' => 'e10GBaseWdmRxOnly',
    '1037' => 'e10GBaseDwdm3033',
    '1038' => 'e10GBaseDwdm3112',
    '1039' => 'e10GBaseDwdm3190',
    '1040' => 'e10GBaseDwdm3268',
    '1041' => 'e10GBaseDwdm3425',
    '1042' => 'e10GBaseDwdm3504',
    '1043' => 'e10GBaseDwdm3582',
    '1044' => 'e10GBaseDwdm3661',
    '1045' => 'e10GBaseDwdm3819',
    '1046' => 'e10GBaseDwdm3898',
    '1047' => 'e10GBaseDwdm3977',
    '1048' => 'e10GBaseDwdm4056',
    '1049' => 'e10GBaseDwdm4214',
    '1050' => 'e10GBaseDwdm4294',
    '1051' => 'e10GBaseDwdm4373',
    '1052' => 'e10GBaseDwdm4453',
    '1053' => 'e10GBaseDwdm4612',
    '1054' => 'e10GBaseDwdm4692',
    '1055' => 'e10GBaseDwdm4772',
    '1056' => 'e10GBaseDwdm4851',
    '1057' => 'e10GBaseDwdm5012',
    '1058' => 'e10GBaseDwdm5092',
    '1059' => 'e10GBaseDwdm5172',
    '1060' => 'e10GBaseDwdm5252',
    '1061' => 'e10GBaseDwdm5413',
    '1062' => 'e10GBaseDwdm5494',
    '1063' => 'e10GBaseDwdm5575',
    '1064' => 'e10GBaseDwdm5655',
    '1065' => 'e10GBaseDwdm5817',
    '1066' => 'e10GBaseDwdm5898',
    '1067' => 'e10GBaseDwdm5979',
    '1068' => 'e10GBaseDwdm6061',
    '1069' => 'e1000BaseBX10D',
    '1070' => 'e1000BaseBX10U',
    '1071' => 'e100BaseUnknown',
    '1072' => 'e100BaseUnapproved',
    '1073' => 'e100BaseSX',
    '1074' => 'e100BaseBX10D',
    '1075' => 'e100BaseBX10U',
    '1076' => 'e10GBaseBad',
    '1077' => 'e10GBaseZR',
    '1078' => 'e100BaseEX',
    '1079' => 'e100BaseZX',
    '1080' => 'e10GBaseLRM',
    '1081' => 'e10GBaseTPluggable',
    '1082' => 'e10GBaseCU1M',
    '1083' => 'e10GBaseCU3M',
    '1084' => 'e10GBaseCU5M',
    '1085' => 'e10GBaseCU7M',
    '1086' => 'e10GBaseCUdot3M',
    '1087' => 'e10GBaseCU2M',
    '1088' => 'e10GBaseCU4M',
    '1089' => 'e10GBaseCU6M',
    '1090' => 'e10GBaseUSR',
    '1091' => 'e10GBaseLRMSM',
    '1092' => 'e1000BaseDwdm3346',
    '1093' => 'e1000BaseDwdm3739',
    '1094' => 'e1000BaseDwdm4134',
    '1095' => 'e1000BaseDwdm4532',
    '1096' => 'e1000BaseDwdm4931',
    '1097' => 'e1000BaseDwdm5332',
    '1098' => 'e1000BaseDwdm5736',
    '1099' => 'e1000BaseDwdm6141',
    '1100' => 'e40GBaseLR',
    '1101' => 'e40GBaseSR',
    '1102' => 'e40GBaseUnapproved',
    '1104' => 'e10GBaseDwdm3347',
    '1105' => 'e10GBaseDwdm3740',
    '1106' => 'e10GBaseDwdm4135',
    '1107' => 'e10GBaseDwdm4532',
    '1108' => 'e10GBaseDwdm4932',
    '1109' => 'e10GBaseDwdm5333',
    '1110' => 'e10GBaseDwdm5736',
    '1111' => 'e10GBaseDwdm6141',
    '1112' => 'e10GBaseACU7M',
    '1113' => 'e10GBaseACU10M',
    '1114' => 'e1000BaseEXSMD',
    '1115' => 'e1000BaseZXSMD',
    '1116' => 'e1000BaseTE',
    '1117' => 'e1000BaseSXMMD',
    '1118' => 'e1000BaseLHSMD',
    '1119' => 'e100BaseFXGE',
  },
  brouterCamMode => {
    '1' => 'filtering',
    '2' => 'forwarding',
  },
  portOperTxFlowControl => {
    '1' => 'on',
    '2' => 'off',
    '3' => 'disagree',
  },
  portChannelAdminStatus => {
    '1' => 'on',
    '2' => 'off',
    '3' => 'desirable',
    '4' => 'auto',
    '5' => 'desirableSilent',
    '6' => 'autoSilent',
  },
  moduleStatus => {
    '1' => 'other',
    '2' => 'ok',
    '3' => 'minorFault',
    '4' => 'majorFault',
  },
  portSpantreeFastStart => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  tokenRingPortSetACbits => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  vlanPortAdminStatus => {
    '1' => 'static',
    '2' => 'dynamic',
  },
  portCpbUdld => {
    '1' => 'yes',
    '2' => 'no',
  },
  ntpSummertimeStatus => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  mcastEnableRgmp => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  radiusServerType => {
    '1' => 'invalid',
    '2' => 'primary',
    '3' => 'other',
  },
  portCpbPortfast => {
    '1' => 'yes',
    '2' => 'no',
  },
  portTopNType => {
    '1' => 'portTopNAllPorts',
    '2' => 'portTopNEthernet',
    '3' => 'portTopNFastEthernet',
    '4' => 'portTopNGigaEthernet',
    '5' => 'portTopNTokenRing',
    '6' => 'portTopNFDDI',
    '7' => 'portTopNAllEthernetPorts',
    '8' => 'portTopN10GigaEthernet',
  },
  tacacsLocalLoginAuthentication => {
    '1' => 'enabled',
    '2' => 'disabled',
    '3' => 'enabledForTelnetOnly',
    '4' => 'enabledForConsoleOnly',
  },
  sysCommunityAccess => {
    '1' => 'other',
    '2' => 'readOnly',
    '3' => 'readWrite',
    '4' => 'readWriteAll',
  },
  ipPermitType => {
    '1' => 'valid',
    '2' => 'invalid',
  },
  syslogServerType => {
    '1' => 'valid',
    '2' => 'invalid',
  },
  sysExtendedRmonEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
    '3' => 'noNAMPresent',
  },
  portOperRxFlowControl => {
    '1' => 'on',
    '2' => 'off',
    '3' => 'disagree',
  },
  fileCopyRuntimeConfigPart => {
    '1' => 'all',
    '2' => 'nonDefault',
  },
  sysEnableConfigTraps => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  sysEnableRedirects => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  sysEnableIpPermitTraps => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  radiusLoginAuthentication => {
    '1' => 'enabled',
    '2' => 'disabled',
    '3' => 'enabledForTelnetOnly',
    '4' => 'enabledForConsoleOnly',
  },
  chassisPs1Status => {
    '1' => 'other',
    '2' => 'ok',
    '3' => 'minorFault',
    '4' => 'majorFault',
  },
  chassisMajorAlarm => {
    '1' => 'off',
    '2' => 'on',
  },
  filterProtocolType => {
    '1' => 'deny',
    '2' => 'invalid',
    '3' => 'permit',
  },
  tacacsLocalEnableAuthentication => {
    '1' => 'enabled',
    '2' => 'disabled',
    '3' => 'enabledForTelnetOnly',
    '4' => 'enabledForConsoleOnly',
  },
  sysExtendedRmonNetflowEnable => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  sysEnableModem => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  ntpClient => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  ntpServerType => {
    '1' => 'valid',
    '2' => 'invalid',
  },
  portCpbSecurity => {
    '1' => 'yes',
    '2' => 'no',
  },
};
package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOSTACKWISEMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-STACKWISE-MIB'} = {
  url => '',
  name => 'CISCO-STACKWISE-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'CISCO-STACKWISE-MIB'} =
    '1.3.6.1.4.1.9.9.500.1';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-STACKWISE-MIB'} = {
  ciscoStackWiseMIB => '1.3.6.1.4.1.9.9.500',
  ciscoStackWiseMIBNotifs => '1.3.6.1.4.1.9.9.500.0',
  cswMIBNotifications => '1.3.6.1.4.1.9.9.500.0.0',
  ciscoStackWiseMIBObjects => '1.3.6.1.4.1.9.9.500.1',
  cswGlobals => '1.3.6.1.4.1.9.9.500.1.1',
  cswMaxSwitchNum => '1.3.6.1.4.1.9.9.500.1.1.1',
  cswMaxSwitchConfigPriority => '1.3.6.1.4.1.9.9.500.1.1.2',
  cswRingRedundant => '1.3.6.1.4.1.9.9.500.1.1.3',
  cswRingRedundantDefinition => 'SNMPv2-TC-v1-MIB::TruthValue',
  cswEnableStackNotifications => '1.3.6.1.4.1.9.9.500.1.1.4',
  cswEnableIndividualStackNotifications => '1.3.6.1.4.1.9.9.500.1.1.5',
  cswStackInfo => '1.3.6.1.4.1.9.9.500.1.2',
  cswSwitchInfoTable => '1.3.6.1.4.1.9.9.500.1.2.1',
  cswSwitchInfoEntry => '1.3.6.1.4.1.9.9.500.1.2.1.1',
  cswSwitchNumCurrent => '1.3.6.1.4.1.9.9.500.1.2.1.1.1',
  cswSwitchNumNextReload => '1.3.6.1.4.1.9.9.500.1.2.1.1.2',
  cswSwitchRole => '1.3.6.1.4.1.9.9.500.1.2.1.1.3',
  cswSwitchRoleDefinition => 'CISCO-STACKWISE-MIB::cswSwitchRole',
  cswSwitchSwPriority => '1.3.6.1.4.1.9.9.500.1.2.1.1.4',
  cswSwitchHwPriority => '1.3.6.1.4.1.9.9.500.1.2.1.1.5',
  cswSwitchState => '1.3.6.1.4.1.9.9.500.1.2.1.1.6',
  cswSwitchStateDefinition => 'CISCO-STACKWISE-MIB::cswSwitchState',
  cswSwitchMacAddress => '1.3.6.1.4.1.9.9.500.1.2.1.1.7',
  cswSwitchSoftwareImage => '1.3.6.1.4.1.9.9.500.1.2.1.1.8',
  cswSwitchPowerBudget => '1.3.6.1.4.1.9.9.500.1.2.1.1.9',
  cswSwitchPowerCommited => '1.3.6.1.4.1.9.9.500.1.2.1.1.10',
  cswSwitchSystemPowerPriority => '1.3.6.1.4.1.9.9.500.1.2.1.1.11',
  cswSwitchPoeDevicesLowPriority => '1.3.6.1.4.1.9.9.500.1.2.1.1.12',
  cswSwitchPoeDevicesHighPriority => '1.3.6.1.4.1.9.9.500.1.2.1.1.13',
  cswStackPortInfoTable => '1.3.6.1.4.1.9.9.500.1.2.2',
  cswStackPortInfoEntry => '1.3.6.1.4.1.9.9.500.1.2.2.1',
  cswStackPortOperStatus => '1.3.6.1.4.1.9.9.500.1.2.2.1.1',
  cswStackPortOperStatusDefinition => 'CISCO-STACKWISE-MIB::cswStackPortOperStatus',
  cswStackPortNeighbor => '1.3.6.1.4.1.9.9.500.1.2.2.1.2',
  cswStackPowerInfo => '1.3.6.1.4.1.9.9.500.1.3',
  cswStackPowerInfoTable => '1.3.6.1.4.1.9.9.500.1.3.1',
  cswStackPowerInfoEntry => '1.3.6.1.4.1.9.9.500.1.3.1.1',
  cswStackPowerStackNumber => '1.3.6.1.4.1.9.9.500.1.3.1.1.1',
  cswStackPowerMode => '1.3.6.1.4.1.9.9.500.1.3.1.1.2',
  cswStackPowerModeDefinition => 'CISCO-STACKWISE-MIB::CswPowerStackMode',
  cswStackPowerMasterMacAddress => '1.3.6.1.4.1.9.9.500.1.3.1.1.3',
  cswStackPowerMasterSwitchNum => '1.3.6.1.4.1.9.9.500.1.3.1.1.4',
  cswStackPowerNumMembers => '1.3.6.1.4.1.9.9.500.1.3.1.1.5',
  cswStackPowerType => '1.3.6.1.4.1.9.9.500.1.3.1.1.6',
  cswStackPowerTypeDefinition => 'CISCO-STACKWISE-MIB::CswPowerStackType',
  cswStackPowerName => '1.3.6.1.4.1.9.9.500.1.3.1.1.7',
  cswStackPowerPortInfoTable => '1.3.6.1.4.1.9.9.500.1.3.2',
  cswStackPowerPortInfoEntry => '1.3.6.1.4.1.9.9.500.1.3.2.1',
  cswStackPowerPortIndex => '1.3.6.1.4.1.9.9.500.1.3.2.1.1',
  cswStackPowerPortOperStatus => '1.3.6.1.4.1.9.9.500.1.3.2.1.2',
  cswStackPowerPortOperStatusDefinition => 'CISCO-STACKWISE-MIB::cswStackPowerPortOperStatus',
  cswStackPowerPortNeighborMacAddress => '1.3.6.1.4.1.9.9.500.1.3.2.1.3',
  cswStackPowerPortNeighborSwitchNum => '1.3.6.1.4.1.9.9.500.1.3.2.1.4',
  cswStackPowerPortLinkStatus => '1.3.6.1.4.1.9.9.500.1.3.2.1.5',
  cswStackPowerPortLinkStatusDefinition => 'CISCO-STACKWISE-MIB::cswStackPowerPortLinkStatus',
  cswStackPowerPortOverCurrentThreshold => '1.3.6.1.4.1.9.9.500.1.3.2.1.6',
  cswStackPowerPortName => '1.3.6.1.4.1.9.9.500.1.3.2.1.7',
  ciscoStackWiseMIBConform => '1.3.6.1.4.1.9.9.500.2',
  cswStackWiseMIBCompliances => '1.3.6.1.4.1.9.9.500.2.1',
  cswStackWiseMIBGroups => '1.3.6.1.4.1.9.9.500.2.2',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'CISCO-STACKWISE-MIB'} = {
  cswStackPortOperStatus => {
    '1' => 'up',
    '2' => 'down',
    '3' => 'forcedDown',
  },
  CswPowerStackMode => {
    '1' => 'powerSharing',
    '2' => 'redundant',
    '3' => 'powerSharingStrict',
    '4' => 'redundantStrict',
  },
  CswPowerStackType => {
    '1' => 'ring',
    '2' => 'star',
  },
  cswStackPowerPortOperStatus => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  cswSwitchState => {
    '1' => 'waiting',
    '2' => 'progressing',
    '3' => 'added',
    '4' => 'ready',
    '5' => 'sdmMismatch',
    '6' => 'verMismatch',
    '7' => 'featureMismatch',
    '8' => 'newMasterInit',
    '9' => 'provisioned',
    '10' => 'invalid',
    '11' => 'removed',
  },
  cswSwitchRole => {
    '1' => 'master',
    '2' => 'member',
    '3' => 'notMember',
  },
  cswStackPowerPortLinkStatus => {
    '1' => 'up',
    '2' => 'down',
  },
};
package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOSYSTEMEXTMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-SYSTEM-EXT-MIB'} = {
  url => '',
  name => 'CISCO-SYSTEM-EXT-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-SYSTEM-EXT-MIB'} = {
  'cseSysCPUUtilization' => '1.3.6.1.4.1.9.9.305.1.1.1.0',
  'cseSysMemoryUtilization' => '1.3.6.1.4.1.9.9.305.1.1.2.0',
  'cseSysConfLastChange' => '1.3.6.1.4.1.9.9.305.1.1.3.0',
  'cseSysAutoSync' => '1.3.6.1.4.1.9.9.305.1.1.4.0',
  'cseSysAutoSyncState' => '1.3.6.1.4.1.9.9.305.1.1.5.0',
  'cseWriteErase' => '1.3.6.1.4.1.9.9.305.1.1.6.0',
  'cseSysConsolePortStatus' => '1.3.6.1.4.1.9.9.305.1.1.7.0',
  'cseSysTelnetServiceActivation' => '1.3.6.1.4.1.9.9.305.1.1.8.0',
  'cseSysFIPSModeActivation' => '1.3.6.1.4.1.9.9.305.1.1.9.0',
  'cseSysUpTime' => '1.3.6.1.4.1.9.9.305.1.1.10.0',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::CISCOVTPMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CISCO-VTP-MIB'} = {
  url => '',
  name => 'CISCO-VTP-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CISCO-VTP-MIB'} = {
  'vlanTrunkPortTable' => '1.3.6.1.4.1.9.9.46.1.6.1',
  'vlanTrunkPortEntry' => '1.3.6.1.4.1.9.9.46.1.6.1.1',
  'vlanTrunkPortIfIndex' => '1.3.6.1.4.1.9.9.46.1.6.1.1.1',
  'vlanTrunkPortManagementDomain' => '1.3.6.1.4.1.9.9.46.1.6.1.1.2',
  'vlanTrunkPortEncapsulationType' => '1.3.6.1.4.1.9.9.46.1.6.1.1.3',
  'vlanTrunkPortVlansEnabled' => '1.3.6.1.4.1.9.9.46.1.6.1.1.4',
  'vlanTrunkPortNativeVlan' => '1.3.6.1.4.1.9.9.46.1.6.1.1.5',
  'vlanTrunkPortRowStatus' => '1.3.6.1.4.1.9.9.46.1.6.1.1.6',
  'vlanTrunkPortInJoins' => '1.3.6.1.4.1.9.9.46.1.6.1.1.7',
  'vlanTrunkPortOutJoins' => '1.3.6.1.4.1.9.9.46.1.6.1.1.8',
  'vlanTrunkPortOldAdverts' => '1.3.6.1.4.1.9.9.46.1.6.1.1.9',
  'vlanTrunkPortVlansPruningEligible' => '1.3.6.1.4.1.9.9.46.1.6.1.1.10',
  'vlanTrunkPortVlansXmitJoined' => '1.3.6.1.4.1.9.9.46.1.6.1.1.11',
  'vlanTrunkPortVlansRcvJoined' => '1.3.6.1.4.1.9.9.46.1.6.1.1.12',
  'vlanTrunkPortDynamicState' => '1.3.6.1.4.1.9.9.46.1.6.1.1.13',
  'vlanTrunkPortDynamicStatus' => '1.3.6.1.4.1.9.9.46.1.6.1.1.14',
  'vlanTrunkPortDynamicStatusDefinition' => {
    '1' => 'trunking',
    '2' => 'notTrunking',
  },
  'vlanTrunkPortVtpEnabled' => '1.3.6.1.4.1.9.9.46.1.6.1.1.15',
  'vlanTrunkPortEncapsulationOperType' => '1.3.6.1.4.1.9.9.46.1.6.1.1.16',
  'vlanTrunkPortVlansEnabled2k' => '1.3.6.1.4.1.9.9.46.1.6.1.1.17',
  'vlanTrunkPortVlansEnabled3k' => '1.3.6.1.4.1.9.9.46.1.6.1.1.18',
  'vlanTrunkPortVlansEnabled4k' => '1.3.6.1.4.1.9.9.46.1.6.1.1.19',
  'vtpVlansPruningEligible2k' => '1.3.6.1.4.1.9.9.46.1.6.1.1.20',
  'vtpVlansPruningEligible3k' => '1.3.6.1.4.1.9.9.46.1.6.1.1.21',
  'vtpVlansPruningEligible4k' => '1.3.6.1.4.1.9.9.46.1.6.1.1.22',
  'vlanTrunkPortVlansXmitJoined2k' => '1.3.6.1.4.1.9.9.46.1.6.1.1.23',
  'vlanTrunkPortVlansXmitJoined3k' => '1.3.6.1.4.1.9.9.46.1.6.1.1.24',
  'vlanTrunkPortVlansXmitJoined4k' => '1.3.6.1.4.1.9.9.46.1.6.1.1.25',
  'vlanTrunkPortVlansRcvJoined2k' => '1.3.6.1.4.1.9.9.46.1.6.1.1.26',
  'vlanTrunkPortVlansRcvJoined3k' => '1.3.6.1.4.1.9.9.46.1.6.1.1.27',
  'vlanTrunkPortVlansRcvJoined4k' => '1.3.6.1.4.1.9.9.46.1.6.1.1.28',
  'vlanTrunkPortDot1qTunnel' => '1.3.6.1.4.1.9.9.46.1.6.1.1.29',
  'vlanTrunkPortVlansActiveFirst2k' => '1.3.6.1.4.1.9.9.46.1.6.1.1.30',
  'vlanTrunkPortVlansActiveSecond2k' => '1.3.6.1.4.1.9.9.46.1.6.1.1.31',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::CLAVISTERMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'CLAVISTER-MIB'} = {
  url => '',
  name => 'CLAVISTER-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'CLAVISTER-MIB'} = {
  'clvSystem' => '1.3.6.1.4.1.5089.1.2.1',
  'clvSysCpuLoad' => '1.3.6.1.4.1.5089.1.2.1.1.0',
  'clvHWSensorTable' => '1.3.6.1.4.1.5089.1.2.1.11',
  'clvHWSensorEntry' => '1.3.6.1.4.1.5089.1.2.1.11.1',
  'clvHWSensorIndex' => '1.3.6.1.4.1.5089.1.2.1.11.1.1',
  'clvHWSensorName' => '1.3.6.1.4.1.5089.1.2.1.11.1.2',
  'clvHWSensorValue' => '1.3.6.1.4.1.5089.1.2.1.11.1.3',
  'clvHWSensorUnit' => '1.3.6.1.4.1.5089.1.2.1.11.1.4',
  'clvSysMemUsage' => '1.3.6.1.4.1.5089.1.2.1.12.0',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::DISKMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'DISK-MIB'} = {
  url => '',
  name => 'DISK-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'DISK-MIB'} = {
  'deviceDiskValueTable' => '1.3.6.1.4.1.3417.2.2.1.1.1',
  'deviceDiskValueEntry' => '1.3.6.1.4.1.3417.2.2.1.1.1.1',
  'deviceDiskIndex' => '1.3.6.1.4.1.3417.2.2.1.1.1.1.1',
  'deviceDiskTrapEnabled' => '1.3.6.1.4.1.3417.2.2.1.1.1.1.2',
  'deviceDiskStatus' => '1.3.6.1.4.1.3417.2.2.1.1.1.1.3',
  'deviceDiskStatusDefinition' => {
    '1' => 'present',
    '2' => 'initializing',
    '3' => 'inserted',
    '4' => 'offline',
    '5' => 'removed',
    '6' => 'not-present',
    '7' => 'empty',
    '8' => 'bad',
    '9' => 'unknown',
  },
  'deviceDiskTimeStamp' => '1.3.6.1.4.1.3417.2.2.1.1.1.1.4',
  'deviceDiskVendor' => '1.3.6.1.4.1.3417.2.2.1.1.1.1.5',
  'deviceDiskProduct' => '1.3.6.1.4.1.3417.2.2.1.1.1.1.6',
  'deviceDiskRevision' => '1.3.6.1.4.1.3417.2.2.1.1.1.1.7',
  'deviceDiskSerialN' => '1.3.6.1.4.1.3417.2.2.1.1.1.1.8',
  'deviceDiskBlockSize' => '1.3.6.1.4.1.3417.2.2.1.1.1.1.9',
  'deviceDiskBlockCount' => '1.3.6.1.4.1.3417.2.2.1.1.1.1.10',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::ENTITYMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'ENTITY-MIB'} = {
  url => '',
  name => 'ENTITY-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'ENTITY-MIB'} = {
  'entPhysicalTable' => '1.3.6.1.2.1.47.1.1.1',
  'entPhysicalEntry' => '1.3.6.1.2.1.47.1.1.1.1',
  'entPhysicalIndex' => '1.3.6.1.2.1.47.1.1.1.1.1',
  'entPhysicalDescr' => '1.3.6.1.2.1.47.1.1.1.1.2',
  'entPhysicalVendorType' => '1.3.6.1.2.1.47.1.1.1.1.3',
  'entPhysicalContainedIn' => '1.3.6.1.2.1.47.1.1.1.1.4',
  'entPhysicalClass' => '1.3.6.1.2.1.47.1.1.1.1.5',
  'entPhysicalClassDefinition' => 'ENTITY-MIB::PhysicalClass',
  'entPhysicalParentRelPos' => '1.3.6.1.2.1.47.1.1.1.1.6',
  'entPhysicalName' => '1.3.6.1.2.1.47.1.1.1.1.7',
  'entPhysicalHardwareRev' => '1.3.6.1.2.1.47.1.1.1.1.8',
  'entPhysicalFirmwareRev' => '1.3.6.1.2.1.47.1.1.1.1.9',
  'entPhysicalSoftwareRev' => '1.3.6.1.2.1.47.1.1.1.1.10',
  'entPhysicalSerialNum' => '1.3.6.1.2.1.47.1.1.1.1.11',
  'entPhysicalMfgName' => '1.3.6.1.2.1.47.1.1.1.1.12',
  'entPhysicalModelName' => '1.3.6.1.2.1.47.1.1.1.1.13',
  'entPhysicalAlias' => '1.3.6.1.2.1.47.1.1.1.1.14',
  'entPhysicalAssetID' => '1.3.6.1.2.1.47.1.1.1.1.15',
  'entPhysicalIsFRU' => '1.3.6.1.2.1.47.1.1.1.1.16',
  'entPhysicalIsFRUDefinition' => {
    '1' => 'true',
    '2' => 'false',
  },
  'entPhysicalMfgDate' => '1.3.6.1.2.1.47.1.1.1.1.17',
  'entPhysicalUris' => '1.3.6.1.2.1.47.1.1.1.1.18',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'ENTITY-MIB'} = {
  'PhysicalClass' => {
    '1' => 'other',
    '2' => 'unknown',
    '3' => 'chassis',
    '4' => 'backplane',
    '5' => 'container',
    '6' => 'powerSupply',
    '7' => 'fan',
    '8' => 'sensor',
    '9' => 'module',
    '10' => 'port',
    '11' => 'stack',
    '12' => 'cpu',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::ENTITYSENSORMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'ENTITY-SENSOR-MIB'} = {
  url => '',
  name => 'ENTITY-SENSOR-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'ENTITY-SENSOR-MIB'} = {
  'entitySensorObjects' => '1.3.6.1.2.1.99.1',
  'entPhySensorTable' => '1.3.6.1.2.1.99.1.1',
  'entPhySensorEntry' => '1.3.6.1.2.1.99.1.1.1',
  'entPhySensorType' => '1.3.6.1.2.1.99.1.1.1.1',
  'entPhySensorTypeDefinition' => {
    '1' => 'other',
    '2' => 'unknown',
    '3' => 'voltsAC',
    '4' => 'voltsDC',
    '5' => 'amperes',
    '6' => 'watts',
    '7' => 'hertz',
    '8' => 'celsius',
    '9' => 'percentRH',
    '10' => 'rpm',
    '11' => 'cmm',
    '12' => 'truthvalue',
  },
  'entPhySensorScale' => '1.3.6.1.2.1.99.1.1.1.2',
  'entPhySensorScaleDefinition' => {
    '1' => 'yocto',
    '2' => 'zepto',
    '3' => 'atto',
    '4' => 'femto',
    '5' => 'pico',
    '6' => 'nano',
    '7' => 'micro',
    '8' => 'milli',
    '9' => 'units',
    '10' => 'kilo',
    '11' => 'mega',
    '12' => 'giga',
    '13' => 'tera',
    '14' => 'exa',
    '15' => 'peta',
    '16' => 'zetta',
    '17' => 'yotta',
  },
  'entPhySensorPrecision' => '1.3.6.1.2.1.99.1.1.1.3',
  'entPhySensorValue' => '1.3.6.1.2.1.99.1.1.1.4',
  'entPhySensorOperStatus' => '1.3.6.1.2.1.99.1.1.1.5',
  'entPhySensorOperStatusDefinition' => {
    '1' => 'ok',
    '2' => 'unavailable',
    '3' => 'nonoperational',
  },
  'entPhySensorUnitsDisplay' => '1.3.6.1.2.1.99.1.1.1.6',
  'entPhySensorValueTimeStamp' => '1.3.6.1.2.1.99.1.1.1.7',
  'entPhySensorValueUpdateRate' => '1.3.6.1.2.1.99.1.1.1.8',
  'entitySensorConformance' => '1.3.6.1.2.1.99.3',
  'entitySensorCompliances' => '1.3.6.1.2.1.99.3.1',
  'entitySensorGroups' => '1.3.6.1.2.1.99.3.2',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::ENTITYSTATEMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'ENTITY-STATE-MIB'} = {
  url => '',
  name => 'ENTITY-STATE-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'ENTITY-STATE-MIB'} =
    '1.3.6.1.2.1.131';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'ENTITY-STATE-MIB'} =
{
  entityStateMIB => '1.3.6.1.2.1.131',
  entStateNotifications => '1.3.6.1.2.1.131.0',
  entStateObjects => '1.3.6.1.2.1.131.1',
  entStateTable => '1.3.6.1.2.1.131.1.1',
  entStateEntry => '1.3.6.1.2.1.131.1.1.1',
  entStateLastChanged => '1.3.6.1.2.1.131.1.1.1.1',
  entStateAdmin => '1.3.6.1.2.1.131.1.1.1.2',
  entStateAdminDefinition => 'ENTITY-STATE-TC-MIB::EntityAdminState',
  entStateOper => '1.3.6.1.2.1.131.1.1.1.3',
  entStateOperDefinition => 'ENTITY-STATE-TC-MIB::EntityOperState',
  entStateUsage => '1.3.6.1.2.1.131.1.1.1.4',
  entStateUsageDefinition => 'ENTITY-STATE-TC-MIB::EntityUsageState',
  entStateAlarm => '1.3.6.1.2.1.131.1.1.1.5',
  entStateAlarmDefinition => 'ENTITY-STATE-TC-MIB::EntityAlarmStatus',
  entStateStandby => '1.3.6.1.2.1.131.1.1.1.6',
  entStateStandbyDefinition => 'ENTITY-STATE-TC-MIB::EntityStandbyStatus',
  entStateConformance => '1.3.6.1.2.1.131.2',
  entStateCompliances => '1.3.6.1.2.1.131.2.1',
  entStateGroups => '1.3.6.1.2.1.131.2.2',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'ENTITY-STATE-TC-MIB'} = {
  EntityAdminState => {
    1 => 'unknown',
    2 => 'locked',
    3 => 'shuttingDown',
    4 => 'unlocked',
  },
  EntityOperState => {
    1 => 'unknown',
    2 => 'disabled',
    3 => 'enabled',
    4 => 'testing',
  },
  EntityUsageState => {
    1 => 'unknown',
    2 => 'idle',
    3 => 'active',
    4 => 'busy',
  },
  EntityAlarmStatus => sub {
    my $val = shift;
    # einstweilen wurscht, muss noch genauer angeschaut werden
    my $dec = unpack("B*", $val);
    return {
    0 => 'unknown',
    1 => 'underRepair',
    2 => 'critical',
    3 => 'major',
    4 => 'minor',
    5 => 'warning',
    6 => 'indeterminate',
    }->{$dec};
  },
  EntityStandbyStatus => {
    1 => 'unknown',
    2 => 'hotStandby',
    3 => 'coldStandby',
    4 => 'providingService',
  },
};

package Monitoring::GLPlugin::SNMP::MibsAndOids::F5BIGIPLOCALMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'F5-BIGIP-LOCAL-MIB'} = {
  url => '',
  name => 'F5-BIGIP-LOCAL-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'F5-BIGIP-LOCAL-MIB'} = {
  'ltmNodeAddrStatusTable' => '1.3.6.1.4.1.3375.2.2.4.3.2',
  'ltmNodeAddrStatusEntry' => '1.3.6.1.4.1.3375.2.2.4.3.2.1',
  'ltmNodeAddrStatusAddrType' => '1.3.6.1.4.1.3375.2.2.4.3.2.1.1',
  'ltmNodeAddrStatusAddr' => '1.3.6.1.4.1.3375.2.2.4.3.2.1.2',
  'ltmNodeAddrStatusAvailState' => '1.3.6.1.4.1.3375.2.2.4.3.2.1.3',
  'ltmNodeAddrStatusEnabledState' => '1.3.6.1.4.1.3375.2.2.4.3.2.1.4',
  'ltmNodeAddrStatusParentType' => '1.3.6.1.4.1.3375.2.2.4.3.2.1.5',
  'ltmNodeAddrStatusDetailReason' => '1.3.6.1.4.1.3375.2.2.4.3.2.1.6',
  'ltmNodeAddrStatusName' => '1.3.6.1.4.1.3375.2.2.4.3.2.1.7',
  'ltmPoolNumber' => '1.3.6.1.4.1.3375.2.2.5.1.1.0',
  'ltmPoolTable' => '1.3.6.1.4.1.3375.2.2.5.1.2',
  'ltmPoolEntry' => '1.3.6.1.4.1.3375.2.2.5.1.2.1',
  'ltmPoolName' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.1',
  'ltmPoolLbMode' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.2',
  'ltmPoolActionOnServiceDown' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.3',
  'ltmPoolMinUpMembers' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.4',
  'ltmPoolMinUpMembersEnable' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.5',
  'ltmPoolMinUpMemberAction' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.6',
  'ltmPoolMinActiveMembers' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.7',
  'ltmPoolActiveMemberCnt' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.8',
  'ltmPoolDisallowSnat' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.9',
  'ltmPoolDisallowNat' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.10',
  'ltmPoolSimpleTimeout' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.11',
  'ltmPoolIpTosToClient' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.12',
  'ltmPoolIpTosToServer' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.13',
  'ltmPoolLinkQosToClient' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.14',
  'ltmPoolLinkQosToServer' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.15',
  'ltmPoolDynamicRatioSum' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.16',
  'ltmPoolMonitorRule' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.17',
  'ltmPoolAvailabilityState' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.18',
  'ltmPoolEnabledState' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.19',
  'ltmPoolDisabledParentType' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.20',
  'ltmPoolStatusReason' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.21',
  'ltmPoolSlowRampTime' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.22',
  'ltmPoolMemberCnt' => '1.3.6.1.4.1.3375.2.2.5.1.2.1.23',
  'ltmPoolStatTable' => '1.3.6.1.4.1.3375.2.2.5.2.3',
  'ltmPoolStatEntry' => '1.3.6.1.4.1.3375.2.2.5.2.3.1',
  'ltmPoolStatName' => '1.3.6.1.4.1.3375.2.2.5.2.3.1.1',
  'ltmPoolStatServerCurConns' => '1.3.6.1.4.1.3375.2.2.5.2.3.1.8',
  'ltmPoolStatCurSessions' => '1.3.6.1.4.1.3375.2.2.5.2.3.1.31',
  'ltmPoolMemberTable' => '1.3.6.1.4.1.3375.2.2.5.3.2',
  'ltmPoolMemberEntry' => '1.3.6.1.4.1.3375.2.2.5.3.2.1',
  'ltmPoolMemberPoolName' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.1',
  'ltmPoolMemberAddrType' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.2',
  'ltmPoolMemberAddr' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.3',
  'ltmPoolMemberPort' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.4',
  'ltmPoolMemberConnLimit' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.5',
  'ltmPoolMemberRatio' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.6',
  'ltmPoolMemberWeight' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.7',
  'ltmPoolMemberPriority' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.8',
  'ltmPoolMemberDynamicRatio' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.9',
  'ltmPoolMemberMonitorState' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.10',
  'ltmPoolMemberMonitorStateDefinition' => 'F5-BIGIP-LOCAL-MIB::ltmPoolMemberMonitorState',
  'ltmPoolMemberMonitorStatus' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.11',
  'ltmPoolMemberMonitorStatusDefinition' => 'F5-BIGIP-LOCAL-MIB::ltmPoolMemberMonitorStatus',
  'ltmPoolMemberNewSessionEnable' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.12',
  'ltmPoolMemberSessionStatus' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.13',
  'ltmPoolMemberMonitorRule' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.14',
  'ltmPoolMemberAvailabilityState' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.15',
  'ltmPoolMemberEnabledState' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.16',
  'ltmPoolMemberDisabledParentType' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.17',
  'ltmPoolMemberStatusReason' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.18',
  'ltmPoolMemberNodeName' => '1.3.6.1.4.1.3375.2.2.5.3.2.1.19',
  'ltmPoolMemberStat' => '1.3.6.1.4.1.3375.2.2.5.4',
  'ltmPoolMemberStatResetStats' => '1.3.6.1.4.1.3375.2.2.5.4.1',
  'ltmPoolMemberStatNumber' => '1.3.6.1.4.1.3375.2.2.5.4.2',
  'ltmPoolMemberStatTable' => '1.3.6.1.4.1.3375.2.2.5.4.3',
  'ltmPoolMemberStatEntry' => '1.3.6.1.4.1.3375.2.2.5.4.3.1',
  'ltmPoolMemberStatPoolName' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.1',
  'ltmPoolMemberStatAddrType' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.2',
  'ltmPoolMemberStatAddr' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.3',
  'ltmPoolMemberStatPort' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.4',
  'ltmPoolMemberStatServerPktsIn' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.5',
  'ltmPoolMemberStatServerBytesIn' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.6',
  'ltmPoolMemberStatServerPktsOut' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.7',
  'ltmPoolMemberStatServerBytesOut' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.8',
  'ltmPoolMemberStatServerMaxConns' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.9',
  'ltmPoolMemberStatServerTotConns' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.10',
  'ltmPoolMemberStatServerCurConns' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.11',
  'ltmPoolMemberStatPvaPktsIn' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.12',
  'ltmPoolMemberStatPvaBytesIn' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.13',
  'ltmPoolMemberStatPvaPktsOut' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.14',
  'ltmPoolMemberStatPvaBytesOut' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.15',
  'ltmPoolMemberStatPvaMaxConns' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.16',
  'ltmPoolMemberStatPvaTotConns' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.17',
  'ltmPoolMemberStatPvaCurConns' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.18',
  'ltmPoolMemberStatTotRequests' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.19',
  'ltmPoolMemberStatTotPvaAssistConn' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.20',
  'ltmPoolMemberStatCurrPvaAssistConn' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.21',
  'ltmPoolMemberStatConnqDepth' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.22',
  'ltmPoolMemberStatConnqAgeHead' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.23',
  'ltmPoolMemberStatConnqAgeMax' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.24',
  'ltmPoolMemberStatConnqAgeEma' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.25',
  'ltmPoolMemberStatConnqAgeEdm' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.26',
  'ltmPoolMemberStatConnqServiced' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.27',
  'ltmPoolMemberStatNodeName' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.28',
  'ltmPoolMemberStatCurSessions' => '1.3.6.1.4.1.3375.2.2.5.4.3.1.29',
  'ltmPoolStatusNumber' => '1.3.6.1.4.1.3375.2.2.5.5.1.0',
  'ltmPoolStatusTable' => '1.3.6.1.4.1.3375.2.2.5.5.2',
  'ltmPoolStatusEntry' => '1.3.6.1.4.1.3375.2.2.5.5.2.1',
  'ltmPoolStatusName' => '1.3.6.1.4.1.3375.2.2.5.5.2.1.1',
  'ltmPoolStatusAvailState' => '1.3.6.1.4.1.3375.2.2.5.5.2.1.2',
  'ltmPoolStatusAvailStateDefinition' => 'F5-BIGIP-LOCAL-MIB::ltmPoolStatusAvailState',
  'ltmPoolStatusEnabledState' => '1.3.6.1.4.1.3375.2.2.5.5.2.1.3',
  'ltmPoolStatusEnabledStateDefinition' => 'F5-BIGIP-LOCAL-MIB::ltmPoolStatusEnabledState',
  'ltmPoolStatusParentType' => '1.3.6.1.4.1.3375.2.2.5.5.2.1.4',
  'ltmPoolStatusDetailReason' => '1.3.6.1.4.1.3375.2.2.5.5.2.1.5',
  'ltmPoolMbrStatusNumber' => '1.3.6.1.4.1.3375.2.2.5.6.1.0',
  'ltmPoolMbrStatusTable' => '1.3.6.1.4.1.3375.2.2.5.6.2',
  'ltmPoolMbrStatusEntry' => '1.3.6.1.4.1.3375.2.2.5.6.2.1',
  'ltmPoolMbrStatusPoolName' => '1.3.6.1.4.1.3375.2.2.5.6.2.1.1',
  'ltmPoolMbrStatusAddrType' => '1.3.6.1.4.1.3375.2.2.5.6.2.1.2',
  'ltmPoolMbrStatusAddr' => '1.3.6.1.4.1.3375.2.2.5.6.2.1.3',
  'ltmPoolMbrStatusPort' => '1.3.6.1.4.1.3375.2.2.5.6.2.1.4',
  'ltmPoolMbrStatusAvailState' => '1.3.6.1.4.1.3375.2.2.5.6.2.1.5',
  'ltmPoolMbrStatusAvailStateDefinition' => 'F5-BIGIP-LOCAL-MIB::ltmPoolMbrStatusAvailState',
  'ltmPoolMbrStatusEnabledState' => '1.3.6.1.4.1.3375.2.2.5.6.2.1.6',
  'ltmPoolMbrStatusEnabledStateDefinition' => 'F5-BIGIP-LOCAL-MIB::ltmPoolMbrStatusEnabledState',
  'ltmPoolMbrStatusParentType' => '1.3.6.1.4.1.3375.2.2.5.6.2.1.7',
  'ltmPoolMbrStatusDetailReason' => '1.3.6.1.4.1.3375.2.2.5.6.2.1.8',
  'ltmPoolMbrStatusNodeName' => '1.3.6.1.4.1.3375.2.2.5.6.2.1.9',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'F5-BIGIP-LOCAL-MIB'} = {
  'ltmPoolMemberMonitorState' => {
    '0' => 'unchecked',
    '1' => 'checking',
    '2' => 'inband',
    '3' => 'forced-up',
    '4' => 'up',
    '19' => 'down',
    '20' => 'forced-down',
    '22' => 'irule-down',
    '23' => 'inband-down',
    '24' => 'down-manual-resume',
    '25' => 'disabled',
  },
  'ltmPoolMemberMonitorStatus' => {
    '0' => 'unchecked',
    '1' => 'checking',
    '2' => 'inband',
    '3' => 'forced-up',
    '4' => 'up',
    '18' => 'addr-down',
    '19' => 'down',
    '20' => 'forced-down',
    '21' => 'maint',
    '22' => 'irule-down',
    '23' => 'inband-down',
    '24' => 'down-manual-resume',
  },
  'ltmPoolStatusEnabledState' => {
    '0' => 'none',
    '1' => 'enabled',
    '2' => 'disabled',
    '3' => 'disabledbyparent',
  },
  'ltmPoolAvailabilityState' => {
    '0' => 'none',
    '1' => 'green',
    '2' => 'yellow',
    '3' => 'red',
    '4' => 'blue',
  },
  'ltmPoolMbrStatusAvailState' => {
    '0' => 'none',
    '1' => 'green',
    '2' => 'yellow',
    '3' => 'red',
    '4' => 'blue',
    '5' => 'gray',
  },
  'ltmPoolLbMode' => {
    '0' => 'roundRobin',
    '1' => 'ratioMember',
    '2' => 'leastConnMember',
    '3' => 'observedMember',
    '4' => 'predictiveMember',
    '5' => 'ratioNodeAddress',
    '6' => 'leastConnNodeAddress',
    '7' => 'fastestNodeAddress',
    '8' => 'observedNodeAddress',
    '9' => 'predictiveNodeAddress',
    '10' => 'dynamicRatio',
    '11' => 'fastestAppResponse',
    '12' => 'leastSessions',
    '13' => 'dynamicRatioMember',
    '14' => 'l3Addr',
    '15' => 'weightedLeastConnMember',
    '16' => 'weightedLeastConnNodeAddr',
    '17' => 'ratioSession',
  },
  'ltmPoolStatusAvailState' => {
    '0' => 'none',
    '1' => 'green',
    '2' => 'yellow',
    '3' => 'red',
    '4' => 'blue',
    '5' => 'grey',
  },
  'ltmPoolMemberEnabledState' => {
    '0' => 'none',
    '1' => 'enabled',
    '2' => 'disabled',
    '3' => 'disabledbyparent',
  },
  'ltmPoolMbrStatusEnabledState' => {
    '0' => 'none',
    '1' => 'enabled',
    '2' => 'disabled',
    '3' => 'disabledbyparent',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::F5BIGIPSYSTEMMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'F5-BIGIP-SYSTEM-MIB'} = {
  url => '',
  name => 'F5-BIGIP-SYSTEM-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'F5-BIGIP-SYSTEM-MIB'} = {
  'sysStatTmTotalCycles' => '1.3.6.1.4.1.3375.2.1.1.2.1.41.0',
  'sysStatTmIdleCycles' => '1.3.6.1.4.1.3375.2.1.1.2.1.42.0',
  'sysStatTmSleepCycles' => '1.3.6.1.4.1.3375.2.1.1.2.1.43.0',
  'sysStatMemoryTotal' => '1.3.6.1.4.1.3375.2.1.1.2.1.44.0',
  'sysStatMemoryUsed' => '1.3.6.1.4.1.3375.2.1.1.2.1.45.0',
  'sysCpuNumber' => '1.3.6.1.4.1.3375.2.1.3.1.1.0',
  'sysCpuTable' => '1.3.6.1.4.1.3375.2.1.3.1.2',
  'sysCpuEntry' => '1.3.6.1.4.1.3375.2.1.3.1.2.1',
  'sysCpuIndex' => '1.3.6.1.4.1.3375.2.1.3.1.2.1.1',
  'sysCpuTemperature' => '1.3.6.1.4.1.3375.2.1.3.1.2.1.2',
  'sysCpuFanSpeed' => '1.3.6.1.4.1.3375.2.1.3.1.2.1.3',
  'sysCpuName' => '1.3.6.1.4.1.3375.2.1.3.1.2.1.4',
  'sysCpuSlot' => '1.3.6.1.4.1.3375.2.1.3.1.2.1.5',
  'sysChassisFan' => '1.3.6.1.4.1.3375.2.1.3.2.1',
  'sysChassisFanNumber' => '1.3.6.1.4.1.3375.2.1.3.2.1.1.0',
  'sysChassisFanTable' => '1.3.6.1.4.1.3375.2.1.3.2.1.2',
  'sysChassisFanEntry' => '1.3.6.1.4.1.3375.2.1.3.2.1.2.1',
  'sysChassisFanIndex' => '1.3.6.1.4.1.3375.2.1.3.2.1.2.1.1',
  'sysChassisFanStatus' => '1.3.6.1.4.1.3375.2.1.3.2.1.2.1.2',
  'sysChassisFanStatusDefinition' => {
    '0' => 'bad',
    '1' => 'good',
    '2' => 'notpresent',
  },
  'sysChassisFanSpeed' => '1.3.6.1.4.1.3375.2.1.3.2.1.2.1.3',
  'sysChassisPowerSupply' => '1.3.6.1.4.1.3375.2.1.3.2.2',
  'sysChassisPowerSupplyNumber' => '1.3.6.1.4.1.3375.2.1.3.2.2.1.0',
  'sysChassisPowerSupplyTable' => '1.3.6.1.4.1.3375.2.1.3.2.2.2',
  'sysChassisPowerSupplyEntry' => '1.3.6.1.4.1.3375.2.1.3.2.2.2.1',
  'sysChassisPowerSupplyIndex' => '1.3.6.1.4.1.3375.2.1.3.2.2.2.1.1',
  'sysChassisPowerSupplyStatus' => '1.3.6.1.4.1.3375.2.1.3.2.2.2.1.2',
  'sysChassisPowerSupplyStatusDefinition' => {
    '0' => 'bad',
    '1' => 'good',
    '2' => 'notpresent',
  },
  'sysChassisTemp' => '1.3.6.1.4.1.3375.2.1.3.2.3',
  'sysChassisTempNumber' => '1.3.6.1.4.1.3375.2.1.3.2.3.1.0',
  'sysChassisTempTable' => '1.3.6.1.4.1.3375.2.1.3.2.3.2',
  'sysChassisTempEntry' => '1.3.6.1.4.1.3375.2.1.3.2.3.2.1',
  'sysChassisTempIndex' => '1.3.6.1.4.1.3375.2.1.3.2.3.2.1.1',
  'sysChassisTempTemperature' => '1.3.6.1.4.1.3375.2.1.3.2.3.2.1.2',
  'sysPlatformInfoName' => '1.3.6.1.4.1.3375.2.1.3.5.1.0',
  'sysPlatformInfoMarketingName' => '1.3.6.1.4.1.3375.2.1.3.5.2.0',
  'sysProduct' => '1.3.6.1.4.1.3375.2.1.4',
  'sysProductName' => '1.3.6.1.4.1.3375.2.1.4.1.0',
  'sysProductVersion' => '1.3.6.1.4.1.3375.2.1.4.2.0',
  'sysProductBuild' => '1.3.6.1.4.1.3375.2.1.4.3.0',
  'sysProductEdition' => '1.3.6.1.4.1.3375.2.1.4.4.0',
  'sysProductDate' => '1.3.6.1.4.1.3375.2.1.4.5.0',
  'sysSubMemory' => '1.3.6.1.4.1.3375.2.1.5',
  'sysSubMemoryResetStats' => '1.3.6.1.4.1.3375.2.1.5.1.0',
  'sysSubMemoryNumber' => '1.3.6.1.4.1.3375.2.1.5.2.0',
  'sysSubMemoryTable' => '1.3.6.1.4.1.3375.2.1.5.3',
  'sysSubMemoryEntry' => '1.3.6.1.4.1.3375.2.1.5.3.1',
  'sysSubMemoryName' => '1.3.6.1.4.1.3375.2.1.5.3.1.1',
  'sysSubMemoryAllocated' => '1.3.6.1.4.1.3375.2.1.5.3.1.2',
  'sysSubMemoryMaxAllocated' => '1.3.6.1.4.1.3375.2.1.5.3.1.3',
  'sysSubMemorySize' => '1.3.6.1.4.1.3375.2.1.5.3.1.4',
  'sysSystem' => '1.3.6.1.4.1.3375.2.1.6',
  'sysSystemName' => '1.3.6.1.4.1.3375.2.1.6.1.0',
  'sysSystemNodeName' => '1.3.6.1.4.1.3375.2.1.6.2.0',
  'sysSystemRelease' => '1.3.6.1.4.1.3375.2.1.6.3.0',
  'sysSystemVersion' => '1.3.6.1.4.1.3375.2.1.6.4.0',
  'sysSystemMachine' => '1.3.6.1.4.1.3375.2.1.6.5.0',
  'sysSystemUptime' => '1.3.6.1.4.1.3375.2.1.6.6.0',
  'sysHostMemoryTotal' => '1.3.6.1.4.1.3375.2.1.7.1.1.0',
  'sysHostMemoryUsed' => '1.3.6.1.4.1.3375.2.1.7.1.2.0',
  'sysPhysicalDiskTable' => '1.3.6.1.4.1.3375.2.1.7.7.2',
  'sysPhysicalDiskEntry' => '1.3.6.1.4.1.3375.2.1.7.7.2.1',
  'sysPhysicalDiskSerialNumber' => '1.3.6.1.4.1.3375.2.1.7.7.2.1.1',
  'sysPhysicalDiskSlotId' => '1.3.6.1.4.1.3375.2.1.7.7.2.1.2',
  'sysPhysicalDiskName' => '1.3.6.1.4.1.3375.2.1.7.7.2.1.3',
  'sysPhysicalDiskIsArrayMember' => '1.3.6.1.4.1.3375.2.1.7.7.2.1.4',
  'sysPhysicalDiskIsArrayMemberDefinition' => {
    '0' => 'false',
    '1' => 'true',
  },
  'sysPhysicalDiskArrayStatus' => '1.3.6.1.4.1.3375.2.1.7.7.2.1.5',
  'sysPhysicalDiskArrayStatusDefinition' => {
    '0' => 'undefined',
    '1' => 'ok',
    '2' => 'replicating',
    '3' => 'missing',
    '4' => 'failed',
  },
  'bigipSystemGroups' => '1.3.6.1.4.1.3375.2.5.2.1',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::FCEOSMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'FCEOS-MIB'} = {
  url => '',
  name => 'FCEOS-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'FCEOS-MIB'} = {
  'fcEosSysCurrentDate' => '1.3.6.1.4.1.289.2.1.1.2.1.1.0',
  'fcEosSysBootDate' => '1.3.6.1.4.1.289.2.1.1.2.1.2.0',
  'fcEosSysFirmwareVersion' => '1.3.6.1.4.1.289.2.1.1.2.1.3.0',
  'fcEosSysTypeNum' => '1.3.6.1.4.1.289.2.1.1.2.1.4.0',
  'fcEosSysModelNum' => '1.3.6.1.4.1.289.2.1.1.2.1.5.0',
  'fcEosSysMfg' => '1.3.6.1.4.1.289.2.1.1.2.1.6.0',
  'fcEosSysPlantOfMfg' => '1.3.6.1.4.1.289.2.1.1.2.1.7.0',
  'fcEosSysEcLevel' => '1.3.6.1.4.1.289.2.1.1.2.1.8.0',
  'fcEosSysSerialNum' => '1.3.6.1.4.1.289.2.1.1.2.1.9.0',
  'fcEosSysOperStatus' => '1.3.6.1.4.1.289.2.1.1.2.1.10.0',
  'fcEosSysOperStatusDefinition' => {
    '1' => 'operational',
    '2' => 'redundant-failure',
    '3' => 'minor-failure',
    '4' => 'major-failure',
    '5' => 'not-operational',
  },
  'fcEosSysState' => '1.3.6.1.4.1.289.2.1.1.2.1.11.0',
  'fcEosSysAdmStatus' => '1.3.6.1.4.1.289.2.1.1.2.1.12.0',
  'fcEosSysConfigSpeed' => '1.3.6.1.4.1.289.2.1.1.2.1.13.0',
  'fcEosSysOpenTrunking' => '1.3.6.1.4.1.289.2.1.1.2.1.14.0',
  'fcEosFruTable' => '1.3.6.1.4.1.289.2.1.1.2.2.1',
  'fcEosFruEntry' => '1.3.6.1.4.1.289.2.1.1.2.2.1.1',
  'fcEosFruCode' => '1.3.6.1.4.1.289.2.1.1.2.2.1.1.1',
  'fcEosFruCodeDefinition' => {
    '1' => 'fru-bkplane',
    '2' => 'fru-ctp',
    '3' => 'fru-sbar',
    '4' => 'fru-fan2',
    '5' => 'fru-fan',
    '6' => 'fru-power',
    '7' => 'fru-reserved',
    '8' => 'fru-glsl',
    '9' => 'fru-gsml',
    '10' => 'fru-gxxl',
    '11' => 'fru-gsf1',
    '12' => 'fru-gsf2',
    '13' => 'fru-glsr',
    '14' => 'fru-gsmr',
    '15' => 'fru-gxxr',
    '16' => 'fru-fint1',
  },
  'fcEosFruPosition' => '1.3.6.1.4.1.289.2.1.1.2.2.1.1.2',
  'fcEosFruStatus' => '1.3.6.1.4.1.289.2.1.1.2.2.1.1.3',
  'fcEosFruStatusDefinition' => {
    '0' => 'unknown',
    '1' => 'active',
    '2' => 'backup',
    '3' => 'update-busy',
    '4' => 'failed',
  },
  'fcEosFruPartNumber' => '1.3.6.1.4.1.289.2.1.1.2.2.1.1.4',
  'fcEosFruSerialNumber' => '1.3.6.1.4.1.289.2.1.1.2.2.1.1.5',
  'fcEosFruPowerOnHours' => '1.3.6.1.4.1.289.2.1.1.2.2.1.1.6',
  'fcEosFruTestDate' => '1.3.6.1.4.1.289.2.1.1.2.2.1.1.7',
  'fcEosTATable' => '1.3.6.1.4.1.289.2.1.1.2.6.1',
  'fcEosTAEntry' => '1.3.6.1.4.1.289.2.1.1.2.6.1.1',
  'fcEosTAIndex' => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.1',
  'fcEosTAName' => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.2',
  'fcEosTAState' => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.3',
  'fcEosTAType' => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.4',
  'fcEosTAPortType' => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.5',
  'fcEosTAPortList' => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.6',
  'fcEosTAInterval' => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.7',
  'fcEosTATriggerValue' => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.8',
  'fcEosTTADirection' => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.9',
  'fcEosTTATriggerDuration' => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.10',
  'fcEosCTACounter' => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.11',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::FCMGMTMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'FCMGMT-MIB'} = {
  url => '',
  name => 'FCMGMT-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'FCMGMT-MIB'} = {
  'fcConnUnitPortStatTxObjects' => '1.3',
  'fcConnUnitSEventTime' => '1.3',
  'fcConnUnitTable' => '1.3',
  'fcConnUnitPortFCClassCap' => '1.3',
  'fcConnUnitLinkPortNumberX' => '1.3',
  'fcConnUnitType' => '1.3',
  'fcConnUnitSnsPortName' => '1.3',
  'fcConnUnitRevsDescription' => '1.3',
  'fcConnUnitEntry' => '1.3.1',
  'fcConnUnitPortStatTable' => '1.3.1',
  'fcConnUnitPortStatEntry' => '1.3.1.1',
  'fcConnUnitId' => '1.3.1.1',
  'fcConnUnitPortStatIndex' => '1.3.1.1.1',
  'fcConnUnitPortStatErrs' => '1.3.1.1.2',
  'fcConnUnitPortStatRxObjects' => '1.3.1.1.4',
  'fcConnUnitPortStatTxElements' => '1.3.1.1.5',
  'fcConnUnitPortStatRxElements' => '1.3.1.1.6',
  'fcConnUnitPortStatBBCreditZero' => '1.3.1.1.7',
  'fcConnUnitPortStatInputBuffsFull' => '1.3.1.1.8',
  'fcConnUnitPortStatFBSYFrames' => '1.3.1.1.9',
  'fcConnUnitPortStatPBSYFrames' => '1.3.1.1.10',
  'fcConnUnitPortStatFRJTFrames' => '1.3.1.1.11',
  'fcConnUnitPortStatPRJTFrames' => '1.3.1.1.12',
  'fcConnUnitPortStatC1RxFrames' => '1.3.1.1.13',
  'fcConnUnitPortStatC1TxFrames' => '1.3.1.1.14',
  'fcConnUnitPortStatC1FBSYFrames' => '1.3.1.1.15',
  'fcConnUnitPortStatC1PBSYFrames' => '1.3.1.1.16',
  'fcConnUnitPortStatC1FRJTFrames' => '1.3.1.1.17',
  'fcConnUnitPortStatC1PRJTFrames' => '1.3.1.1.18',
  'fcConnUnitPortStatC2RxFrames' => '1.3.1.1.19',
  'fcConnUnitPortStatC2TxFrames' => '1.3.1.1.20',
  'fcConnUnitPortStatC2FBSYFrames' => '1.3.1.1.21',
  'fcConnUnitPortStatC2PBSYFrames' => '1.3.1.1.22',
  'fcConnUnitPortStatC2FRJTFrames' => '1.3.1.1.23',
  'fcConnUnitPortStatC2PRJTFrames' => '1.3.1.1.24',
  'fcConnUnitPortStatC3RxFrames' => '1.3.1.1.25',
  'fcConnUnitPortStatC3TxFrames' => '1.3.1.1.26',
  'fcConnUnitPortStatC3Discards' => '1.3.1.1.27',
  'fcConnUnitPortStatRxMcastObjects' => '1.3.1.1.28',
  'fcConnUnitPortStatTxMcastObjects' => '1.3.1.1.29',
  'fcConnUnitPortStatInvalidTxWords' => '1.3.1.1.40',
  'fcConnUnitPortStatPSPErrs' => '1.3.1.1.41',
  'fcConnUnitPortStatLossOfSignal' => '1.3.1.1.42',
  'fcConnUnitPortStatLossOfSync' => '1.3.1.1.43',
  'fcConnUnitPortStatInvOrderedSets' => '1.3.1.1.44',
  'fcConnUnitPortStatFramesTooLong' => '1.3.1.1.45',
  'fcConnUnitPortStatFramesTooShort' => '1.3.1.1.46',
  'fcConnUnitPortStatAddressErrs' => '1.3.1.1.47',
  'fcConnUnitPortStatDelimiterErrs' => '1.3.1.1.48',
  'fcConnUnitPortStatEncodingErrs' => '1.3.1.1.49',
  'fcConnUnitGlobalId' => '1.3.1.2',
  'fcConnUnitNumPorts' => '1.3.1.4',
  'fcConnUnitState' => '1.3.1.5',
  'fcConnUnitStatus' => '1.3.1.6',
  'fcConnUnitProduct' => '1.3.1.7',
  'fcConnUnitSerialNo' => '1.3.1.8',
  'fcConnUnitUpTime' => '1.3.1.9',
  'fcConnUnitUrl' => '1.3.1.10',
  'fcConnUnitDomainId' => '1.3.1.11',
  'fcConnUnitProxyMaster' => '1.3.1.12',
  'fcConnUnitPrincipal' => '1.3.1.13',
  'fcConnUnitNumSensors' => '1.3.1.14',
  'fcConnUnitNumRevs' => '1.3.1.15',
  'fcConnUnitModuleId' => '1.3.1.16',
  'fcConnUnitName' => '1.3.1.17',
  'fcConnUnitInfo' => '1.3.1.18',
  'fcConnUnitControl' => '1.3.1.19',
  'fcConnUnitContact' => '1.3.1.20',
  'fcConnUnitLocation' => '1.3.1.21',
  'fcConnUnitEventFilter' => '1.3.1.22',
  'fcConnUnitNumEvents' => '1.3.1.23',
  'fcConnUnitMaxEvents' => '1.3.1.24',
  'fcConnUnitEventCurrID' => '1.3.1.25',
  'fcConnUnitRevsTable' => '1.3.6.1.2.1.8888.1.1.4',
  'fcConnUnitRevsEntry' => '1.3.6.1.2.1.8888.1.1.4.1',
  'fcConnUnitRevsIndex' => '1.3.6.1.2.1.8888.1.1.4.1.1',
  'fcConnUnitRevsRevision' => '1.3.6.1.2.1.8888.1.1.4.1.2',
  'fcConnUnitSensorTable' => '1.3.6.1.2.1.8888.1.1.5',
  'fcConnUnitSensorEntry' => '1.3.6.1.2.1.8888.1.1.5.1',
  'fcConnUnitSensorIndex' => '1.3.6.1.2.1.8888.1.1.5.1.1',
  'fcConnUnitSensorName' => '1.3.6.1.2.1.8888.1.1.5.1.2',
  'fcConnUnitSensorStatus' => '1.3.6.1.2.1.8888.1.1.5.1.3',
  'fcConnUnitSensorStatusDefinition' => {
    '1' => 'unknown',
    '2' => 'other',
    '3' => 'ok',
    '4' => 'warning',
    '5' => 'failed',
  },
  'fcConnUnitSensorInfo' => '1.3.6.1.2.1.8888.1.1.5.1.4',
  'fcConnUnitSensorMessage' => '1.3.6.1.2.1.8888.1.1.5.1.5',
  'fcConnUnitSensorType' => '1.3.6.1.2.1.8888.1.1.5.1.6',
  'fcConnUnitSensorTypeDefinition' => {
    '1' => 'unknown',
    '2' => 'other',
    '3' => 'battery',
    '4' => 'fan',
    '5' => 'powerSupply',
    '6' => 'transmitter',
    '7' => 'enclosure',
    '8' => 'board',
    '9' => 'receiver',
  },
  'fcConnUnitSensorCharacteristic' => '1.3.6.1.2.1.8888.1.1.5.1.7',
  'fcConnUnitSensorCharacteristicDefinition' => {
    '1' => 'unknown',
    '2' => 'other',
    '3' => 'temperature',
    '4' => 'pressure',
    '5' => 'emf',
    '6' => 'currentValue',
    '7' => 'airflow',
    '8' => 'frequency',
    '9' => 'power',
  },
  'fcConnUnitPortTable' => '1.3.6.1.2.1.8888.1.1.6',
  'fcConnUnitPortEntry' => '1.3.6.1.2.1.8888.1.1.6.1',
  'fcConnUnitPortIndex' => '1.3.6.1.2.1.8888.1.1.6.1.1',
  'fcConnUnitPortType' => '1.3.6.1.2.1.8888.1.1.6.1.2',
  'fcConnUnitPortFCClassOp' => '1.3.6.1.2.1.8888.1.1.6.1.4',
  'fcConnUnitPortState' => '1.3.6.1.2.1.8888.1.1.6.1.5',
  'fcConnUnitPortStatus' => '1.3.6.1.2.1.8888.1.1.6.1.6',
  'fcConnUnitPortTransmitterType' => '1.3.6.1.2.1.8888.1.1.6.1.7',
  'fcConnUnitPortModuleType' => '1.3.6.1.2.1.8888.1.1.6.1.8',
  'fcConnUnitPortWwn' => '1.3.6.1.2.1.8888.1.1.6.1.9',
  'fcConnUnitPortFCId' => '1.3.6.1.2.1.8888.1.1.6.1.10',
  'fcConnUnitPortSerialNo' => '1.3.6.1.2.1.8888.1.1.6.1.11',
  'fcConnUnitPortRevision' => '1.3.6.1.2.1.8888.1.1.6.1.12',
  'fcConnUnitPortVendor' => '1.3.6.1.2.1.8888.1.1.6.1.13',
  'fcConnUnitPortSpeed' => '1.3.6.1.2.1.8888.1.1.6.1.14',
  'fcConnUnitPortControl' => '1.3.6.1.2.1.8888.1.1.6.1.15',
  'fcConnUnitPortName' => '1.3.6.1.2.1.8888.1.1.6.1.16',
  'fcConnUnitPortPhysicalNumber' => '1.3.6.1.2.1.8888.1.1.6.1.17',
  'fcConnUnitPortProtocolCap' => '1.3.6.1.2.1.8888.1.1.6.1.18',
  'fcConnUnitPortProtocolOp' => '1.3.6.1.2.1.8888.1.1.6.1.19',
  'fcConnUnitPortNodeWwn' => '1.3.6.1.2.1.8888.1.1.6.1.20',
  'fcConnUnitPortHWState' => '1.3.6.1.2.1.8888.1.1.6.1.21',
  'fcConnUnitEventTable' => '1.3.6.1.2.1.8888.1.1.7',
  'fcConnUnitEventEntry' => '1.3.6.1.2.1.8888.1.1.7.1',
  'fcConnUnitEventIndex' => '1.3.6.1.2.1.8888.1.1.7.1.1',
  'fcConnUnitREventTime' => '1.3.6.1.2.1.8888.1.1.7.1.2',
  'fcConnUnitEventSeverity' => '1.3.6.1.2.1.8888.1.1.7.1.4',
  'fcConnUnitEventType' => '1.3.6.1.2.1.8888.1.1.7.1.5',
  'fcConnUnitEventObject' => '1.3.6.1.2.1.8888.1.1.7.1.6',
  'fcConnUnitEventDescr' => '1.3.6.1.2.1.8888.1.1.7.1.7',
  'fcConnUnitLinkTable' => '1.3.6.1.2.1.8888.1.1.8',
  'fcConnUnitLinkEntry' => '1.3.6.1.2.1.8888.1.1.8.1',
  'fcConnUnitLinkIndex' => '1.3.6.1.2.1.8888.1.1.8.1.1',
  'fcConnUnitLinkNodeIdX' => '1.3.6.1.2.1.8888.1.1.8.1.2',
  'fcConnUnitLinkPortWwnX' => '1.3.6.1.2.1.8888.1.1.8.1.4',
  'fcConnUnitLinkNodeIdY' => '1.3.6.1.2.1.8888.1.1.8.1.5',
  'fcConnUnitLinkPortNumberY' => '1.3.6.1.2.1.8888.1.1.8.1.6',
  'fcConnUnitLinkPortWwnY' => '1.3.6.1.2.1.8888.1.1.8.1.7',
  'fcConnUnitLinkAgentAddressY' => '1.3.6.1.2.1.8888.1.1.8.1.8',
  'fcConnUnitLinkAgentAddressTypeY' => '1.3.6.1.2.1.8888.1.1.8.1.9',
  'fcConnUnitLinkAgentPortY' => '1.3.6.1.2.1.8888.1.1.8.1.10',
  'fcConnUnitLinkUnitTypeY' => '1.3.6.1.2.1.8888.1.1.8.1.11',
  'fcConnUnitLinkConnIdY' => '1.3.6.1.2.1.8888.1.1.8.1.12',
  'fcConnUnitSnsMaxRows' => '1.3.6.1.2.1.8888.1.1.9.0',
  'fcConnUnitSnsTable' => '1.3.6.1.2.1.8888.1.4.1',
  'fcConnUnitSnsEntry' => '1.3.6.1.2.1.8888.1.4.1.1',
  'fcConnUnitSnsPortIndex' => '1.3.6.1.2.1.8888.1.4.1.1.1',
  'fcConnUnitSnsPortIdentifier' => '1.3.6.1.2.1.8888.1.4.1.1.2',
  'fcConnUnitSnsNodeName' => '1.3.6.1.2.1.8888.1.4.1.1.4',
  'fcConnUnitSnsClassOfSvc' => '1.3.6.1.2.1.8888.1.4.1.1.5',
  'fcConnUnitSnsNodeIPAddress' => '1.3.6.1.2.1.8888.1.4.1.1.6',
  'fcConnUnitSnsProcAssoc' => '1.3.6.1.2.1.8888.1.4.1.1.7',
  'fcConnUnitSnsFC4Type' => '1.3.6.1.2.1.8888.1.4.1.1.8',
  'fcConnUnitSnsPortType' => '1.3.6.1.2.1.8888.1.4.1.1.9',
  'fcConnUnitSnsPortIPAddress' => '1.3.6.1.2.1.8888.1.4.1.1.10',
  'fcConnUnitSnsFabricPortName' => '1.3.6.1.2.1.8888.1.4.1.1.11',
  'fcConnUnitSnsHardAddress' => '1.3.6.1.2.1.8888.1.4.1.1.12',
  'fcConnUnitSnsSymbolicPortName' => '1.3.6.1.2.1.8888.1.4.1.1.13',
  'fcConnUnitSnsSymbolicNodeName' => '1.3.6.1.2.1.8888.1.4.1.1.14',
  'fcConnUnitPortStatRxBcastObjects' => '1.30',
  'fcConnUnitPortStatTxBcastObjects' => '1.31',
  'fcConnUnitPortStatRxLinkResets' => '1.32',
  'fcConnUnitPortStatTxLinkResets' => '1.33',
  'fcConnUnitPortStatLinkResets' => '1.34',
  'fcConnUnitPortStatRxOfflineSeqs' => '1.35',
  'fcConnUnitPortStatTxOfflineSeqs' => '1.36',
  'fcConnUnitPortStatOfflineSeqs' => '1.37',
  'fcConnUnitPortStatLinkFailures' => '1.38',
  'fcConnUnitPortStatInvalidCRC' => '1.39',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::FORTINETFORTIGATEMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'FORTINET-FORTIGATE-MIB'} = {
  url => '',
  name => 'FORTINET-FORTIGATE-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'FORTINET-FORTIGATE-MIB'} = {
  'fgSystem' => '1.3.6.1.4.1.12356.101.4',
  'fgSystemInfo' => '1.3.6.1.4.1.12356.101.4.1',
  'fgSysVersion' => '1.3.6.1.4.1.12356.101.4.1.1.0',
  'fgSysMgmtVdom' => '1.3.6.1.4.1.12356.101.4.1.2.0',
  'fgSysCpuUsage' => '1.3.6.1.4.1.12356.101.4.1.3.0',
  'fgSysMemUsage' => '1.3.6.1.4.1.12356.101.4.1.4.0',
  'fgSysMemCapacity' => '1.3.6.1.4.1.12356.101.4.1.5.0',
  'fgSysDiskUsage' => '1.3.6.1.4.1.12356.101.4.1.6.0',
  'fgSysDiskCapacity' => '1.3.6.1.4.1.12356.101.4.1.7.0',
  'fgSysSesCount' => '1.3.6.1.4.1.12356.101.4.1.8.0',
  'fgSoftware' => '1.3.6.1.4.1.12356.101.4.2',
  'fgSysVersionAv' => '1.3.6.1.4.1.12356.101.4.2.1.0',
  'fgSysVersionIps' => '1.3.6.1.4.1.12356.101.4.2.2.0',
  'fgHwSensors' => '1.3.6.1.4.1.12356.101.4.3',
  'fgHwSensorCount' => '1.3.6.1.4.1.12356.101.4.3.1.0',
  'fgHwSensorTable' => '1.3.6.1.4.1.12356.101.4.3.2',
  'fgHwSensorEntry' => '1.3.6.1.4.1.12356.101.4.3.2.1',
  'fgHwSensorEntIndex' => '1.3.6.1.4.1.12356.101.4.3.2.1.1',
  'fgHwSensorEntName' => '1.3.6.1.4.1.12356.101.4.3.2.1.2',
  'fgHwSensorEntValue' => '1.3.6.1.4.1.12356.101.4.3.2.1.3',
  'fgHwSensorEntAlarmStatus' => '1.3.6.1.4.1.12356.101.4.3.2.1.4',
  'fgHwSensorEntAlarmStatusDefinition' => {
    '0' => 'false',
    '1' => 'true',
  },
  'fgFirewall' => '1.3.6.1.4.1.12356.101.5',
  'fgFwPolicies' => '1.3.6.1.4.1.12356.101.5.1',
  'fgFwPolInfo' => '1.3.6.1.4.1.12356.101.5.1.1',
  'fgFwPolTables' => '1.3.6.1.4.1.12356.101.5.1.2',
  'fgFwPolStatsTable' => '1.3.6.1.4.1.12356.101.5.1.2.1',
  'fgFwPolStatsEntry' => '1.3.6.1.4.1.12356.101.5.1.2.1.1',
  'fgFwPolID' => '1.3.6.1.4.1.12356.101.5.1.2.1.1.1',
  'fgFwPolPktCount' => '1.3.6.1.4.1.12356.101.5.1.2.1.1.2',
  'fgFwPolByteCount' => '1.3.6.1.4.1.12356.101.5.1.2.1.1.3',
  'fgFwUsers' => '1.3.6.1.4.1.12356.101.5.2',
  'fgFwUserInfo' => '1.3.6.1.4.1.12356.101.5.2.1',
  'fgFwUserNumber' => '1.3.6.1.4.1.12356.101.5.2.1.1.0',
  'fgFwUserAuthTimeout' => '1.3.6.1.4.1.12356.101.5.2.1.2.0',
  'fgFwUserTables' => '1.3.6.1.4.1.12356.101.5.2.2',
  'fgFwUserTable' => '1.3.6.1.4.1.12356.101.5.2.2.1',
  'fgFwUserEntry' => '1.3.6.1.4.1.12356.101.5.2.2.1.1',
  'fgFwUserIndex' => '1.3.6.1.4.1.12356.101.5.2.2.1.1.1',
  'fgFwUserName' => '1.3.6.1.4.1.12356.101.5.2.2.1.1.2',
  'fgFwUserAuth' => '1.3.6.1.4.1.12356.101.5.2.2.1.1.3',
  'fgFwUserState' => '1.3.6.1.4.1.12356.101.5.2.2.1.1.4',
  'fgFwUserVdom' => '1.3.6.1.4.1.12356.101.5.2.2.1.1.5',
  'fgMgmt' => '1.3.6.1.4.1.12356.101.6',
  'fgFmTrapPrefix' => '1.3.6.1.4.1.12356.101.6.0',
  'fgAdmin' => '1.3.6.1.4.1.12356.101.6.1',
  'fgAdminOptions' => '1.3.6.1.4.1.12356.101.6.1.1',
  'fgAdminIdleTimeout' => '1.3.6.1.4.1.12356.101.6.1.1.1.0',
  'fgAdminLcdProtection' => '1.3.6.1.4.1.12356.101.6.1.1.2.0',
  'fgAdminTables' => '1.3.6.1.4.1.12356.101.6.1.2',
  'fgAdminTable' => '1.3.6.1.4.1.12356.101.6.1.2.1',
  'fgAdminEntry' => '1.3.6.1.4.1.12356.101.6.1.2.1.1',
  'fgAdminVdom' => '1.3.6.1.4.1.12356.101.6.1.2.1.1.1',
  'fgMgmtTrapObjects' => '1.3.6.1.4.1.12356.101.6.2',
  'fgManIfIp' => '1.3.6.1.4.1.12356.101.6.2.1.0',
  'fgManIfMask' => '1.3.6.1.4.1.12356.101.6.2.2.0',
  'fgIntf' => '1.3.6.1.4.1.12356.101.7',
  'fgIntfInfo' => '1.3.6.1.4.1.12356.101.7.1',
  'fgIntfTables' => '1.3.6.1.4.1.12356.101.7.2',
  'fgIntfTable' => '1.3.6.1.4.1.12356.101.7.2.1',
  'fgIntfEntry' => '1.3.6.1.4.1.12356.101.7.2.1.1',
  'fgIntfEntVdom' => '1.3.6.1.4.1.12356.101.7.2.1.1.1',
  'fgAntivirus' => '1.3.6.1.4.1.12356.101.8',
  'fgAvInfo' => '1.3.6.1.4.1.12356.101.8.1',
  'fgAvTables' => '1.3.6.1.4.1.12356.101.8.2',
  'fgAvStatsTable' => '1.3.6.1.4.1.12356.101.8.2.1',
  'fgAvStatsEntry' => '1.3.6.1.4.1.12356.101.8.2.1.1',
  'fgAvVirusDetected' => '1.3.6.1.4.1.12356.101.8.2.1.1.1',
  'fgAvVirusBlocked' => '1.3.6.1.4.1.12356.101.8.2.1.1.2',
  'fgAvHTTPVirusDetected' => '1.3.6.1.4.1.12356.101.8.2.1.1.3',
  'fgAvHTTPVirusBlocked' => '1.3.6.1.4.1.12356.101.8.2.1.1.4',
  'fgAvSMTPVirusDetected' => '1.3.6.1.4.1.12356.101.8.2.1.1.5',
  'fgAvSMTPVirusBlocked' => '1.3.6.1.4.1.12356.101.8.2.1.1.6',
  'fgAvPOP3VirusDetected' => '1.3.6.1.4.1.12356.101.8.2.1.1.7',
  'fgAvPOP3VirusBlocked' => '1.3.6.1.4.1.12356.101.8.2.1.1.8',
  'fgAvIMAPVirusDetected' => '1.3.6.1.4.1.12356.101.8.2.1.1.9',
  'fgAvIMAPVirusBlocked' => '1.3.6.1.4.1.12356.101.8.2.1.1.10',
  'fgAvFTPVirusDetected' => '1.3.6.1.4.1.12356.101.8.2.1.1.11',
  'fgAvFTPVirusBlocked' => '1.3.6.1.4.1.12356.101.8.2.1.1.12',
  'fgAvIMVirusDetected' => '1.3.6.1.4.1.12356.101.8.2.1.1.13',
  'fgAvIMVirusBlocked' => '1.3.6.1.4.1.12356.101.8.2.1.1.14',
  'fgAvNNTPVirusDetected' => '1.3.6.1.4.1.12356.101.8.2.1.1.15',
  'fgAvNNTPVirusBlocked' => '1.3.6.1.4.1.12356.101.8.2.1.1.16',
  'fgAvOversizedDetected' => '1.3.6.1.4.1.12356.101.8.2.1.1.17',
  'fgAvOversizedBlocked' => '1.3.6.1.4.1.12356.101.8.2.1.1.18',
  'fgAvTrapObjects' => '1.3.6.1.4.1.12356.101.8.3',
  'fgAvTrapVirName' => '1.3.6.1.4.1.12356.101.8.3.1.0',
  'fgIps' => '1.3.6.1.4.1.12356.101.9',
  'fgIpsInfo' => '1.3.6.1.4.1.12356.101.9.1',
  'fgIpsTables' => '1.3.6.1.4.1.12356.101.9.2',
  'fgIpsStatsTable' => '1.3.6.1.4.1.12356.101.9.2.1',
  'fgIpsStatsEntry' => '1.3.6.1.4.1.12356.101.9.2.1.1',
  'fgIpsIntrusionsDetected' => '1.3.6.1.4.1.12356.101.9.2.1.1.1',
  'fgIpsIntrusionsBlocked' => '1.3.6.1.4.1.12356.101.9.2.1.1.2',
  'fgIpsCritSevDetections' => '1.3.6.1.4.1.12356.101.9.2.1.1.3',
  'fgIpsHighSevDetections' => '1.3.6.1.4.1.12356.101.9.2.1.1.4',
  'fgIpsMedSevDetections' => '1.3.6.1.4.1.12356.101.9.2.1.1.5',
  'fgIpsLowSevDetections' => '1.3.6.1.4.1.12356.101.9.2.1.1.6',
  'fgIpsInfoSevDetections' => '1.3.6.1.4.1.12356.101.9.2.1.1.7',
  'fgIpsSignatureDetections' => '1.3.6.1.4.1.12356.101.9.2.1.1.8',
  'fgIpsAnomalyDetections' => '1.3.6.1.4.1.12356.101.9.2.1.1.9',
  'fgIpsTrapObjects' => '1.3.6.1.4.1.12356.101.9.3',
  'fgIpsTrapSigId' => '1.3.6.1.4.1.12356.101.9.3.1.0',
  'fgIpsTrapSrcIp' => '1.3.6.1.4.1.12356.101.9.3.2.0',
  'fgIpsTrapSigMsg' => '1.3.6.1.4.1.12356.101.9.3.3.0',
  'fgApplications' => '1.3.6.1.4.1.12356.101.10',
  'fgWebfilter' => '1.3.6.1.4.1.12356.101.10.1',
  'fgWebfilterInfo' => '1.3.6.1.4.1.12356.101.10.1.1',
  'fgWebfilterTables' => '1.3.6.1.4.1.12356.101.10.1.2',
  'fgWebfilterStatsTable' => '1.3.6.1.4.1.12356.101.10.1.2.1',
  'fgWebfilterStatsEntry' => '1.3.6.1.4.1.12356.101.10.1.2.1.1',
  'fgWfHTTPBlocked' => '1.3.6.1.4.1.12356.101.10.1.2.1.1.1',
  'fgWfHTTPSBlocked' => '1.3.6.1.4.1.12356.101.10.1.2.1.1.2',
  'fgWfHTTPURLBlocked' => '1.3.6.1.4.1.12356.101.10.1.2.1.1.3',
  'fgWfHTTPSURLBlocked' => '1.3.6.1.4.1.12356.101.10.1.2.1.1.4',
  'fgWfActiveXBlocked' => '1.3.6.1.4.1.12356.101.10.1.2.1.1.5',
  'fgWfCookieBlocked' => '1.3.6.1.4.1.12356.101.10.1.2.1.1.6',
  'fgWfAppletBlocked' => '1.3.6.1.4.1.12356.101.10.1.2.1.1.7',
  'fgFortiGuardStatsTable' => '1.3.6.1.4.1.12356.101.10.1.2.2',
  'fgFortiGuardStatsEntry' => '1.3.6.1.4.1.12356.101.10.1.2.2.1',
  'fgFgWfHTTPExamined' => '1.3.6.1.4.1.12356.101.10.1.2.2.1.1',
  'fgFgWfHTTPSExamined' => '1.3.6.1.4.1.12356.101.10.1.2.2.1.2',
  'fgFgWfHTTPAllowed' => '1.3.6.1.4.1.12356.101.10.1.2.2.1.3',
  'fgFgWfHTTPSAllowed' => '1.3.6.1.4.1.12356.101.10.1.2.2.1.4',
  'fgFgWfHTTPBlocked' => '1.3.6.1.4.1.12356.101.10.1.2.2.1.5',
  'fgFgWfHTTPSBlocked' => '1.3.6.1.4.1.12356.101.10.1.2.2.1.6',
  'fgFgWfHTTPLogged' => '1.3.6.1.4.1.12356.101.10.1.2.2.1.7',
  'fgFgWfHTTPSLogged' => '1.3.6.1.4.1.12356.101.10.1.2.2.1.8',
  'fgFgWfHTTPOverridden' => '1.3.6.1.4.1.12356.101.10.1.2.2.1.9',
  'fgFgWfHTTPSOverridden' => '1.3.6.1.4.1.12356.101.10.1.2.2.1.10',
  'fgAppProxyHTTP' => '1.3.6.1.4.1.12356.101.10.100',
  'fgApHTTPUpTime' => '1.3.6.1.4.1.12356.101.10.100.1.0',
  'fgApHTTPMemUsage' => '1.3.6.1.4.1.12356.101.10.100.2.0',
  'fgApHTTPStatsTable' => '1.3.6.1.4.1.12356.101.10.100.3',
  'fgApHTTPStatsEntry' => '1.3.6.1.4.1.12356.101.10.100.3.1',
  'fgApHTTPReqProcessed' => '1.3.6.1.4.1.12356.101.10.100.3.1.1',
  'fgAppProxySMTP' => '1.3.6.1.4.1.12356.101.10.101',
  'fgApSMTPUpTime' => '1.3.6.1.4.1.12356.101.10.101.1.0',
  'fgApSMTPMemUsage' => '1.3.6.1.4.1.12356.101.10.101.2.0',
  'fgApSMTPStatsTable' => '1.3.6.1.4.1.12356.101.10.101.3',
  'fgApSMTPStatsEntry' => '1.3.6.1.4.1.12356.101.10.101.3.1',
  'fgApSMTPReqProcessed' => '1.3.6.1.4.1.12356.101.10.101.3.1.1',
  'fgApSMTPSpamDetected' => '1.3.6.1.4.1.12356.101.10.101.3.1.2',
  'fgAppProxyPOP3' => '1.3.6.1.4.1.12356.101.10.102',
  'fgApPOP3UpTime' => '1.3.6.1.4.1.12356.101.10.102.1.0',
  'fgApPOP3MemUsage' => '1.3.6.1.4.1.12356.101.10.102.2.0',
  'fgApPOP3StatsTable' => '1.3.6.1.4.1.12356.101.10.102.3',
  'fgApPOP3StatsEntry' => '1.3.6.1.4.1.12356.101.10.102.3.1',
  'fgApPOP3ReqProcessed' => '1.3.6.1.4.1.12356.101.10.102.3.1.1',
  'fgApPOP3SpamDetected' => '1.3.6.1.4.1.12356.101.10.102.3.1.2',
  'fgAppProxyIMAP' => '1.3.6.1.4.1.12356.101.10.103',
  'fgApIMAPUpTime' => '1.3.6.1.4.1.12356.101.10.103.1.0',
  'fgApIMAPMemUsage' => '1.3.6.1.4.1.12356.101.10.103.2.0',
  'fgApIMAPStatsTable' => '1.3.6.1.4.1.12356.101.10.103.3',
  'fgApIMAPStatsEntry' => '1.3.6.1.4.1.12356.101.10.103.3.1',
  'fgApIMAPReqProcessed' => '1.3.6.1.4.1.12356.101.10.103.3.1.1',
  'fgApIMAPSpamDetected' => '1.3.6.1.4.1.12356.101.10.103.3.1.2',
  'fgAppProxyNNTP' => '1.3.6.1.4.1.12356.101.10.104',
  'fgApNNTPUpTime' => '1.3.6.1.4.1.12356.101.10.104.1.0',
  'fgApNNTPMemUsage' => '1.3.6.1.4.1.12356.101.10.104.2.0',
  'fgApNNTPStatsTable' => '1.3.6.1.4.1.12356.101.10.104.3',
  'fgApNNTPStatsEntry' => '1.3.6.1.4.1.12356.101.10.104.3.1',
  'fgApNNTPReqProcessed' => '1.3.6.1.4.1.12356.101.10.104.3.1.1',
  'fgAppProxyIM' => '1.3.6.1.4.1.12356.101.10.105',
  'fgApIMUpTime' => '1.3.6.1.4.1.12356.101.10.105.1.0',
  'fgApIMMemUsage' => '1.3.6.1.4.1.12356.101.10.105.2.0',
  'fgApIMStatsTable' => '1.3.6.1.4.1.12356.101.10.105.3',
  'fgApIMStatsEntry' => '1.3.6.1.4.1.12356.101.10.105.3.1',
  'fgApIMReqProcessed' => '1.3.6.1.4.1.12356.101.10.105.3.1.1',
  'fgAppProxySIP' => '1.3.6.1.4.1.12356.101.10.106',
  'fgApSIPUpTime' => '1.3.6.1.4.1.12356.101.10.106.1.0',
  'fgApSIPMemUsage' => '1.3.6.1.4.1.12356.101.10.106.2.0',
  'fgApSIPStatsTable' => '1.3.6.1.4.1.12356.101.10.106.3',
  'fgApSIPStatsEntry' => '1.3.6.1.4.1.12356.101.10.106.3.1',
  'fgApSIPClientReg' => '1.3.6.1.4.1.12356.101.10.106.3.1.1',
  'fgApSIPCallHandling' => '1.3.6.1.4.1.12356.101.10.106.3.1.2',
  'fgApSIPServices' => '1.3.6.1.4.1.12356.101.10.106.3.1.3',
  'fgApSIPOtherReq' => '1.3.6.1.4.1.12356.101.10.106.3.1.4',
  'fgAppScanUnit' => '1.3.6.1.4.1.12356.101.10.107',
  'fgAppSuNumber' => '1.3.6.1.4.1.12356.101.10.107.1.0',
  'fgAppSuStatsTable' => '1.3.6.1.4.1.12356.101.10.107.2',
  'fgAppSuStatsEntry' => '1.3.6.1.4.1.12356.101.10.107.2.1',
  'fgAppSuIndex' => '1.3.6.1.4.1.12356.101.10.107.2.1.1',
  'fgAppSuFileScanned' => '1.3.6.1.4.1.12356.101.10.107.2.1.2',
  'fgAppVoIP' => '1.3.6.1.4.1.12356.101.10.108',
  'fgAppVoIPStatsTable' => '1.3.6.1.4.1.12356.101.10.108.1',
  'fgAppVoIPStatsEntry' => '1.3.6.1.4.1.12356.101.10.108.1.1',
  'fgAppVoIPConn' => '1.3.6.1.4.1.12356.101.10.108.1.1.1',
  'fgAppVoIPCallBlocked' => '1.3.6.1.4.1.12356.101.10.108.1.1.2',
  'fgAppP2P' => '1.3.6.1.4.1.12356.101.10.109',
  'fgAppP2PStatsTable' => '1.3.6.1.4.1.12356.101.10.109.1',
  'fgAppP2PStatsEntry' => '1.3.6.1.4.1.12356.101.10.109.1.1',
  'fgAppP2PConnBlocked' => '1.3.6.1.4.1.12356.101.10.109.1.1.1',
  'fgAppP2PProtoTable' => '1.3.6.1.4.1.12356.101.10.109.2',
  'fgAppP2PProtoEntry' => '1.3.6.1.4.1.12356.101.10.109.2.1',
  'fgAppP2PProtEntProto' => '1.3.6.1.4.1.12356.101.10.109.2.1.1',
  'fgAppP2PProtEntBytes' => '1.3.6.1.4.1.12356.101.10.109.2.1.2',
  'fgAppP2PProtoEntLastReset' => '1.3.6.1.4.1.12356.101.10.109.2.1.3',
  'fgAppIM' => '1.3.6.1.4.1.12356.101.10.110',
  'fgAppIMStatsTable' => '1.3.6.1.4.1.12356.101.10.110.1',
  'fgAppIMStatsEntry' => '1.3.6.1.4.1.12356.101.10.110.1.1',
  'fgAppIMMessages' => '1.3.6.1.4.1.12356.101.10.110.1.1.1',
  'fgAppIMFileTransfered' => '1.3.6.1.4.1.12356.101.10.110.1.1.2',
  'fgAppIMFileTxBlocked' => '1.3.6.1.4.1.12356.101.10.110.1.1.3',
  'fgAppIMConnBlocked' => '1.3.6.1.4.1.12356.101.10.110.1.1.4',
  'fgAppProxyFTP' => '1.3.6.1.4.1.12356.101.10.111',
  'fgApFTPUpTime' => '1.3.6.1.4.1.12356.101.10.111.1.0',
  'fgApFTPMemUsage' => '1.3.6.1.4.1.12356.101.10.111.2.0',
  'fgApFTPStatsTable' => '1.3.6.1.4.1.12356.101.10.111.3',
  'fgApFTPStatsEntry' => '1.3.6.1.4.1.12356.101.10.111.3.1',
  'fgApFTPReqProcessed' => '1.3.6.1.4.1.12356.101.10.111.3.1.1',
  'fgInetProto' => '1.3.6.1.4.1.12356.101.11',
  'fgInetProtoInfo' => '1.3.6.1.4.1.12356.101.11.1',
  'fgInetProtoTables' => '1.3.6.1.4.1.12356.101.11.2',
  'fgIpSessTable' => '1.3.6.1.4.1.12356.101.11.2.1',
  'fgIpSessEntry' => '1.3.6.1.4.1.12356.101.11.2.1.1',
  'fgIpSessIndex' => '1.3.6.1.4.1.12356.101.11.2.1.1.1',
  'fgIpSessProto' => '1.3.6.1.4.1.12356.101.11.2.1.1.2',
  'fgIpSessFromAddr' => '1.3.6.1.4.1.12356.101.11.2.1.1.3',
  'fgIpSessFromPort' => '1.3.6.1.4.1.12356.101.11.2.1.1.4',
  'fgIpSessToAddr' => '1.3.6.1.4.1.12356.101.11.2.1.1.5',
  'fgIpSessToPort' => '1.3.6.1.4.1.12356.101.11.2.1.1.6',
  'fgIpSessExp' => '1.3.6.1.4.1.12356.101.11.2.1.1.7',
  'fgIpSessVdom' => '1.3.6.1.4.1.12356.101.11.2.1.1.8',
  'fgIpSessStatsTable' => '1.3.6.1.4.1.12356.101.11.2.2',
  'fgIpSessStatsEntry' => '1.3.6.1.4.1.12356.101.11.2.2.1',
  'fgIpSessNumber' => '1.3.6.1.4.1.12356.101.11.2.2.1.1',
  'fgVpn' => '1.3.6.1.4.1.12356.101.12',
  'fgVpnInfo' => '1.3.6.1.4.1.12356.101.12.1',
  'fgVpnTables' => '1.3.6.1.4.1.12356.101.12.2',
  'fgVpnDialupTable' => '1.3.6.1.4.1.12356.101.12.2.1',
  'fgVpnDialupEntry' => '1.3.6.1.4.1.12356.101.12.2.1.1',
  'fgVpnDialupIndex' => '1.3.6.1.4.1.12356.101.12.2.1.1.1',
  'fgVpnDialupGateway' => '1.3.6.1.4.1.12356.101.12.2.1.1.2',
  'fgVpnDialupLifetime' => '1.3.6.1.4.1.12356.101.12.2.1.1.3',
  'fgVpnDialupTimeout' => '1.3.6.1.4.1.12356.101.12.2.1.1.4',
  'fgVpnDialupSrcBegin' => '1.3.6.1.4.1.12356.101.12.2.1.1.5',
  'fgVpnDialupSrcEnd' => '1.3.6.1.4.1.12356.101.12.2.1.1.6',
  'fgVpnDialupDstAddr' => '1.3.6.1.4.1.12356.101.12.2.1.1.7',
  'fgVpnDialupVdom' => '1.3.6.1.4.1.12356.101.12.2.1.1.8',
  'fgVpnDialupInOctets' => '1.3.6.1.4.1.12356.101.12.2.1.1.9',
  'fgVpnDialupOutOctets' => '1.3.6.1.4.1.12356.101.12.2.1.1.10',
  'fgVpnTunTable' => '1.3.6.1.4.1.12356.101.12.2.2',
  'fgVpnTunEntry' => '1.3.6.1.4.1.12356.101.12.2.2.1',
  'fgVpnTunEntIndex' => '1.3.6.1.4.1.12356.101.12.2.2.1.1',
  'fgVpnTunEntPhase1Name' => '1.3.6.1.4.1.12356.101.12.2.2.1.2',
  'fgVpnTunEntPhase2Name' => '1.3.6.1.4.1.12356.101.12.2.2.1.3',
  'fgVpnTunEntRemGwyIp' => '1.3.6.1.4.1.12356.101.12.2.2.1.4',
  'fgVpnTunEntRemGwyPort' => '1.3.6.1.4.1.12356.101.12.2.2.1.5',
  'fgVpnTunEntLocGwyIp' => '1.3.6.1.4.1.12356.101.12.2.2.1.6',
  'fgVpnTunEntLocGwyPort' => '1.3.6.1.4.1.12356.101.12.2.2.1.7',
  'fgVpnTunEntSelectorSrcBeginIp' => '1.3.6.1.4.1.12356.101.12.2.2.1.8',
  'fgVpnTunEntSelectorSrcEndIp' => '1.3.6.1.4.1.12356.101.12.2.2.1.9',
  'fgVpnTunEntSelectorSrcPort' => '1.3.6.1.4.1.12356.101.12.2.2.1.10',
  'fgVpnTunEntSelectorDstBeginIp' => '1.3.6.1.4.1.12356.101.12.2.2.1.11',
  'fgVpnTunEntSelectorDstEndIp' => '1.3.6.1.4.1.12356.101.12.2.2.1.12',
  'fgVpnTunEntSelectorDstPort' => '1.3.6.1.4.1.12356.101.12.2.2.1.13',
  'fgVpnTunEntSelectorProto' => '1.3.6.1.4.1.12356.101.12.2.2.1.14',
  'fgVpnTunEntLifeSecs' => '1.3.6.1.4.1.12356.101.12.2.2.1.15',
  'fgVpnTunEntLifeBytes' => '1.3.6.1.4.1.12356.101.12.2.2.1.16',
  'fgVpnTunEntTimeout' => '1.3.6.1.4.1.12356.101.12.2.2.1.17',
  'fgVpnTunEntInOctets' => '1.3.6.1.4.1.12356.101.12.2.2.1.18',
  'fgVpnTunEntOutOctets' => '1.3.6.1.4.1.12356.101.12.2.2.1.19',
  'fgVpnTunEntStatus' => '1.3.6.1.4.1.12356.101.12.2.2.1.20',
  'fgVpnTunEntVdom' => '1.3.6.1.4.1.12356.101.12.2.2.1.21',
  'fgVpnSslStatsTable' => '1.3.6.1.4.1.12356.101.12.2.3',
  'fgVpnSslStatsEntry' => '1.3.6.1.4.1.12356.101.12.2.3.1',
  'fgVpnSslState' => '1.3.6.1.4.1.12356.101.12.2.3.1.1',
  'fgVpnSslStatsLoginUsers' => '1.3.6.1.4.1.12356.101.12.2.3.1.2',
  'fgVpnSslStatsMaxUsers' => '1.3.6.1.4.1.12356.101.12.2.3.1.3',
  'fgVpnSslStatsActiveWebSessions' => '1.3.6.1.4.1.12356.101.12.2.3.1.4',
  'fgVpnSslStatsMaxWebSessions' => '1.3.6.1.4.1.12356.101.12.2.3.1.5',
  'fgVpnSslStatsActiveTunnels' => '1.3.6.1.4.1.12356.101.12.2.3.1.6',
  'fgVpnSslStatsMaxTunnels' => '1.3.6.1.4.1.12356.101.12.2.3.1.7',
  'fgVpnSslTunnelTable' => '1.3.6.1.4.1.12356.101.12.2.4',
  'fgVpnSslTunnelEntry' => '1.3.6.1.4.1.12356.101.12.2.4.1',
  'fgVpnSslTunnelIndex' => '1.3.6.1.4.1.12356.101.12.2.4.1.1',
  'fgVpnSslTunnelVdom' => '1.3.6.1.4.1.12356.101.12.2.4.1.2',
  'fgVpnSslTunnelUserName' => '1.3.6.1.4.1.12356.101.12.2.4.1.3',
  'fgVpnSslTunnelSrcIp' => '1.3.6.1.4.1.12356.101.12.2.4.1.4',
  'fgVpnSslTunnelIp' => '1.3.6.1.4.1.12356.101.12.2.4.1.5',
  'fgVpnSslTunnelUpTime' => '1.3.6.1.4.1.12356.101.12.2.4.1.6',
  'fgVpnSslTunnelBytesIn' => '1.3.6.1.4.1.12356.101.12.2.4.1.7',
  'fgVpnSslTunnelBytesOut' => '1.3.6.1.4.1.12356.101.12.2.4.1.8',
  'fgVpnTrapObjects' => '1.3.6.1.4.1.12356.101.12.3',
  'fgVpnTrapLocalGateway' => '1.3.6.1.4.1.12356.101.12.3.2.0',
  'fgVpnTrapRemoteGateway' => '1.3.6.1.4.1.12356.101.12.3.3.0',
  'fgHighAvailability' => '1.3.6.1.4.1.12356.101.13',
  'fgHaInfo' => '1.3.6.1.4.1.12356.101.13.1',
  'fgHaSystemMode' => '1.3.6.1.4.1.12356.101.13.1.1.0',
  'fgHaGroupId' => '1.3.6.1.4.1.12356.101.13.1.2.0',
  'fgHaPriority' => '1.3.6.1.4.1.12356.101.13.1.3.0',
  'fgHaOverride' => '1.3.6.1.4.1.12356.101.13.1.4.0',
  'fgHaAutoSync' => '1.3.6.1.4.1.12356.101.13.1.5.0',
  'fgHaSchedule' => '1.3.6.1.4.1.12356.101.13.1.6.0',
  'fgHaGroupName' => '1.3.6.1.4.1.12356.101.13.1.7.0',
  'fgHaTables' => '1.3.6.1.4.1.12356.101.13.2',
  'fgHaStatsTable' => '1.3.6.1.4.1.12356.101.13.2.1',
  'fgHaStatsEntry' => '1.3.6.1.4.1.12356.101.13.2.1.1',
  'fgHaStatsIndex' => '1.3.6.1.4.1.12356.101.13.2.1.1.1',
  'fgHaStatsSerial' => '1.3.6.1.4.1.12356.101.13.2.1.1.2',
  'fgHaStatsCpuUsage' => '1.3.6.1.4.1.12356.101.13.2.1.1.3',
  'fgHaStatsMemUsage' => '1.3.6.1.4.1.12356.101.13.2.1.1.4',
  'fgHaStatsNetUsage' => '1.3.6.1.4.1.12356.101.13.2.1.1.5',
  'fgHaStatsSesCount' => '1.3.6.1.4.1.12356.101.13.2.1.1.6',
  'fgHaStatsPktCount' => '1.3.6.1.4.1.12356.101.13.2.1.1.7',
  'fgHaStatsByteCount' => '1.3.6.1.4.1.12356.101.13.2.1.1.8',
  'fgHaStatsIdsCount' => '1.3.6.1.4.1.12356.101.13.2.1.1.9',
  'fgHaStatsAvCount' => '1.3.6.1.4.1.12356.101.13.2.1.1.10',
  'fgHaStatsHostname' => '1.3.6.1.4.1.12356.101.13.2.1.1.11',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::FOUNDRYSNAGENTMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'FOUNDRY-SN-AGENT-MIB'} = {
  url => '',
  name => 'FOUNDRY-SN-AGENT-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'FOUNDRY-SN-AGENT-MIB'} = {
  'snChasPwrSupplyTable' => '1.3.6.1.4.1.1991.1.1.1.2.1',
  'snChasPwrSupplyEntry' => '1.3.6.1.4.1.1991.1.1.1.2.1.1',
  'snChasPwrSupplyIndex' => '1.3.6.1.4.1.1991.1.1.1.2.1.1.1',
  'snChasPwrSupplyDescription' => '1.3.6.1.4.1.1991.1.1.1.2.1.1.2',
  'snChasPwrSupplyOperStatus' => '1.3.6.1.4.1.1991.1.1.1.2.1.1.3',
  'snChasPwrSupplyOperStatusDefinition' => {
    '1' => 'other',
    '2' => 'normal',
    '3' => 'failure',
  },
  'snChasFan' => '1.3.6.1.4.1.1991.1.1.1.3',
  'snChasFanTable' => '1.3.6.1.4.1.1991.1.1.1.3.1',
  'snChasFanEntry' => '1.3.6.1.4.1.1991.1.1.1.3.1.1',
  'snChasFanIndex' => '1.3.6.1.4.1.1991.1.1.1.3.1.1.1',
  'snChasFanDescription' => '1.3.6.1.4.1.1991.1.1.1.3.1.1.2',
  'snChasFanOperStatus' => '1.3.6.1.4.1.1991.1.1.1.3.1.1.3',
  'snChasFanOperStatusDefinition' => {
    '1' => 'other',
    '2' => 'normal',
    '3' => 'failure',
  },
  'snAgGblCpuUtil1SecAvg' => '1.3.6.1.4.1.1991.1.1.2.1.50.0',
  'snAgGblCpuUtil5SecAvg' => '1.3.6.1.4.1.1991.1.1.2.1.51.0',
  'snAgGblCpuUtil1MinAvg' => '1.3.6.1.4.1.1991.1.1.2.1.52.0',
  'snAgGblDynMemUtil' => '1.3.6.1.4.1.1991.1.1.2.1.53.0',
  'snAgGblDynMemTotal' => '1.3.6.1.4.1.1991.1.1.2.1.54.0',
  'snAgGblDynMemFree' => '1.3.6.1.4.1.1991.1.1.2.1.55.0',
  'snAgentCpuUtilTable' => '1.3.6.1.4.1.1991.1.1.2.11.1',
  'snAgentCpuUtilEntry' => '1.3.6.1.4.1.1991.1.1.2.11.1.1',
  'snAgentCpuUtilSlotNum' => '1.3.6.1.4.1.1991.1.1.2.11.1.1.1',
  'snAgentCpuUtilCpuId' => '1.3.6.1.4.1.1991.1.1.2.11.1.1.2',
  'snAgentCpuUtilInterval' => '1.3.6.1.4.1.1991.1.1.2.11.1.1.3',
  'snAgentCpuUtilValue' => '1.3.6.1.4.1.1991.1.1.2.11.1.1.4',
  'snAgentCpuUtilPercent' => '1.3.6.1.4.1.1991.1.1.2.11.1.1.5',
  'snAgentCpuUtil100thPercent' => '1.3.6.1.4.1.1991.1.1.2.11.1.1.6',
  'snAgentTempTable' => '1.3.6.1.4.1.1991.1.1.2.13.1',
  'snAgentTempEntry' => '1.3.6.1.4.1.1991.1.1.2.13.1.1',
  'snAgentTempSlotNum' => '1.3.6.1.4.1.1991.1.1.2.13.1.1.1',
  'snAgentTempSensorId' => '1.3.6.1.4.1.1991.1.1.2.13.1.1.2',
  'snAgentTempSensorDescr' => '1.3.6.1.4.1.1991.1.1.2.13.1.1.3',
  'snAgentTempValue' => '1.3.6.1.4.1.1991.1.1.2.13.1.1.4',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::FOUNDRYSNSWL4SWITCHGROUPMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB'} = {
  url => '',
  name => 'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB'} = {
  'snL4Gen' => '1.3.6.1.4.1.1991.1.1.4.1',
  'snL4MaxSessionLimit' => '1.3.6.1.4.1.1991.1.1.4.1.1.0',
  'snL4TcpSynLimit' => '1.3.6.1.4.1.1991.1.1.4.1.2.0',
  'snL4slbGlobalSDAType' => '1.3.6.1.4.1.1991.1.1.4.1.3.0',
  'snL4slbTotalConnections' => '1.3.6.1.4.1.1991.1.1.4.1.4.0',
  'snL4slbLimitExceeds' => '1.3.6.1.4.1.1991.1.1.4.1.5.0',
  'snL4slbForwardTraffic' => '1.3.6.1.4.1.1991.1.1.4.1.6.0',
  'snL4slbReverseTraffic' => '1.3.6.1.4.1.1991.1.1.4.1.7.0',
  'snL4slbDrops' => '1.3.6.1.4.1.1991.1.1.4.1.8.0',
  'snL4slbDangling' => '1.3.6.1.4.1.1991.1.1.4.1.9.0',
  'snL4slbDisableCount' => '1.3.6.1.4.1.1991.1.1.4.1.10.0',
  'snL4slbAged' => '1.3.6.1.4.1.1991.1.1.4.1.11.0',
  'snL4slbFinished' => '1.3.6.1.4.1.1991.1.1.4.1.12.0',
  'snL4FreeSessionCount' => '1.3.6.1.4.1.1991.1.1.4.1.13.0',
  'snL4BackupInterface' => '1.3.6.1.4.1.1991.1.1.4.1.14.0',
  'snL4BackupMacAddr' => '1.3.6.1.4.1.1991.1.1.4.1.15.0',
  'snL4Active' => '1.3.6.1.4.1.1991.1.1.4.1.16.0',
  'snL4Redundancy' => '1.3.6.1.4.1.1991.1.1.4.1.17.0',
  'snL4Backup' => '1.3.6.1.4.1.1991.1.1.4.1.18.0',
  'snL4BecomeActive' => '1.3.6.1.4.1.1991.1.1.4.1.19.0',
  'snL4BecomeStandBy' => '1.3.6.1.4.1.1991.1.1.4.1.20.0',
  'snL4BackupState' => '1.3.6.1.4.1.1991.1.1.4.1.21.0',
  'snL4NoPDUSent' => '1.3.6.1.4.1.1991.1.1.4.1.22.0',
  'snL4NoPDUCount' => '1.3.6.1.4.1.1991.1.1.4.1.23.0',
  'snL4NoPortMap' => '1.3.6.1.4.1.1991.1.1.4.1.24.0',
  'snL4unsuccessfulConn' => '1.3.6.1.4.1.1991.1.1.4.1.25.0',
  'snL4PingInterval' => '1.3.6.1.4.1.1991.1.1.4.1.26.0',
  'snL4PingRetry' => '1.3.6.1.4.1.1991.1.1.4.1.27.0',
  'snL4TcpAge' => '1.3.6.1.4.1.1991.1.1.4.1.28.0',
  'snL4UdpAge' => '1.3.6.1.4.1.1991.1.1.4.1.29.0',
  'snL4EnableMaxSessionLimitReachedTrap' => '1.3.6.1.4.1.1991.1.1.4.1.30.0',
  'snL4EnableTcpSynLimitReachedTrap' => '1.3.6.1.4.1.1991.1.1.4.1.31.0',
  'snL4EnableRealServerUpTrap' => '1.3.6.1.4.1.1991.1.1.4.1.32.0',
  'snL4EnableRealServerDownTrap' => '1.3.6.1.4.1.1991.1.1.4.1.33.0',
  'snL4EnableRealServerPortUpTrap' => '1.3.6.1.4.1.1991.1.1.4.1.34.0',
  'snL4EnableRealServerPortDownTrap' => '1.3.6.1.4.1.1991.1.1.4.1.35.0',
  'snL4EnableRealServerMaxConnLimitReachedTrap' => '1.3.6.1.4.1.1991.1.1.4.1.36.0',
  'snL4EnableBecomeStandbyTrap' => '1.3.6.1.4.1.1991.1.1.4.1.37.0',
  'snL4EnableBecomeActiveTrap' => '1.3.6.1.4.1.1991.1.1.4.1.38.0',
  'snL4slbRouterInterfacePortMask' => '1.3.6.1.4.1.1991.1.1.4.1.39.0',
  'snL4MaxNumWebCacheGroup' => '1.3.6.1.4.1.1991.1.1.4.1.40.0',
  'snL4MaxNumWebCachePerGroup' => '1.3.6.1.4.1.1991.1.1.4.1.41.0',
  'snL4WebCacheStateful' => '1.3.6.1.4.1.1991.1.1.4.1.42.0',
  'snL4EnableGslbHealthCheckIpUpTrap' => '1.3.6.1.4.1.1991.1.1.4.1.43.0',
  'snL4EnableGslbHealthCheckIpDownTrap' => '1.3.6.1.4.1.1991.1.1.4.1.44.0',
  'snL4EnableGslbHealthCheckIpPortUpTrap' => '1.3.6.1.4.1.1991.1.1.4.1.45.0',
  'snL4EnableGslbHealthCheckIpPortDownTrap' => '1.3.6.1.4.1.1991.1.1.4.1.46.0',
  'snL4EnableGslbRemoteGslbSiDownTrap' => '1.3.6.1.4.1.1991.1.1.4.1.47.0',
  'snL4EnableGslbRemoteGslbSiUpTrap' => '1.3.6.1.4.1.1991.1.1.4.1.48.0',
  'snL4EnableGslbRemoteSiDownTrap' => '1.3.6.1.4.1.1991.1.1.4.1.49.0',
  'snL4EnableGslbRemoteSiUpTrap' => '1.3.6.1.4.1.1991.1.1.4.1.50.0',
  'snL4slbRouterInterfacePortList' => '1.3.6.1.4.1.1991.1.1.4.1.51.0',
  'snL4VirtualServer' => '1.3.6.1.4.1.1991.1.1.4.2',
  'snL4VirtualServerTable' => '1.3.6.1.4.1.1991.1.1.4.2.1',
  'snL4VirtualServerEntry' => '1.3.6.1.4.1.1991.1.1.4.2.1.1',
  'snL4VirtualServerIndex' => '1.3.6.1.4.1.1991.1.1.4.2.1.1.1',
  'snL4VirtualServerName' => '1.3.6.1.4.1.1991.1.1.4.2.1.1.2',
  'snL4VirtualServerVirtualIP' => '1.3.6.1.4.1.1991.1.1.4.2.1.1.3',
  'snL4VirtualServerAdminStatus' => '1.3.6.1.4.1.1991.1.1.4.2.1.1.4',
  'snL4VirtualServerAdminStatusDefinition' => 'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB::L4Status',
  'snL4VirtualServerSDAType' => '1.3.6.1.4.1.1991.1.1.4.2.1.1.5',
  'snL4VirtualServerSDATypeDefinition' => {
    '0' => 'default',
    '1' => 'leastconnection',
    '2' => 'roundrobin',
    '3' => 'weighted',
  },
  'snL4VirtualServerRowStatus' => '1.3.6.1.4.1.1991.1.1.4.2.1.1.6',
  'snL4VirtualServerDeleteState' => '1.3.6.1.4.1.1991.1.1.4.2.1.1.7',
  'snL4VirtualServerDeleteStateDefinition' => 'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB::L4DeleteState',
  'snL4RealServer' => '1.3.6.1.4.1.1991.1.1.4.3',
  'snL4RealServerTable' => '1.3.6.1.4.1.1991.1.1.4.3.1',
  'snL4RealServerEntry' => '1.3.6.1.4.1.1991.1.1.4.3.1.1',
  'snL4RealServerIndex' => '1.3.6.1.4.1.1991.1.1.4.3.1.1.1',
  'snL4RealServerName' => '1.3.6.1.4.1.1991.1.1.4.3.1.1.2',
  'snL4RealServerIP' => '1.3.6.1.4.1.1991.1.1.4.3.1.1.3',
  'snL4RealServerAdminStatus' => '1.3.6.1.4.1.1991.1.1.4.3.1.1.4',
  'snL4RealServerAdminStatusDefinition' => 'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB::L4Status',
  'snL4RealServerMaxConnections' => '1.3.6.1.4.1.1991.1.1.4.3.1.1.5',
  'snL4RealServerWeight' => '1.3.6.1.4.1.1991.1.1.4.3.1.1.6',
  'snL4RealServerRowStatus' => '1.3.6.1.4.1.1991.1.1.4.3.1.1.7',
  'snL4RealServerDeleteState' => '1.3.6.1.4.1.1991.1.1.4.3.1.1.8',
  'snL4VirtualServerPort' => '1.3.6.1.4.1.1991.1.1.4.4',
  'snL4VirtualServerPortTable' => '1.3.6.1.4.1.1991.1.1.4.4.1',
  'snL4VirtualServerPortEntry' => '1.3.6.1.4.1.1991.1.1.4.4.1.1',
  'snL4VirtualServerPortIndex' => '1.3.6.1.4.1.1991.1.1.4.4.1.1.1',
  'snL4VirtualServerPortServerName' => '1.3.6.1.4.1.1991.1.1.4.4.1.1.2',
  'snL4VirtualServerPortPort' => '1.3.6.1.4.1.1991.1.1.4.4.1.1.3',
  'snL4VirtualServerPortAdminStatus' => '1.3.6.1.4.1.1991.1.1.4.4.1.1.4',
  'snL4VirtualServerPortAdminStatusDefinition' => 'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB::L4Status',
  'snL4VirtualServerPortSticky' => '1.3.6.1.4.1.1991.1.1.4.4.1.1.5',
  'snL4VirtualServerPortStickyDefinition' => {
    '0' => 'disabled',
    '1' => 'enabled',
  },
  'snL4VirtualServerPortConcurrent' => '1.3.6.1.4.1.1991.1.1.4.4.1.1.6',
  'snL4VirtualServerPortConcurrentDefinition' => {
    '0' => 'disabled',
    '1' => 'enabled',
  },
  'snL4VirtualServerPortRowStatus' => '1.3.6.1.4.1.1991.1.1.4.4.1.1.7',
  'snL4VirtualServerPortDeleteState' => '1.3.6.1.4.1.1991.1.1.4.4.1.1.8',
  'snL4RealServerPort' => '1.3.6.1.4.1.1991.1.1.4.5',
  'snL4RealServerPortTable' => '1.3.6.1.4.1.1991.1.1.4.5.1',
  'snL4RealServerPortEntry' => '1.3.6.1.4.1.1991.1.1.4.5.1.1',
  'snL4RealServerPortIndex' => '1.3.6.1.4.1.1991.1.1.4.5.1.1.1',
  'snL4RealServerPortServerName' => '1.3.6.1.4.1.1991.1.1.4.5.1.1.2',
  'snL4RealServerPortPort' => '1.3.6.1.4.1.1991.1.1.4.5.1.1.3',
  'snL4RealServerPortAdminStatus' => '1.3.6.1.4.1.1991.1.1.4.5.1.1.4',
  'snL4RealServerPortRowStatus' => '1.3.6.1.4.1.1991.1.1.4.5.1.1.5',
  'snL4RealServerPortDeleteState' => '1.3.6.1.4.1.1991.1.1.4.5.1.1.6',
  'snL4Bind' => '1.3.6.1.4.1.1991.1.1.4.6',
  'snL4BindTable' => '1.3.6.1.4.1.1991.1.1.4.6.1',
  'snL4BindEntry' => '1.3.6.1.4.1.1991.1.1.4.6.1.1',
  'snL4BindIndex' => '1.3.6.1.4.1.1991.1.1.4.6.1.1.1',
  'snL4BindVirtualServerName' => '1.3.6.1.4.1.1991.1.1.4.6.1.1.2',
  'snL4BindVirtualPortNumber' => '1.3.6.1.4.1.1991.1.1.4.6.1.1.3',
  'snL4BindRealServerName' => '1.3.6.1.4.1.1991.1.1.4.6.1.1.4',
  'snL4BindRealPortNumber' => '1.3.6.1.4.1.1991.1.1.4.6.1.1.5',
  'snL4BindRowStatus' => '1.3.6.1.4.1.1991.1.1.4.6.1.1.6',
  'snL4VirtualServerStatus' => '1.3.6.1.4.1.1991.1.1.4.7',
  'snL4VirtualServerStatusTable' => '1.3.6.1.4.1.1991.1.1.4.7.1',
  'snL4VirtualServerStatusEntry' => '1.3.6.1.4.1.1991.1.1.4.7.1.1',
  'snL4VirtualServerStatusIndex' => '1.3.6.1.4.1.1991.1.1.4.7.1.1.1',
  'snL4VirtualServerStatusName' => '1.3.6.1.4.1.1991.1.1.4.7.1.1.2',
  'snL4VirtualServerStatusReceivePkts' => '1.3.6.1.4.1.1991.1.1.4.7.1.1.3',
  'snL4VirtualServerStatusTransmitPkts' => '1.3.6.1.4.1.1991.1.1.4.7.1.1.4',
  'snL4VirtualServerStatusTotalConnections' => '1.3.6.1.4.1.1991.1.1.4.7.1.1.5',
  'snL4RealServerStatus' => '1.3.6.1.4.1.1991.1.1.4.8',
  'snL4RealServerStatusTable' => '1.3.6.1.4.1.1991.1.1.4.8.1',
  'snL4RealServerStatusEntry' => '1.3.6.1.4.1.1991.1.1.4.8.1.1',
  'snL4RealServerStatusIndex' => '1.3.6.1.4.1.1991.1.1.4.8.1.1.1',
  'snL4RealServerStatusName' => '1.3.6.1.4.1.1991.1.1.4.8.1.1.2',
  'snL4RealServerStatusRealIP' => '1.3.6.1.4.1.1991.1.1.4.8.1.1.3',
  'snL4RealServerStatusReceivePkts' => '1.3.6.1.4.1.1991.1.1.4.8.1.1.4',
  'snL4RealServerStatusTransmitPkts' => '1.3.6.1.4.1.1991.1.1.4.8.1.1.5',
  'snL4RealServerStatusCurConnections' => '1.3.6.1.4.1.1991.1.1.4.8.1.1.6',
  'snL4RealServerStatusTotalConnections' => '1.3.6.1.4.1.1991.1.1.4.8.1.1.7',
  'snL4RealServerStatusAge' => '1.3.6.1.4.1.1991.1.1.4.8.1.1.8',
  'snL4RealServerStatusState' => '1.3.6.1.4.1.1991.1.1.4.8.1.1.9',
  'snL4RealServerStatusStateDefinition' => {
    '0' => 'serverdisabled',
    '1' => 'serverenabled',
    '2' => 'serverfailed',
    '3' => 'servertesting',
    '4' => 'serversuspect',
    '5' => 'servershutdown',
    '6' => 'serveractive',
  },
  'snL4RealServerStatusReassignments' => '1.3.6.1.4.1.1991.1.1.4.8.1.1.10',
  'snL4RealServerStatusReassignmentLimit' => '1.3.6.1.4.1.1991.1.1.4.8.1.1.11',
  'snL4RealServerStatusFailedPortExists' => '1.3.6.1.4.1.1991.1.1.4.8.1.1.12',
  'snL4RealServerStatusFailTime' => '1.3.6.1.4.1.1991.1.1.4.8.1.1.13',
  'snL4RealServerStatusPeakConnections' => '1.3.6.1.4.1.1991.1.1.4.8.1.1.14',
  'snL4VirtualServerPortStatus' => '1.3.6.1.4.1.1991.1.1.4.9',
  'snL4VirtualServerPortStatusTable' => '1.3.6.1.4.1.1991.1.1.4.9.1',
  'snL4VirtualServerPortStatusEntry' => '1.3.6.1.4.1.1991.1.1.4.9.1.1',
  'snL4VirtualServerPortStatusIndex' => '1.3.6.1.4.1.1991.1.1.4.9.1.1.1',
  'snL4VirtualServerPortStatusPort' => '1.3.6.1.4.1.1991.1.1.4.9.1.1.2',
  'snL4VirtualServerPortStatusServerName' => '1.3.6.1.4.1.1991.1.1.4.9.1.1.3',
  'snL4VirtualServerPortStatusCurrentConnection' => '1.3.6.1.4.1.1991.1.1.4.9.1.1.4',
  'snL4VirtualServerPortStatusTotalConnection' => '1.3.6.1.4.1.1991.1.1.4.9.1.1.5',
  'snL4VirtualServerPortStatusPeakConnection' => '1.3.6.1.4.1.1991.1.1.4.9.1.1.6',
  'snL4RealServerPortStatus' => '1.3.6.1.4.1.1991.1.1.4.10',
  'snL4RealServerPortStatusTable' => '1.3.6.1.4.1.1991.1.1.4.10.1',
  'snL4RealServerPortStatusEntry' => '1.3.6.1.4.1.1991.1.1.4.10.1.1',
  'snL4RealServerPortStatusIndex' => '1.3.6.1.4.1.1991.1.1.4.10.1.1.1',
  'snL4RealServerPortStatusPort' => '1.3.6.1.4.1.1991.1.1.4.10.1.1.2',
  'snL4RealServerPortStatusServerName' => '1.3.6.1.4.1.1991.1.1.4.10.1.1.3',
  'snL4RealServerPortStatusReassignCount' => '1.3.6.1.4.1.1991.1.1.4.10.1.1.4',
  'snL4RealServerPortStatusState' => '1.3.6.1.4.1.1991.1.1.4.10.1.1.5',
  'snL4RealServerPortStatusStateDefinition' => {
    '0' => 'disabled',
    '1' => 'enabled',
    '2' => 'failed',
    '3' => 'testing',
    '4' => 'suspect',
    '5' => 'shutdown',
    '6' => 'active',
    '7' => 'unbound',
    '8' => 'awaitUnbind',
    '9' => 'awaitDelete',
  },
  'snL4RealServerPortStatusFailTime' => '1.3.6.1.4.1.1991.1.1.4.10.1.1.6',
  'snL4RealServerPortStatusCurrentConnection' => '1.3.6.1.4.1.1991.1.1.4.10.1.1.7',
  'snL4RealServerPortStatusTotalConnection' => '1.3.6.1.4.1.1991.1.1.4.10.1.1.8',
  'snL4RealServerPortStatusRxPkts' => '1.3.6.1.4.1.1991.1.1.4.10.1.1.9',
  'snL4RealServerPortStatusTxPkts' => '1.3.6.1.4.1.1991.1.1.4.10.1.1.10',
  'snL4RealServerPortStatusRxBytes' => '1.3.6.1.4.1.1991.1.1.4.10.1.1.11',
  'snL4RealServerPortStatusTxBytes' => '1.3.6.1.4.1.1991.1.1.4.10.1.1.12',
  'snL4RealServerPortStatusPeakConnection' => '1.3.6.1.4.1.1991.1.1.4.10.1.1.13',
  'snL4Policy' => '1.3.6.1.4.1.1991.1.1.4.11',
  'snL4PolicyTable' => '1.3.6.1.4.1.1991.1.1.4.11.1',
  'snL4PolicyEntry' => '1.3.6.1.4.1.1991.1.1.4.11.1.1',
  'snL4PolicyId' => '1.3.6.1.4.1.1991.1.1.4.11.1.1.1',
  'snL4PolicyPriority' => '1.3.6.1.4.1.1991.1.1.4.11.1.1.2',
  'snL4PolicyScope' => '1.3.6.1.4.1.1991.1.1.4.11.1.1.3',
  'snL4PolicyProtocol' => '1.3.6.1.4.1.1991.1.1.4.11.1.1.4',
  'snL4PolicyPort' => '1.3.6.1.4.1.1991.1.1.4.11.1.1.5',
  'snL4PolicyRowStatus' => '1.3.6.1.4.1.1991.1.1.4.11.1.1.6',
  'snL4PolicyPortAccess' => '1.3.6.1.4.1.1991.1.1.4.12',
  'snL4PolicyPortAccessTable' => '1.3.6.1.4.1.1991.1.1.4.12.1',
  'snL4PolicyPortAccessEntry' => '1.3.6.1.4.1.1991.1.1.4.12.1.1',
  'snL4PolicyPortAccessPort' => '1.3.6.1.4.1.1991.1.1.4.12.1.1.1',
  'snL4PolicyPortAccessList' => '1.3.6.1.4.1.1991.1.1.4.12.1.1.2',
  'snL4PolicyPortAccessRowStatus' => '1.3.6.1.4.1.1991.1.1.4.12.1.1.3',
  'snL4Trap' => '1.3.6.1.4.1.1991.1.1.4.13',
  'snL4TrapRealServerIP' => '1.3.6.1.4.1.1991.1.1.4.13.1.0',
  'snL4TrapRealServerName' => '1.3.6.1.4.1.1991.1.1.4.13.2.0',
  'snL4TrapRealServerPort' => '1.3.6.1.4.1.1991.1.1.4.13.3.0',
  'snL4TrapRealServerCurConnections' => '1.3.6.1.4.1.1991.1.1.4.13.4.0',
  'snL4WebCache' => '1.3.6.1.4.1.1991.1.1.4.14',
  'snL4WebCacheTable' => '1.3.6.1.4.1.1991.1.1.4.14.1',
  'snL4WebCacheEntry' => '1.3.6.1.4.1.1991.1.1.4.14.1.1',
  'snL4WebCacheIP' => '1.3.6.1.4.1.1991.1.1.4.14.1.1.1',
  'snL4WebCacheName' => '1.3.6.1.4.1.1991.1.1.4.14.1.1.2',
  'snL4WebCacheAdminStatus' => '1.3.6.1.4.1.1991.1.1.4.14.1.1.3',
  'snL4WebCacheMaxConnections' => '1.3.6.1.4.1.1991.1.1.4.14.1.1.4',
  'snL4WebCacheWeight' => '1.3.6.1.4.1.1991.1.1.4.14.1.1.5',
  'snL4WebCacheRowStatus' => '1.3.6.1.4.1.1991.1.1.4.14.1.1.6',
  'snL4WebCacheDeleteState' => '1.3.6.1.4.1.1991.1.1.4.14.1.1.7',
  'snL4WebCacheGroup' => '1.3.6.1.4.1.1991.1.1.4.15',
  'snL4WebCacheGroupTable' => '1.3.6.1.4.1.1991.1.1.4.15.1',
  'snL4WebCacheGroupEntry' => '1.3.6.1.4.1.1991.1.1.4.15.1.1',
  'snL4WebCacheGroupId' => '1.3.6.1.4.1.1991.1.1.4.15.1.1.1',
  'snL4WebCacheGroupName' => '1.3.6.1.4.1.1991.1.1.4.15.1.1.2',
  'snL4WebCacheGroupWebCacheIpList' => '1.3.6.1.4.1.1991.1.1.4.15.1.1.3',
  'snL4WebCacheGroupDestMask' => '1.3.6.1.4.1.1991.1.1.4.15.1.1.4',
  'snL4WebCacheGroupSrcMask' => '1.3.6.1.4.1.1991.1.1.4.15.1.1.5',
  'snL4WebCacheGroupAdminStatus' => '1.3.6.1.4.1.1991.1.1.4.15.1.1.6',
  'snL4WebCacheGroupRowStatus' => '1.3.6.1.4.1.1991.1.1.4.15.1.1.7',
  'snL4WebCacheTrafficStats' => '1.3.6.1.4.1.1991.1.1.4.16',
  'snL4WebCacheTrafficStatsTable' => '1.3.6.1.4.1.1991.1.1.4.16.1',
  'snL4WebCacheTrafficStatsEntry' => '1.3.6.1.4.1.1991.1.1.4.16.1.1',
  'snL4WebCacheTrafficIp' => '1.3.6.1.4.1.1991.1.1.4.16.1.1.1',
  'snL4WebCacheTrafficPort' => '1.3.6.1.4.1.1991.1.1.4.16.1.1.2',
  'snL4WebCacheCurrConnections' => '1.3.6.1.4.1.1991.1.1.4.16.1.1.3',
  'snL4WebCacheTotalConnections' => '1.3.6.1.4.1.1991.1.1.4.16.1.1.4',
  'snL4WebCacheTxPkts' => '1.3.6.1.4.1.1991.1.1.4.16.1.1.5',
  'snL4WebCacheRxPkts' => '1.3.6.1.4.1.1991.1.1.4.16.1.1.6',
  'snL4WebCacheTxOctets' => '1.3.6.1.4.1.1991.1.1.4.16.1.1.7',
  'snL4WebCacheRxOctets' => '1.3.6.1.4.1.1991.1.1.4.16.1.1.8',
  'snL4WebCachePortState' => '1.3.6.1.4.1.1991.1.1.4.16.1.1.9',
  'snL4WebUncachedTrafficStats' => '1.3.6.1.4.1.1991.1.1.4.17',
  'snL4WebUncachedTrafficStatsTable' => '1.3.6.1.4.1.1991.1.1.4.17.1',
  'snL4WebUncachedTrafficStatsEntry' => '1.3.6.1.4.1.1991.1.1.4.17.1.1',
  'snL4WebServerPort' => '1.3.6.1.4.1.1991.1.1.4.17.1.1.1',
  'snL4WebClientPort' => '1.3.6.1.4.1.1991.1.1.4.17.1.1.2',
  'snL4WebUncachedTxPkts' => '1.3.6.1.4.1.1991.1.1.4.17.1.1.3',
  'snL4WebUncachedRxPkts' => '1.3.6.1.4.1.1991.1.1.4.17.1.1.4',
  'snL4WebUncachedTxOctets' => '1.3.6.1.4.1.1991.1.1.4.17.1.1.5',
  'snL4WebUncachedRxOctets' => '1.3.6.1.4.1.1991.1.1.4.17.1.1.6',
  'snL4WebServerPortName' => '1.3.6.1.4.1.1991.1.1.4.17.1.1.7',
  'snL4WebClientPortName' => '1.3.6.1.4.1.1991.1.1.4.17.1.1.8',
  'snL4WebCachePort' => '1.3.6.1.4.1.1991.1.1.4.18',
  'snL4WebCachePortTable' => '1.3.6.1.4.1.1991.1.1.4.18.1',
  'snL4WebCachePortEntry' => '1.3.6.1.4.1.1991.1.1.4.18.1.1',
  'snL4WebCachePortServerIp' => '1.3.6.1.4.1.1991.1.1.4.18.1.1.1',
  'snL4WebCachePortPort' => '1.3.6.1.4.1.1991.1.1.4.18.1.1.2',
  'snL4WebCachePortAdminStatus' => '1.3.6.1.4.1.1991.1.1.4.18.1.1.3',
  'snL4WebCachePortRowStatus' => '1.3.6.1.4.1.1991.1.1.4.18.1.1.4',
  'snL4WebCachePortDeleteState' => '1.3.6.1.4.1.1991.1.1.4.18.1.1.5',
  'snL4RealServerCfg' => '1.3.6.1.4.1.1991.1.1.4.19',
  'snL4RealServerCfgTable' => '1.3.6.1.4.1.1991.1.1.4.19.1',
  'snL4RealServerCfgEntry' => '1.3.6.1.4.1.1991.1.1.4.19.1.1',
  'snL4RealServerCfgIP' => '1.3.6.1.4.1.1991.1.1.4.19.1.1.1',
  'snL4RealServerCfgName' => '1.3.6.1.4.1.1991.1.1.4.19.1.1.2',
  'snL4RealServerCfgAdminStatus' => '1.3.6.1.4.1.1991.1.1.4.19.1.1.3',
  'snL4RealServerCfgMaxConnections' => '1.3.6.1.4.1.1991.1.1.4.19.1.1.4',
  'snL4RealServerCfgWeight' => '1.3.6.1.4.1.1991.1.1.4.19.1.1.5',
  'snL4RealServerCfgRowStatus' => '1.3.6.1.4.1.1991.1.1.4.19.1.1.6',
  'snL4RealServerCfgDeleteState' => '1.3.6.1.4.1.1991.1.1.4.19.1.1.7',
  'snL4RealServerPortCfg' => '1.3.6.1.4.1.1991.1.1.4.20',
  'snL4RealServerPortCfgTable' => '1.3.6.1.4.1.1991.1.1.4.20.1',
  'snL4RealServerPortCfgEntry' => '1.3.6.1.4.1.1991.1.1.4.20.1.1',
  'snL4RealServerPortCfgIP' => '1.3.6.1.4.1.1991.1.1.4.20.1.1.1',
  'snL4RealServerPortCfgServerName' => '1.3.6.1.4.1.1991.1.1.4.20.1.1.2',
  'snL4RealServerPortCfgPort' => '1.3.6.1.4.1.1991.1.1.4.20.1.1.3',
  'snL4RealServerPortCfgAdminStatus' => '1.3.6.1.4.1.1991.1.1.4.20.1.1.4',
  'snL4RealServerPortCfgRowStatus' => '1.3.6.1.4.1.1991.1.1.4.20.1.1.5',
  'snL4RealServerPortCfgDeleteState' => '1.3.6.1.4.1.1991.1.1.4.20.1.1.6',
  'snL4VirtualServerCfg' => '1.3.6.1.4.1.1991.1.1.4.21',
  'snL4VirtualServerCfgTable' => '1.3.6.1.4.1.1991.1.1.4.21.1',
  'snL4VirtualServerCfgEntry' => '1.3.6.1.4.1.1991.1.1.4.21.1.1',
  'snL4VirtualServerCfgVirtualIP' => '1.3.6.1.4.1.1991.1.1.4.21.1.1.1',
  'snL4VirtualServerCfgName' => '1.3.6.1.4.1.1991.1.1.4.21.1.1.2',
  'snL4VirtualServerCfgAdminStatus' => '1.3.6.1.4.1.1991.1.1.4.21.1.1.3',
  'snL4VirtualServerCfgSDAType' => '1.3.6.1.4.1.1991.1.1.4.21.1.1.4',
  'snL4VirtualServerCfgRowStatus' => '1.3.6.1.4.1.1991.1.1.4.21.1.1.5',
  'snL4VirtualServerCfgDeleteState' => '1.3.6.1.4.1.1991.1.1.4.21.1.1.6',
  'snL4VirtualServerPortCfg' => '1.3.6.1.4.1.1991.1.1.4.22',
  'snL4VirtualServerPortCfgTable' => '1.3.6.1.4.1.1991.1.1.4.22.1',
  'snL4VirtualServerPortCfgEntry' => '1.3.6.1.4.1.1991.1.1.4.22.1.1',
  'snL4VirtualServerPortCfgIP' => '1.3.6.1.4.1.1991.1.1.4.22.1.1.1',
  'snL4VirtualServerPortCfgPort' => '1.3.6.1.4.1.1991.1.1.4.22.1.1.2',
  'snL4VirtualServerPortCfgServerName' => '1.3.6.1.4.1.1991.1.1.4.22.1.1.3',
  'snL4VirtualServerPortCfgAdminStatus' => '1.3.6.1.4.1.1991.1.1.4.22.1.1.4',
  'snL4VirtualServerPortCfgSticky' => '1.3.6.1.4.1.1991.1.1.4.22.1.1.5',
  'snL4VirtualServerPortCfgConcurrent' => '1.3.6.1.4.1.1991.1.1.4.22.1.1.6',
  'snL4VirtualServerPortCfgRowStatus' => '1.3.6.1.4.1.1991.1.1.4.22.1.1.7',
  'snL4VirtualServerPortCfgDeleteState' => '1.3.6.1.4.1.1991.1.1.4.22.1.1.8',
  'snL4RealServerStatistic' => '1.3.6.1.4.1.1991.1.1.4.23',
  'snL4RealServerStatisticTable' => '1.3.6.1.4.1.1991.1.1.4.23.1',
  'snL4RealServerStatisticEntry' => '1.3.6.1.4.1.1991.1.1.4.23.1.1',
  'snL4RealServerStatisticRealIP' => '1.3.6.1.4.1.1991.1.1.4.23.1.1.1',
  'snL4RealServerStatisticName' => '1.3.6.1.4.1.1991.1.1.4.23.1.1.2',
  'snL4RealServerStatisticReceivePkts' => '1.3.6.1.4.1.1991.1.1.4.23.1.1.3',
  'snL4RealServerStatisticTransmitPkts' => '1.3.6.1.4.1.1991.1.1.4.23.1.1.4',
  'snL4RealServerStatisticCurConnections' => '1.3.6.1.4.1.1991.1.1.4.23.1.1.5',
  'snL4RealServerStatisticTotalConnections' => '1.3.6.1.4.1.1991.1.1.4.23.1.1.6',
  'snL4RealServerStatisticAge' => '1.3.6.1.4.1.1991.1.1.4.23.1.1.7',
  'snL4RealServerStatisticState' => '1.3.6.1.4.1.1991.1.1.4.23.1.1.8',
  'snL4RealServerStatisticStateDefinition' => {
    '0' => 'serverdisabled',
    '1' => 'serverenabled',
    '2' => 'serverfailed',
    '3' => 'servertesting',
    '4' => 'serversuspect',
    '5' => 'servershutdown',
    '6' => 'serveractive',
  },
  'snL4RealServerStatisticReassignments' => '1.3.6.1.4.1.1991.1.1.4.23.1.1.9',
  'snL4RealServerStatisticReassignmentLimit' => '1.3.6.1.4.1.1991.1.1.4.23.1.1.10',
  'snL4RealServerStatisticFailedPortExists' => '1.3.6.1.4.1.1991.1.1.4.23.1.1.11',
  'snL4RealServerStatisticFailTime' => '1.3.6.1.4.1.1991.1.1.4.23.1.1.12',
  'snL4RealServerStatisticPeakConnections' => '1.3.6.1.4.1.1991.1.1.4.23.1.1.13',
  'snL4RealServerPortStatistic' => '1.3.6.1.4.1.1991.1.1.4.24',
  'snL4RealServerPortStatisticTable' => '1.3.6.1.4.1.1991.1.1.4.24.1',
  'snL4RealServerPortStatisticEntry' => '1.3.6.1.4.1.1991.1.1.4.24.1.1',
  'snL4RealServerPortStatisticIP' => '1.3.6.1.4.1.1991.1.1.4.24.1.1.1',
  'snL4RealServerPortStatisticPort' => '1.3.6.1.4.1.1991.1.1.4.24.1.1.2',
  'snL4RealServerPortStatisticServerName' => '1.3.6.1.4.1.1991.1.1.4.24.1.1.3',
  'snL4RealServerPortStatisticReassignCount' => '1.3.6.1.4.1.1991.1.1.4.24.1.1.4',
  'snL4RealServerPortStatisticState' => '1.3.6.1.4.1.1991.1.1.4.24.1.1.5',
  'snL4RealServerPortStatisticStateDefinition' => {
    '0' => 'disabled',
    '1' => 'enabled',
    '2' => 'failed',
    '3' => 'testing',
    '4' => 'suspect',
    '5' => 'shutdown',
    '6' => 'active',
    '7' => 'unbound',
    '8' => 'awaitUnbind',
    '9' => 'awaitDelete',
  },
  'snL4RealServerPortStatisticFailTime' => '1.3.6.1.4.1.1991.1.1.4.24.1.1.6',
  'snL4RealServerPortStatisticCurrentConnection' => '1.3.6.1.4.1.1991.1.1.4.24.1.1.7',
  'snL4RealServerPortStatisticTotalConnection' => '1.3.6.1.4.1.1991.1.1.4.24.1.1.8',
  'snL4RealServerPortStatisticRxPkts' => '1.3.6.1.4.1.1991.1.1.4.24.1.1.9',
  'snL4RealServerPortStatisticTxPkts' => '1.3.6.1.4.1.1991.1.1.4.24.1.1.10',
  'snL4RealServerPortStatisticRxBytes' => '1.3.6.1.4.1.1991.1.1.4.24.1.1.11',
  'snL4RealServerPortStatisticTxBytes' => '1.3.6.1.4.1.1991.1.1.4.24.1.1.12',
  'snL4RealServerPortStatisticPeakConnection' => '1.3.6.1.4.1.1991.1.1.4.24.1.1.13',
  'snL4VirtualServerStatistic' => '1.3.6.1.4.1.1991.1.1.4.25',
  'snL4VirtualServerStatisticTable' => '1.3.6.1.4.1.1991.1.1.4.25.1',
  'snL4VirtualServerStatisticEntry' => '1.3.6.1.4.1.1991.1.1.4.25.1.1',
  'snL4VirtualServerStatisticIP' => '1.3.6.1.4.1.1991.1.1.4.25.1.1.1',
  'snL4VirtualServerStatisticName' => '1.3.6.1.4.1.1991.1.1.4.25.1.1.2',
  'snL4VirtualServerStatisticReceivePkts' => '1.3.6.1.4.1.1991.1.1.4.25.1.1.3',
  'snL4VirtualServerStatisticTransmitPkts' => '1.3.6.1.4.1.1991.1.1.4.25.1.1.4',
  'snL4VirtualServerStatisticTotalConnections' => '1.3.6.1.4.1.1991.1.1.4.25.1.1.5',
  'snL4VirtualServerStatisticReceiveBytes' => '1.3.6.1.4.1.1991.1.1.4.25.1.1.6',
  'snL4VirtualServerStatisticTransmitBytes' => '1.3.6.1.4.1.1991.1.1.4.25.1.1.7',
  'snL4VirtualServerStatisticSymmetricState' => '1.3.6.1.4.1.1991.1.1.4.25.1.1.8',
  'snL4VirtualServerStatisticSymmetricPriority' => '1.3.6.1.4.1.1991.1.1.4.25.1.1.9',
  'snL4VirtualServerStatisticSymmetricKeep' => '1.3.6.1.4.1.1991.1.1.4.25.1.1.10',
  'snL4VirtualServerStatisticSymmetricActivates' => '1.3.6.1.4.1.1991.1.1.4.25.1.1.11',
  'snL4VirtualServerStatisticSymmetricInactives' => '1.3.6.1.4.1.1991.1.1.4.25.1.1.12',
  'snL4VirtualServerStatisticSymmetricBestStandbyMacAddr' => '1.3.6.1.4.1.1991.1.1.4.25.1.1.13',
  'snL4VirtualServerStatisticSymmetricActiveMacAddr' => '1.3.6.1.4.1.1991.1.1.4.25.1.1.14',
  'snL4VirtualServerPortStatistic' => '1.3.6.1.4.1.1991.1.1.4.26',
  'snL4VirtualServerPortStatisticTable' => '1.3.6.1.4.1.1991.1.1.4.26.1',
  'snL4VirtualServerPortStatisticEntry' => '1.3.6.1.4.1.1991.1.1.4.26.1.1',
  'snL4VirtualServerPortStatisticIP' => '1.3.6.1.4.1.1991.1.1.4.26.1.1.1',
  'snL4VirtualServerPortStatisticPort' => '1.3.6.1.4.1.1991.1.1.4.26.1.1.2',
  'snL4VirtualServerPortStatisticServerName' => '1.3.6.1.4.1.1991.1.1.4.26.1.1.3',
  'snL4VirtualServerPortStatisticCurrentConnection' => '1.3.6.1.4.1.1991.1.1.4.26.1.1.4',
  'snL4VirtualServerPortStatisticTotalConnection' => '1.3.6.1.4.1.1991.1.1.4.26.1.1.5',
  'snL4VirtualServerPortStatisticPeakConnection' => '1.3.6.1.4.1.1991.1.1.4.26.1.1.6',
  'snL4GslbSiteRemoteServerIrons' => '1.3.6.1.4.1.1991.1.1.4.27',
  'snL4GslbSiteRemoteServerIronTable' => '1.3.6.1.4.1.1991.1.1.4.27.1',
  'snL4GslbSiteRemoteServerIronEntry' => '1.3.6.1.4.1.1991.1.1.4.27.1.1',
  'snL4GslbSiteRemoteServerIronIP' => '1.3.6.1.4.1.1991.1.1.4.27.1.1.1',
  'snL4GslbSiteRemoteServerIronPreference' => '1.3.6.1.4.1.1991.1.1.4.27.1.1.2',
  'snL4History' => '1.3.6.1.4.1.1991.1.1.4.28',
  'snL4RealServerHistoryControlTable' => '1.3.6.1.4.1.1991.1.1.4.28.1',
  'snL4RealServerHistoryControlEntry' => '1.3.6.1.4.1.1991.1.1.4.28.1.1',
  'snL4RealServerHistoryControlIndex' => '1.3.6.1.4.1.1991.1.1.4.28.1.1.1',
  'snL4RealServerHistoryControlDataSource' => '1.3.6.1.4.1.1991.1.1.4.28.1.1.2',
  'snL4RealServerHistoryControlBucketsRequested' => '1.3.6.1.4.1.1991.1.1.4.28.1.1.3',
  'snL4RealServerHistoryControlBucketsGranted' => '1.3.6.1.4.1.1991.1.1.4.28.1.1.4',
  'snL4RealServerHistoryControlInterval' => '1.3.6.1.4.1.1991.1.1.4.28.1.1.5',
  'snL4RealServerHistoryControlOwner' => '1.3.6.1.4.1.1991.1.1.4.28.1.1.6',
  'snL4RealServerHistoryControlStatus' => '1.3.6.1.4.1.1991.1.1.4.28.1.1.7',
  'snL4RealServerHistoryTable' => '1.3.6.1.4.1.1991.1.1.4.28.2',
  'snL4RealServerHistoryEntry' => '1.3.6.1.4.1.1991.1.1.4.28.2.1',
  'snL4RealServerHistoryIndex' => '1.3.6.1.4.1.1991.1.1.4.28.2.1.1',
  'snL4RealServerHistorySampleIndex' => '1.3.6.1.4.1.1991.1.1.4.28.2.1.2',
  'snL4RealServerHistoryIntervalStart' => '1.3.6.1.4.1.1991.1.1.4.28.2.1.3',
  'snL4RealServerHistoryReceivePkts' => '1.3.6.1.4.1.1991.1.1.4.28.2.1.4',
  'snL4RealServerHistoryTransmitPkts' => '1.3.6.1.4.1.1991.1.1.4.28.2.1.5',
  'snL4RealServerHistoryTotalConnections' => '1.3.6.1.4.1.1991.1.1.4.28.2.1.6',
  'snL4RealServerHistoryCurConnections' => '1.3.6.1.4.1.1991.1.1.4.28.2.1.7',
  'snL4RealServerHistoryPeakConnections' => '1.3.6.1.4.1.1991.1.1.4.28.2.1.8',
  'snL4RealServerHistoryReassignments' => '1.3.6.1.4.1.1991.1.1.4.28.2.1.9',
  'snL4RealServerPortHistoryControlTable' => '1.3.6.1.4.1.1991.1.1.4.28.3',
  'snL4RealServerPortHistoryControlEntry' => '1.3.6.1.4.1.1991.1.1.4.28.3.1',
  'snL4RealServerPortHistoryControlIndex' => '1.3.6.1.4.1.1991.1.1.4.28.3.1.1',
  'snL4RealServerPortHistoryControlDataSource' => '1.3.6.1.4.1.1991.1.1.4.28.3.1.2',
  'snL4RealServerPortHistoryControlBucketsRequested' => '1.3.6.1.4.1.1991.1.1.4.28.3.1.3',
  'snL4RealServerPortHistoryControlBucketsGranted' => '1.3.6.1.4.1.1991.1.1.4.28.3.1.4',
  'snL4RealServerPortHistoryControlInterval' => '1.3.6.1.4.1.1991.1.1.4.28.3.1.5',
  'snL4RealServerPortHistoryControlOwner' => '1.3.6.1.4.1.1991.1.1.4.28.3.1.6',
  'snL4RealServerPortHistoryControlStatus' => '1.3.6.1.4.1.1991.1.1.4.28.3.1.7',
  'snL4RealServerPortHistoryTable' => '1.3.6.1.4.1.1991.1.1.4.28.4',
  'snL4RealServerPortHistoryEntry' => '1.3.6.1.4.1.1991.1.1.4.28.4.1',
  'snL4RealServerPortHistoryIndex' => '1.3.6.1.4.1.1991.1.1.4.28.4.1.1',
  'snL4RealServerPortHistorySampleIndex' => '1.3.6.1.4.1.1991.1.1.4.28.4.1.2',
  'snL4RealServerPortHistoryIntervalStart' => '1.3.6.1.4.1.1991.1.1.4.28.4.1.3',
  'snL4RealServerPortHistoryReceivePkts' => '1.3.6.1.4.1.1991.1.1.4.28.4.1.4',
  'snL4RealServerPortHistoryTransmitPkts' => '1.3.6.1.4.1.1991.1.1.4.28.4.1.5',
  'snL4RealServerPortHistoryTotalConnections' => '1.3.6.1.4.1.1991.1.1.4.28.4.1.6',
  'snL4RealServerPortHistoryCurConnections' => '1.3.6.1.4.1.1991.1.1.4.28.4.1.7',
  'snL4RealServerPortHistoryPeakConnections' => '1.3.6.1.4.1.1991.1.1.4.28.4.1.8',
  'snL4RealServerPortHistoryResponseTime' => '1.3.6.1.4.1.1991.1.1.4.28.4.1.9',
  'snL4VirtualServerHistoryControlTable' => '1.3.6.1.4.1.1991.1.1.4.28.5',
  'snL4VirtualServerHistoryControlEntry' => '1.3.6.1.4.1.1991.1.1.4.28.5.1',
  'snL4VirtualServerHistoryControlIndex' => '1.3.6.1.4.1.1991.1.1.4.28.5.1.1',
  'snL4VirtualServerHistoryControlDataSource' => '1.3.6.1.4.1.1991.1.1.4.28.5.1.2',
  'snL4VirtualServerHistoryControlBucketsRequested' => '1.3.6.1.4.1.1991.1.1.4.28.5.1.3',
  'snL4VirtualServerHistoryControlBucketsGranted' => '1.3.6.1.4.1.1991.1.1.4.28.5.1.4',
  'snL4VirtualServerHistoryControlInterval' => '1.3.6.1.4.1.1991.1.1.4.28.5.1.5',
  'snL4VirtualServerHistoryControlOwner' => '1.3.6.1.4.1.1991.1.1.4.28.5.1.6',
  'snL4VirtualServerHistoryControlStatus' => '1.3.6.1.4.1.1991.1.1.4.28.5.1.7',
  'snL4VirtualServerHistoryTable' => '1.3.6.1.4.1.1991.1.1.4.28.6',
  'snL4VirtualServerHistoryEntry' => '1.3.6.1.4.1.1991.1.1.4.28.6.1',
  'snL4VirtualServerHistoryIndex' => '1.3.6.1.4.1.1991.1.1.4.28.6.1.1',
  'snL4VirtualServerHistorySampleIndex' => '1.3.6.1.4.1.1991.1.1.4.28.6.1.2',
  'snL4VirtualServerHistoryIntervalStart' => '1.3.6.1.4.1.1991.1.1.4.28.6.1.3',
  'snL4VirtualServerHistoryReceivePkts' => '1.3.6.1.4.1.1991.1.1.4.28.6.1.4',
  'snL4VirtualServerHistoryTransmitPkts' => '1.3.6.1.4.1.1991.1.1.4.28.6.1.5',
  'snL4VirtualServerHistoryTotalConnections' => '1.3.6.1.4.1.1991.1.1.4.28.6.1.6',
  'snL4VirtualServerHistoryCurConnections' => '1.3.6.1.4.1.1991.1.1.4.28.6.1.7',
  'snL4VirtualServerHistoryPeakConnections' => '1.3.6.1.4.1.1991.1.1.4.28.6.1.8',
  'snL4VirtualServerPortHistoryControlTable' => '1.3.6.1.4.1.1991.1.1.4.28.7',
  'snL4VirtualServerPortHistoryControlEntry' => '1.3.6.1.4.1.1991.1.1.4.28.7.1',
  'snL4VirtualServerPortHistoryControlIndex' => '1.3.6.1.4.1.1991.1.1.4.28.7.1.1',
  'snL4VirtualServerPortHistoryControlDataSource' => '1.3.6.1.4.1.1991.1.1.4.28.7.1.2',
  'snL4VirtualServerPortHistoryControlBucketsRequested' => '1.3.6.1.4.1.1991.1.1.4.28.7.1.3',
  'snL4VirtualServerPortHistoryControlBucketsGranted' => '1.3.6.1.4.1.1991.1.1.4.28.7.1.4',
  'snL4VirtualServerPortHistoryControlInterval' => '1.3.6.1.4.1.1991.1.1.4.28.7.1.5',
  'snL4VirtualServerPortHistoryControlOwner' => '1.3.6.1.4.1.1991.1.1.4.28.7.1.6',
  'snL4VirtualServerPortHistoryControlStatus' => '1.3.6.1.4.1.1991.1.1.4.28.7.1.7',
  'snL4VirtualServerPortHistoryTable' => '1.3.6.1.4.1.1991.1.1.4.28.8',
  'snL4VirtualServerPortHistoryEntry' => '1.3.6.1.4.1.1991.1.1.4.28.8.1',
  'snL4VirtualServerPortHistoryIndex' => '1.3.6.1.4.1.1991.1.1.4.28.8.1.1',
  'snL4VirtualServerPortHistorySampleIndex' => '1.3.6.1.4.1.1991.1.1.4.28.8.1.2',
  'snL4VirtualServerPortHistoryIntervalStart' => '1.3.6.1.4.1.1991.1.1.4.28.8.1.3',
  'snL4VirtualServerPortHistoryReceivePkts' => '1.3.6.1.4.1.1991.1.1.4.28.8.1.4',
  'snL4VirtualServerPortHistoryTransmitPkts' => '1.3.6.1.4.1.1991.1.1.4.28.8.1.5',
  'snL4VirtualServerPortHistoryTotalConnections' => '1.3.6.1.4.1.1991.1.1.4.28.8.1.6',
  'snL4VirtualServerPortHistoryCurConnections' => '1.3.6.1.4.1.1991.1.1.4.28.8.1.7',
  'snL4VirtualServerPortHistoryPeakConnections' => '1.3.6.1.4.1.1991.1.1.4.28.8.1.8',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB'} = {
  'L4RowSts' => {
    '1' => 'other',
    '2' => 'valid',
    '3' => 'delete',
    '4' => 'create',
    '5' => 'modify',
  },
  'L4Status' => {
    '0' => 'disabled',
    '1' => 'enabled',
  },
  'L4DeleteState' => {
    '0' => 'done',
    '1' => 'waitdelete',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::HH3CENTITYEXTMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'HH3C-ENTITY-EXT-MIB'} = {
  url => '',
  name => 'HH3C-ENTITY-EXT-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'HH3C-ENTITY-EXT-MIB'} = {
  'hh3cEntityExtStateTable' => '1.3.6.1.4.1.25506.2.6.1.1.1',
  'hh3cEntityExtStateEntry' => '1.3.6.1.4.1.25506.2.6.1.1.1.1',
  'hh3cEntityExtCpuUsage' => '1.3.6.1.4.1.25506.2.6.1.1.1.1.6',
  'hh3cEntityExtTemperature' => '1.3.6.1.4.1.25506.2.6.1.1.1.1.12',
  'hh3cEntityExtErrorStatus' => '1.3.6.1.4.1.25506.2.6.1.1.1.1.19',
  'hh3cEntityExtErrorStatusDefinition' => 'HH3C-ENTITY-EXT-MIB::hh3cEntityExtErrorStatusValue',
  'hh3cEntityExtCpuAvgUsage' => '1.3.6.1.4.1.25506.2.6.1.1.1.1.26',
  'hh3cEntityExtMemAvgUsage' => '1.3.6.1.4.1.25506.2.6.1.1.1.1.27',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'HH3C-ENTITY-EXT-MIB'} = {
  'hh3cEntityExtErrorStatusValue' => {
    '1' => 'notSupported',
    '2' => 'normal',
    '3' => 'postFailure',
    '4' => 'entityAbsent',
    '11' => 'poeError',
    '21' => 'stackError',
    '22' => 'stackPortBlocked',
    '23' => 'stackPortFailed',
    '31' => 'sfpRecvError',
    '32' => 'sfpSendError',
    '33' => 'sfpBothError',
    '41' => 'fanError',
    '51' => 'psuError',
    '61' => 'rpsError',
    '71' => 'moduleFaulty',
    '81' => 'sensorError',
    '91' => 'hardwareFaulty',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::HOSTRESOURCESMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'HOST-RESOURCES-MIB'} = {
  url => '',
  name => 'HOST-RESOURCES-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'HOST-RESOURCES-MIB'} = 
  '1.3.6.1.2.1.25';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'HOST-RESOURCES-MIB'} = {
  'host' => '1.3.6.1.2.1.25',
  'hrSystem' => '1.3.6.1.2.1.25.1',
  'hrSystemUptime' => '1.3.6.1.2.1.25.1.1.0',
  'hrSystemDate' => '1.3.6.1.2.1.25.1.2.0',
  'hrSystemInitialLoadDevice' => '1.3.6.1.2.1.25.1.3.0',
  'hrSystemInitialLoadParameters' => '1.3.6.1.2.1.25.1.4.0',
  'hrSystemNumUsers' => '1.3.6.1.2.1.25.1.5.0',
  'hrSystemProcesses' => '1.3.6.1.2.1.25.1.6.0',
  'hrSystemMaxProcesses' => '1.3.6.1.2.1.25.1.7.0',
  'hrStorage' => '1.3.6.1.2.1.25.2',
  'hrStorageTypes' => '1.3.6.1.2.1.25.2.1',
  'hrStorageOther' => '1.3.6.1.2.1.25.2.1.1',
  'hrStorageRam' => '1.3.6.1.2.1.25.2.1.2',
  'hrStorageVirtualMemory' => '1.3.6.1.2.1.25.2.1.3',
  'hrStorageFixedDisk' => '1.3.6.1.2.1.25.2.1.4',
  'hrStorageRemovableDisk' => '1.3.6.1.2.1.25.2.1.5',
  'hrStorageFloppyDisk' => '1.3.6.1.2.1.25.2.1.6',
  'hrStorageCompactDisc' => '1.3.6.1.2.1.25.2.1.7',
  'hrStorageRamDisk' => '1.3.6.1.2.1.25.2.1.8',
  'hrMemorySize' => '1.3.6.1.2.1.25.2.2.0',
  'hrStorageTable' => '1.3.6.1.2.1.25.2.3',
  'hrStorageEntry' => '1.3.6.1.2.1.25.2.3.1',
  'hrStorageIndex' => '1.3.6.1.2.1.25.2.3.1.1',
  'hrStorageType' => '1.3.6.1.2.1.25.2.3.1.2',
  'hrStorageTypeDefinition' => 'OID::HOST-RESOURCES-MIB',
  'hrStorageDescr' => '1.3.6.1.2.1.25.2.3.1.3',
  'hrStorageAllocationUnits' => '1.3.6.1.2.1.25.2.3.1.4',
  'hrStorageSize' => '1.3.6.1.2.1.25.2.3.1.5',
  'hrStorageUsed' => '1.3.6.1.2.1.25.2.3.1.6',
  'hrStorageAllocationFailures' => '1.3.6.1.2.1.25.2.3.1.7',
  'hrDevice' => '1.3.6.1.2.1.25.3',
  'hrDeviceTypes' => '1.3.6.1.2.1.25.3.1',
  'hrDeviceOther' => '1.3.6.1.2.1.25.3.1.1',
  'hrDeviceUnknown' => '1.3.6.1.2.1.25.3.1.2',
  'hrDeviceProcessor' => '1.3.6.1.2.1.25.3.1.3',
  'hrDeviceNetwork' => '1.3.6.1.2.1.25.3.1.4',
  'hrDevicePrinter' => '1.3.6.1.2.1.25.3.1.5',
  'hrDeviceDiskStorage' => '1.3.6.1.2.1.25.3.1.6',
  'hrDeviceVideo' => '1.3.6.1.2.1.25.3.1.10',
  'hrDeviceAudio' => '1.3.6.1.2.1.25.3.1.11',
  'hrDeviceCoprocessor' => '1.3.6.1.2.1.25.3.1.12',
  'hrDeviceKeyboard' => '1.3.6.1.2.1.25.3.1.13',
  'hrDeviceModem' => '1.3.6.1.2.1.25.3.1.14',
  'hrDeviceParallelPort' => '1.3.6.1.2.1.25.3.1.15',
  'hrDevicePointing' => '1.3.6.1.2.1.25.3.1.16',
  'hrDeviceSerialPort' => '1.3.6.1.2.1.25.3.1.17',
  'hrDeviceTape' => '1.3.6.1.2.1.25.3.1.18',
  'hrDeviceClock' => '1.3.6.1.2.1.25.3.1.19',
  'hrDeviceVolatileMemory' => '1.3.6.1.2.1.25.3.1.20',
  'hrDeviceNonVolatileMemory' => '1.3.6.1.2.1.25.3.1.21',
  'hrDeviceTable' => '1.3.6.1.2.1.25.3.2',
  'hrDeviceEntry' => '1.3.6.1.2.1.25.3.2.1',
  'hrDeviceIndex' => '1.3.6.1.2.1.25.3.2.1.1',
  'hrDeviceType' => '1.3.6.1.2.1.25.3.2.1.2',
  'hrDeviceDescr' => '1.3.6.1.2.1.25.3.2.1.3',
  'hrDeviceID' => '1.3.6.1.2.1.25.3.2.1.4',
  'hrDeviceStatus' => '1.3.6.1.2.1.25.3.2.1.5',
  'hrDeviceErrors' => '1.3.6.1.2.1.25.3.2.1.6',
  'hrProcessorTable' => '1.3.6.1.2.1.25.3.3',
  'hrProcessorEntry' => '1.3.6.1.2.1.25.3.3.1',
  'hrProcessorFrwID' => '1.3.6.1.2.1.25.3.3.1.1',
  'hrProcessorLoad' => '1.3.6.1.2.1.25.3.3.1.2',
  'hrNetworkTable' => '1.3.6.1.2.1.25.3.4',
  'hrNetworkEntry' => '1.3.6.1.2.1.25.3.4.1',
  'hrNetworkIfIndex' => '1.3.6.1.2.1.25.3.4.1.1',
  'hrPrinterTable' => '1.3.6.1.2.1.25.3.5',
  'hrPrinterEntry' => '1.3.6.1.2.1.25.3.5.1',
  'hrPrinterStatus' => '1.3.6.1.2.1.25.3.5.1.1',
  'hrPrinterDetectedErrorState' => '1.3.6.1.2.1.25.3.5.1.2',
  'hrDiskStorageTable' => '1.3.6.1.2.1.25.3.6',
  'hrDiskStorageEntry' => '1.3.6.1.2.1.25.3.6.1',
  'hrDiskStorageAccess' => '1.3.6.1.2.1.25.3.6.1.1',
  'hrDiskStorageMedia' => '1.3.6.1.2.1.25.3.6.1.2',
  'hrDiskStorageRemoveble' => '1.3.6.1.2.1.25.3.6.1.3',
  'hrDiskStorageCapacity' => '1.3.6.1.2.1.25.3.6.1.4',
  'hrPartitionTable' => '1.3.6.1.2.1.25.3.7',
  'hrPartitionEntry' => '1.3.6.1.2.1.25.3.7.1',
  'hrPartitionIndex' => '1.3.6.1.2.1.25.3.7.1.1',
  'hrPartitionLabel' => '1.3.6.1.2.1.25.3.7.1.2',
  'hrPartitionID' => '1.3.6.1.2.1.25.3.7.1.3',
  'hrPartitionSize' => '1.3.6.1.2.1.25.3.7.1.4',
  'hrPartitionFSIndex' => '1.3.6.1.2.1.25.3.7.1.5',
  'hrFSTable' => '1.3.6.1.2.1.25.3.8',
  'hrFSEntry' => '1.3.6.1.2.1.25.3.8.1',
  'hrFSIndex' => '1.3.6.1.2.1.25.3.8.1.1',
  'hrFSMountPoint' => '1.3.6.1.2.1.25.3.8.1.2',
  'hrFSRemoteMountPoint' => '1.3.6.1.2.1.25.3.8.1.3',
  'hrFSType' => '1.3.6.1.2.1.25.3.8.1.4',
  'hrFSAccess' => '1.3.6.1.2.1.25.3.8.1.5',
  'hrFSBootable' => '1.3.6.1.2.1.25.3.8.1.6',
  'hrFSStorageIndex' => '1.3.6.1.2.1.25.3.8.1.7',
  'hrFSLastFullBackupDate' => '1.3.6.1.2.1.25.3.8.1.8',
  'hrFSLastPartialBackupDate' => '1.3.6.1.2.1.25.3.8.1.9',
  'hrFSTypes' => '1.3.6.1.2.1.25.3.9',
  'hrFSOther' => '1.3.6.1.2.1.25.3.9.1',
  'hrFSUnknown' => '1.3.6.1.2.1.25.3.9.2',
  'hrFSBerkeleyFFS' => '1.3.6.1.2.1.25.3.9.3',
  'hrFSSys5FS' => '1.3.6.1.2.1.25.3.9.4',
  'hrFSFat' => '1.3.6.1.2.1.25.3.9.5',
  'hrFSHPFS' => '1.3.6.1.2.1.25.3.9.6',
  'hrFSHFS' => '1.3.6.1.2.1.25.3.9.7',
  'hrFSMFS' => '1.3.6.1.2.1.25.3.9.8',
  'hrFSNTFS' => '1.3.6.1.2.1.25.3.9.9',
  'hrFSVNode' => '1.3.6.1.2.1.25.3.9.10',
  'hrFSJournaled' => '1.3.6.1.2.1.25.3.9.11',
  'hrFSiso9660' => '1.3.6.1.2.1.25.3.9.12',
  'hrFSRockRidge' => '1.3.6.1.2.1.25.3.9.13',
  'hrFSNFS' => '1.3.6.1.2.1.25.3.9.14',
  'hrFSNetware' => '1.3.6.1.2.1.25.3.9.15',
  'hrFSAFS' => '1.3.6.1.2.1.25.3.9.16',
  'hrFSDFS' => '1.3.6.1.2.1.25.3.9.17',
  'hrFSAppleshare' => '1.3.6.1.2.1.25.3.9.18',
  'hrFSRFS' => '1.3.6.1.2.1.25.3.9.19',
  'hrFSDGCFS' => '1.3.6.1.2.1.25.3.9.20',
  'hrFSBFS' => '1.3.6.1.2.1.25.3.9.21',
  'hrSWRun' => '1.3.6.1.2.1.25.4',
  'hrSWOSIndex' => '1.3.6.1.2.1.25.4.1.0',
  'hrSWRunTable' => '1.3.6.1.2.1.25.4.2',
  'hrSWRunEntry' => '1.3.6.1.2.1.25.4.2.1',
  'hrSWRunIndex' => '1.3.6.1.2.1.25.4.2.1.1',
  'hrSWRunName' => '1.3.6.1.2.1.25.4.2.1.2',
  'hrSWRunID' => '1.3.6.1.2.1.25.4.2.1.3',
  'hrSWRunPath' => '1.3.6.1.2.1.25.4.2.1.4',
  'hrSWRunParameters' => '1.3.6.1.2.1.25.4.2.1.5',
  'hrSWRunType' => '1.3.6.1.2.1.25.4.2.1.6',
  'hrSWRunStatus' => '1.3.6.1.2.1.25.4.2.1.7',
  'hrSWRunPerf' => '1.3.6.1.2.1.25.5',
  'hrSWRunPerfTable' => '1.3.6.1.2.1.25.5.1',
  'hrSWRunPerfEntry' => '1.3.6.1.2.1.25.5.1.1',
  'hrSWRunPerfCPU' => '1.3.6.1.2.1.25.5.1.1.1',
  'hrSWRunPerfMem' => '1.3.6.1.2.1.25.5.1.1.2',
  'hrSWInstalled' => '1.3.6.1.2.1.25.6',
  'hrSWInstalledLastChange' => '1.3.6.1.2.1.25.6.1.0',
  'hrSWInstalledLastUpdateTime' => '1.3.6.1.2.1.25.6.2.0',
  'hrSWInstalledTable' => '1.3.6.1.2.1.25.6.3',
  'hrSWInstalledEntry' => '1.3.6.1.2.1.25.6.3.1',
  'hrSWInstalledIndex' => '1.3.6.1.2.1.25.6.3.1.1',
  'hrSWInstalledName' => '1.3.6.1.2.1.25.6.3.1.2',
  'hrSWInstalledID' => '1.3.6.1.2.1.25.6.3.1.3',
  'hrSWInstalledType' => '1.3.6.1.2.1.25.6.3.1.4',
  'hrSWInstalledDate' => '1.3.6.1.2.1.25.6.3.1.5',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::HPICFCHASSISMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'HP-ICF-CHASSIS-MIB'} = {
  url => '',
  name => 'HP-ICF-CHASSIS-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'HP-ICF-CHASSIS-MIB'} =
  '1.3.6.1.4.1.11.2.14.11.1.2.6';
# sensor-table, because lots of oids will be superseeded by std. entity-mib
# However, the hpicfSensorTable will still be valid.

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'HP-ICF-CHASSIS-MIB'} = {
  'hpicfSensorTable' => '1.3.6.1.4.1.11.2.14.11.1.2.6',
  'hpicfSensorEntry' => '1.3.6.1.4.1.11.2.14.11.1.2.6.1',
  'hpicfSensorIndex' => '1.3.6.1.4.1.11.2.14.11.1.2.6.1.1',
  'hpicfSensorObjectId' => '1.3.6.1.4.1.11.2.14.11.1.2.6.1.2',
  'hpicfSensorObjectIdDefinition' => {
    '1' => 'fan sensor',
    '2' => 'power supply',
    '3' => 'redundant power supply',
    '4' => 'over-temperature sensor',
  },
  'hpicfSensorNumber' => '1.3.6.1.4.1.11.2.14.11.1.2.6.1.3',
  'hpicfSensorStatus' => '1.3.6.1.4.1.11.2.14.11.1.2.6.1.4',
  'hpicfSensorStatusDefinition' => {
    '1' => 'unknown',
    '2' => 'bad',
    '3' => 'warning',
    '4' => 'good',
    '5' => 'notPresent',
  },
  'hpicfSensorWarnings' => '1.3.6.1.4.1.11.2.14.11.1.2.6.1.5',
  'hpicfSensorFailures' => '1.3.6.1.4.1.11.2.14.11.1.2.6.1.6',
  'hpicfSensorDescr' => '1.3.6.1.4.1.11.2.14.11.1.2.6.1.7',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::IFMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'IFMIB'} = {
  url => '',
  name => 'IFMIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'IFMIB'} = {
  'ifNumber' => '1.3.6.1.2.1.2.1',
  'ifTable' => '1.3.6.1.2.1.2.2',
  'ifEntry' => '1.3.6.1.2.1.2.2.1',
  'ifIndex' => '1.3.6.1.2.1.2.2.1.1',
  'ifDescr' => '1.3.6.1.2.1.2.2.1.2',
  'ifType' => '1.3.6.1.2.1.2.2.1.3',
  'ifTypeDefinition' => 'IFMIB::ifType',
  'ifMtu' => '1.3.6.1.2.1.2.2.1.4',
  'ifSpeed' => '1.3.6.1.2.1.2.2.1.5',
  'ifPhysAddress' => '1.3.6.1.2.1.2.2.1.6',
  'ifAdminStatus' => '1.3.6.1.2.1.2.2.1.7',
  'ifAdminStatusDefinition' => {
    '1' => 'up',
    '2' => 'down',
    '3' => 'testing',
  },
  'ifOperStatus' => '1.3.6.1.2.1.2.2.1.8',
  'ifOperStatusDefinition' => {
    '1' => 'up',
    '2' => 'down',
    '3' => 'testing',
    '4' => 'unknown',
    '5' => 'dormant',
    '6' => 'notPresent',
    '7' => 'lowerLayerDown',
  },
  'ifLastChange' => '1.3.6.1.2.1.2.2.1.9',
  'ifInOctets' => '1.3.6.1.2.1.2.2.1.10',
  'ifInUcastPkts' => '1.3.6.1.2.1.2.2.1.11',
  'ifInNUcastPkts' => '1.3.6.1.2.1.2.2.1.12',
  'ifInDiscards' => '1.3.6.1.2.1.2.2.1.13',
  'ifInErrors' => '1.3.6.1.2.1.2.2.1.14',
  'ifInUnknownProtos' => '1.3.6.1.2.1.2.2.1.15',
  'ifOutOctets' => '1.3.6.1.2.1.2.2.1.16',
  'ifOutUcastPkts' => '1.3.6.1.2.1.2.2.1.17',
  'ifOutNUcastPkts' => '1.3.6.1.2.1.2.2.1.18',
  'ifOutDiscards' => '1.3.6.1.2.1.2.2.1.19',
  'ifOutErrors' => '1.3.6.1.2.1.2.2.1.20',
  'ifOutQLen' => '1.3.6.1.2.1.2.2.1.21',
  'ifSpecific' => '1.3.6.1.2.1.2.2.1.22',
  'ifXTable' => '1.3.6.1.2.1.31.1.1',
  'ifXEntry' => '1.3.6.1.2.1.31.1.1.1',
  'ifName' => '1.3.6.1.2.1.31.1.1.1.1',
  'ifInMulticastPkts' => '1.3.6.1.2.1.31.1.1.1.2',
  'ifInBroadcastPkts' => '1.3.6.1.2.1.31.1.1.1.3',
  'ifOutMulticastPkts' => '1.3.6.1.2.1.31.1.1.1.4',
  'ifOutBroadcastPkts' => '1.3.6.1.2.1.31.1.1.1.5',
  'ifHCInOctets' => '1.3.6.1.2.1.31.1.1.1.6',
  'ifHCInUcastPkts' => '1.3.6.1.2.1.31.1.1.1.7',
  'ifHCInMulticastPkts' => '1.3.6.1.2.1.31.1.1.1.8',
  'ifHCInBroadcastPkts' => '1.3.6.1.2.1.31.1.1.1.9',
  'ifHCOutOctets' => '1.3.6.1.2.1.31.1.1.1.10',
  'ifHCOutUcastPkts' => '1.3.6.1.2.1.31.1.1.1.11',
  'ifHCOutMulticastPkts' => '1.3.6.1.2.1.31.1.1.1.12',
  'ifHCOutBroadcastPkts' => '1.3.6.1.2.1.31.1.1.1.13',
  'ifLinkUpDownTrapEnable' => '1.3.6.1.2.1.31.1.1.1.14',
  'ifLinkUpDownTrapEnableDefinition' => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  'ifHighSpeed' => '1.3.6.1.2.1.31.1.1.1.15',
  'ifPromiscuousMode' => '1.3.6.1.2.1.31.1.1.1.16',
  'ifConnectorPresent' => '1.3.6.1.2.1.31.1.1.1.17',
  'ifAlias' => '1.3.6.1.2.1.31.1.1.1.18',
  'ifCounterDiscontinuityTime' => '1.3.6.1.2.1.31.1.1.1.19',
  'ifTableLastChange' => '1.3.6.1.2.1.31.1.5',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'IFMIB'} = {
  'ifType' => {
    '1' => 'other',
    '2' => 'regular1822',
    '3' => 'hdh1822',
    '4' => 'ddnX25',
    '5' => 'rfc877x25',
    '6' => 'ethernetCsmacd',
    '7' => 'iso88023Csmacd',
    '8' => 'iso88024TokenBus',
    '9' => 'iso88025TokenRing',
    '10' => 'iso88026Man',
    '11' => 'starLan',
    '12' => 'proteon10Mbit',
    '13' => 'proteon80Mbit',
    '14' => 'hyperchannel',
    '15' => 'fddi',
    '16' => 'lapb',
    '17' => 'sdlc',
    '18' => 'ds1',
    '19' => 'e1',
    '20' => 'basicISDN',
    '21' => 'primaryISDN',
    '22' => 'propPointToPointSerial',
    '23' => 'ppp',
    '24' => 'softwareLoopback',
    '25' => 'eon',
    '26' => 'ethernet3Mbit',
    '27' => 'nsip',
    '28' => 'slip',
    '29' => 'ultra',
    '30' => 'ds3',
    '31' => 'sip',
    '32' => 'frameRelay',
    '33' => 'rs232',
    '34' => 'para',
    '35' => 'arcnet',
    '36' => 'arcnetPlus',
    '37' => 'atm',
    '38' => 'miox25',
    '39' => 'sonet',
    '40' => 'x25ple',
    '41' => 'iso88022llc',
    '42' => 'localTalk',
    '43' => 'smdsDxi',
    '44' => 'frameRelayService',
    '45' => 'v35',
    '46' => 'hssi',
    '47' => 'hippi',
    '48' => 'modem',
    '49' => 'aal5',
    '50' => 'sonetPath',
    '51' => 'sonetVT',
    '52' => 'smdsIcip',
    '53' => 'propVirtual',
    '54' => 'propMultiplexor',
    '55' => 'ieee80212',
    '56' => 'fibreChannel',
    '57' => 'hippiInterface',
    '58' => 'frameRelayInterconnect',
    '59' => 'aflane8023',
    '60' => 'aflane8025',
    '61' => 'cctEmul',
    '62' => 'fastEther',
    '63' => 'isdn',
    '64' => 'v11',
    '65' => 'v36',
    '66' => 'g703at64k',
    '67' => 'g703at2mb',
    '68' => 'qllc',
    '69' => 'fastEtherFX',
    '70' => 'channel',
    '71' => 'ieee80211',
    '72' => 'ibm370parChan',
    '73' => 'escon',
    '74' => 'dlsw',
    '75' => 'isdns',
    '76' => 'isdnu',
    '77' => 'lapd',
    '78' => 'ipSwitch',
    '79' => 'rsrb',
    '80' => 'atmLogical',
    '81' => 'ds0',
    '82' => 'ds0Bundle',
    '83' => 'bsc',
    '84' => 'async',
    '85' => 'cnr',
    '86' => 'iso88025Dtr',
    '87' => 'eplrs',
    '88' => 'arap',
    '89' => 'propCnls',
    '90' => 'hostPad',
    '91' => 'termPad',
    '92' => 'frameRelayMPI',
    '93' => 'x213',
    '94' => 'adsl',
    '95' => 'radsl',
    '96' => 'sdsl',
    '97' => 'vdsl',
    '98' => 'iso88025CRFPInt',
    '99' => 'myrinet',
    '100' => 'voiceEM',
    '101' => 'voiceFXO',
    '102' => 'voiceFXS',
    '103' => 'voiceEncap',
    '104' => 'voiceOverIp',
    '105' => 'atmDxi',
    '106' => 'atmFuni',
    '107' => 'atmIma',
    '108' => 'pppMultilinkBundle',
    '109' => 'ipOverCdlc',
    '110' => 'ipOverClaw',
    '111' => 'stackToStack',
    '112' => 'virtualIpAddress',
    '113' => 'mpc',
    '114' => 'ipOverAtm',
    '115' => 'iso88025Fiber',
    '116' => 'tdlc',
    '117' => 'gigabitEthernet',
    '118' => 'hdlc',
    '119' => 'lapf',
    '120' => 'v37',
    '121' => 'x25mlp',
    '122' => 'x25huntGroup',
    '123' => 'transpHdlc',
    '124' => 'interleave',
    '125' => 'fast',
    '126' => 'ip',
    '127' => 'docsCableMaclayer',
    '128' => 'docsCableDownstream',
    '129' => 'docsCableUpstream',
    '130' => 'a12MppSwitch',
    '131' => 'tunnel',
    '132' => 'coffee',
    '133' => 'ces',
    '134' => 'atmSubInterface',
    '135' => 'l2vlan',
    '136' => 'l3ipvlan',
    '137' => 'l3ipxvlan',
    '138' => 'digitalPowerline',
    '139' => 'mediaMailOverIp',
    '140' => 'dtm',
    '141' => 'dcn',
    '142' => 'ipForward',
    '143' => 'msdsl',
    '144' => 'ieee1394',
    '145' => 'if-gsn',
    '146' => 'dvbRccMacLayer',
    '147' => 'dvbRccDownstream',
    '148' => 'dvbRccUpstream',
    '149' => 'atmVirtual',
    '150' => 'mplsTunnel',
    '151' => 'srp',
    '152' => 'voiceOverAtm',
    '153' => 'voiceOverFrameRelay',
    '154' => 'idsl',
    '155' => 'compositeLink',
    '156' => 'ss7SigLink',
    '157' => 'propWirelessP2P',
    '158' => 'frForward',
    '159' => 'rfc1483',
    '160' => 'usb',
    '161' => 'ieee8023adLag',
    '162' => 'bgppolicyaccounting',
    '163' => 'frf16MfrBundle',
    '164' => 'h323Gatekeeper',
    '165' => 'h323Proxy',
    '166' => 'mpls',
    '167' => 'mfSigLink',
    '168' => 'hdsl2',
    '169' => 'shdsl',
    '170' => 'ds1FDL',
    '171' => 'pos',
    '172' => 'dvbAsiIn',
    '173' => 'dvbAsiOut',
    '174' => 'plc',
    '175' => 'nfas',
    '176' => 'tr008',
    '177' => 'gr303RDT',
    '178' => 'gr303IDT',
    '179' => 'isup',
    '180' => 'propDocsWirelessMaclayer',
    '181' => 'propDocsWirelessDownstream',
    '182' => 'propDocsWirelessUpstream',
    '183' => 'hiperlan2',
    '184' => 'propBWAp2Mp',
    '185' => 'sonetOverheadChannel',
    '186' => 'digitalWrapperOverheadChannel',
    '187' => 'aal2',
    '188' => 'radioMAC',
    '189' => 'atmRadio',
    '190' => 'imt',
    '191' => 'mvl',
    '192' => 'reachDSL',
    '193' => 'frDlciEndPt',
    '194' => 'atmVciEndPt',
    '195' => 'opticalChannel',
    '196' => 'opticalTransport',
    '197' => 'propAtm',
    '198' => 'voiceOverCable',
    '199' => 'infiniband',
    '200' => 'teLink',
    '201' => 'q2931',
    '202' => 'virtualTg',
    '203' => 'sipTg',
    '204' => 'sipSig',
    '205' => 'docsCableUpstreamChannel',
    '206' => 'econet',
    '207' => 'pon155',
    '208' => 'pon622',
    '209' => 'bridge',
    '210' => 'linegroup',
    '211' => 'voiceEMFGD',
    '212' => 'voiceFGDEANA',
    '213' => 'voiceDID',
    '214' => 'mpegTransport',
    '215' => 'sixToFour',
    '216' => 'gtp',
    '217' => 'pdnEtherLoop1',
    '218' => 'pdnEtherLoop2',
    '219' => 'opticalChannelGroup',
    '220' => 'homepna',
    '221' => 'gfp',
    '222' => 'ciscoISLvlan',
    '223' => 'actelisMetaLOOP',
    '224' => 'fcipLink',
    '225' => 'rpr',
    '226' => 'qam',
    '227' => 'lmp',
    '228' => 'cblVectaStar',
    '229' => 'docsCableMCmtsDownstream',
    '230' => 'adsl2',
    '231' => 'macSecControlledIF',
    '232' => 'macSecUncontrolledIF',
    '233' => 'aviciOpticalEther',
    '234' => 'atmbond',
    '235' => 'voiceFGDOS',
    '236' => 'mocaVersion1',
    '237' => 'ieee80216WMAN',
    '238' => 'adsl2plus',
    '239' => 'dvbRcsMacLayer',
    '240' => 'dvbTdm',
    '241' => 'dvbRcsTdma',
    '242' => 'x86Laps',
    '243' => 'wwanPP',
    '244' => 'wwanPP2',
    '245' => 'voiceEBS',
    '246' => 'ifPwType',
    '247' => 'ilan',
    '248' => 'pip',
    '249' => 'aluELP',
    '250' => 'gpon',
    '251' => 'vdsl2',
    '252' => 'capwapDot11Profile',
    '253' => 'capwapDot11Bss',
    '254' => 'capwapWtpVirtualRadio',
    '255' => 'bits',
    '256' => 'docsCableUpstreamRfPort',
    '257' => 'cableDownstreamRfPort',
    '258' => 'vmwareVirtualNic',
    '259' => 'ieee802154',
    '260' => 'otnOdu',
    '261' => 'otnOtu',
    '262' => 'ifVfiType',
    '263' => 'g9981',
    '264' => 'g9982',
    '265' => 'g9983',
    '266' => 'aluEpon',
    '267' => 'aluEponOnu',
    '268' => 'aluEponPhysicalUni',
    '269' => 'aluEponLogicalLink',
    '270' => 'aluGponOnu',
    '271' => 'aluGponPhysicalUni',
    '272' => 'vmwareNicTeam',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::IPFORWARDMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'IP-FORWARD-MIB'} = {
  url => '',
  name => 'IP-FORWARD-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::requirements->{'IP-FORWARD-MIB'} = [
  'SNMPv2-TC-v1-MIB',
];

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'IP-FORWARD-MIB'} = 
  '1.3.6.1.2.1.4.24';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'IP-FORWARD-MIB'} = {
  'ipForward' => '1.3.6.1.2.1.4.24',
  'ipForwardNumber' => '1.3.6.1.2.1.4.24.1.0',
  'ipForwardTable' => '1.3.6.1.2.1.4.24.2',
  'ipForwardEntry' => '1.3.6.1.2.1.4.24.2.1',
  'ipForwardDest' => '1.3.6.1.2.1.4.24.2.1.1',
  'ipForwardMask' => '1.3.6.1.2.1.4.24.2.1.2',
  'ipForwardPolicy' => '1.3.6.1.2.1.4.24.2.1.3',
  'ipForwardNextHop' => '1.3.6.1.2.1.4.24.2.1.4',
  'ipForwardIfIndex' => '1.3.6.1.2.1.4.24.2.1.5',
  'ipForwardType' => '1.3.6.1.2.1.4.24.2.1.6',
  'ipForwardProto' => '1.3.6.1.2.1.4.24.2.1.7',
  'ipForwardAge' => '1.3.6.1.2.1.4.24.2.1.8',
  'ipForwardInfo' => '1.3.6.1.2.1.4.24.2.1.9',
  'ipForwardNextHopAS' => '1.3.6.1.2.1.4.24.2.1.10',
  'ipForwardMetric1' => '1.3.6.1.2.1.4.24.2.1.11',
  'ipForwardMetric2' => '1.3.6.1.2.1.4.24.2.1.12',
  'ipForwardMetric3' => '1.3.6.1.2.1.4.24.2.1.13',
  'ipForwardMetric4' => '1.3.6.1.2.1.4.24.2.1.14',
  'ipForwardMetric5' => '1.3.6.1.2.1.4.24.2.1.15',
  'ipCidrRouteNumber' => '1.3.6.1.2.1.4.24.3.0',
  'ipCidrRouteTable' => '1.3.6.1.2.1.4.24.4',
  'ipCidrRouteEntry' => '1.3.6.1.2.1.4.24.4.1',
  'ipCidrRouteDest' => '1.3.6.1.2.1.4.24.4.1.1',
  'ipCidrRouteMask' => '1.3.6.1.2.1.4.24.4.1.2',
  'ipCidrRouteTos' => '1.3.6.1.2.1.4.24.4.1.3',
  'ipCidrRouteNextHop' => '1.3.6.1.2.1.4.24.4.1.4',
  'ipCidrRouteIfIndex' => '1.3.6.1.2.1.4.24.4.1.5',
  'ipCidrRouteType' => '1.3.6.1.2.1.4.24.4.1.6',
  'ipCidrRouteTypeDefinition' => {
    '1' => 'other',
    '2' => 'reject',
    '3' => 'local',
    '4' => 'remote',
  },
  'ipCidrRouteProto' => '1.3.6.1.2.1.4.24.4.1.7',
  'ipCidrRouteProtoDefinition' => {
    '1' => 'other',
    '2' => 'local',
    '3' => 'netmgmt',
    '4' => 'icmp',
    '5' => 'egp',
    '6' => 'ggp',
    '7' => 'hello',
    '8' => 'rip',
    '9' => 'isIs',
    '10' => 'esIs',
    '11' => 'ciscoIgrp',
    '12' => 'bbnSpfIgp',
    '13' => 'ospf',
    '14' => 'bgp',
    '15' => 'idpr',
    '16' => 'ciscoEigrp',
  },
  'ipCidrRouteAge' => '1.3.6.1.2.1.4.24.4.1.8',
  'ipCidrRouteInfo' => '1.3.6.1.2.1.4.24.4.1.9',
  'ipCidrRouteNextHopAS' => '1.3.6.1.2.1.4.24.4.1.10',
  'ipCidrRouteMetric1' => '1.3.6.1.2.1.4.24.4.1.11',
  'ipCidrRouteMetric2' => '1.3.6.1.2.1.4.24.4.1.12',
  'ipCidrRouteMetric3' => '1.3.6.1.2.1.4.24.4.1.13',
  'ipCidrRouteMetric4' => '1.3.6.1.2.1.4.24.4.1.14',
  'ipCidrRouteMetric5' => '1.3.6.1.2.1.4.24.4.1.15',
  'ipCidrRouteStatus' => '1.3.6.1.2.1.4.24.4.1.16',
  'ipCidrRouteStatusDefinition' => 'SNMPv2-TC-v1-MIB::RowStatus',
  'ipForwardConformance' => '1.3.6.1.2.1.4.24.5',
  'ipForwardGroups' => '1.3.6.1.2.1.4.24.5.1',
  'ipForwardCompliances' => '1.3.6.1.2.1.4.24.5.2',
  'inetCidrRouteNumber' => '1.3.6.1.2.1.4.24.6.0',
  'inetCidrRouteTable' => '1.3.6.1.2.1.4.24.7',
  'inetCidrRouteEntry' => '1.3.6.1.2.1.4.24.7.1',
  'inetCidrRouteDestType' => '1.3.6.1.2.1.4.24.7.1.1',
  'inetCidrRouteDest' => '1.3.6.1.2.1.4.24.7.1.2',
  'inetCidrRoutePfxLen' => '1.3.6.1.2.1.4.24.7.1.3',
  'inetCidrRoutePolicy' => '1.3.6.1.2.1.4.24.7.1.4',
  'inetCidrRouteNextHopType' => '1.3.6.1.2.1.4.24.7.1.5',
  'inetCidrRouteNextHop' => '1.3.6.1.2.1.4.24.7.1.6',
  'inetCidrRouteIfIndex' => '1.3.6.1.2.1.4.24.7.1.7',
  'inetCidrRouteType' => '1.3.6.1.2.1.4.24.7.1.8',
  'inetCidrRouteProto' => '1.3.6.1.2.1.4.24.7.1.9',
  'inetCidrRouteAge' => '1.3.6.1.2.1.4.24.7.1.10',
  'inetCidrRouteNextHopAS' => '1.3.6.1.2.1.4.24.7.1.11',
  'inetCidrRouteMetric1' => '1.3.6.1.2.1.4.24.7.1.12',
  'inetCidrRouteMetric2' => '1.3.6.1.2.1.4.24.7.1.13',
  'inetCidrRouteMetric3' => '1.3.6.1.2.1.4.24.7.1.14',
  'inetCidrRouteMetric4' => '1.3.6.1.2.1.4.24.7.1.15',
  'inetCidrRouteMetric5' => '1.3.6.1.2.1.4.24.7.1.16',
  'inetCidrRouteStatus' => '1.3.6.1.2.1.4.24.7.1.17',
  'inetCidrRouteDiscards' => '1.3.6.1.2.1.4.24.8.0',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::IPMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'IP-MIB'} = {
  url => '',
  name => 'IP-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'IP-MIB'} = {
  'ip' => '1.3.6.1.2.1.4',
  'ipForwarding' => '1.3.6.1.2.1.4.1',
  'ipDefaultTTL' => '1.3.6.1.2.1.4.2',
  'ipInReceives' => '1.3.6.1.2.1.4.3',
  'ipInHdrErrors' => '1.3.6.1.2.1.4.4',
  'ipInAddrErrors' => '1.3.6.1.2.1.4.5',
  'ipForwDatagrams' => '1.3.6.1.2.1.4.6',
  'ipInUnknownProtos' => '1.3.6.1.2.1.4.7',
  'ipInDiscards' => '1.3.6.1.2.1.4.8',
  'ipInDelivers' => '1.3.6.1.2.1.4.9',
  'ipOutRequests' => '1.3.6.1.2.1.4.10',
  'ipOutDiscards' => '1.3.6.1.2.1.4.11',
  'ipOutNoRoutes' => '1.3.6.1.2.1.4.12',
  'ipReasmTimeout' => '1.3.6.1.2.1.4.13',
  'ipReasmReqds' => '1.3.6.1.2.1.4.14',
  'ipReasmOKs' => '1.3.6.1.2.1.4.15',
  'ipReasmFails' => '1.3.6.1.2.1.4.16',
  'ipFragOKs' => '1.3.6.1.2.1.4.17',
  'ipFragFails' => '1.3.6.1.2.1.4.18',
  'ipFragCreates' => '1.3.6.1.2.1.4.19',
  'ipAddrTable' => '1.3.6.1.2.1.4.20',
  'ipAddrEntry' => '1.3.6.1.2.1.4.20.1',
  'ipAdEntAddr' => '1.3.6.1.2.1.4.20.1.1',
  'ipAdEntIfIndex' => '1.3.6.1.2.1.4.20.1.2',
  'ipAdEntNetMask' => '1.3.6.1.2.1.4.20.1.3',
  'ipAdEntBcastAddr' => '1.3.6.1.2.1.4.20.1.4',
  'ipAdEntReasmMaxSize' => '1.3.6.1.2.1.4.20.1.5',
  'ipRouteTable' => '1.3.6.1.2.1.4.21',
  'ipRouteEntry' => '1.3.6.1.2.1.4.21.1',
  'ipRouteDest' => '1.3.6.1.2.1.4.21.1.1',
  'ipRouteIfIndex' => '1.3.6.1.2.1.4.21.1.2',
  'ipRouteMetric1' => '1.3.6.1.2.1.4.21.1.3',
  'ipRouteMetric2' => '1.3.6.1.2.1.4.21.1.4',
  'ipRouteMetric3' => '1.3.6.1.2.1.4.21.1.5',
  'ipRouteMetric4' => '1.3.6.1.2.1.4.21.1.6',
  'ipRouteNextHop' => '1.3.6.1.2.1.4.21.1.7',
  'ipRouteType' => '1.3.6.1.2.1.4.21.1.8',
  'ipRouteProto' => '1.3.6.1.2.1.4.21.1.9',
  'ipRouteAge' => '1.3.6.1.2.1.4.21.1.10',
  'ipRouteMask' => '1.3.6.1.2.1.4.21.1.11',
  'ipRouteMetric5' => '1.3.6.1.2.1.4.21.1.12',
  'ipRouteInfo' => '1.3.6.1.2.1.4.21.1.13',
  'ipNetToMediaTable' => '1.3.6.1.2.1.4.22',
  'ipNetToMediaEntry' => '1.3.6.1.2.1.4.22.1',
  'ipNetToMediaIfIndex' => '1.3.6.1.2.1.4.22.1.1',
  'ipNetToMediaPhysAddress' => '1.3.6.1.2.1.4.22.1.2',
  'ipNetToMediaNetAddress' => '1.3.6.1.2.1.4.22.1.3',
  'ipNetToMediaType' => '1.3.6.1.2.1.4.22.1.4',
  'ipRoutingDiscards' => '1.3.6.1.2.1.4.23',
  'icmp' => '1.3.6.1.2.1.5',
  'icmpInMsgs' => '1.3.6.1.2.1.5.1',
  'icmpInErrors' => '1.3.6.1.2.1.5.2',
  'icmpInDestUnreachs' => '1.3.6.1.2.1.5.3',
  'icmpInTimeExcds' => '1.3.6.1.2.1.5.4',
  'icmpInParmProbs' => '1.3.6.1.2.1.5.5',
  'icmpInSrcQuenchs' => '1.3.6.1.2.1.5.6',
  'icmpInRedirects' => '1.3.6.1.2.1.5.7',
  'icmpInEchos' => '1.3.6.1.2.1.5.8',
  'icmpInEchoReps' => '1.3.6.1.2.1.5.9',
  'icmpInTimestamps' => '1.3.6.1.2.1.5.10',
  'icmpInTimestampReps' => '1.3.6.1.2.1.5.11',
  'icmpInAddrMasks' => '1.3.6.1.2.1.5.12',
  'icmpInAddrMaskReps' => '1.3.6.1.2.1.5.13',
  'icmpOutMsgs' => '1.3.6.1.2.1.5.14',
  'icmpOutErrors' => '1.3.6.1.2.1.5.15',
  'icmpOutDestUnreachs' => '1.3.6.1.2.1.5.16',
  'icmpOutTimeExcds' => '1.3.6.1.2.1.5.17',
  'icmpOutParmProbs' => '1.3.6.1.2.1.5.18',
  'icmpOutSrcQuenchs' => '1.3.6.1.2.1.5.19',
  'icmpOutRedirects' => '1.3.6.1.2.1.5.20',
  'icmpOutEchos' => '1.3.6.1.2.1.5.21',
  'icmpOutEchoReps' => '1.3.6.1.2.1.5.22',
  'icmpOutTimestamps' => '1.3.6.1.2.1.5.23',
  'icmpOutTimestampReps' => '1.3.6.1.2.1.5.24',
  'icmpOutAddrMasks' => '1.3.6.1.2.1.5.25',
  'icmpOutAddrMaskReps' => '1.3.6.1.2.1.5.26',
  'ipMIBConformance' => '1.3.6.1.2.1.48.2',
  'ipMIBCompliances' => '1.3.6.1.2.1.48.2.1',
  'ipMIBGroups' => '1.3.6.1.2.1.48.2.2',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::JUNIPERMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'JUNIPER-MIB'} = {
  url => '',
  name => 'JUNIPER-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'JUNIPER-MIB'} =
  '1.3.6.1.4.1.2636.3.1';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'JUNIPER-MIB'} = {
  jnxBoxAnatomy => '1.3.6.1.4.1.2636.3.1',
  jnxBoxClass => '1.3.6.1.4.1.2636.3.1.1',
  jnxBoxDescr => '1.3.6.1.4.1.2636.3.1.2',
  jnxBoxSerialNo => '1.3.6.1.4.1.2636.3.1.3',
  jnxBoxRevision => '1.3.6.1.4.1.2636.3.1.4',
  jnxBoxInstalled => '1.3.6.1.4.1.2636.3.1.5',
  jnxContainersTable => '1.3.6.1.4.1.2636.3.1.6',
  jnxContainersEntry => '1.3.6.1.4.1.2636.3.1.6.1',
  jnxContainersIndex => '1.3.6.1.4.1.2636.3.1.6.1.1',
  jnxContainersView => '1.3.6.1.4.1.2636.3.1.6.1.2',
  jnxContainersLevel => '1.3.6.1.4.1.2636.3.1.6.1.3',
  jnxContainersWithin => '1.3.6.1.4.1.2636.3.1.6.1.4',
  jnxContainersType => '1.3.6.1.4.1.2636.3.1.6.1.5',
  jnxContainersDescr => '1.3.6.1.4.1.2636.3.1.6.1.6',
  jnxContainersCount => '1.3.6.1.4.1.2636.3.1.6.1.7',
  jnxContentsLastChange => '1.3.6.1.4.1.2636.3.1.7',
  jnxContentsTable => '1.3.6.1.4.1.2636.3.1.8',
  jnxContentsEntry => '1.3.6.1.4.1.2636.3.1.8.1',
  jnxContentsContainerIndex => '1.3.6.1.4.1.2636.3.1.8.1.1',
  jnxContentsL1Index => '1.3.6.1.4.1.2636.3.1.8.1.2',
  jnxContentsL2Index => '1.3.6.1.4.1.2636.3.1.8.1.3',
  jnxContentsL3Index => '1.3.6.1.4.1.2636.3.1.8.1.4',
  jnxContentsType => '1.3.6.1.4.1.2636.3.1.8.1.5',
  jnxContentsDescr => '1.3.6.1.4.1.2636.3.1.8.1.6',
  jnxContentsSerialNo => '1.3.6.1.4.1.2636.3.1.8.1.7',
  jnxContentsRevision => '1.3.6.1.4.1.2636.3.1.8.1.8',
  jnxContentsInstalled => '1.3.6.1.4.1.2636.3.1.8.1.9',
  jnxContentsPartNo => '1.3.6.1.4.1.2636.3.1.8.1.10',
  jnxContentsChassisId => '1.3.6.1.4.1.2636.3.1.8.1.11',
  jnxContentsChassisIdDefinition => 'JUNIPER-MIB::JnxChassisId',
  jnxContentsChassisDescr => '1.3.6.1.4.1.2636.3.1.8.1.12',
  jnxContentsChassisCleiCode => '1.3.6.1.4.1.2636.3.1.8.1.13',
  jnxLEDLastChange => '1.3.6.1.4.1.2636.3.1.9',
  jnxLEDTable => '1.3.6.1.4.1.2636.3.1.10',
  jnxLEDEntry => '1.3.6.1.4.1.2636.3.1.10.1',
  jnxLEDAssociateTable => '1.3.6.1.4.1.2636.3.1.10.1.1',
  jnxLEDAssociateTableDefinition => 'JUNIPER-MIB::jnxLEDAssociateTable',
  jnxLEDAssociateIndex => '1.3.6.1.4.1.2636.3.1.10.1.2',
  jnxLEDL1Index => '1.3.6.1.4.1.2636.3.1.10.1.3',
  jnxLEDL2Index => '1.3.6.1.4.1.2636.3.1.10.1.4',
  jnxLEDL3Index => '1.3.6.1.4.1.2636.3.1.10.1.5',
  jnxLEDOriginator => '1.3.6.1.4.1.2636.3.1.10.1.6',
  jnxLEDDescr => '1.3.6.1.4.1.2636.3.1.10.1.7',
  jnxLEDState => '1.3.6.1.4.1.2636.3.1.10.1.8',
  jnxLEDStateDefinition => 'JUNIPER-MIB::jnxLEDState',
  jnxLEDStateOrdered => '1.3.6.1.4.1.2636.3.1.10.1.9',
  jnxLEDStateOrderedDefinition => 'JUNIPER-MIB::jnxLEDStateOrdered',
  jnxFilledLastChange => '1.3.6.1.4.1.2636.3.1.11',
  jnxFilledTable => '1.3.6.1.4.1.2636.3.1.12',
  jnxFilledEntry => '1.3.6.1.4.1.2636.3.1.12.1',
  jnxFilledContainerIndex => '1.3.6.1.4.1.2636.3.1.12.1.1',
  jnxFilledL1Index => '1.3.6.1.4.1.2636.3.1.12.1.2',
  jnxFilledL2Index => '1.3.6.1.4.1.2636.3.1.12.1.3',
  jnxFilledL3Index => '1.3.6.1.4.1.2636.3.1.12.1.4',
  jnxFilledDescr => '1.3.6.1.4.1.2636.3.1.12.1.5',
  jnxFilledState => '1.3.6.1.4.1.2636.3.1.12.1.6',
  jnxFilledStateDefinition => 'JUNIPER-MIB::jnxFilledState',
  jnxFilledChassisId => '1.3.6.1.4.1.2636.3.1.12.1.7',
  jnxFilledChassisIdDefinition => 'JUNIPER-MIB::JnxChassisId',
  jnxFilledChassisDescr => '1.3.6.1.4.1.2636.3.1.12.1.8',
  jnxOperatingTable => '1.3.6.1.4.1.2636.3.1.13',
  jnxOperatingEntry => '1.3.6.1.4.1.2636.3.1.13.1',
  jnxOperatingContentsIndex => '1.3.6.1.4.1.2636.3.1.13.1.1',
  jnxOperatingL1Index => '1.3.6.1.4.1.2636.3.1.13.1.2',
  jnxOperatingL2Index => '1.3.6.1.4.1.2636.3.1.13.1.3',
  jnxOperatingL3Index => '1.3.6.1.4.1.2636.3.1.13.1.4',
  jnxOperatingDescr => '1.3.6.1.4.1.2636.3.1.13.1.5',
  jnxOperatingState => '1.3.6.1.4.1.2636.3.1.13.1.6',
  jnxOperatingStateDefinition => 'JUNIPER-MIB::jnxOperatingState',
  jnxOperatingTemp => '1.3.6.1.4.1.2636.3.1.13.1.7',
  jnxOperatingCPU => '1.3.6.1.4.1.2636.3.1.13.1.8',
  jnxOperatingISR => '1.3.6.1.4.1.2636.3.1.13.1.9',
  jnxOperatingDRAMSize => '1.3.6.1.4.1.2636.3.1.13.1.10',
  jnxOperatingBuffer => '1.3.6.1.4.1.2636.3.1.13.1.11',
  jnxOperatingHeap => '1.3.6.1.4.1.2636.3.1.13.1.12',
  jnxOperatingUpTime => '1.3.6.1.4.1.2636.3.1.13.1.13',
  jnxOperatingLastRestart => '1.3.6.1.4.1.2636.3.1.13.1.14',
  jnxOperatingMemory => '1.3.6.1.4.1.2636.3.1.13.1.15',
  jnxOperatingStateOrdered => '1.3.6.1.4.1.2636.3.1.13.1.16',
  jnxOperatingStateOrderedDefinition => 'JUNIPER-MIB::jnxOperatingStateOrdered',
  jnxOperatingChassisId => '1.3.6.1.4.1.2636.3.1.13.1.17',
  jnxOperatingChassisIdDefinition => 'JUNIPER-MIB::JnxChassisId',
  jnxOperatingChassisDescr => '1.3.6.1.4.1.2636.3.1.13.1.18',
  jnxOperatingRestartTime => '1.3.6.1.4.1.2636.3.1.13.1.19',
  jnxRedundancyTable => '1.3.6.1.4.1.2636.3.1.14',
  jnxRedundancyEntry => '1.3.6.1.4.1.2636.3.1.14.1',
  jnxRedundancyContentsIndex => '1.3.6.1.4.1.2636.3.1.14.1.1',
  jnxRedundancyL1Index => '1.3.6.1.4.1.2636.3.1.14.1.2',
  jnxRedundancyL2Index => '1.3.6.1.4.1.2636.3.1.14.1.3',
  jnxRedundancyL3Index => '1.3.6.1.4.1.2636.3.1.14.1.4',
  jnxRedundancyDescr => '1.3.6.1.4.1.2636.3.1.14.1.5',
  jnxRedundancyConfig => '1.3.6.1.4.1.2636.3.1.14.1.6',
  jnxRedundancyConfigDefinition => 'JUNIPER-MIB::jnxRedundancyConfig',
  jnxRedundancyState => '1.3.6.1.4.1.2636.3.1.14.1.7',
  jnxRedundancyStateDefinition => 'JUNIPER-MIB::jnxRedundancyState',
  jnxRedundancySwitchoverCount => '1.3.6.1.4.1.2636.3.1.14.1.8',
  jnxRedundancySwitchoverTime => '1.3.6.1.4.1.2636.3.1.14.1.9',
  jnxRedundancySwitchoverReason => '1.3.6.1.4.1.2636.3.1.14.1.10',
  jnxRedundancySwitchoverReasonDefinition => 'JUNIPER-MIB::jnxRedundancySwitchoverReason',
  jnxRedundancyKeepaliveHeartbeat => '1.3.6.1.4.1.2636.3.1.14.1.11',
  jnxRedundancyKeepaliveTimeout => '1.3.6.1.4.1.2636.3.1.14.1.12',
  jnxRedundancyKeepaliveElapsed => '1.3.6.1.4.1.2636.3.1.14.1.13',
  jnxRedundancyKeepaliveLoss => '1.3.6.1.4.1.2636.3.1.14.1.14',
  jnxRedundancyChassisId => '1.3.6.1.4.1.2636.3.1.14.1.15',
  jnxRedundancyChassisIdDefinition => 'JUNIPER-MIB::JnxChassisId',
  jnxRedundancyChassisDescr => '1.3.6.1.4.1.2636.3.1.14.1.16',
  jnxFruTable => '1.3.6.1.4.1.2636.3.1.15',
  jnxFruEntry => '1.3.6.1.4.1.2636.3.1.15.1',
  jnxFruContentsIndex => '1.3.6.1.4.1.2636.3.1.15.1.1',
  jnxFruL1Index => '1.3.6.1.4.1.2636.3.1.15.1.2',
  jnxFruL2Index => '1.3.6.1.4.1.2636.3.1.15.1.3',
  jnxFruL3Index => '1.3.6.1.4.1.2636.3.1.15.1.4',
  jnxFruName => '1.3.6.1.4.1.2636.3.1.15.1.5',
  jnxFruType => '1.3.6.1.4.1.2636.3.1.15.1.6',
  jnxFruTypeDefinition => 'JUNIPER-MIB::jnxFruType',
  jnxFruSlot => '1.3.6.1.4.1.2636.3.1.15.1.7',
  jnxFruState => '1.3.6.1.4.1.2636.3.1.15.1.8',
  jnxFruStateDefinition => 'JUNIPER-MIB::jnxFruState',
  jnxFruTemp => '1.3.6.1.4.1.2636.3.1.15.1.9',
  jnxFruOfflineReason => '1.3.6.1.4.1.2636.3.1.15.1.10',
  jnxFruOfflineReasonDefinition => 'JUNIPER-MIB::jnxFruOfflineReason',
  jnxFruLastPowerOff => '1.3.6.1.4.1.2636.3.1.15.1.11',
  jnxFruLastPowerOn => '1.3.6.1.4.1.2636.3.1.15.1.12',
  jnxFruPowerUpTime => '1.3.6.1.4.1.2636.3.1.15.1.13',
  jnxFruChassisId => '1.3.6.1.4.1.2636.3.1.15.1.14',
  jnxFruChassisIdDefinition => 'JUNIPER-MIB::JnxChassisId',
  jnxFruChassisDescr => '1.3.6.1.4.1.2636.3.1.15.1.15',
  jnxFruPsdAssignment => '1.3.6.1.4.1.2636.3.1.15.1.16',
  jnxBoxKernelMemoryUsedPercent => '1.3.6.1.4.1.2636.3.1.16',
  jnxBoxSystemDomainType => '1.3.6.1.4.1.2636.3.1.17',
  jnxBoxSystemDomainTypeDefinition => 'JUNIPER-MIB::jnxBoxSystemDomainType',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'JUNIPER-MIB'} = {
  jnxFruState => {
    '1' => 'unknown',
    '2' => 'empty',
    '3' => 'present',
    '4' => 'ready',
    '5' => 'announceOnline',
    '6' => 'online',
    '7' => 'anounceOffline',
    '8' => 'offline',
    '9' => 'diagnostic',
    '10' => 'standby',
  },
  jnxLEDAssociateTable => {
    '1' => 'other',
    '2' => 'jnxContainersTable',
    '3' => 'jnxContentsTable',
  },
  jnxFruType => {
    '1' => 'other',
    '2' => 'clockGenerator',
    '3' => 'flexiblePicConcentrator',
    '4' => 'switchingAndForwardingModule',
    '5' => 'controlBoard',
    '6' => 'routingEngine',
    '7' => 'powerEntryModule',
    '8' => 'frontPanelModule',
    '9' => 'switchInterfaceBoard',
    '10' => 'processorMezzanineBoardForSIB',
    '11' => 'portInterfaceCard',
    '12' => 'craftInterfacePanel',
    '13' => 'fan',
    '14' => 'lineCardChassis',
    '15' => 'forwardingEngineBoard',
    '16' => 'protectedSystemDomain',
  },
  jnxOperatingState => {
    '1' => 'unknown',
    '2' => 'running',
    '3' => 'ready',
    '4' => 'reset',
    '5' => 'runningAtFullSpeed',
    '6' => 'down',
    '7' => 'standby',
  },
  jnxRedundancySwitchoverReason => {
    '1' => 'other',
    '2' => 'neverSwitched',
    '3' => 'userSwitched',
    '4' => 'autoSwitched',
  },
  jnxFilledState => {
    '1' => 'unknown',
    '2' => 'empty',
    '3' => 'filled',
  },
  jnxBoxSystemDomainType => {
    '1' => 'notApplicable',
    '2' => 'rootSystemDomain',
    '3' => 'protectedSystemDomain',
  },
  JnxChassisId => {
    '1' => 'unknown',
    '2' => 'singleChassis',
    '3' => 'scc',
    '4' => 'lcc0',
    '5' => 'lcc1',
    '6' => 'lcc2',
    '7' => 'lcc3',
    '8' => 'jcs1',
    '9' => 'jcs2',
    '10' => 'jcs3',
    '11' => 'jcs4',
    '12' => 'node0',
    '13' => 'node1',
    '14' => 'sfc0',
    '15' => 'sfc1',
    '16' => 'sfc2',
    '17' => 'sfc3',
    '18' => 'sfc4',
    '19' => 'lcc4',
    '20' => 'lcc5',
    '21' => 'lcc6',
    '22' => 'lcc7',
    '23' => 'lcc8',
    '24' => 'lcc9',
    '25' => 'lcc10',
    '26' => 'lcc11',
    '27' => 'lcc12',
    '28' => 'lcc13',
    '29' => 'lcc14',
    '30' => 'lcc15',
  },
  jnxRedundancyConfig => {
    '1' => 'unknown',
    '2' => 'master',
    '3' => 'backup',
    '4' => 'disabled',
    '5' => 'notApplicable',
  },
  jnxLEDState => {
    '1' => 'other',
    '2' => 'green',
    '3' => 'yellow',
    '4' => 'red',
    '5' => 'blue',
    '6' => 'amber',
  },
  jnxOperatingStateOrdered => {
    '1' => 'running',
    '2' => 'standby',
    '3' => 'ready',
    '4' => 'runningAtFullSpeed',
    '5' => 'reset',
    '6' => 'down',
    '7' => 'unknown',
  },
  jnxFruOfflineReason => {
    '1' => 'unknown',
    '2' => 'none',
    '3' => 'error',
    '4' => 'noPower',
    '5' => 'configPowerOff',
    '6' => 'configHoldInReset',
    '7' => 'cliCommand',
    '8' => 'buttonPress',
    '9' => 'cliRestart',
    '10' => 'overtempShutdown',
    '11' => 'masterClockDown',
    '12' => 'singleSfmModeChange',
    '13' => 'packetSchedulingModeChange',
    '14' => 'physicalRemoval',
    '15' => 'unresponsiveRestart',
    '16' => 'sonetClockAbsent',
    '17' => 'rddPowerOff',
    '18' => 'majorErrors',
    '19' => 'minorErrors',
    '20' => 'lccHardRestart',
    '21' => 'lccVersionMismatch',
    '22' => 'powerCycle',
    '23' => 'reconnect',
    '24' => 'overvoltage',
    '25' => 'pfeVersionMismatch',
    '26' => 'febRddCfgChange',
    '27' => 'fpcMisconfig',
    '28' => 'fruReconnectFail',
    '29' => 'fruFwddReset',
    '30' => 'fruFebSwitch',
    '31' => 'fruFebOffline',
    '32' => 'fruInServSoftUpgradeError',
    '33' => 'fruChasdPowerRatingExceed',
    '34' => 'fruConfigOffline',
    '35' => 'fruServiceRestartRequest',
    '36' => 'spuResetRequest',
    '37' => 'spuFlowdDown',
    '38' => 'spuSpi4Down',
    '39' => 'spuWatchdogTimeout',
    '40' => 'spuCoreDump',
    '41' => 'fpgaSpi4LinkDown',
    '42' => 'i3Spi4LinkDown',
    '43' => 'cppDisconnect',
    '44' => 'cpuNotBoot',
    '45' => 'spuCoreDumpComplete',
    '46' => 'rstOnSpcSpuFailure',
    '47' => 'softRstOnSpcSpuFailure',
    '48' => 'hwAuthenticationFailure',
    '49' => 'reconnectFpcFail',
    '50' => 'fpcAppFailed',
    '51' => 'fpcKernelCrash',
    '52' => 'spuFlowdDownNoCore',
    '53' => 'spuFlowdCoreDumpIncomplete',
    '54' => 'spuFlowdCoreDumpComplete',
    '55' => 'spuIdpdDownNoCore',
    '56' => 'spuIdpdCoreDumpIncomplete',
    '57' => 'spuIdpdCoreDumpComplete',
    '58' => 'spuCoreDumpIncomplete',
    '59' => 'spuIdpdDown',
    '60' => 'fruPfeReset',
    '61' => 'fruReconnectNotReady',
    '62' => 'fruSfLinkDown',
  },
  jnxRedundancyState => {
    '1' => 'unknown',
    '2' => 'master',
    '3' => 'backup',
    '4' => 'disabled',
  },
  jnxLEDStateOrdered => {
    '1' => 'blue',
    '2' => 'green',
    '3' => 'amber',
    '4' => 'yellow',
    '5' => 'red',
    '6' => 'other',
  },
};
package Monitoring::GLPlugin::SNMP::MibsAndOids::JUNIPERIVEMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'JUNIPER-IVE-MIB'} = {
  url => '',
  name => 'JUNIPER-IVE-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'JUNIPER-IVE-MIB'} =
    '1.3.6.1.4.1.12532';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'JUNIPER-IVE-MIB'} = {
  'logFullPercent' => '1.3.6.1.4.1.12532.1.0',
  'signedInWebUsers' => '1.3.6.1.4.1.12532.2.0',
  'signedInMailUsers' => '1.3.6.1.4.1.12532.3.0',
  'blockedIP' => '1.3.6.1.4.1.12532.4.0',
  'authServerName' => '1.3.6.1.4.1.12532.5.0',
  'productName' => '1.3.6.1.4.1.12532.6.0',
  'productVersion' => '1.3.6.1.4.1.12532.7.0',
  'fileName' => '1.3.6.1.4.1.12532.8.0',
  'meetingUserCount' => '1.3.6.1.4.1.12532.9.0',
  'iveCpuUtil' => '1.3.6.1.4.1.12532.10.0',
  'iveMemoryUtil' => '1.3.6.1.4.1.12532.11.0',
  'iveConcurrentUsers' => '1.3.6.1.4.1.12532.12.0',
  'clusterConcurrentUsers' => '1.3.6.1.4.1.12532.13.0',
  'iveTotalHits' => '1.3.6.1.4.1.12532.14.0',
  'iveFileHits' => '1.3.6.1.4.1.12532.15.0',
  'iveWebHits' => '1.3.6.1.4.1.12532.16.0',
  'iveAppletHits' => '1.3.6.1.4.1.12532.17.0',
  'ivetermHits' => '1.3.6.1.4.1.12532.18.0',
  'iveSAMHits' => '1.3.6.1.4.1.12532.19.0',
  'iveNCHits' => '1.3.6.1.4.1.12532.20.0',
  'meetingHits' => '1.3.6.1.4.1.12532.21.0',
  'meetingCount' => '1.3.6.1.4.1.12532.22.0',
  'logName' => '1.3.6.1.4.1.12532.23.0',
  'iveSwapUtil' => '1.3.6.1.4.1.12532.24.0',
  'diskFullPercent' => '1.3.6.1.4.1.12532.25.0',
  'logID' => '1.3.6.1.4.1.12532.27.0',
  'logType' => '1.3.6.1.4.1.12532.28.0',
  'logDescription' => '1.3.6.1.4.1.12532.29.0',
  'ivsName' => '1.3.6.1.4.1.12532.30.0',
  'ocspResponderURL' => '1.3.6.1.4.1.12532.31.0',
  'fanDescription' => '1.3.6.1.4.1.12532.32.0',
  'psDescription' => '1.3.6.1.4.1.12532.33.0',
  'raidDescription' => '1.3.6.1.4.1.12532.34.0',
  'clusterName' => '1.3.6.1.4.1.12532.35.0',
  'nodeList' => '1.3.6.1.4.1.12532.36.0',
  'vipType' => '1.3.6.1.4.1.12532.37.0',
  'currentVIP' => '1.3.6.1.4.1.12532.38.0',
  'newVIP' => '1.3.6.1.4.1.12532.39.0',
  'nicEvent' => '1.3.6.1.4.1.12532.40.0',
  'nodeName' => '1.3.6.1.4.1.12532.41.0',
  'iveTemperature' => '1.3.6.1.4.1.12532.42.0',
  'iveVPNTunnels' => '1.3.6.1.4.1.12532.43.0',
  'iveSSLConnections' => '1.3.6.1.4.1.12532.44.0',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::LARAMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'LARA-MIB'} = {
  url => '',
  name => 'LARA-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'LARA-MIB'} = {
  'lantronix' => '1.3.6.1.4.1.244',
  'products' => '1.3.6.1.4.1.244.1',
  'sls' => '1.3.6.1.4.1.244.1.11',
  'board' => '1.3.6.1.4.1.244.1.11.1',
  'Info' => '1.3.6.1.4.1.244.1.11.1.1',
  'firmwareVersion' => '1.3.6.1.4.1.244.1.11.1.1.1',
  'serialNumber' => '1.3.6.1.4.1.244.1.11.1.1.2',
  'IP' => '1.3.6.1.4.1.244.1.11.1.1.3',
  'Netmask' => '1.3.6.1.4.1.244.1.11.1.1.4',
  'Gateway' => '1.3.6.1.4.1.244.1.11.1.1.5',
  'MAC' => '1.3.6.1.4.1.244.1.11.1.1.6',
  'HardwareRev' => '1.3.6.1.4.1.244.1.11.1.1.7',
  'eventType' => '1.3.6.1.4.1.244.1.11.1.1.8',
  'eventDesc' => '1.3.6.1.4.1.244.1.11.1.1.9',
  'userLoginName' => '1.3.6.1.4.1.244.1.11.1.1.10',
  'remoteHost' => '1.3.6.1.4.1.244.1.11.1.1.11',
  'Users' => '1.3.6.1.4.1.244.1.11.1.2',
  'Actions' => '1.3.6.1.4.1.244.1.11.1.3',
  'host' => '1.3.6.1.4.1.244.1.11.2',
  'HostInfo' => '1.3.6.1.4.1.244.1.11.2.1',
  'checkHostPower' => '1.3.6.1.4.1.244.1.11.2.1.1',
  'checkHostPowerDefinition' => {
    '1' => 'hasPower',
    '2' => 'hasnoPower',
    '3' => 'error',
    '4' => 'notsupported',
  },
  'HostActions' => '1.3.6.1.4.1.244.1.11.2.2',
  'Common' => '1.3.6.1.4.1.244.1.11.3',
  'Traps' => '1.3.6.1.4.1.244.1.11.4',
  'DummyTrap' => '1.3.6.1.4.1.244.1.11.4.1',
  'Loginfailed' => '1.3.6.1.4.1.244.1.11.4.2',
  'Loginsuccess' => '1.3.6.1.4.1.244.1.11.4.3',
  'SecurityViolation' => '1.3.6.1.4.1.244.1.11.4.4',
  'Generic' => '1.3.6.1.4.1.244.1.11.4.5',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::LMSENSORSMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'LM-SENSORS-MIB'} = {
  url => '',
  name => 'LM-SENSORS-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'LM-SENSORS-MIB'} = {
  'lmSensors' => '1.3.6.1.4.1.2021.13.16',
  'lmSensorsMIB' => '1.3.6.1.4.1.2021.13.16.1',
  'lmTempSensorsTable' => '1.3.6.1.4.1.2021.13.16.2',
  'lmTempSensorsEntry' => '1.3.6.1.4.1.2021.13.16.2.1',
  'lmTempSensorsIndex' => '1.3.6.1.4.1.2021.13.16.2.1.1',
  'lmTempSensorsDevice' => '1.3.6.1.4.1.2021.13.16.2.1.2',
  'lmTempSensorsValue' => '1.3.6.1.4.1.2021.13.16.2.1.3',
  'lmFanSensorsTable' => '1.3.6.1.4.1.2021.13.16.3',
  'lmFanSensorsEntry' => '1.3.6.1.4.1.2021.13.16.3.1',
  'lmFanSensorsIndex' => '1.3.6.1.4.1.2021.13.16.3.1.1',
  'lmFanSensorsDevice' => '1.3.6.1.4.1.2021.13.16.3.1.2',
  'lmFanSensorsValue' => '1.3.6.1.4.1.2021.13.16.3.1.3',
  'lmVoltSensorsTable' => '1.3.6.1.4.1.2021.13.16.4',
  'lmVoltSensorsEntry' => '1.3.6.1.4.1.2021.13.16.4.1',
  'lmVoltSensorsIndex' => '1.3.6.1.4.1.2021.13.16.4.1.1',
  'lmVoltSensorsDevice' => '1.3.6.1.4.1.2021.13.16.4.1.2',
  'lmVoltSensorsValue' => '1.3.6.1.4.1.2021.13.16.4.1.3',
  'lmMiscSensorsTable' => '1.3.6.1.4.1.2021.13.16.5',
  'lmMiscSensorsEntry' => '1.3.6.1.4.1.2021.13.16.5.1',
  'lmMiscSensorsIndex' => '1.3.6.1.4.1.2021.13.16.5.1.1',
  'lmMiscSensorsDevice' => '1.3.6.1.4.1.2021.13.16.5.1.2',
  'lmMiscSensorsValue' => '1.3.6.1.4.1.2021.13.16.5.1.3',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::LOADBALSYSTEMMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'LOAD-BAL-SYSTEM-MIB'} = {
  url => '',
  name => 'LOAD-BAL-SYSTEM-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'LOAD-BAL-SYSTEM-MIB'} = {
  'poolTable' => '1.3.6.1.4.1.3375.1.1.7.2',
  'poolEntry' => '1.3.6.1.4.1.3375.1.1.7.2.1',
  'poolName' => '1.3.6.1.4.1.3375.1.1.7.2.1.1',
  'poolLBMode' => '1.3.6.1.4.1.3375.1.1.7.2.1.2',
  'poolDependent' => '1.3.6.1.4.1.3375.1.1.7.2.1.3',
  'poolMemberQty' => '1.3.6.1.4.1.3375.1.1.7.2.1.4',
  'poolBitsin' => '1.3.6.1.4.1.3375.1.1.7.2.1.5',
  'poolBitsout' => '1.3.6.1.4.1.3375.1.1.7.2.1.6',
  'poolBitsinHi32' => '1.3.6.1.4.1.3375.1.1.7.2.1.7',
  'poolBitsoutHi32' => '1.3.6.1.4.1.3375.1.1.7.2.1.8',
  'poolPktsin' => '1.3.6.1.4.1.3375.1.1.7.2.1.9',
  'poolPktsout' => '1.3.6.1.4.1.3375.1.1.7.2.1.10',
  'poolPktsinHi32' => '1.3.6.1.4.1.3375.1.1.7.2.1.11',
  'poolPktsoutHi32' => '1.3.6.1.4.1.3375.1.1.7.2.1.12',
  'poolMaxConn' => '1.3.6.1.4.1.3375.1.1.7.2.1.13',
  'poolCurrentConn' => '1.3.6.1.4.1.3375.1.1.7.2.1.14',
  'poolTotalConn' => '1.3.6.1.4.1.3375.1.1.7.2.1.15',
  'poolPersistMode' => '1.3.6.1.4.1.3375.1.1.7.2.1.16',
  'poolSSLTimeout' => '1.3.6.1.4.1.3375.1.1.7.2.1.17',
  'poolSimpleTimeout' => '1.3.6.1.4.1.3375.1.1.7.2.1.18',
  'poolSimpleMask' => '1.3.6.1.4.1.3375.1.1.7.2.1.19',
  'poolStickyMask' => '1.3.6.1.4.1.3375.1.1.7.2.1.20',
  'poolCookieMode' => '1.3.6.1.4.1.3375.1.1.7.2.1.21',
  'poolCookieExpiration' => '1.3.6.1.4.1.3375.1.1.7.2.1.22',
  'poolCookieHashName' => '1.3.6.1.4.1.3375.1.1.7.2.1.23',
  'poolCookieHashOffset' => '1.3.6.1.4.1.3375.1.1.7.2.1.24',
  'poolCookieHashLength' => '1.3.6.1.4.1.3375.1.1.7.2.1.25',
  'poolMinActiveMembers' => '1.3.6.1.4.1.3375.1.1.7.2.1.26',
  'poolActiveMemberCount' => '1.3.6.1.4.1.3375.1.1.7.2.1.27',
  'poolPersistMirror' => '1.3.6.1.4.1.3375.1.1.7.2.1.28',
  'poolFallbackHost' => '1.3.6.1.4.1.3375.1.1.7.2.1.29',
  'poolMemberTable' => '1.3.6.1.4.1.3375.1.1.8.2',
  'poolMemberEntry' => '1.3.6.1.4.1.3375.1.1.8.2.1',
  'poolMemberPoolName' => '1.3.6.1.4.1.3375.1.1.8.2.1.1',
  'poolMemberIpAddress' => '1.3.6.1.4.1.3375.1.1.8.2.1.2',
  'poolMemberPort' => '1.3.6.1.4.1.3375.1.1.8.2.1.3',
  'poolMemberMaintenance' => '1.3.6.1.4.1.3375.1.1.8.2.1.4',
  'poolMemberRatio' => '1.3.6.1.4.1.3375.1.1.8.2.1.5',
  'poolMemberPriority' => '1.3.6.1.4.1.3375.1.1.8.2.1.6',
  'poolMemberWeight' => '1.3.6.1.4.1.3375.1.1.8.2.1.7',
  'poolMemberRipeness' => '1.3.6.1.4.1.3375.1.1.8.2.1.8',
  'poolMemberBitsin' => '1.3.6.1.4.1.3375.1.1.8.2.1.9',
  'poolMemberBitsout' => '1.3.6.1.4.1.3375.1.1.8.2.1.10',
  'poolMemberBitsinHi32' => '1.3.6.1.4.1.3375.1.1.8.2.1.11',
  'poolMemberBitsoutHi32' => '1.3.6.1.4.1.3375.1.1.8.2.1.12',
  'poolMemberPktsin' => '1.3.6.1.4.1.3375.1.1.8.2.1.13',
  'poolMemberPktsout' => '1.3.6.1.4.1.3375.1.1.8.2.1.14',
  'poolMemberPktsinHi32' => '1.3.6.1.4.1.3375.1.1.8.2.1.15',
  'poolMemberPktsoutHi32' => '1.3.6.1.4.1.3375.1.1.8.2.1.16',
  'poolMemberConnLimit' => '1.3.6.1.4.1.3375.1.1.8.2.1.17',
  'poolMemberMaxConn' => '1.3.6.1.4.1.3375.1.1.8.2.1.18',
  'poolMemberCurrentConn' => '1.3.6.1.4.1.3375.1.1.8.2.1.19',
  'poolMemberTotalConn' => '1.3.6.1.4.1.3375.1.1.8.2.1.20',
  'poolMemberStatus' => '1.3.6.1.4.1.3375.1.1.8.2.1.21',
  'poolMemberIpStatus' => '1.3.6.1.4.1.3375.1.1.8.2.1.22',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::MINIIFMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'MINI-IFMIB'} = {
  url => '',
  name => 'MINI-IFMIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'MINI-IFMIB'} = {
  'ifNumber' => '1.3.6.1.2.1.2.1',
  'ifTable' => '1.3.6.1.2.1.2.2',
  'ifEntry' => '1.3.6.1.2.1.2.2.1',
  'ifIndex' => '1.3.6.1.2.1.2.2.1.1',
  'ifDescr' => '1.3.6.1.2.1.2.2.1.2',
  'ifXTable' => '1.3.6.1.2.1.31.1.1',
  'ifXEntry' => '1.3.6.1.2.1.31.1.1.1',
  'ifName' => '1.3.6.1.2.1.31.1.1.1.1',
  'ifAlias' => '1.3.6.1.2.1.31.1.1.1.18',
  'ifTableLastChange' => '1.3.6.1.2.1.31.1.5',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::NETGEARMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'NETGEAR-MIB'} = {
  url => '',
  name => 'NETGEAR-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'NETGEAR-MIB'} = 
  '1.3.6.1.4.1.4526';



package Monitoring::GLPlugin::SNMP::MibsAndOids::NETSCREENCHASSISMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'NETSCREEN-CHASSIS-MIB'} = {
  url => '',
  name => 'NETSCREEN-CHASSIS-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'NETSCREEN-CHASSIS-MIB'} = {
  'nsPowerTable' => '1.3.6.1.4.1.3224.21.1',
  'nsPowerEntry' => '1.3.6.1.4.1.3224.21.1.1',
  'nsPowerId' => '1.3.6.1.4.1.3224.21.1.1.1',
  'nsPowerStatus' => '1.3.6.1.4.1.3224.21.1.1.2',
  'nsPowerStatusDefinition' => {
    '0' => 'fail',
    '1' => 'good',
  },
  'nsPowerDesc' => '1.3.6.1.4.1.3224.21.1.1.3',
  'nsFanTable' => '1.3.6.1.4.1.3224.21.2',
  'nsFanEntry' => '1.3.6.1.4.1.3224.21.2.1',
  'nsFanId' => '1.3.6.1.4.1.3224.21.2.1.1',
  'nsFanStatus' => '1.3.6.1.4.1.3224.21.2.1.2',
  'nsFanStatusDefinition' => {
    '0' => 'fail',
    '1' => 'good',
    '2' => 'notInstalled',
  },
  'nsFanDesc' => '1.3.6.1.4.1.3224.21.2.1.3',
  'sysBatteryStatus' => '1.3.6.1.4.1.3224.21.3.0',
  'sysBatteryStatusDefinition' => {
    '1' => 'good',
    '2' => 'error',
  },
  'nsTemperatureTable' => '1.3.6.1.4.1.3224.21.4',
  'nsTemperatureEntry' => '1.3.6.1.4.1.3224.21.4.1',
  'nsTemperatureId' => '1.3.6.1.4.1.3224.21.4.1.1',
  'nsTemperatureSlotId' => '1.3.6.1.4.1.3224.21.4.1.2',
  'nsTemperatureCur' => '1.3.6.1.4.1.3224.21.4.1.3',
  'nsTemperatureDesc' => '1.3.6.1.4.1.3224.21.4.1.4',
  'nsSlotTable' => '1.3.6.1.4.1.3224.21.5',
  'nsSlotEntry' => '1.3.6.1.4.1.3224.21.5.1',
  'nsSlotId' => '1.3.6.1.4.1.3224.21.5.1.1',
  'nsSlotType' => '1.3.6.1.4.1.3224.21.5.1.2',
  'nsSlotStatus' => '1.3.6.1.4.1.3224.21.5.1.3',
  'nsSlotStatusDefinition' => {
    '0' => 'fail',
    '1' => 'good',
    '2' => 'notInstalled',
  },
  'nsSlotSN' => '1.3.6.1.4.1.3224.21.5.1.4',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::NETSCREENPRODUCTSMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'NETSCREEN-PRODUCTS-MIB'} = {
  url => '',
  name => 'NETSCREEN-PRODUCTS-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'NETSCREEN-PRODUCTS-MIB'} = 
  '1.3.6.1.4.1.3224.1';



package Monitoring::GLPlugin::SNMP::MibsAndOids::NETSCREENRESOURCEMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'NETSCREEN-RESOURCE-MIB'} = {
  url => '',
  name => 'NETSCREEN-RESOURCE-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'NETSCREEN-RESOURCE-MIB'} = {
  'nsResCpuAvg' => '1.3.6.1.4.1.3224.16.1.1.0',
  'nsResCpuLast1Min' => '1.3.6.1.4.1.3224.16.1.2.0',
  'nsResCpuLast5Min' => '1.3.6.1.4.1.3224.16.1.3.0',
  'nsResCpuLast15Min' => '1.3.6.1.4.1.3224.16.1.4.0',
  'nsResMemAllocate' => '1.3.6.1.4.1.3224.16.2.1.0',
  'nsResMemLeft' => '1.3.6.1.4.1.3224.16.2.2.0',
  'nsResMemFrag' => '1.3.6.1.4.1.3224.16.2.3.0',
  'nsResSessAllocate' => '1.3.6.1.4.1.3224.16.3.2.0',
  'nsResSessMaxium' => '1.3.6.1.4.1.3224.16.3.3.0',
  'nsResSessFailed' => '1.3.6.1.4.1.3224.16.3.4.0',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::NETSWITCHMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'NETSWITCH-MIB'} = {
  url => '',
  name => 'NETSWITCH-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'NETSWITCH-MIB'} =
    '1.3.6.1.4.1.11.2.14.11.5.1.1';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'NETSWITCH-MIB'} = {
  hpOpSystem => '1.3.6.1.4.1.11.2.14.11.5.1.1',
  hpBuf => '1.3.6.1.4.1.11.2.14.11.5.1.1.1',
  hpMsgBuf => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.1',
  hpMsgBufTable => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.1.1',
  hpMsgBufEntry => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.1.1.1',
  hpMsgBufSlotIndex => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.1.1.1.1',
  hpMsgBufCorrupted => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.1.1.1.2',
  hpMsgBufFree => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.1.1.1.3',
  hpMsgBufInit => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.1.1.1.4',
  hpMsgBufMin => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.1.1.1.5',
  hpMsgBufMiss => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.1.1.1.6',
  hpMsgBufSize => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.1.1.1.7',
  hpPktBuf => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.2',
  hpPktBufTable => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.2.1',
  hpPktBufEntry => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.2.1.1',
  hpPktBufSlotIndex => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.2.1.1.1',
  hpPktBufCorrupted => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.2.1.1.2',
  hpPktBufFree => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.2.1.1.3',
  hpPktBufInit => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.2.1.1.4',
  hpPktBufMin => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.2.1.1.5',
  hpPktBufMiss => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.2.1.1.6',
  hpPktBufSize => '1.3.6.1.4.1.11.2.14.11.5.1.1.1.2.1.1.7',
  hpMem => '1.3.6.1.4.1.11.2.14.11.5.1.1.2',
  hpLocalMem => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1',
  hpLocalMemTable => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1',
  hpLocalMemEntry => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1',
  hpLocalMemSlotIndex => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.1',
  hpLocalMemSlabCnt => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.2',
  hpLocalMemFreeSegCnt => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.3',
  hpLocalMemAllocSegCnt => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.4',
  hpLocalMemTotalBytes => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.5',
  hpLocalMemFreeBytes => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.6',
  hpLocalMemAllocBytes => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.7',
  hpGlobalMem => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2',
  hpGlobalMemTable => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1',
  hpGlobalMemEntry => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1',
  hpGlobalMemSlotIndex => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1.1',
  hpGlobalMemSlabCnt => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1.2',
  hpGlobalMemFreeSegCnt => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1.3',
  hpGlobalMemAllocSegCnt => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1.4',
  hpGlobalMemTotalBytes => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1.5',
  hpGlobalMemFreeBytes => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1.6',
  hpGlobalMemAllocBytes => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1.7',
  hpSwitchOsVersion => '1.3.6.1.4.1.11.2.14.11.5.1.1.3',
  hpSwitchRomVersion => '1.3.6.1.4.1.11.2.14.11.5.1.1.4',
  hpSwitchSmartCardType => '1.3.6.1.4.1.11.2.14.11.5.1.1.5',
  hpSwitchSmartCardTypeDefinition => 'NETSWITCH-MIB::hpSwitchSmartCardType',
  hpSwitchBaseMACAddress => '1.3.6.1.4.1.11.2.14.11.5.1.1.6',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'NETSWITCH-MIB'} = {
  hpSwitchSmartCardType => {
    '1' => 'none',
    '2' => 'fddi',
    '3' => 'atm',
    '4' => 'fddiAndATM',
    '5' => 'other',
  },
};
package Monitoring::GLPlugin::SNMP::MibsAndOids::OLDCISCOCPUMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'OLD-CISCO-CPU-MIB'} = {
  url => '',
  name => 'OLD-CISCO-CPU-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'OLD-CISCO-CPU-MIB'} = {
  'busyPer' => '1.3.6.1.4.1.9.2.1.56.0',
  'avgBusy1' => '1.3.6.1.4.1.9.2.1.57.0',
  'avgBusy5' => '1.3.6.1.4.1.9.2.1.58.0',
  'idleCount' => '1.3.6.1.4.1.9.2.1.59.0',
  'idleWired' => '1.3.6.1.4.1.9.2.1.60.0',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::OLDNETSWITCHMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'OLD-NETSWITCH-MIB'} = {
  url => '',
  name => 'OLD-NETSWITCH-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'OLD-NETSWITCH-MIB'} = {
  'hpLocalMemTable' => '1.3.6.1.2.1.1.7.11.12.1.2.1.1',
  'hpLocalMemEntry' => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1',
  'hpLocalMemSlotIndex' => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1.1',
  'hpLocalMemSlabCnt' => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1.2',
  'hpLocalMemFreeSegCnt' => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1.3',
  'hpLocalMemAllocSegCnt' => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1.4',
  'hpLocalMemTotalBytes' => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1.5',
  'hpLocalMemFreeBytes' => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1.6',
  'hpLocalMemAllocBytes' => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1.7',
  'hpGlobalMemTable' => '1.3.6.1.2.1.1.7.11.12.1.2.2.1',
  'hpGlobalMemEntry' => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1',
  'hpGlobalMemSlotIndex' => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1.1',
  'hpGlobalMemSlabCnt' => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1.2',
  'hpGlobalMemFreeSegCnt' => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1.3',
  'hpGlobalMemAllocSegCnt' => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1.4',
  'hpGlobalMemTotalBytes' => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1.5',
  'hpGlobalMemFreeBytes' => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1.6',
  'hpGlobalMemAllocBytes' => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1.7',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::OLDSTATISTICSMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'OLD-STATISTICS-MIB'} = {
  url => '',
  name => 'OLD-STATISTICS-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'OLD-STATISTICS-MIB'} = {
  'hpSwitchCpuStat' => '1.3.6.1.2.1.1.7.11.12.9.6.1.0',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::ONEACCESSSYSMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'ONEACCESS-SYS-MIB'} = {
  url => '',
  name => 'ONEACCESS-SYS-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'ONEACCESS-SYS-MIB'} = 
  '1.3.6.1.4.1.13191.1.100.671';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'ONEACCESS-SYS-MIB'} = {
  'oacExpIMSysHwcClassDefinitions' => 'HASH(0x6005a74e0)',
  'oacSysMIBModule' => '1.3.6.1.4.1.13191.1.100.671',
  'oacExpIMSysStatistics' => '1.3.6.1.4.1.13191.10.3.3.1',
  'oacSysMemStatistics' => '1.3.6.1.4.1.13191.10.3.3.1.1',
  'oacSysMemoryFree' => '1.3.6.1.4.1.13191.10.3.3.1.1.1',
  'oacSysMemoryAllocated' => '1.3.6.1.4.1.13191.10.3.3.1.1.2',
  'oacSysMemoryTotal' => '1.3.6.1.4.1.13191.10.3.3.1.1.3',
  'oacSysMemoryUsed' => '1.3.6.1.4.1.13191.10.3.3.1.1.4',
  'oacSysCpuStatistics' => '1.3.6.1.4.1.13191.10.3.3.1.2',
  'oacSysCpuUsed' => '1.3.6.1.4.1.13191.10.3.3.1.2.1',
  'oacSysSecureCrashlogCount' => '1.3.6.1.4.1.13191.10.3.3.1.100',
  'oacExpIMSysHardwareDescription' => '1.3.6.1.4.1.13191.10.3.3.2',
  'oacSysIMSysMainBoard' => '1.3.6.1.4.1.13191.10.3.3.2.1',
  'oacSysIMSysMainIdentifier' => '1.3.6.1.4.1.13191.10.3.3.2.1.1',
  'oacSysIMSysMainManufacturedIdentity' => '1.3.6.1.4.1.13191.10.3.3.2.1.2',
  'oacSysIMSysMainManufacturedDate' => '1.3.6.1.4.1.13191.10.3.3.2.1.3',
  'oacSysIMSysMainCPU' => '1.3.6.1.4.1.13191.10.3.3.2.1.4',
  'oacSysIMSysMainBSPVersion' => '1.3.6.1.4.1.13191.10.3.3.2.1.5',
  'oacSysIMSysMainBootVersion' => '1.3.6.1.4.1.13191.10.3.3.2.1.6',
  'oacSysIMSysMainBootDateCreation' => '1.3.6.1.4.1.13191.10.3.3.2.1.7',
  'oacExpIMSysHwComponents' => '1.3.6.1.4.1.13191.10.3.3.2.2',
  'oacExpIMSysHwComponentsCount' => '1.3.6.1.4.1.13191.10.3.3.2.2.1',
  'oacExpIMSysHwComponentsTable' => '1.3.6.1.4.1.13191.10.3.3.2.2.2',
  'oacExpIMSysHwComponentsEntry' => '1.3.6.1.4.1.13191.10.3.3.2.2.2.1',
  'oacExpIMSysHwcIndex' => '1.3.6.1.4.1.13191.10.3.3.2.2.2.1.1',
  'oacExpIMSysHwcClass' => '1.3.6.1.4.1.13191.10.3.3.2.2.2.1.2',
  'oacExpIMSysHwcType' => '1.3.6.1.4.1.13191.10.3.3.2.2.2.1.3',
  'oacExpIMSysHwcTypeDefinition' => {
    '0' => 'mainboard',
    '1' => 'microprocessor',
    '2' => 'ram',
    '3' => 'flash',
    '4' => 'dsp',
    '5' => 'uplink',
    '6' => 'module',
  },
  'oacExpIMSysHwcDescription' => '1.3.6.1.4.1.13191.10.3.3.2.2.2.1.4',
  'oacExpIMSysHwcSerialNumber' => '1.3.6.1.4.1.13191.10.3.3.2.2.2.1.5',
  'oacExpIMSysHwcManufacturer' => '1.3.6.1.4.1.13191.10.3.3.2.2.2.1.6',
  'oacExpIMSysHwcManufacturedDate' => '1.3.6.1.4.1.13191.10.3.3.2.2.2.1.7',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::OSPFMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'OSPF-MIB'} = {
  url => '',
  name => 'OSPF-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::requirements->{'OSPF-MIB'} = [
  'SNMPv2-TC-v1-MIB',
];

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'OSPF-MIB'} = {
  'ospf' => '1.3.6.1.2.1.14',
  'ospfGeneralGroup' => '1.3.6.1.2.1.14.1',
  'ospfRouterId' => '1.3.6.1.2.1.14.1.1',
  'ospfAdminStat' => '1.3.6.1.2.1.14.1.2',
  'ospfVersionNumber' => '1.3.6.1.2.1.14.1.3',
  'ospfVersionNumberDefinition' => 'OSPF-MIB::ospfVersionNumber',
  'ospfAreaBdrRtrStatus' => '1.3.6.1.2.1.14.1.4',
  'ospfASBdrRtrStatus' => '1.3.6.1.2.1.14.1.5',
  'ospfExternLsaCount' => '1.3.6.1.2.1.14.1.6',
  'ospfExternLsaCksumSum' => '1.3.6.1.2.1.14.1.7',
  'ospfTOSSupport' => '1.3.6.1.2.1.14.1.8',
  'ospfOriginateNewLsas' => '1.3.6.1.2.1.14.1.9',
  'ospfRxNewLsas' => '1.3.6.1.2.1.14.1.10',
  'ospfExtLsdbLimit' => '1.3.6.1.2.1.14.1.11',
  'ospfMulticastExtensions' => '1.3.6.1.2.1.14.1.12',
  'ospfExitOverflowInterval' => '1.3.6.1.2.1.14.1.13',
  'ospfDemandExtensions' => '1.3.6.1.2.1.14.1.14',
  'ospfRFC1583Compatibility' => '1.3.6.1.2.1.14.1.15',
  'ospfOpaqueLsaSupport' => '1.3.6.1.2.1.14.1.16',
  'ospfReferenceBandwidth' => '1.3.6.1.2.1.14.1.17',
  'ospfRestartSupport' => '1.3.6.1.2.1.14.1.18',
  'ospfRestartSupportDefinition' => 'OSPF-MIB::ospfRestartSupport',
  'ospfRestartInterval' => '1.3.6.1.2.1.14.1.19',
  'ospfRestartStrictLsaChecking' => '1.3.6.1.2.1.14.1.20',
  'ospfRestartStatus' => '1.3.6.1.2.1.14.1.21',
  'ospfRestartStatusDefinition' => 'OSPF-MIB::ospfRestartStatus',
  'ospfRestartAge' => '1.3.6.1.2.1.14.1.22',
  'ospfRestartExitReason' => '1.3.6.1.2.1.14.1.23',
  'ospfRestartExitReasonDefinition' => 'OSPF-MIB::ospfRestartExitReason',
  'ospfAsLsaCount' => '1.3.6.1.2.1.14.1.24',
  'ospfAsLsaCksumSum' => '1.3.6.1.2.1.14.1.25',
  'ospfStubRouterSupport' => '1.3.6.1.2.1.14.1.26',
  'ospfStubRouterAdvertisement' => '1.3.6.1.2.1.14.1.27',
  'ospfStubRouterAdvertisementDefinition' => 'OSPF-MIB::ospfStubRouterAdvertisement',
  'ospfDiscontinuityTime' => '1.3.6.1.2.1.14.1.28',
  'ospfAreaTable' => '1.3.6.1.2.1.14.2',
  'ospfAreaEntry' => '1.3.6.1.2.1.14.2.1',
  'ospfAreaId' => '1.3.6.1.2.1.14.2.1.1',
  'ospfAuthType' => '1.3.6.1.2.1.14.2.1.2',
  'ospfAuthTypeDefinition' => {
    '0' => 'none',
    '1' => 'simplePassword',
    '2' => 'md5',
  },
  'ospfImportAsExtern' => '1.3.6.1.2.1.14.2.1.3',
  'ospfImportAsExternDefinition' => 'OSPF-MIB::ospfImportAsExtern',
  'ospfSpfRuns' => '1.3.6.1.2.1.14.2.1.4',
  'ospfAreaBdrRtrCount' => '1.3.6.1.2.1.14.2.1.5',
  'ospfAsBdrRtrCount' => '1.3.6.1.2.1.14.2.1.6',
  'ospfAreaLsaCount' => '1.3.6.1.2.1.14.2.1.7',
  'ospfAreaLsaCksumSum' => '1.3.6.1.2.1.14.2.1.8',
  'ospfAreaSummary' => '1.3.6.1.2.1.14.2.1.9',
  'ospfAreaSummaryDefinition' => 'OSPF-MIB::ospfAreaSummary',
  'ospfAreaStatus' => '1.3.6.1.2.1.14.2.1.10',
  'ospfAreaStatusDefinition' => 'SNMPv2-TC-v1-MIB::RowStatus',
  'ospfAreaNssaTranslatorRole' => '1.3.6.1.2.1.14.2.1.11',
  'ospfAreaNssaTranslatorRoleDefinition' => 'OSPF-MIB::ospfAreaNssaTranslatorRole',
  'ospfAreaNssaTranslatorState' => '1.3.6.1.2.1.14.2.1.12',
  'ospfAreaNssaTranslatorStateDefinition' => 'OSPF-MIB::ospfAreaNssaTranslatorState',
  'ospfAreaNssaTranslatorStabilityInterval' => '1.3.6.1.2.1.14.2.1.13',
  'ospfAreaNssaTranslatorEvents' => '1.3.6.1.2.1.14.2.1.14',
  'ospfStubAreaTable' => '1.3.6.1.2.1.14.3',
  'ospfStubAreaEntry' => '1.3.6.1.2.1.14.3.1',
  'ospfStubAreaId' => '1.3.6.1.2.1.14.3.1.1',
  'ospfStubTOS' => '1.3.6.1.2.1.14.3.1.2',
  'ospfStubMetric' => '1.3.6.1.2.1.14.3.1.3',
  'ospfStubStatus' => '1.3.6.1.2.1.14.3.1.4',
  'ospfStubMetricType' => '1.3.6.1.2.1.14.3.1.5',
  'ospfStubMetricTypeDefinition' => 'OSPF-MIB::ospfStubMetricType',
  'ospfLsdbTable' => '1.3.6.1.2.1.14.4',
  'ospfLsdbEntry' => '1.3.6.1.2.1.14.4.1',
  'ospfLsdbAreaId' => '1.3.6.1.2.1.14.4.1.1',
  'ospfLsdbType' => '1.3.6.1.2.1.14.4.1.2',
  'ospfLsdbTypeDefinition' => 'OSPF-MIB::ospfLsdbType',
  'ospfLsdbLsid' => '1.3.6.1.2.1.14.4.1.3',
  'ospfLsdbRouterId' => '1.3.6.1.2.1.14.4.1.4',
  'ospfLsdbSequence' => '1.3.6.1.2.1.14.4.1.5',
  'ospfLsdbAge' => '1.3.6.1.2.1.14.4.1.6',
  'ospfLsdbChecksum' => '1.3.6.1.2.1.14.4.1.7',
  'ospfLsdbAdvertisement' => '1.3.6.1.2.1.14.4.1.8',
  'ospfAreaRangeTable' => '1.3.6.1.2.1.14.5',
  'ospfAreaRangeEntry' => '1.3.6.1.2.1.14.5.1',
  'ospfAreaRangeAreaId' => '1.3.6.1.2.1.14.5.1.1',
  'ospfAreaRangeNet' => '1.3.6.1.2.1.14.5.1.2',
  'ospfAreaRangeMask' => '1.3.6.1.2.1.14.5.1.3',
  'ospfAreaRangeStatus' => '1.3.6.1.2.1.14.5.1.4',
  'ospfAreaRangeEffect' => '1.3.6.1.2.1.14.5.1.5',
  'ospfAreaRangeEffectDefinition' => 'OSPF-MIB::ospfAreaRangeEffect',
  'ospfHostTable' => '1.3.6.1.2.1.14.6',
  'ospfHostEntry' => '1.3.6.1.2.1.14.6.1',
  'ospfHostIpAddress' => '1.3.6.1.2.1.14.6.1.1',
  'ospfHostTOS' => '1.3.6.1.2.1.14.6.1.2',
  'ospfHostMetric' => '1.3.6.1.2.1.14.6.1.3',
  'ospfHostStatus' => '1.3.6.1.2.1.14.6.1.4',
  'ospfHostStatusDefinition' => 'SNMPv2-TC-v1-MIB::RowStatus',
  'ospfHostAreaID' => '1.3.6.1.2.1.14.6.1.5',
  'ospfHostCfgAreaID' => '1.3.6.1.2.1.14.6.1.6',
  'ospfIfTable' => '1.3.6.1.2.1.14.7',
  'ospfIfEntry' => '1.3.6.1.2.1.14.7.1',
  'ospfIfIpAddress' => '1.3.6.1.2.1.14.7.1.1',
  'ospfAddressLessIf' => '1.3.6.1.2.1.14.7.1.2',
  'ospfIfAreaId' => '1.3.6.1.2.1.14.7.1.3',
  'ospfIfType' => '1.3.6.1.2.1.14.7.1.4',
  'ospfIfTypeDefinition' => 'OSPF-MIB::ospfIfType',
  'ospfIfAdminStat' => '1.3.6.1.2.1.14.7.1.5',
  'ospfIfAdminStatDefinition' => 'OSPF-MIB::Status',
  'ospfIfRtrPriority' => '1.3.6.1.2.1.14.7.1.6',
  'ospfIfTransitDelay' => '1.3.6.1.2.1.14.7.1.7',
  'ospfIfRetransInterval' => '1.3.6.1.2.1.14.7.1.8',
  'ospfIfHelloInterval' => '1.3.6.1.2.1.14.7.1.9',
  'ospfIfRtrDeadInterval' => '1.3.6.1.2.1.14.7.1.10',
  'ospfIfPollInterval' => '1.3.6.1.2.1.14.7.1.11',
  'ospfIfState' => '1.3.6.1.2.1.14.7.1.12',
  'ospfIfStateDefinition' => 'OSPF-MIB::ospfIfState',
  'ospfIfDesignatedRouter' => '1.3.6.1.2.1.14.7.1.13',
  'ospfIfBackupDesignatedRouter' => '1.3.6.1.2.1.14.7.1.14',
  'ospfIfEvents' => '1.3.6.1.2.1.14.7.1.15',
  'ospfIfAuthKey' => '1.3.6.1.2.1.14.7.1.16',
  'ospfIfStatus' => '1.3.6.1.2.1.14.7.1.17',
  'ospfIfStatusDefinition' => 'SNMPv2-TC-v1-MIB::RowStatus',
  'ospfIfMulticastForwarding' => '1.3.6.1.2.1.14.7.1.18',
  'ospfIfMulticastForwardingDefinition' => 'OSPF-MIB::ospfIfMulticastForwarding',
  'ospfIfDemand' => '1.3.6.1.2.1.14.7.1.19',
  'ospfIfDemandDefinition' => 'SNMPv2-TC-v1-MIB::TruthValue',
  'ospfIfAuthType' => '1.3.6.1.2.1.14.7.1.20',
  'ospfIfAuthTypeDefinition' => 'OSPF-MIB::AuType',
  'ospfIfLsaCount' => '1.3.6.1.2.1.14.7.1.21',
  'ospfIfLsaCksumSum' => '1.3.6.1.2.1.14.7.1.22',
  'ospfIfDesignatedRouterId' => '1.3.6.1.2.1.14.7.1.23',
  'ospfIfBackupDesignatedRouterId' => '1.3.6.1.2.1.14.7.1.24',
  'ospfIfMetricTable' => '1.3.6.1.2.1.14.8',
  'ospfIfMetricEntry' => '1.3.6.1.2.1.14.8.1',
  'ospfIfMetricIpAddress' => '1.3.6.1.2.1.14.8.1.1',
  'ospfIfMetricAddressLessIf' => '1.3.6.1.2.1.14.8.1.2',
  'ospfIfMetricTOS' => '1.3.6.1.2.1.14.8.1.3',
  'ospfIfMetricValue' => '1.3.6.1.2.1.14.8.1.4',
  'ospfIfMetricStatus' => '1.3.6.1.2.1.14.8.1.5',
  'ospfIfMetricStatusDefinition' => 'SNMPv2-TC-v1-MIB::RowStatus',
  'ospfVirtIfTable' => '1.3.6.1.2.1.14.9',
  'ospfVirtIfEntry' => '1.3.6.1.2.1.14.9.1',
  'ospfVirtIfAreaId' => '1.3.6.1.2.1.14.9.1.1',
  'ospfVirtIfNeighbor' => '1.3.6.1.2.1.14.9.1.2',
  'ospfVirtIfTransitDelay' => '1.3.6.1.2.1.14.9.1.3',
  'ospfVirtIfRetransInterval' => '1.3.6.1.2.1.14.9.1.4',
  'ospfVirtIfHelloInterval' => '1.3.6.1.2.1.14.9.1.5',
  'ospfVirtIfRtrDeadInterval' => '1.3.6.1.2.1.14.9.1.6',
  'ospfVirtIfState' => '1.3.6.1.2.1.14.9.1.7',
  'ospfVirtIfStateDefinition' => 'OSPF-MIB::ospfVirtIfState',
  'ospfVirtIfEvents' => '1.3.6.1.2.1.14.9.1.8',
  'ospfVirtIfAuthKey' => '1.3.6.1.2.1.14.9.1.9',
  'ospfVirtIfStatus' => '1.3.6.1.2.1.14.9.1.10',
  'ospfVirtIfAuthType' => '1.3.6.1.2.1.14.9.1.11',
  'ospfVirtIfLsaCount' => '1.3.6.1.2.1.14.9.1.12',
  'ospfVirtIfLsaCksumSum' => '1.3.6.1.2.1.14.9.1.13',
  'ospfNbrTable' => '1.3.6.1.2.1.14.10',
  'ospfNbrEntry' => '1.3.6.1.2.1.14.10.1',
  'ospfNbrIpAddr' => '1.3.6.1.2.1.14.10.1.1',
  'ospfNbrAddressLessIndex' => '1.3.6.1.2.1.14.10.1.2',
  'ospfNbrRtrId' => '1.3.6.1.2.1.14.10.1.3',
  'ospfNbrOptions' => '1.3.6.1.2.1.14.10.1.4',
  'ospfNbrPriority' => '1.3.6.1.2.1.14.10.1.5',
  'ospfNbrState' => '1.3.6.1.2.1.14.10.1.6',
  'ospfNbrStateDefinition' => 'OSPF-MIB::ospfNbrState',
  'ospfNbrEvents' => '1.3.6.1.2.1.14.10.1.7',
  'ospfNbrLsRetransQLen' => '1.3.6.1.2.1.14.10.1.8',
  'ospfNbmaNbrStatus' => '1.3.6.1.2.1.14.10.1.9',
  'ospfNbmaNbrStatusDefinition' => 'SNMPv2-TC-v1-MIB::RowStatus',
  'ospfNbmaNbrPermanence' => '1.3.6.1.2.1.14.10.1.10',
  'ospfNbmaNbrPermanenceDefinition' => 'OSPF-MIB::ospfNbmaNbrPermanence',
  'ospfNbrHelloSuppressed' => '1.3.6.1.2.1.14.10.1.11',
  'ospfNbrHelloSuppressedDefinition' => 'SNMPv2-TC-v1-MIB::TruthValue',
  'ospfNbrRestartHelperStatus' => '1.3.6.1.2.1.14.10.1.12',
  'ospfNbrRestartHelperStatusDefinition' => 'OSPF-MIB::ospfNbrRestartHelperStatus',
  'ospfNbrRestartHelperAge' => '1.3.6.1.2.1.14.10.1.13',
  'ospfNbrRestartHelperExitReason' => '1.3.6.1.2.1.14.10.1.14',
  'ospfNbrRestartHelperExitReasonDefinition' => 'OSPF-MIB::ospfNbrRestartHelperExitReason',
  'ospfVirtNbrTable' => '1.3.6.1.2.1.14.11',
  'ospfVirtNbrEntry' => '1.3.6.1.2.1.14.11.1',
  'ospfVirtNbrArea' => '1.3.6.1.2.1.14.11.1.1',
  'ospfVirtNbrRtrId' => '1.3.6.1.2.1.14.11.1.2',
  'ospfVirtNbrIpAddr' => '1.3.6.1.2.1.14.11.1.3',
  'ospfVirtNbrOptions' => '1.3.6.1.2.1.14.11.1.4',
  'ospfVirtNbrOptionsDefinition' => 'OSPF-MIB::ospfVirtNbrOptions',
  'ospfVirtNbrState' => '1.3.6.1.2.1.14.11.1.5',
  'ospfVirtNbrStateDefinition' => 'OSPF-MIB::ospfVirtNbrState',
  'ospfVirtNbrEvents' => '1.3.6.1.2.1.14.11.1.6',
  'ospfVirtNbrLsRetransQLen' => '1.3.6.1.2.1.14.11.1.7',
  'ospfVirtNbrHelloSuppressed' => '1.3.6.1.2.1.14.11.1.8',
  'ospfVirtNbrRestartHelperStatus' => '1.3.6.1.2.1.14.11.1.9',
  'ospfVirtNbrRestartHelperStatusDefinition' => 'OSPF-MIB::ospfVirtNbrRestartHelperStatus',
  'ospfVirtNbrRestartHelperAge' => '1.3.6.1.2.1.14.11.1.10',
  'ospfVirtNbrRestartHelperExitReason' => '1.3.6.1.2.1.14.11.1.11',
  'ospfVirtNbrRestartHelperExitReasonDefinition' => 'OSPF-MIB::ospfVirtNbrRestartHelperExitReason',
  'ospfExtLsdbTable' => '1.3.6.1.2.1.14.12',
  'ospfExtLsdbEntry' => '1.3.6.1.2.1.14.12.1',
  'ospfExtLsdbType' => '1.3.6.1.2.1.14.12.1.1',
  'ospfExtLsdbTypeDefinition' => 'OSPF-MIB::ospfExtLsdbType',
  'ospfExtLsdbLsid' => '1.3.6.1.2.1.14.12.1.2',
  'ospfExtLsdbRouterId' => '1.3.6.1.2.1.14.12.1.3',
  'ospfExtLsdbSequence' => '1.3.6.1.2.1.14.12.1.4',
  'ospfExtLsdbAge' => '1.3.6.1.2.1.14.12.1.5',
  'ospfExtLsdbChecksum' => '1.3.6.1.2.1.14.12.1.6',
  'ospfExtLsdbAdvertisement' => '1.3.6.1.2.1.14.12.1.7',
  'ospfRouteGroup' => '1.3.6.1.2.1.14.13',
  'ospfIntraArea' => '1.3.6.1.2.1.14.13.1',
  'ospfInterArea' => '1.3.6.1.2.1.14.13.2',
  'ospfExternalType1' => '1.3.6.1.2.1.14.13.3',
  'ospfExternalType2' => '1.3.6.1.2.1.14.13.4',
  'ospfAreaAggregateTable' => '1.3.6.1.2.1.14.14',
  'ospfAreaAggregateEntry' => '1.3.6.1.2.1.14.14.1',
  'ospfAreaAggregateAreaID' => '1.3.6.1.2.1.14.14.1.1',
  'ospfAreaAggregateLsdbType' => '1.3.6.1.2.1.14.14.1.2',
  'ospfAreaAggregateLsdbTypeDefinition' => 'OSPF-MIB::ospfAreaAggregateLsdbType',
  'ospfAreaAggregateNet' => '1.3.6.1.2.1.14.14.1.3',
  'ospfAreaAggregateMask' => '1.3.6.1.2.1.14.14.1.4',
  'ospfAreaAggregateStatus' => '1.3.6.1.2.1.14.14.1.5',
  'ospfAreaAggregateEffect' => '1.3.6.1.2.1.14.14.1.6',
  'ospfAreaAggregateEffectDefinition' => 'OSPF-MIB::ospfAreaAggregateEffect',
  'ospfAreaAggregateExtRouteTag' => '1.3.6.1.2.1.14.14.1.7',
  'ospfConformance' => '1.3.6.1.2.1.14.15',
  'ospfGroups' => '1.3.6.1.2.1.14.15.1',
  'ospfCompliances' => '1.3.6.1.2.1.14.15.2',
  'ospfLocalLsdbTable' => '1.3.6.1.2.1.14.17',
  'ospfLocalLsdbEntry' => '1.3.6.1.2.1.14.17.1',
  'ospfLocalLsdbIpAddress' => '1.3.6.1.2.1.14.17.1.1',
  'ospfLocalLsdbAddressLessIf' => '1.3.6.1.2.1.14.17.1.2',
  'ospfLocalLsdbType' => '1.3.6.1.2.1.14.17.1.3',
  'ospfLocalLsdbTypeDefinition' => 'OSPF-MIB::ospfLocalLsdbType',
  'ospfLocalLsdbLsid' => '1.3.6.1.2.1.14.17.1.4',
  'ospfLocalLsdbRouterId' => '1.3.6.1.2.1.14.17.1.5',
  'ospfLocalLsdbSequence' => '1.3.6.1.2.1.14.17.1.6',
  'ospfLocalLsdbAge' => '1.3.6.1.2.1.14.17.1.7',
  'ospfLocalLsdbChecksum' => '1.3.6.1.2.1.14.17.1.8',
  'ospfLocalLsdbAdvertisement' => '1.3.6.1.2.1.14.17.1.9',
  'ospfVirtLocalLsdbTable' => '1.3.6.1.2.1.14.18',
  'ospfVirtLocalLsdbEntry' => '1.3.6.1.2.1.14.18.1',
  'ospfVirtLocalLsdbTransitArea' => '1.3.6.1.2.1.14.18.1.1',
  'ospfVirtLocalLsdbNeighbor' => '1.3.6.1.2.1.14.18.1.2',
  'ospfVirtLocalLsdbType' => '1.3.6.1.2.1.14.18.1.3',
  'ospfVirtLocalLsdbTypeDefinition' => 'OSPF-MIB::ospfVirtLocalLsdbType',
  'ospfVirtLocalLsdbLsid' => '1.3.6.1.2.1.14.18.1.4',
  'ospfVirtLocalLsdbRouterId' => '1.3.6.1.2.1.14.18.1.5',
  'ospfVirtLocalLsdbSequence' => '1.3.6.1.2.1.14.18.1.6',
  'ospfVirtLocalLsdbAge' => '1.3.6.1.2.1.14.18.1.7',
  'ospfVirtLocalLsdbChecksum' => '1.3.6.1.2.1.14.18.1.8',
  'ospfVirtLocalLsdbAdvertisement' => '1.3.6.1.2.1.14.18.1.9',
  'ospfAsLsdbTable' => '1.3.6.1.2.1.14.19',
  'ospfAsLsdbEntry' => '1.3.6.1.2.1.14.19.1',
  'ospfAsLsdbType' => '1.3.6.1.2.1.14.19.1.1',
  'ospfAsLsdbTypeDefinition' => 'OSPF-MIB::ospfAsLsdbType',
  'ospfAsLsdbLsid' => '1.3.6.1.2.1.14.19.1.2',
  'ospfAsLsdbRouterId' => '1.3.6.1.2.1.14.19.1.3',
  'ospfAsLsdbSequence' => '1.3.6.1.2.1.14.19.1.4',
  'ospfAsLsdbAge' => '1.3.6.1.2.1.14.19.1.5',
  'ospfAsLsdbChecksum' => '1.3.6.1.2.1.14.19.1.6',
  'ospfAsLsdbAdvertisement' => '1.3.6.1.2.1.14.19.1.7',
  'ospfAreaLsaCountTable' => '1.3.6.1.2.1.14.20',
  'ospfAreaLsaCountEntry' => '1.3.6.1.2.1.14.20.1',
  'ospfAreaLsaCountAreaId' => '1.3.6.1.2.1.14.20.1.1',
  'ospfAreaLsaCountLsaType' => '1.3.6.1.2.1.14.20.1.2',
  'ospfAreaLsaCountLsaTypeDefinition' => 'OSPF-MIB::ospfAreaLsaCountLsaType',
  'ospfAreaLsaCountNumber' => '1.3.6.1.2.1.14.20.1.3',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'OSPF-MIB'} = {
  'ospfAreaAggregateEffect' => {
    '1' => 'advertiseMatching',
    '2' => 'doNotAdvertiseMatching',
  },
  'ospfLocalLsdbType' => {
    '9' => 'localOpaqueLink',
  },
  'ospfVirtNbrRestartHelperStatus' => {
    '1' => 'notHelping',
    '2' => 'helping',
  },
  'ospfImportAsExtern' => {
    '1' => 'importExternal',
    '2' => 'importNoExternal',
    '3' => 'importNssa',
  },
  'ospfStubMetricType' => {
    '1' => 'ospfMetric',
    '2' => 'comparableCost',
    '3' => 'nonComparable',
  },
  'ospfAreaNssaTranslatorRole' => {
    '1' => 'always',
    '2' => 'candidate',
  },
  'ospfNbrRestartHelperStatus' => {
    '1' => 'notHelping',
    '2' => 'helping',
  },
  'AuType' => {
    '0' => 'Null authentication',
    '1' => 'Simple password',
  },
  'ospfVersionNumber' => {
    '2' => 'version2',
  },
  'ospfAreaAggregateLsdbType' => {
    '3' => 'summaryLink',
    '7' => 'nssaExternalLink',
  },
  'ospfExtLsdbType' => {
    '5' => 'asExternalLink',
  },
  'ospfStubRouterAdvertisement' => {
    '1' => 'doNotAdvertise',
    '2' => 'advertise',
  },
  'ospfAreaNssaTranslatorState' => {
    '1' => 'enabled',
    '2' => 'elected',
    '3' => 'disabled',
  },
  'ospfNbrRestartHelperExitReason' => {
    '1' => 'none',
    '2' => 'inProgress',
    '3' => 'completed',
    '4' => 'timedOut',
    '5' => 'topologyChanged',
  },
  'ospfAreaLsaCountLsaType' => {
    '1' => 'routerLink',
    '2' => 'networkLink',
    '3' => 'summaryLink',
    '4' => 'asSummaryLink',
    '6' => 'multicastLink',
    '7' => 'nssaExternalLink',
    '10' => 'areaOpaqueLink',
  },
  'ospfIfState' => {
    '1' => 'down',
    '2' => 'loopback',
    '3' => 'waiting',
    '4' => 'pointToPoint',
    '5' => 'designatedRouter',
    '6' => 'backupDesignatedRouter',
    '7' => 'otherDesignatedRouter',
  },
  'ospfNbmaNbrPermanence' => {
    '1' => 'dynamic',
    '2' => 'permanent',
  },
  'ospfLsdbType' => {
    '1' => 'routerLink',
    '2' => 'networkLink',
    '3' => 'summaryLink',
    '4' => 'asSummaryLink',
    '5' => 'asExternalLink',
    '6' => 'multicastLink',
    '7' => 'nssaExternalLink',
    '10' => 'areaOpaqueLink',
  },
  'ospfVirtIfState' => {
    '1' => 'down',
    '4' => 'pointToPoint',
  },
  'ospfRestartStatus' => {
    '1' => 'notRestarting',
    '2' => 'plannedRestart',
    '3' => 'unplannedRestart',
  },
  'ospfAreaSummary' => {
    '1' => 'noAreaSummary',
    '2' => 'sendAreaSummary',
  },
  'ospfNbrState' => {
    '1' => 'down',
    '2' => 'attempt',
    '3' => 'init',
    '4' => 'twoWay',
    '5' => 'exchangeStart',
    '6' => 'exchange',
    '7' => 'loading',
    '8' => 'full',
  },
  'ospfVirtNbrRestartHelperExitReason' => {
    '1' => 'none',
    '2' => 'inProgress',
    '3' => 'completed',
    '4' => 'timedOut',
    '5' => 'topologyChanged',
  },
  'ospfRestartExitReason' => {
    '1' => 'none',
    '2' => 'inProgress',
    '3' => 'completed',
    '4' => 'timedOut',
    '5' => 'topologyChanged',
  },
  'ospfIfType' => {
    '1' => 'broadcast',
    '2' => 'nbma',
    '3' => 'pointToPoint',
    '5' => 'pointToMultipoint',
  },
  'Status' => {
    '1' => 'enabled',
    '2' => 'disabled',
  },
  'ospfVirtNbrState' => {
    '1' => 'down',
    '2' => 'attempt',
    '3' => 'init',
    '4' => 'twoWay',
    '5' => 'exchangeStart',
    '6' => 'exchange',
    '7' => 'loading',
    '8' => 'full',
  },
  'ospfAsLsdbType' => {
    '5' => 'asExternalLink',
    '11' => 'asOpaqueLink',
  },
  'ospfAreaRangeEffect' => {
    '1' => 'advertiseMatching',
    '2' => 'doNotAdvertiseMatching',
  },
  'ospfIfMulticastForwarding' => {
    '1' => 'blocked',
    '2' => 'multicast',
    '3' => 'unicast',
  },
  'ospfVirtNbrOptions' => 'REPAIRME',
  'ospfRestartSupport' => {
    '1' => 'none',
    '2' => 'plannedOnly',
    '3' => 'plannedAndUnplanned',
  },
  'ospfVirtLocalLsdbType' => {
    '9' => 'localOpaqueLink',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::PANCOMMONMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'PAN-COMMON-MIB'} = {
  url => '',
  name => 'PAN-COMMON-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'PAN-COMMON-MIB'} = {
  'panCommonConfMib' => '1.3.6.1.4.1.25461.2.1.1',
  'panCommonObjs' => '1.3.6.1.4.1.25461.2.1.2',
  'panSys' => '1.3.6.1.4.1.25461.2.1.2.1',
  'panSysSwVersion' => '1.3.6.1.4.1.25461.2.1.2.1.1.0',
  'panSysHwVersion' => '1.3.6.1.4.1.25461.2.1.2.1.2.0',
  'panSysSerialNumber' => '1.3.6.1.4.1.25461.2.1.2.1.3.0',
  'panSysTimeZoneOffset' => '1.3.6.1.4.1.25461.2.1.2.1.4.0',
  'panSysDaylightSaving' => '1.3.6.1.4.1.25461.2.1.2.1.5.0',
  'panSysVpnClientVersion' => '1.3.6.1.4.1.25461.2.1.2.1.6.0',
  'panSysAppVersion' => '1.3.6.1.4.1.25461.2.1.2.1.7.0',
  'panSysAvVersion' => '1.3.6.1.4.1.25461.2.1.2.1.8.0',
  'panSysThreatVersion' => '1.3.6.1.4.1.25461.2.1.2.1.9.0',
  'panSysUrlFilteringVersion' => '1.3.6.1.4.1.25461.2.1.2.1.10.0',
  'panSysHAState' => '1.3.6.1.4.1.25461.2.1.2.1.11.0',
  'panSysHAPeerState' => '1.3.6.1.4.1.25461.2.1.2.1.12.0',
  'panSysHAMode' => '1.3.6.1.4.1.25461.2.1.2.1.13.0',
  'panSysUrlFilteringDatabase' => '1.3.6.1.4.1.25461.2.1.2.1.14.0',
  'panSysGlobalProtectClientVersion' => '1.3.6.1.4.1.25461.2.1.2.1.15.0',
  'panSysOpswatDatafileVersion' => '1.3.6.1.4.1.25461.2.1.2.1.16.0',
  'panChassis' => '1.3.6.1.4.1.25461.2.1.2.2',
  'panChassisType' => '1.3.6.1.4.1.25461.2.1.2.2.1.0',
  'panMSeriesMode' => '1.3.6.1.4.1.25461.2.1.2.2.2.0',
  'panSession' => '1.3.6.1.4.1.25461.2.1.2.3',
  'panSessionUtilization' => '1.3.6.1.4.1.25461.2.1.2.3.1.0',
  'panSessionMax' => '1.3.6.1.4.1.25461.2.1.2.3.2.0',
  'panSessionActive' => '1.3.6.1.4.1.25461.2.1.2.3.3.0',
  'panSessionActiveTcp' => '1.3.6.1.4.1.25461.2.1.2.3.4.0',
  'panSessionActiveUdp' => '1.3.6.1.4.1.25461.2.1.2.3.5.0',
  'panSessionActiveICMP' => '1.3.6.1.4.1.25461.2.1.2.3.6.0',
  'panSessionActiveSslProxy' => '1.3.6.1.4.1.25461.2.1.2.3.7.0',
  'panSessionSslProxyUtilization' => '1.3.6.1.4.1.25461.2.1.2.3.8.0',
  'panVsysTable' => '1.3.6.1.4.1.25461.2.1.2.3.9',
  'panVsysEntry' => '1.3.6.1.4.1.25461.2.1.2.3.9.1',
  'panVsysId' => '1.3.6.1.4.1.25461.2.1.2.3.9.1.1',
  'panVsysName' => '1.3.6.1.4.1.25461.2.1.2.3.9.1.2',
  'panVsysSessionUtilizationPct' => '1.3.6.1.4.1.25461.2.1.2.3.9.1.3',
  'panVsysActiveSessions' => '1.3.6.1.4.1.25461.2.1.2.3.9.1.4',
  'panVsysMaxSessions' => '1.3.6.1.4.1.25461.2.1.2.3.9.1.5',
  'panMgmt' => '1.3.6.1.4.1.25461.2.1.2.4',
  'panMgmtPanoramaConnected' => '1.3.6.1.4.1.25461.2.1.2.4.1.0',
  'panMgmtPanorama2Connected' => '1.3.6.1.4.1.25461.2.1.2.4.2.0',
  'panGlobalProtect' => '1.3.6.1.4.1.25461.2.1.2.5',
  'panGPGatewayUtilization' => '1.3.6.1.4.1.25461.2.1.2.5.1',
  'panGPGWUtilizationPct' => '1.3.6.1.4.1.25461.2.1.2.5.1.1.0',
  'panGPGWUtilizationMaxTunnels' => '1.3.6.1.4.1.25461.2.1.2.5.1.2.0',
  'panGPGWUtilizationActiveTunnels' => '1.3.6.1.4.1.25461.2.1.2.5.1.3.0',
  'panCommonEvents' => '1.3.6.1.4.1.25461.2.1.3',
  'panCommonEventObjs' => '1.3.6.1.4.1.25461.2.1.3.1',
  'panCommonEventDescr' => '1.3.6.1.4.1.25461.2.1.3.1.1.0',
  'panCommonEventEvents' => '1.3.6.1.4.1.25461.2.1.3.2',
  'panCommonEventEventsV2' => '1.3.6.1.4.1.25461.2.1.3.2.0',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::PANPRODUCTSMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'PAN-PRODUCTS-MIB'} = {
  url => '',
  name => 'PAN-PRODUCTS-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'PAN-PRODUCTS-MIB'} = 
  '1.3.6.1.4.1.25461.2.3';



package Monitoring::GLPlugin::SNMP::MibsAndOids::PROXYMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'PROXY-MIB'} = {
  url => '',
  name => 'PROXY-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'PROXY-MIB'} = {
  'proxyMemUsage' => '1.3.6.1.3.25.17.1.1.0',
  'proxyStorage' => '1.3.6.1.3.25.17.1.2.0',
  'proxyCpuUsage' => '1.3.6.1.3.25.17.1.3.0',
  'proxyUpTime' => '1.3.6.1.3.25.17.1.4.0',
  'proxyConfig' => '1.3.6.1.3.25.17.2',
  'proxyAdmin' => '1.3.6.1.3.25.17.2.1.0',
  'proxySoftware' => '1.3.6.1.3.25.17.2.2.0',
  'proxyVersion' => '1.3.6.1.3.25.17.2.3.0',
  'proxySysPerf' => '1.3.6.1.3.25.17.3.1',
  'proxyCpuLoad' => '1.3.6.1.3.25.17.3.1.1.0',
  'proxyNumObjects' => '1.3.6.1.3.25.17.3.1.2.0',
  'proxyProtoPerf' => '1.3.6.1.3.25.17.3.2',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::RAPIDCITYMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'RAPID-CITY-MIB'} = {
  url => '',
  name => 'RAPID-CITY-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'RAPID-CITY-MIB'} = 
  '1.3.6.1.4.1.2272';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'RAPID-CITY-MIB'} = {
  'rcSysCpuUtil' => '1.3.6.1.4.1.2272.1.1.20',
  'rcSysDramSize' => '1.3.6.1.4.1.2272.1.1.46',
  'rcSysDramUsed' => '1.3.6.1.4.1.2272.1.1.47',
  'rcSysDramFree' => '1.3.6.1.4.1.2272.1.1.48',
  'rcChasSerialNumber' => '1.3.6.1.4.1.2272.1.4.2',
  'rcChasHardwareRevision' => '1.3.6.1.4.1.2272.1.4.3',
  'rcChasNumSlots' => '1.3.6.1.4.1.2272.1.4.4',
  'rcChasNumPorts' => '1.3.6.1.4.1.2272.1.4.5',
  'rcChasTestResult' => '1.3.6.1.4.1.2272.1.4.6',
  'rcChasTestResultDefinition' => {
    '1' => 'other',
    '2' => 'ok',
    '3' => 'crceeprom',
    '4' => 'timer',
    '5' => 'procdram',
    '6' => 'led',
    '7' => 'formaccpuaccess',
    '8' => 'asiccpuaccess',
    '9' => 'memory',
    '10' => 'loopback',
  },
  'rcChasFan' => '1.3.6.1.4.1.2272.1.4.7',
  'rcChasFanTable' => '1.3.6.1.4.1.2272.1.4.7.1',
  'rcChasFanEntry' => '1.3.6.1.4.1.2272.1.4.7.1.1',
  'rcChasFanId' => '1.3.6.1.4.1.2272.1.4.7.1.1.1',
  'rcChasFanOperStatus' => '1.3.6.1.4.1.2272.1.4.7.1.1.2',
  'rcChasFanOperStatusDefinition' => {
    '1' => 'unknown',
    '2' => 'up',
    '3' => 'down',
  },
  'rcChasFanAmbientTemperature' => '1.3.6.1.4.1.2272.1.4.7.1.1.3',
  'rcChasPowerSupply' => '1.3.6.1.4.1.2272.1.4.8',
  'rcChasPowerSupplyTable' => '1.3.6.1.4.1.2272.1.4.8.1',
  'rcChasPowerSupplyEntry' => '1.3.6.1.4.1.2272.1.4.8.1.1',
  'rcChasPowerSupplyId' => '1.3.6.1.4.1.2272.1.4.8.1.1.1',
  'rcChasPowerSupplyOperStatus' => '1.3.6.1.4.1.2272.1.4.8.1.1.2',
  'rcChasPowerSupplyOperStatusDefinition' => {
    '1' => 'unknown',
    '2' => 'empty',
    '3' => 'up',
    '4' => 'down',
  },
  'rcChasPowerSupplyDetailTable' => '1.3.6.1.4.1.2272.1.4.8.2',
  'rcChasPowerSupplyDetailEntry' => '1.3.6.1.4.1.2272.1.4.8.2.1',
  'rcChasPowerSupplyDetailId' => '1.3.6.1.4.1.2272.1.4.8.2.1.1',
  'rcChasPowerSupplyDetailType' => '1.3.6.1.4.1.2272.1.4.8.2.1.2',
  'rcChasPowerSupplyDetailTypeDefinition' => {
    '0' => 'unknown',
    '1' => 'ac',
    '2' => 'dc',
  },
  'rcChasPowerSupplyDetailSerialNumber' => '1.3.6.1.4.1.2272.1.4.8.2.1.3',
  'rcChasPowerSupplyDetailHardwareRevision' => '1.3.6.1.4.1.2272.1.4.8.2.1.4',
  'rcChasPowerSupplyDetailPartNumber' => '1.3.6.1.4.1.2272.1.4.8.2.1.5',
  'rcChasPowerSupplyDetailDescription' => '1.3.6.1.4.1.2272.1.4.8.2.1.6',
  'rc2kChassisPortOperStatus' => '1.3.6.1.4.1.2272.1.100.1.1.0',
  'rc2kChassisTemperature' => '1.3.6.1.4.1.2272.1.100.1.2.0',
  'rc2kChassisAmbientLowerTemperature' => '1.3.6.1.4.1.2272.1.100.1.3.0',
  'rc2kChassisAmbientUpperTemperature' => '1.3.6.1.4.1.2272.1.100.1.4.0',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::RESOURCEMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'RESOURCE-MIB'} = {
  url => '',
  name => 'RESOURCE-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'RESOURCE-MIB'} = {
  'cpuIndex' => '1.3.6.1.4.1.3417.2.8.1.1.0',
  'cpuName' => '1.3.6.1.4.1.3417.2.8.1.2.0',
  'cpuUtilizationValue' => '1.3.6.1.4.1.3417.2.8.1.3.0',
  'cpuWarningThreshold' => '1.3.6.1.4.1.3417.2.8.1.4.0',
  'cpuWarningInterval' => '1.3.6.1.4.1.3417.2.8.1.5.0',
  'cpuCriticalThreshold' => '1.3.6.1.4.1.3417.2.8.1.6.0',
  'cpuCriticalInterval' => '1.3.6.1.4.1.3417.2.8.1.7.0',
  'cpuNotificationType' => '1.3.6.1.4.1.3417.2.8.1.8.0',
  'cpuCurrentState' => '1.3.6.1.4.1.3417.2.8.1.9.0',
  'cpuPreviousState' => '1.3.6.1.4.1.3417.2.8.1.10.0',
  'cpuLastChangeTime' => '1.3.6.1.4.1.3417.2.8.1.11.0',
  'cpuEvent' => '1.3.6.1.4.1.3417.2.8.1.12',
  'cpuTrap' => '1.3.6.1.4.1.3417.2.8.1.12.1',
  'memory' => '1.3.6.1.4.1.3417.2.8.2',
  'memIndex' => '1.3.6.1.4.1.3417.2.8.2.1.0',
  'memName' => '1.3.6.1.4.1.3417.2.8.2.2.0',
  'memPressureValue' => '1.3.6.1.4.1.3417.2.8.2.3.0',
  'memWarningThreshold' => '1.3.6.1.4.1.3417.2.8.2.4.0',
  'memWarningInterval' => '1.3.6.1.4.1.3417.2.8.2.5.0',
  'memCriticalThreshold' => '1.3.6.1.4.1.3417.2.8.2.6.0',
  'memCriticalInterval' => '1.3.6.1.4.1.3417.2.8.2.7.0',
  'memNotificationType' => '1.3.6.1.4.1.3417.2.8.2.8.0',
  'memCurrentState' => '1.3.6.1.4.1.3417.2.8.2.9.0',
  'memPreviousState' => '1.3.6.1.4.1.3417.2.8.2.10.0',
  'memLastChangeTime' => '1.3.6.1.4.1.3417.2.8.2.11.0',
  'memEvent' => '1.3.6.1.4.1.3417.2.8.2.12',
  'memTrap' => '1.3.6.1.4.1.3417.2.8.2.12.1',
  'network' => '1.3.6.1.4.1.3417.2.8.3',
  'netTable' => '1.3.6.1.4.1.3417.2.8.3.1',
  'netEntry' => '1.3.6.1.4.1.3417.2.8.3.1.1',
  'netIndex' => '1.3.6.1.4.1.3417.2.8.3.1.1.1',
  'netName' => '1.3.6.1.4.1.3417.2.8.3.1.1.2',
  'netUtilizationValue' => '1.3.6.1.4.1.3417.2.8.3.1.1.3',
  'netWarningThreshold' => '1.3.6.1.4.1.3417.2.8.3.1.1.4',
  'netWarningInterval' => '1.3.6.1.4.1.3417.2.8.3.1.1.5',
  'netCriticalThreshold' => '1.3.6.1.4.1.3417.2.8.3.1.1.6',
  'netCriticalInterval' => '1.3.6.1.4.1.3417.2.8.3.1.1.7',
  'netNotificationType' => '1.3.6.1.4.1.3417.2.8.3.1.1.8',
  'netCurrentState' => '1.3.6.1.4.1.3417.2.8.3.1.1.9',
  'netPreviousState' => '1.3.6.1.4.1.3417.2.8.3.1.1.10',
  'netLastChangeTime' => '1.3.6.1.4.1.3417.2.8.3.1.1.11',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::RMONMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'RMON-MIB'} = {
  url => 'https://www.ietf.org/rfc/rfc1271.txt',
  name => 'RMON-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'RMON-MIB'} =
    '1.3.6.1.2.1.16';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'RMON-MIB'} = {
  rmon => '1.3.6.1.2.1.16',
  rmonEventsV2 => '1.3.6.1.2.1.16.0',
  statistics => '1.3.6.1.2.1.16.1',
  etherStatsTable => '1.3.6.1.2.1.16.1.1',
  etherStatsEntry => '1.3.6.1.2.1.16.1.1.1',
  etherStatsIndex => '1.3.6.1.2.1.16.1.1.1.1',
  etherStatsDataSource => '1.3.6.1.2.1.16.1.1.1.2',
  etherStatsDropEvents => '1.3.6.1.2.1.16.1.1.1.3',
  etherStatsOctets => '1.3.6.1.2.1.16.1.1.1.4',
  etherStatsPkts => '1.3.6.1.2.1.16.1.1.1.5',
  etherStatsBroadcastPkts => '1.3.6.1.2.1.16.1.1.1.6',
  etherStatsMulticastPkts => '1.3.6.1.2.1.16.1.1.1.7',
  etherStatsCRCAlignErrors => '1.3.6.1.2.1.16.1.1.1.8',
  etherStatsUndersizePkts => '1.3.6.1.2.1.16.1.1.1.9',
  etherStatsOversizePkts => '1.3.6.1.2.1.16.1.1.1.10',
  etherStatsFragments => '1.3.6.1.2.1.16.1.1.1.11',
  etherStatsJabbers => '1.3.6.1.2.1.16.1.1.1.12',
  etherStatsCollisions => '1.3.6.1.2.1.16.1.1.1.13',
  etherStatsPkts64Octets => '1.3.6.1.2.1.16.1.1.1.14',
  etherStatsPkts65to127Octets => '1.3.6.1.2.1.16.1.1.1.15',
  etherStatsPkts128to255Octets => '1.3.6.1.2.1.16.1.1.1.16',
  etherStatsPkts256to511Octets => '1.3.6.1.2.1.16.1.1.1.17',
  etherStatsPkts512to1023Octets => '1.3.6.1.2.1.16.1.1.1.18',
  etherStatsPkts1024to1518Octets => '1.3.6.1.2.1.16.1.1.1.19',
  etherStatsOwner => '1.3.6.1.2.1.16.1.1.1.20',
  etherStatsStatus => '1.3.6.1.2.1.16.1.1.1.21',
  etherStatsStatusDefinition => 'RMON-MIB::EntryStatus',
  history => '1.3.6.1.2.1.16.2',
  historyControlTable => '1.3.6.1.2.1.16.2.1',
  historyControlEntry => '1.3.6.1.2.1.16.2.1.1',
  historyControlIndex => '1.3.6.1.2.1.16.2.1.1.1',
  historyControlDataSource => '1.3.6.1.2.1.16.2.1.1.2',
  historyControlBucketsRequested => '1.3.6.1.2.1.16.2.1.1.3',
  historyControlBucketsGranted => '1.3.6.1.2.1.16.2.1.1.4',
  historyControlInterval => '1.3.6.1.2.1.16.2.1.1.5',
  historyControlOwner => '1.3.6.1.2.1.16.2.1.1.6',
  historyControlStatus => '1.3.6.1.2.1.16.2.1.1.7',
  historyControlStatusDefinition => 'RMON-MIB::EntryStatus',
  etherHistoryTable => '1.3.6.1.2.1.16.2.2',
  etherHistoryEntry => '1.3.6.1.2.1.16.2.2.1',
  etherHistoryIndex => '1.3.6.1.2.1.16.2.2.1.1',
  etherHistorySampleIndex => '1.3.6.1.2.1.16.2.2.1.2',
  etherHistoryIntervalStart => '1.3.6.1.2.1.16.2.2.1.3',
  etherHistoryDropEvents => '1.3.6.1.2.1.16.2.2.1.4',
  etherHistoryOctets => '1.3.6.1.2.1.16.2.2.1.5',
  etherHistoryPkts => '1.3.6.1.2.1.16.2.2.1.6',
  etherHistoryBroadcastPkts => '1.3.6.1.2.1.16.2.2.1.7',
  etherHistoryMulticastPkts => '1.3.6.1.2.1.16.2.2.1.8',
  etherHistoryCRCAlignErrors => '1.3.6.1.2.1.16.2.2.1.9',
  etherHistoryUndersizePkts => '1.3.6.1.2.1.16.2.2.1.10',
  etherHistoryOversizePkts => '1.3.6.1.2.1.16.2.2.1.11',
  etherHistoryFragments => '1.3.6.1.2.1.16.2.2.1.12',
  etherHistoryJabbers => '1.3.6.1.2.1.16.2.2.1.13',
  etherHistoryCollisions => '1.3.6.1.2.1.16.2.2.1.14',
  etherHistoryUtilization => '1.3.6.1.2.1.16.2.2.1.15',
  alarm => '1.3.6.1.2.1.16.3',
  alarmTable => '1.3.6.1.2.1.16.3.1',
  alarmEntry => '1.3.6.1.2.1.16.3.1.1',
  alarmIndex => '1.3.6.1.2.1.16.3.1.1.1',
  alarmInterval => '1.3.6.1.2.1.16.3.1.1.2',
  alarmVariable => '1.3.6.1.2.1.16.3.1.1.3',
  alarmSampleType => '1.3.6.1.2.1.16.3.1.1.4',
  alarmSampleTypeDefinition => 'RMON-MIB::alarmSampleType',
  alarmValue => '1.3.6.1.2.1.16.3.1.1.5',
  alarmStartupAlarm => '1.3.6.1.2.1.16.3.1.1.6',
  alarmStartupAlarmDefinition => 'RMON-MIB::alarmStartupAlarm',
  alarmRisingThreshold => '1.3.6.1.2.1.16.3.1.1.7',
  alarmFallingThreshold => '1.3.6.1.2.1.16.3.1.1.8',
  alarmRisingEventIndex => '1.3.6.1.2.1.16.3.1.1.9',
  alarmFallingEventIndex => '1.3.6.1.2.1.16.3.1.1.10',
  alarmOwner => '1.3.6.1.2.1.16.3.1.1.11',
  alarmStatus => '1.3.6.1.2.1.16.3.1.1.12',
  alarmStatusDefinition => 'RMON-MIB::EntryStatus',
  hosts => '1.3.6.1.2.1.16.4',
  hostControlTable => '1.3.6.1.2.1.16.4.1',
  hostControlEntry => '1.3.6.1.2.1.16.4.1.1',
  hostControlIndex => '1.3.6.1.2.1.16.4.1.1.1',
  hostControlDataSource => '1.3.6.1.2.1.16.4.1.1.2',
  hostControlTableSize => '1.3.6.1.2.1.16.4.1.1.3',
  hostControlLastDeleteTime => '1.3.6.1.2.1.16.4.1.1.4',
  hostControlOwner => '1.3.6.1.2.1.16.4.1.1.5',
  hostControlStatus => '1.3.6.1.2.1.16.4.1.1.6',
  hostControlStatusDefinition => 'RMON-MIB::EntryStatus',
  hostTable => '1.3.6.1.2.1.16.4.2',
  hostEntry => '1.3.6.1.2.1.16.4.2.1',
  hostAddress => '1.3.6.1.2.1.16.4.2.1.1',
  hostCreationOrder => '1.3.6.1.2.1.16.4.2.1.2',
  hostIndex => '1.3.6.1.2.1.16.4.2.1.3',
  hostInPkts => '1.3.6.1.2.1.16.4.2.1.4',
  hostOutPkts => '1.3.6.1.2.1.16.4.2.1.5',
  hostInOctets => '1.3.6.1.2.1.16.4.2.1.6',
  hostOutOctets => '1.3.6.1.2.1.16.4.2.1.7',
  hostOutErrors => '1.3.6.1.2.1.16.4.2.1.8',
  hostOutBroadcastPkts => '1.3.6.1.2.1.16.4.2.1.9',
  hostOutMulticastPkts => '1.3.6.1.2.1.16.4.2.1.10',
  hostTimeTable => '1.3.6.1.2.1.16.4.3',
  hostTimeEntry => '1.3.6.1.2.1.16.4.3.1',
  hostTimeAddress => '1.3.6.1.2.1.16.4.3.1.1',
  hostTimeCreationOrder => '1.3.6.1.2.1.16.4.3.1.2',
  hostTimeIndex => '1.3.6.1.2.1.16.4.3.1.3',
  hostTimeInPkts => '1.3.6.1.2.1.16.4.3.1.4',
  hostTimeOutPkts => '1.3.6.1.2.1.16.4.3.1.5',
  hostTimeInOctets => '1.3.6.1.2.1.16.4.3.1.6',
  hostTimeOutOctets => '1.3.6.1.2.1.16.4.3.1.7',
  hostTimeOutErrors => '1.3.6.1.2.1.16.4.3.1.8',
  hostTimeOutBroadcastPkts => '1.3.6.1.2.1.16.4.3.1.9',
  hostTimeOutMulticastPkts => '1.3.6.1.2.1.16.4.3.1.10',
  hostTopN => '1.3.6.1.2.1.16.5',
  hostTopNControlTable => '1.3.6.1.2.1.16.5.1',
  hostTopNControlEntry => '1.3.6.1.2.1.16.5.1.1',
  hostTopNControlIndex => '1.3.6.1.2.1.16.5.1.1.1',
  hostTopNHostIndex => '1.3.6.1.2.1.16.5.1.1.2',
  hostTopNRateBase => '1.3.6.1.2.1.16.5.1.1.3',
  hostTopNRateBaseDefinition => 'RMON-MIB::hostTopNRateBase',
  hostTopNTimeRemaining => '1.3.6.1.2.1.16.5.1.1.4',
  hostTopNDuration => '1.3.6.1.2.1.16.5.1.1.5',
  hostTopNRequestedSize => '1.3.6.1.2.1.16.5.1.1.6',
  hostTopNGrantedSize => '1.3.6.1.2.1.16.5.1.1.7',
  hostTopNStartTime => '1.3.6.1.2.1.16.5.1.1.8',
  hostTopNOwner => '1.3.6.1.2.1.16.5.1.1.9',
  hostTopNStatus => '1.3.6.1.2.1.16.5.1.1.10',
  hostTopNStatusDefinition => 'RMON-MIB::EntryStatus',
  hostTopNTable => '1.3.6.1.2.1.16.5.2',
  hostTopNEntry => '1.3.6.1.2.1.16.5.2.1',
  hostTopNReport => '1.3.6.1.2.1.16.5.2.1.1',
  hostTopNIndex => '1.3.6.1.2.1.16.5.2.1.2',
  hostTopNAddress => '1.3.6.1.2.1.16.5.2.1.3',
  hostTopNRate => '1.3.6.1.2.1.16.5.2.1.4',
  matrix => '1.3.6.1.2.1.16.6',
  matrixControlTable => '1.3.6.1.2.1.16.6.1',
  matrixControlEntry => '1.3.6.1.2.1.16.6.1.1',
  matrixControlIndex => '1.3.6.1.2.1.16.6.1.1.1',
  matrixControlDataSource => '1.3.6.1.2.1.16.6.1.1.2',
  matrixControlTableSize => '1.3.6.1.2.1.16.6.1.1.3',
  matrixControlLastDeleteTime => '1.3.6.1.2.1.16.6.1.1.4',
  matrixControlOwner => '1.3.6.1.2.1.16.6.1.1.5',
  matrixControlStatus => '1.3.6.1.2.1.16.6.1.1.6',
  matrixControlStatusDefinition => 'RMON-MIB::EntryStatus',
  matrixSDTable => '1.3.6.1.2.1.16.6.2',
  matrixSDEntry => '1.3.6.1.2.1.16.6.2.1',
  matrixSDSourceAddress => '1.3.6.1.2.1.16.6.2.1.1',
  matrixSDDestAddress => '1.3.6.1.2.1.16.6.2.1.2',
  matrixSDIndex => '1.3.6.1.2.1.16.6.2.1.3',
  matrixSDPkts => '1.3.6.1.2.1.16.6.2.1.4',
  matrixSDOctets => '1.3.6.1.2.1.16.6.2.1.5',
  matrixSDErrors => '1.3.6.1.2.1.16.6.2.1.6',
  matrixDSTable => '1.3.6.1.2.1.16.6.3',
  matrixDSEntry => '1.3.6.1.2.1.16.6.3.1',
  matrixDSSourceAddress => '1.3.6.1.2.1.16.6.3.1.1',
  matrixDSDestAddress => '1.3.6.1.2.1.16.6.3.1.2',
  matrixDSIndex => '1.3.6.1.2.1.16.6.3.1.3',
  matrixDSPkts => '1.3.6.1.2.1.16.6.3.1.4',
  matrixDSOctets => '1.3.6.1.2.1.16.6.3.1.5',
  matrixDSErrors => '1.3.6.1.2.1.16.6.3.1.6',
  filter => '1.3.6.1.2.1.16.7',
  filterTable => '1.3.6.1.2.1.16.7.1',
  filterEntry => '1.3.6.1.2.1.16.7.1.1',
  filterIndex => '1.3.6.1.2.1.16.7.1.1.1',
  filterChannelIndex => '1.3.6.1.2.1.16.7.1.1.2',
  filterPktDataOffset => '1.3.6.1.2.1.16.7.1.1.3',
  filterPktData => '1.3.6.1.2.1.16.7.1.1.4',
  filterPktDataMask => '1.3.6.1.2.1.16.7.1.1.5',
  filterPktDataNotMask => '1.3.6.1.2.1.16.7.1.1.6',
  filterPktStatus => '1.3.6.1.2.1.16.7.1.1.7',
  filterPktStatusMask => '1.3.6.1.2.1.16.7.1.1.8',
  filterPktStatusNotMask => '1.3.6.1.2.1.16.7.1.1.9',
  filterOwner => '1.3.6.1.2.1.16.7.1.1.10',
  filterStatus => '1.3.6.1.2.1.16.7.1.1.11',
  filterStatusDefinition => 'RMON-MIB::EntryStatus',
  channelTable => '1.3.6.1.2.1.16.7.2',
  channelEntry => '1.3.6.1.2.1.16.7.2.1',
  channelIndex => '1.3.6.1.2.1.16.7.2.1.1',
  channelIfIndex => '1.3.6.1.2.1.16.7.2.1.2',
  channelAcceptType => '1.3.6.1.2.1.16.7.2.1.3',
  channelAcceptTypeDefinition => 'RMON-MIB::channelAcceptType',
  channelDataControl => '1.3.6.1.2.1.16.7.2.1.4',
  channelDataControlDefinition => 'RMON-MIB::channelDataControl',
  channelTurnOnEventIndex => '1.3.6.1.2.1.16.7.2.1.5',
  channelTurnOffEventIndex => '1.3.6.1.2.1.16.7.2.1.6',
  channelEventIndex => '1.3.6.1.2.1.16.7.2.1.7',
  channelEventStatus => '1.3.6.1.2.1.16.7.2.1.8',
  channelEventStatusDefinition => 'RMON-MIB::channelEventStatus',
  channelMatches => '1.3.6.1.2.1.16.7.2.1.9',
  channelDescription => '1.3.6.1.2.1.16.7.2.1.10',
  channelOwner => '1.3.6.1.2.1.16.7.2.1.11',
  channelStatus => '1.3.6.1.2.1.16.7.2.1.12',
  channelStatusDefinition => 'RMON-MIB::EntryStatus',
  capture => '1.3.6.1.2.1.16.8',
  bufferControlTable => '1.3.6.1.2.1.16.8.1',
  bufferControlEntry => '1.3.6.1.2.1.16.8.1.1',
  bufferControlIndex => '1.3.6.1.2.1.16.8.1.1.1',
  bufferControlChannelIndex => '1.3.6.1.2.1.16.8.1.1.2',
  bufferControlFullStatus => '1.3.6.1.2.1.16.8.1.1.3',
  bufferControlFullStatusDefinition => 'RMON-MIB::bufferControlFullStatus',
  bufferControlFullAction => '1.3.6.1.2.1.16.8.1.1.4',
  bufferControlFullActionDefinition => 'RMON-MIB::bufferControlFullAction',
  bufferControlCaptureSliceSize => '1.3.6.1.2.1.16.8.1.1.5',
  bufferControlDownloadSliceSize => '1.3.6.1.2.1.16.8.1.1.6',
  bufferControlDownloadOffset => '1.3.6.1.2.1.16.8.1.1.7',
  bufferControlMaxOctetsRequested => '1.3.6.1.2.1.16.8.1.1.8',
  bufferControlMaxOctetsGranted => '1.3.6.1.2.1.16.8.1.1.9',
  bufferControlCapturedPackets => '1.3.6.1.2.1.16.8.1.1.10',
  bufferControlTurnOnTime => '1.3.6.1.2.1.16.8.1.1.11',
  bufferControlOwner => '1.3.6.1.2.1.16.8.1.1.12',
  bufferControlStatus => '1.3.6.1.2.1.16.8.1.1.13',
  bufferControlStatusDefinition => 'RMON-MIB::EntryStatus',
  captureBufferTable => '1.3.6.1.2.1.16.8.2',
  captureBufferEntry => '1.3.6.1.2.1.16.8.2.1',
  captureBufferControlIndex => '1.3.6.1.2.1.16.8.2.1.1',
  captureBufferIndex => '1.3.6.1.2.1.16.8.2.1.2',
  captureBufferPacketID => '1.3.6.1.2.1.16.8.2.1.3',
  captureBufferPacketData => '1.3.6.1.2.1.16.8.2.1.4',
  captureBufferPacketLength => '1.3.6.1.2.1.16.8.2.1.5',
  captureBufferPacketTime => '1.3.6.1.2.1.16.8.2.1.6',
  captureBufferPacketStatus => '1.3.6.1.2.1.16.8.2.1.7',
  event => '1.3.6.1.2.1.16.9',
  eventTable => '1.3.6.1.2.1.16.9.1',
  eventEntry => '1.3.6.1.2.1.16.9.1.1',
  eventIndex => '1.3.6.1.2.1.16.9.1.1.1',
  eventDescription => '1.3.6.1.2.1.16.9.1.1.2',
  eventType => '1.3.6.1.2.1.16.9.1.1.3',
  eventTypeDefinition => 'RMON-MIB::eventType',
  eventCommunity => '1.3.6.1.2.1.16.9.1.1.4',
  eventLastTimeSent => '1.3.6.1.2.1.16.9.1.1.5',
  eventOwner => '1.3.6.1.2.1.16.9.1.1.6',
  eventStatus => '1.3.6.1.2.1.16.9.1.1.7',
  eventStatusDefinition => 'RMON-MIB::EntryStatus',
  logTable => '1.3.6.1.2.1.16.9.2',
  logEntry => '1.3.6.1.2.1.16.9.2.1',
  logEventIndex => '1.3.6.1.2.1.16.9.2.1.1',
  logIndex => '1.3.6.1.2.1.16.9.2.1.2',
  logTime => '1.3.6.1.2.1.16.9.2.1.3',
  logDescription => '1.3.6.1.2.1.16.9.2.1.4',
  rmonConformance => '1.3.6.1.2.1.16.20',
  rmonMibModule => '1.3.6.1.2.1.16.20.8',
  rmonCompliances => '1.3.6.1.2.1.16.20.9',
  rmonGroups => '1.3.6.1.2.1.16.20.10',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'RMON-MIB'} = {
  channelDataControl => {
    '1' => 'on',
    '2' => 'off',
  },
  alarmSampleType => {
    '1' => 'absoluteValue',
    '2' => 'deltaValue',
  },
  hostTopNRateBase => {
    '1' => 'hostTopNInPkts',
    '2' => 'hostTopNOutPkts',
    '3' => 'hostTopNInOctets',
    '4' => 'hostTopNOutOctets',
    '5' => 'hostTopNOutErrors',
    '6' => 'hostTopNOutBroadcastPkts',
    '7' => 'hostTopNOutMulticastPkts',
  },
  channelEventStatus => {
    '1' => 'eventReady',
    '2' => 'eventFired',
    '3' => 'eventAlwaysReady',
  },
  bufferControlFullAction => {
    '1' => 'lockWhenFull',
    '2' => 'wrapWhenFull',
  },
  bufferControlFullStatus => {
    '1' => 'spaceAvailable',
    '2' => 'full',
  },
  eventType => {
    '1' => 'none',
    '2' => 'log',
    '3' => 'snmptrap',
    '4' => 'logandtrap',
  },
  channelAcceptType => {
    '1' => 'acceptMatched',
    '2' => 'acceptFailed',
  },
  alarmStartupAlarm => {
    '1' => 'risingAlarm',
    '2' => 'fallingAlarm',
    '3' => 'risingOrFallingAlarm',
  },
  EntryStatus => {
    '1' => 'valid',
    '2' => 'createRequest',
    '3' => 'underCreation',
    '4' => 'invalid',
  },
};
package Monitoring::GLPlugin::SNMP::MibsAndOids::S5CHASSISMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'S5-CHASSIS-MIB'} = {
  url => '',
  name => 'S5-CHASSIS-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'S5-CHASSIS-MIB'} = 
  '1.3.6.1.4.1.45.1.6.3';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'S5-CHASSIS-MIB'} = {
  's5ChasGen' => '1.3.6.1.4.1.45.1.6.3.1',
  's5ChasType' => '1.3.6.1.4.1.45.1.6.3.1.1',
  's5ChasDescr' => '1.3.6.1.4.1.45.1.6.3.1.2',
  's5ChasLocation' => '1.3.6.1.4.1.45.1.6.3.1.3',
  's5ChasContact' => '1.3.6.1.4.1.45.1.6.3.1.4',
  's5ChasVer' => '1.3.6.1.4.1.45.1.6.3.1.5',
  's5ChasSerNum' => '1.3.6.1.4.1.45.1.6.3.1.6',
  's5ChasGblPhysChngs' => '1.3.6.1.4.1.45.1.6.3.1.7',
  's5ChasGblPhysLstChng' => '1.3.6.1.4.1.45.1.6.3.1.8',
  's5ChasGblAttChngs' => '1.3.6.1.4.1.45.1.6.3.1.9',
  's5ChasGblAttLstChng' => '1.3.6.1.4.1.45.1.6.3.1.10',
  's5ChasGblConfChngs' => '1.3.6.1.4.1.45.1.6.3.1.11',
  's5ChasGblConfLstChng' => '1.3.6.1.4.1.45.1.6.3.1.12',
  's5ChasGrp' => '1.3.6.1.4.1.45.1.6.3.2',
  's5ChasGrpTable' => '1.3.6.1.4.1.45.1.6.3.2.1',
  's5ChasGrpEntry' => '1.3.6.1.4.1.45.1.6.3.2.1.1',
  's5ChasGrpIndx' => '1.3.6.1.4.1.45.1.6.3.2.1.1.1',
  's5ChasGrpType' => '1.3.6.1.4.1.45.1.6.3.2.1.1.2',
  's5ChasGrpDescr' => '1.3.6.1.4.1.45.1.6.3.2.1.1.3',
  's5ChasGrpMaxEnts' => '1.3.6.1.4.1.45.1.6.3.2.1.1.4',
  's5ChasGrpNumEnts' => '1.3.6.1.4.1.45.1.6.3.2.1.1.5',
  's5ChasGrpPhysChngs' => '1.3.6.1.4.1.45.1.6.3.2.1.1.6',
  's5ChasGrpPhysLstChng' => '1.3.6.1.4.1.45.1.6.3.2.1.1.7',
  's5ChasGrpEncodeFactor' => '1.3.6.1.4.1.45.1.6.3.2.1.1.8',
  's5ChasCom' => '1.3.6.1.4.1.45.1.6.3.3',
  's5ChasComTable' => '1.3.6.1.4.1.45.1.6.3.3.1',
  's5ChasComEntry' => '1.3.6.1.4.1.45.1.6.3.3.1.1',
  's5ChasComGrpIndx' => '1.3.6.1.4.1.45.1.6.3.3.1.1.1',
  's5ChasComIndx' => '1.3.6.1.4.1.45.1.6.3.3.1.1.2',
  's5ChasComSubIndx' => '1.3.6.1.4.1.45.1.6.3.3.1.1.3',
  's5ChasComType' => '1.3.6.1.4.1.45.1.6.3.3.1.1.4',
  's5ChasComDescr' => '1.3.6.1.4.1.45.1.6.3.3.1.1.5',
  's5ChasComVer' => '1.3.6.1.4.1.45.1.6.3.3.1.1.6',
  's5ChasComSerNum' => '1.3.6.1.4.1.45.1.6.3.3.1.1.7',
  's5ChasComLstChng' => '1.3.6.1.4.1.45.1.6.3.3.1.1.8',
  's5ChasComAdminState' => '1.3.6.1.4.1.45.1.6.3.3.1.1.9',
  's5ChasComAdminStateDefinition' => {
    '1' => 'other',
    '2' => 'notAvail',
    '3' => 'disable',
    '4' => 'enable',
    '5' => 'reset',
    '6' => 'test',
  },
  's5ChasComOperState' => '1.3.6.1.4.1.45.1.6.3.3.1.1.10',
  's5ChasComOperStateDefinition' => {
    '1' => 'other',
    '2' => 'notAvail',
    '3' => 'removed',
    '4' => 'disabled',
    '5' => 'normal',
    '6' => 'resetInProg',
    '7' => 'testing',
    '8' => 'warning',
    '9' => 'nonFatalErr',
    '10' => 'fatalErr',
    '11' => 'notConfig',
    '12' => 'obsoleted',
  },
  's5ChasComMaxSubs' => '1.3.6.1.4.1.45.1.6.3.3.1.1.11',
  's5ChasComNumSubs' => '1.3.6.1.4.1.45.1.6.3.3.1.1.12',
  's5ChasComRelPos' => '1.3.6.1.4.1.45.1.6.3.3.1.1.13',
  's5ChasComLocation' => '1.3.6.1.4.1.45.1.6.3.3.1.1.14',
  's5ChasComGroupMap' => '1.3.6.1.4.1.45.1.6.3.3.1.1.15',
  's5ChasComBaseNumPorts' => '1.3.6.1.4.1.45.1.6.3.3.1.1.16',
  's5ChasComTotalNumPorts' => '1.3.6.1.4.1.45.1.6.3.3.1.1.17',
  's5ChasComIpAddress' => '1.3.6.1.4.1.45.1.6.3.3.1.1.18',
  's5ChasBrd' => '1.3.6.1.4.1.45.1.6.3.4',
  's5ChasBrdTable' => '1.3.6.1.4.1.45.1.6.3.4.1',
  's5ChasBrdEntry' => '1.3.6.1.4.1.45.1.6.3.4.1.1',
  's5ChasBrdIndx' => '1.3.6.1.4.1.45.1.6.3.4.1.1.1',
  's5ChasBrdLeds' => '1.3.6.1.4.1.45.1.6.3.4.1.1.2',
  's5ChasBrdNumAtt' => '1.3.6.1.4.1.45.1.6.3.4.1.1.3',
  's5ChasBrdAttChngs' => '1.3.6.1.4.1.45.1.6.3.4.1.1.4',
  's5ChasBrdAttLstChng' => '1.3.6.1.4.1.45.1.6.3.4.1.1.5',
  's5ChasBrdStatusDsply' => '1.3.6.1.4.1.45.1.6.3.4.1.1.6',
  's5ChasBrdDateCode' => '1.3.6.1.4.1.45.1.6.3.4.1.1.7',
  's5ChasBrdCfgSrc' => '1.3.6.1.4.1.45.1.6.3.4.1.1.8',
  's5ChasBrdCfgSrcDefinition' => {
    '1' => 'other',
    '2' => 'dfltJmpr',
    '3' => 'prmMem',
    '4' => 'brdCfg',
    '5' => 'sm',
    '6' => 'smDfltJmpr',
    '7' => 'smPrmMem',
    '8' => 'smBrdCfg',
  },
  's5ChasBrdCfgChngs' => '1.3.6.1.4.1.45.1.6.3.4.1.1.9',
  's5ChasAttTable' => '1.3.6.1.4.1.45.1.6.3.4.2',
  's5ChasAttEntry' => '1.3.6.1.4.1.45.1.6.3.4.2.1',
  's5ChasAttBrdIndx' => '1.3.6.1.4.1.45.1.6.3.4.2.1.1',
  's5ChasAttIndx' => '1.3.6.1.4.1.45.1.6.3.4.2.1.2',
  's5ChasAttDfltAtt' => '1.3.6.1.4.1.45.1.6.3.4.2.1.3',
  's5ChasAttCurAtt' => '1.3.6.1.4.1.45.1.6.3.4.2.1.4',
  's5ChasAttChngs' => '1.3.6.1.4.1.45.1.6.3.4.2.1.5',
  's5ChasAttLstChng' => '1.3.6.1.4.1.45.1.6.3.4.2.1.6',
  's5ChasAttClusterConnCapability' => '1.3.6.1.4.1.45.1.6.3.4.2.1.7',
  's5ChasLocChanTable' => '1.3.6.1.4.1.45.1.6.3.4.3',
  's5ChasLocChanEntry' => '1.3.6.1.4.1.45.1.6.3.4.3.1',
  's5ChasLocChanBrdIndx' => '1.3.6.1.4.1.45.1.6.3.4.3.1.1',
  's5ChasLocChanIndx' => '1.3.6.1.4.1.45.1.6.3.4.3.1.2',
  's5ChasLocChanBkplMode' => '1.3.6.1.4.1.45.1.6.3.4.3.1.3',
  's5ChasLocChanBkplModeDefinition' => {
    '1' => 'other',
    '2' => 'connected',
    '3' => 'notConnected',
  },
  's5ChasStore' => '1.3.6.1.4.1.45.1.6.3.5',
  's5ChasStoreTable' => '1.3.6.1.4.1.45.1.6.3.5.1',
  's5ChasStoreEntry' => '1.3.6.1.4.1.45.1.6.3.5.1.1',
  's5ChasStoreGrpIndx' => '1.3.6.1.4.1.45.1.6.3.5.1.1.1',
  's5ChasStoreComIndx' => '1.3.6.1.4.1.45.1.6.3.5.1.1.2',
  's5ChasStoreSubIndx' => '1.3.6.1.4.1.45.1.6.3.5.1.1.3',
  's5ChasStoreIndx' => '1.3.6.1.4.1.45.1.6.3.5.1.1.4',
  's5ChasStoreType' => '1.3.6.1.4.1.45.1.6.3.5.1.1.5',
  's5ChasStoreCurSize' => '1.3.6.1.4.1.45.1.6.3.5.1.1.6',
  's5ChasStoreCntntVer' => '1.3.6.1.4.1.45.1.6.3.5.1.1.7',
  's5ChasStoreFilename' => '1.3.6.1.4.1.45.1.6.3.5.1.1.8',
  's5ChasSm' => '1.3.6.1.4.1.45.1.6.3.6',
  's5ChasSmLeds' => '1.3.6.1.4.1.45.1.6.3.6.1',
  's5ChasSmDateCode' => '1.3.6.1.4.1.45.1.6.3.6.2',
  's5ChasTmpSnr' => '1.3.6.1.4.1.45.1.6.3.7',
  's5ChasTmpSnrTable' => '1.3.6.1.4.1.45.1.6.3.7.1',
  's5ChasTmpSnrEntry' => '1.3.6.1.4.1.45.1.6.3.7.1.1',
  's5ChasTmpSnrGrpIndx' => '1.3.6.1.4.1.45.1.6.3.7.1.1.1',
  's5ChasTmpSnrIndx' => '1.3.6.1.4.1.45.1.6.3.7.1.1.2',
  's5ChasTmpSnrSubIndx' => '1.3.6.1.4.1.45.1.6.3.7.1.1.3',
  's5ChasTmpSnrValue' => '1.3.6.1.4.1.45.1.6.3.7.1.1.4',
  's5ChasTmpSnrTmpValue' => '1.3.6.1.4.1.45.1.6.3.7.1.1.5',
  's5ChasUtil' => '1.3.6.1.4.1.45.1.6.3.8',
  's5ChasUtilTable' => '1.3.6.1.4.1.45.1.6.3.8.1',
  's5ChasUtilEntry' => '1.3.6.1.4.1.45.1.6.3.8.1.1',
  's5ChasUtilGrpIndx' => '1.3.6.1.4.1.45.1.6.3.8.1.1.1',
  's5ChasUtilIndx' => '1.3.6.1.4.1.45.1.6.3.8.1.1.2',
  's5ChasUtilSubIndx' => '1.3.6.1.4.1.45.1.6.3.8.1.1.3',
  's5ChasUtilTotalCPUUsage' => '1.3.6.1.4.1.45.1.6.3.8.1.1.4',
  's5ChasUtilCPUUsageLast1Minute' => '1.3.6.1.4.1.45.1.6.3.8.1.1.5',
  's5ChasUtilCPUUsageLast10Minutes' => '1.3.6.1.4.1.45.1.6.3.8.1.1.6',
  's5ChasUtilCPUUsageLast1Hour' => '1.3.6.1.4.1.45.1.6.3.8.1.1.7',
  's5ChasUtilCPUUsageLast24Hours' => '1.3.6.1.4.1.45.1.6.3.8.1.1.8',
  's5ChasUtilMemoryAvailable' => '1.3.6.1.4.1.45.1.6.3.8.1.1.9',
  's5ChasUtilMemoryMinAvailable' => '1.3.6.1.4.1.45.1.6.3.8.1.1.10',
  's5ChasUtilCPUUsageLast10Seconds' => '1.3.6.1.4.1.45.1.6.3.8.1.1.11',
  's5ChasUtilMemoryTotalMB' => '1.3.6.1.4.1.45.1.6.3.8.1.1.12',
  's5ChasUtilMemoryAvailableMB' => '1.3.6.1.4.1.45.1.6.3.8.1.1.13',
  's5ChasPs' => '1.3.6.1.4.1.45.1.6.3.9',
  's5ChasPsRpsuTable' => '1.3.6.1.4.1.45.1.6.3.9.1',
  's5ChasPsRpsuEntry' => '1.3.6.1.4.1.45.1.6.3.9.1.1',
  's5ChasPsRpsuGrpIndx' => '1.3.6.1.4.1.45.1.6.3.9.1.1.1',
  's5ChasPsRpsuIndx' => '1.3.6.1.4.1.45.1.6.3.9.1.1.2',
  's5ChasPsRpsuSubIndx' => '1.3.6.1.4.1.45.1.6.3.9.1.1.3',
  's5ChasPsRpsuType' => '1.3.6.1.4.1.45.1.6.3.9.1.1.4',
  's5ChasPsRpsuTypeDefinition' => {
    '1' => 'bayStack10',
    '2' => 'nes',
  },
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::SENSORMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'SENSOR-MIB'} = {
  url => '',
  name => 'SENSOR-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'SENSOR-MIB'} = {
  'deviceSensorValueTable' => '1.3.6.1.4.1.3417.2.1.1.1.1',
  'deviceSensorValueEntry' => '1.3.6.1.4.1.3417.2.1.1.1.1.1',
  'deviceSensorIndex' => '1.3.6.1.4.1.3417.2.1.1.1.1.1.1',
  'deviceSensorTrapEnabled' => '1.3.6.1.4.1.3417.2.1.1.1.1.1.2',
  'deviceSensorUnits' => '1.3.6.1.4.1.3417.2.1.1.1.1.1.3',
  'deviceSensorUnitsDefinition' => {
    '1' => 'other',
    '2' => 'truthvalue',
    '3' => 'specialEnum',
    '4' => 'volts',
    '5' => 'celsius',
    '6' => 'rpm',
  },
  'deviceSensorScale' => '1.3.6.1.4.1.3417.2.1.1.1.1.1.4',
  'deviceSensorValue' => '1.3.6.1.4.1.3417.2.1.1.1.1.1.5',
  'deviceSensorCode' => '1.3.6.1.4.1.3417.2.1.1.1.1.1.6',
  'deviceSensorCodeDefinition' => {
    '1' => 'ok',
    '2' => 'unknown',
    '3' => 'not-installed',
    '4' => 'voltage-low-warning',
    '5' => 'voltage-low-critical',
    '6' => 'no-power',
    '7' => 'voltage-high-warning',
    '8' => 'voltage-high-critical',
    '9' => 'voltage-high-severe',
    '10' => 'temperature-high-warning',
    '11' => 'temperature-high-critical',
    '12' => 'temperature-high-severe',
    '13' => 'fan-slow-warning',
    '14' => 'fan-slow-critical',
    '15' => 'fan-stopped',
  },
  'deviceSensorStatus' => '1.3.6.1.4.1.3417.2.1.1.1.1.1.7',
  'deviceSensorStatusDefinition' => {
    '1' => 'ok',
    '2' => 'unavailable',
    '3' => 'nonoperational',
  },
  'deviceSensorTimeStamp' => '1.3.6.1.4.1.3417.2.1.1.1.1.1.8',
  'deviceSensorName' => '1.3.6.1.4.1.3417.2.1.1.1.1.1.9',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::SNMPV2TCV1MIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'SNMPv2-TC-v1-MIB'} = {
  url => '',
  name => 'SNMPv2-TC-v1-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'SNMPv2-TC-v1-MIB'} = {
  'TruthValue' => {
    1 => 'true',
    2 => 'false',
  },
  'RowStatus' => {
    1 => 'active',
    2 => 'notInService',
    3 => 'notReady',
    4 => 'createAndGo',
    5 => 'createAndWait',
    6 => 'destroy',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::STATISTICSMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'STATISTICS-MIB'} = {
  url => '',
  name => 'STATISTICS-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'STATISTICS-MIB'} = {
  'hpSwitchCpuStat' => '1.3.6.1.4.1.11.2.14.11.5.1.9.6.1.0',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::SWMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'SW-MIB'} = {
  url => '',
  name => 'SW-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'SW-MIB'} = 
  '1.3.6.1.4.1.1588.2.1.1.1';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'SW-MIB'} = {
  'sw' => '1.3.6.1.4.1.1588.2.1.1.1',
  'swFirmwareVersion' => '1.3.6.1.4.1.1588.2.1.1.1.1.6.0',
  'swSensorTable' => '1.3.6.1.4.1.1588.2.1.1.1.1.22',
  'swSensorEntry' => '1.3.6.1.4.1.1588.2.1.1.1.1.22.1',
  'swSensorIndex' => '1.3.6.1.4.1.1588.2.1.1.1.1.22.1.1',
  'swSensorType' => '1.3.6.1.4.1.1588.2.1.1.1.1.22.1.2',
  'swSensorTypeDefinition' => {
    '1' => 'temperature',
    '2' => 'fan',
    '3' => 'power-supply',
  },
  'swSensorStatus' => '1.3.6.1.4.1.1588.2.1.1.1.1.22.1.3',
  'swSensorStatusDefinition' => {
    '1' => 'unknown',
    '2' => 'faulty',
    '3' => 'below-min',
    '4' => 'nominal',
    '5' => 'above-max',
    '6' => 'absent',
  },
  'swSensorValue' => '1.3.6.1.4.1.1588.2.1.1.1.1.22.1.4',
  'swSensorInfo' => '1.3.6.1.4.1.1588.2.1.1.1.1.22.1.5',
  'swFwFabricWatchLicense' => '1.3.6.1.4.1.1588.2.1.1.1.10.1.0',
  'swFwFabricWatchLicenseDefinition' => {
    '1' => 'swFwLicensed',
    '2' => 'swFwNotLicensed',
  },
  'swFwThresholdTable' => '1.3.6.1.4.1.1588.2.1.1.1.10.3',
  'swFwThresholdEntry' => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1',
  'swFwThresholdIndex' => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.1',
  'swFwStatus' => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.2',
  'swFwName' => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.3',
  'swFwLabel' => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.4',
  'swFwCurVal' => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.5',
  'swFwLastEvent' => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.6',
  'swFwLastEventVal' => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.7',
  'swFwLastEventTime' => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.8',
  'swFwLastState' => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.9',
  'swFwBehaviorType' => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.10',
  'swFwBehaviorInt' => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.11',
  'swCpuOrMemoryUsage' => '1.3.6.1.4.1.1588.2.1.1.1.26',
  'swCpuUsage' => '1.3.6.1.4.1.1588.2.1.1.1.26.1',
  'swCpuNoOfRetries' => '1.3.6.1.4.1.1588.2.1.1.1.26.2',
  'swCpuUsageLimit' => '1.3.6.1.4.1.1588.2.1.1.1.26.3',
  'swCpuPollingInterval' => '1.3.6.1.4.1.1588.2.1.1.1.26.4',
  'swCpuAction' => '1.3.6.1.4.1.1588.2.1.1.1.26.5',
  'swMemUsage' => '1.3.6.1.4.1.1588.2.1.1.1.26.6',
  'swMemNoOfRetries' => '1.3.6.1.4.1.1588.2.1.1.1.26.7',
  'swMemUsageLimit' => '1.3.6.1.4.1.1588.2.1.1.1.26.8',
  'swMemPollingInterval' => '1.3.6.1.4.1.1588.2.1.1.1.26.9',
  'swMemAction' => '1.3.6.1.4.1.1588.2.1.1.1.26.10',
  'swMemUsageLimit1' => '1.3.6.1.4.1.1588.2.1.1.1.26.11',
  'swMemUsageLimit3' => '1.3.6.1.4.1.1588.2.1.1.1.26.12',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::SYNOPTICSROOTMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'SYNOPTICS-ROOT-MIB'} = {
  url => '',
  name => 'SW-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'SYNOPTICS-ROOT-MIB'} = 
  '1.3.6.1.4.1.45.3';



package Monitoring::GLPlugin::SNMP::MibsAndOids::SYSTEMRESOURCESMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'SYSTEM-RESOURCES-MIB'} = {
  url => '',
  name => 'SYSTEM-RESOURCES-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'SYSTEM-RESOURCES-MIB'} = {
  'cpuIndex' => '1.3.6.1.4.1.3417.2.8.1.1.0',
  'cpuName' => '1.3.6.1.4.1.3417.2.8.1.2.0',
  'cpuUtilizationValue' => '1.3.6.1.4.1.3417.2.8.1.3.0',
  'cpuWarningThreshold' => '1.3.6.1.4.1.3417.2.8.1.4.0',
  'cpuWarningInterval' => '1.3.6.1.4.1.3417.2.8.1.5.0',
  'cpuCriticalThreshold' => '1.3.6.1.4.1.3417.2.8.1.6.0',
  'cpuCriticalInterval' => '1.3.6.1.4.1.3417.2.8.1.7.0',
  'cpuNotificationType' => '1.3.6.1.4.1.3417.2.8.1.8.0',
  'cpuCurrentState' => '1.3.6.1.4.1.3417.2.8.1.9.0',
  'cpuPreviousState' => '1.3.6.1.4.1.3417.2.8.1.10.0',
  'cpuLastChangeTime' => '1.3.6.1.4.1.3417.2.8.1.11.0',
  'cpuEvent' => '1.3.6.1.4.1.3417.2.8.1.12',
  'cpuTrap' => '1.3.6.1.4.1.3417.2.8.1.12.1',
  'memory' => '1.3.6.1.4.1.3417.2.8.2',
  'memIndex' => '1.3.6.1.4.1.3417.2.8.2.1.0',
  'memName' => '1.3.6.1.4.1.3417.2.8.2.2.0',
  'memPressureValue' => '1.3.6.1.4.1.3417.2.8.2.3.0',
  'memWarningThreshold' => '1.3.6.1.4.1.3417.2.8.2.4.0',
  'memWarningInterval' => '1.3.6.1.4.1.3417.2.8.2.5.0',
  'memCriticalThreshold' => '1.3.6.1.4.1.3417.2.8.2.6.0',
  'memCriticalInterval' => '1.3.6.1.4.1.3417.2.8.2.7.0',
  'memNotificationType' => '1.3.6.1.4.1.3417.2.8.2.8.0',
  'memCurrentState' => '1.3.6.1.4.1.3417.2.8.2.9.0',
  'memPreviousState' => '1.3.6.1.4.1.3417.2.8.2.10.0',
  'memLastChangeTime' => '1.3.6.1.4.1.3417.2.8.2.11.0',
  'memEvent' => '1.3.6.1.4.1.3417.2.8.2.12',
  'memTrap' => '1.3.6.1.4.1.3417.2.8.2.12.1',
  'network' => '1.3.6.1.4.1.3417.2.8.3',
  'netTable' => '1.3.6.1.4.1.3417.2.8.3.1',
  'netEntry' => '1.3.6.1.4.1.3417.2.8.3.1.1',
  'netIndex' => '1.3.6.1.4.1.3417.2.8.3.1.1.1',
  'netName' => '1.3.6.1.4.1.3417.2.8.3.1.1.2',
  'netUtilizationValue' => '1.3.6.1.4.1.3417.2.8.3.1.1.3',
  'netWarningThreshold' => '1.3.6.1.4.1.3417.2.8.3.1.1.4',
  'netWarningInterval' => '1.3.6.1.4.1.3417.2.8.3.1.1.5',
  'netCriticalThreshold' => '1.3.6.1.4.1.3417.2.8.3.1.1.6',
  'netCriticalInterval' => '1.3.6.1.4.1.3417.2.8.3.1.1.7',
  'netNotificationType' => '1.3.6.1.4.1.3417.2.8.3.1.1.8',
  'netCurrentState' => '1.3.6.1.4.1.3417.2.8.3.1.1.9',
  'netPreviousState' => '1.3.6.1.4.1.3417.2.8.3.1.1.10',
  'netLastChangeTime' => '1.3.6.1.4.1.3417.2.8.3.1.1.11',
};




$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'UCD-DISKIO-MIB'} = {
  url => 'http://www.circitor.fr/Mibs/Files/UCD-DISKIO-MIB.mib',
  name => 'UCD-DISKIO-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'UCD-DISKIO-MIB'} =
    '1.3.6.1.4.1.2021.13.15';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'UCD-DISKIO-MIB'} = {
  ucdDiskIOMIB => '1.3.6.1.4.1.2021.13.15',
  diskIOTable => '1.3.6.1.4.1.2021.13.15.1',
  diskIOEntry => '1.3.6.1.4.1.2021.13.15.1.1',
  diskIOIndex => '1.3.6.1.4.1.2021.13.15.1.1.1',
  diskIODevice => '1.3.6.1.4.1.2021.13.15.1.1.2',
  diskIONRead => '1.3.6.1.4.1.2021.13.15.1.1.3',
  diskIONWritten => '1.3.6.1.4.1.2021.13.15.1.1.4',
  diskIOReads => '1.3.6.1.4.1.2021.13.15.1.1.5',
  diskIOWrites => '1.3.6.1.4.1.2021.13.15.1.1.6',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'UCD-DISKIO-MIB'} = {
};
package Monitoring::GLPlugin::SNMP::MibsAndOids::UCDSNMPMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'UCD-SNMP-MIB'} = {
  url => 'http://www.net-snmp.org/docs/mibs/UCD-SNMP-MIB.txt',
  name => 'UCD-SNMP-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'UCD-SNMP-MIB'} =
    '1.3.6.1.4.1.2021';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'UCD-SNMP-MIB'} = {
  ucdavis => '1.3.6.1.4.1.2021',
  prTable => '1.3.6.1.4.1.2021.2',
  prEntry => '1.3.6.1.4.1.2021.2.1',
  prIndex => '1.3.6.1.4.1.2021.2.1.1',
  prNames => '1.3.6.1.4.1.2021.2.1.2',
  prMin => '1.3.6.1.4.1.2021.2.1.3',
  prMax => '1.3.6.1.4.1.2021.2.1.4',
  prCount => '1.3.6.1.4.1.2021.2.1.5',
  prErrorFlag => '1.3.6.1.4.1.2021.2.1.100',
  prErrorFlagDefinition => 'UCD-SNMP-MIB::UCDErrorFlag',
  prErrMessage => '1.3.6.1.4.1.2021.2.1.101',
  prErrFix => '1.3.6.1.4.1.2021.2.1.102',
  prErrFixDefinition => 'UCD-SNMP-MIB::UCDErrorFix',
  prErrFixCmd => '1.3.6.1.4.1.2021.2.1.103',
  memory => '1.3.6.1.4.1.2021.4',
  memIndex => '1.3.6.1.4.1.2021.4.1',
  memErrorName => '1.3.6.1.4.1.2021.4.2',
  memTotalSwap => '1.3.6.1.4.1.2021.4.3',
  memAvailSwap => '1.3.6.1.4.1.2021.4.4',
  memTotalReal => '1.3.6.1.4.1.2021.4.5',
  memAvailReal => '1.3.6.1.4.1.2021.4.6',
  memTotalSwapTXT => '1.3.6.1.4.1.2021.4.7',
  memAvailSwapTXT => '1.3.6.1.4.1.2021.4.8',
  memTotalRealTXT => '1.3.6.1.4.1.2021.4.9',
  memAvailRealTXT => '1.3.6.1.4.1.2021.4.10',
  memTotalFree => '1.3.6.1.4.1.2021.4.11',
  memMinimumSwap => '1.3.6.1.4.1.2021.4.12',
  memShared => '1.3.6.1.4.1.2021.4.13',
  memBuffer => '1.3.6.1.4.1.2021.4.14',
  memCached => '1.3.6.1.4.1.2021.4.15',
  memUsedSwapTXT => '1.3.6.1.4.1.2021.4.16',
  memUsedRealTXT => '1.3.6.1.4.1.2021.4.17',
  memSwapError => '1.3.6.1.4.1.2021.4.100',
  memSwapErrorDefinition => 'UCD-SNMP-MIB::UCDErrorFlag',
  memSwapErrorMsg => '1.3.6.1.4.1.2021.4.101',
  extTable => '1.3.6.1.4.1.2021.8',
  extEntry => '1.3.6.1.4.1.2021.8.1',
  extIndex => '1.3.6.1.4.1.2021.8.1.1',
  extNames => '1.3.6.1.4.1.2021.8.1.2',
  extCommand => '1.3.6.1.4.1.2021.8.1.3',
  extResult => '1.3.6.1.4.1.2021.8.1.100',
  extOutput => '1.3.6.1.4.1.2021.8.1.101',
  extErrFix => '1.3.6.1.4.1.2021.8.1.102',
  extErrFixDefinition => 'UCD-SNMP-MIB::UCDErrorFix',
  extErrFixCmd => '1.3.6.1.4.1.2021.8.1.103',
  dskTable => '1.3.6.1.4.1.2021.9',
  dskEntry => '1.3.6.1.4.1.2021.9.1',
  dskIndex => '1.3.6.1.4.1.2021.9.1.1',
  dskPath => '1.3.6.1.4.1.2021.9.1.2',
  dskDevice => '1.3.6.1.4.1.2021.9.1.3',
  dskMinimum => '1.3.6.1.4.1.2021.9.1.4',
  dskMinPercent => '1.3.6.1.4.1.2021.9.1.5',
  dskTotal => '1.3.6.1.4.1.2021.9.1.6',
  dskAvail => '1.3.6.1.4.1.2021.9.1.7',
  dskUsed => '1.3.6.1.4.1.2021.9.1.8',
  dskPercent => '1.3.6.1.4.1.2021.9.1.9',
  dskPercentNode => '1.3.6.1.4.1.2021.9.1.10',
  dskTotalLow => '1.3.6.1.4.1.2021.9.1.11',
  dskTotalHigh => '1.3.6.1.4.1.2021.9.1.12',
  dskAvailLow => '1.3.6.1.4.1.2021.9.1.13',
  dskAvailHigh => '1.3.6.1.4.1.2021.9.1.14',
  dskUsedLow => '1.3.6.1.4.1.2021.9.1.15',
  dskUsedHigh => '1.3.6.1.4.1.2021.9.1.16',
  dskErrorFlag => '1.3.6.1.4.1.2021.9.1.100',
  dskErrorFlagDefinition => 'UCD-SNMP-MIB::UCDErrorFlag',
  dskErrorMsg => '1.3.6.1.4.1.2021.9.1.101',
  laTable => '1.3.6.1.4.1.2021.10',
  laEntry => '1.3.6.1.4.1.2021.10.1',
  laIndex => '1.3.6.1.4.1.2021.10.1.1',
  laNames => '1.3.6.1.4.1.2021.10.1.2',
  laLoad => '1.3.6.1.4.1.2021.10.1.3',
  laConfig => '1.3.6.1.4.1.2021.10.1.4',
  laLoadInt => '1.3.6.1.4.1.2021.10.1.5',
  laLoadFloat => '1.3.6.1.4.1.2021.10.1.6',
  laErrorFlag => '1.3.6.1.4.1.2021.10.1.100',
  laErrorFlagDefinition => 'UCD-SNMP-MIB::UCDErrorFlag',
  laErrMessage => '1.3.6.1.4.1.2021.10.1.101',
  systemStats => '1.3.6.1.4.1.2021.11',
  ssIndex => '1.3.6.1.4.1.2021.11.1',
  ssErrorName => '1.3.6.1.4.1.2021.11.2',
  ssSwapIn => '1.3.6.1.4.1.2021.11.3',
  ssSwapOut => '1.3.6.1.4.1.2021.11.4',
  ssIOSent => '1.3.6.1.4.1.2021.11.5',
  ssIOReceive => '1.3.6.1.4.1.2021.11.6',
  ssSysInterrupts => '1.3.6.1.4.1.2021.11.7',
  ssSysContext => '1.3.6.1.4.1.2021.11.8',
  ssCpuUser => '1.3.6.1.4.1.2021.11.9',
  ssCpuSystem => '1.3.6.1.4.1.2021.11.10',
  ssCpuIdle => '1.3.6.1.4.1.2021.11.11',
  ssCpuRawUser => '1.3.6.1.4.1.2021.11.50',
  ssCpuRawNice => '1.3.6.1.4.1.2021.11.51',
  ssCpuRawSystem => '1.3.6.1.4.1.2021.11.52',
  ssCpuRawIdle => '1.3.6.1.4.1.2021.11.53',
  ssCpuRawWait => '1.3.6.1.4.1.2021.11.54',
  ssCpuRawKernel => '1.3.6.1.4.1.2021.11.55',
  ssCpuRawInterrupt => '1.3.6.1.4.1.2021.11.56',
  ssIORawSent => '1.3.6.1.4.1.2021.11.57',
  ssIORawReceived => '1.3.6.1.4.1.2021.11.58',
  ssRawInterrupts => '1.3.6.1.4.1.2021.11.59',
  ssRawContexts => '1.3.6.1.4.1.2021.11.60',
  ssCpuRawSoftIRQ => '1.3.6.1.4.1.2021.11.61',
  ssRawSwapIn => '1.3.6.1.4.1.2021.11.62',
  ssRawSwapOut => '1.3.6.1.4.1.2021.11.63',
  ssCpuRawSteal => '1.3.6.1.4.1.2021.11.64',
  ssCpuRawGuest => '1.3.6.1.4.1.2021.11.65',
  ssCpuRawGuestNice => '1.3.6.1.4.1.2021.11.66',
  ucdInternal => '1.3.6.1.4.1.2021.12',
  ucdExperimental => '1.3.6.1.4.1.2021.13',
  fileTable => '1.3.6.1.4.1.2021.15',
  fileEntry => '1.3.6.1.4.1.2021.15.1',
  fileIndex => '1.3.6.1.4.1.2021.15.1.1',
  fileName => '1.3.6.1.4.1.2021.15.1.2',
  fileSize => '1.3.6.1.4.1.2021.15.1.3',
  fileMax => '1.3.6.1.4.1.2021.15.1.4',
  fileErrorFlag => '1.3.6.1.4.1.2021.15.1.100',
  fileErrorFlagDefinition => 'UCD-SNMP-MIB::UCDErrorFlag',
  fileErrorMsg => '1.3.6.1.4.1.2021.15.1.101',
  logMatch => '1.3.6.1.4.1.2021.16',
  logMatchMaxEntries => '1.3.6.1.4.1.2021.16.1',
  logMatchTable => '1.3.6.1.4.1.2021.16.2',
  logMatchEntry => '1.3.6.1.4.1.2021.16.2.1',
  logMatchIndex => '1.3.6.1.4.1.2021.16.2.1.1',
  logMatchName => '1.3.6.1.4.1.2021.16.2.1.2',
  logMatchFilename => '1.3.6.1.4.1.2021.16.2.1.3',
  logMatchRegEx => '1.3.6.1.4.1.2021.16.2.1.4',
  logMatchGlobalCounter => '1.3.6.1.4.1.2021.16.2.1.5',
  logMatchGlobalCount => '1.3.6.1.4.1.2021.16.2.1.6',
  logMatchCurrentCounter => '1.3.6.1.4.1.2021.16.2.1.7',
  logMatchCurrentCount => '1.3.6.1.4.1.2021.16.2.1.8',
  logMatchCounter => '1.3.6.1.4.1.2021.16.2.1.9',
  logMatchCount => '1.3.6.1.4.1.2021.16.2.1.10',
  logMatchCycle => '1.3.6.1.4.1.2021.16.2.1.11',
  logMatchErrorFlag => '1.3.6.1.4.1.2021.16.2.1.100',
  logMatchErrorFlagDefinition => 'UCD-SNMP-MIB::UCDErrorFlag',
  logMatchRegExCompilation => '1.3.6.1.4.1.2021.16.2.1.101',
  version => '1.3.6.1.4.1.2021.100',
  versionIndex => '1.3.6.1.4.1.2021.100.1',
  versionTag => '1.3.6.1.4.1.2021.100.2',
  versionDate => '1.3.6.1.4.1.2021.100.3',
  versionCDate => '1.3.6.1.4.1.2021.100.4',
  versionIdent => '1.3.6.1.4.1.2021.100.5',
  versionConfigureOptions => '1.3.6.1.4.1.2021.100.6',
  versionClearCache => '1.3.6.1.4.1.2021.100.10',
  versionUpdateConfig => '1.3.6.1.4.1.2021.100.11',
  versionRestartAgent => '1.3.6.1.4.1.2021.100.12',
  versionSavePersistentData => '1.3.6.1.4.1.2021.100.13',
  versionDoDebugging => '1.3.6.1.4.1.2021.100.20',
  snmperrs => '1.3.6.1.4.1.2021.101',
  snmperrIndex => '1.3.6.1.4.1.2021.101.1',
  snmperrNames => '1.3.6.1.4.1.2021.101.2',
  snmperrErrorFlag => '1.3.6.1.4.1.2021.101.100',
  snmperrErrorFlagDefinition => 'UCD-SNMP-MIB::UCDErrorFlag',
  snmperrErrMessage => '1.3.6.1.4.1.2021.101.101',
  mrTable => '1.3.6.1.4.1.2021.102',
  mrEntry => '1.3.6.1.4.1.2021.102.1',
  mrIndex => '1.3.6.1.4.1.2021.102.1.1',
  mrModuleName => '1.3.6.1.4.1.2021.102.1.2',
  ucdSnmpAgent => '1.3.6.1.4.1.2021.250',
  hpux9 => '1.3.6.1.4.1.2021.250.1',
  sunos4 => '1.3.6.1.4.1.2021.250.2',
  solaris => '1.3.6.1.4.1.2021.250.3',
  osf => '1.3.6.1.4.1.2021.250.4',
  ultrix => '1.3.6.1.4.1.2021.250.5',
  hpux10 => '1.3.6.1.4.1.2021.250.6',
  netbsd1 => '1.3.6.1.4.1.2021.250.7',
  freebsd => '1.3.6.1.4.1.2021.250.8',
  irix => '1.3.6.1.4.1.2021.250.9',
  linux => '1.3.6.1.4.1.2021.250.10',
  bsdi => '1.3.6.1.4.1.2021.250.11',
  openbsd => '1.3.6.1.4.1.2021.250.12',
  win32 => '1.3.6.1.4.1.2021.250.13',
  hpux11 => '1.3.6.1.4.1.2021.250.14',
  aix => '1.3.6.1.4.1.2021.250.15',
  macosx => '1.3.6.1.4.1.2021.250.16',
  dragonfly => '1.3.6.1.4.1.2021.250.17',
  unknown => '1.3.6.1.4.1.2021.250.255',
  ucdTraps => '1.3.6.1.4.1.2021.251',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'UCD-SNMP-MIB'} = {
  UCDErrorFlag => {
    '0' => 'noError',
    '1' => 'error',
  },
  UCDErrorFix => {
    '0' => 'noError',
    '1' => 'runFix',
  },
};
package Monitoring::GLPlugin::SNMP::MibsAndOids::USAGEMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'USAGE-MIB'} = {
  url => '',
  name => 'USAGE-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'USAGE-MIB'} = {
  'deviceUsageTable' => '1.3.6.1.4.1.3417.2.4.1.1',
  'deviceUsageEntry' => '1.3.6.1.4.1.3417.2.4.1.1.1',
  'deviceUsageIndex' => '1.3.6.1.4.1.3417.2.4.1.1.1.1',
  'deviceUsageTrapEnabled' => '1.3.6.1.4.1.3417.2.4.1.1.1.2',
  'deviceUsageName' => '1.3.6.1.4.1.3417.2.4.1.1.1.3',
  'deviceUsagePercent' => '1.3.6.1.4.1.3417.2.4.1.1.1.4',
  'deviceUsageHigh' => '1.3.6.1.4.1.3417.2.4.1.1.1.5',
  'deviceUsageStatus' => '1.3.6.1.4.1.3417.2.4.1.1.1.6',
  'deviceUsageStatusDefinition' => {
    '1' => 'ok',
    '2' => 'high',
  },
  'deviceUsageTime' => '1.3.6.1.4.1.3417.2.4.1.1.1.7',
};




package Monitoring::GLPlugin::SNMP::MibsAndOids::VRRPMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'VRRP-MIB'} = {
  url => 'ftp://ftp.cisco.com/pub/mibs/v2/VRRP-MIB.my',
  name => 'VRRP-MIB'
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::requirements->{'VRRP-MIB'} = [
  'SNMPv2-TC-v1-MIB',
];

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'VRRP-MIB'} = {
  vrrpMIB => '.1.3.6.1.2.1.68',
  vrrpNotifications => '.1.3.6.1.2.1.68.0',
  vrrpTrapNewMaster => '.1.3.6.1.2.1.68.0.1',
  vrrpTrapAuthFailure => '.1.3.6.1.2.1.68.0.2',
  vrrpOperations => '.1.3.6.1.2.1.68.1',
  vrrpNodeVersion => '.1.3.6.1.2.1.68.1.1',
  vrrpNotificationCntl => '.1.3.6.1.2.1.68.1.2',
  vrrpOperTable => '.1.3.6.1.2.1.68.1.3',
  vrrpOperEntry => '.1.3.6.1.2.1.68.1.3.1',
  vrrpOperVrId => '.1.3.6.1.2.1.68.1.3.1.1',
  vrrpOperAuthKey => '.1.3.6.1.2.1.68.1.3.1.10',
  vrrpOperAdvertisementInterval => '.1.3.6.1.2.1.68.1.3.1.11',
  vrrpOperPreemptMode => '.1.3.6.1.2.1.68.1.3.1.12',
  vrrpOperVirtualRouterUpTime => '.1.3.6.1.2.1.68.1.3.1.13',
  vrrpOperProtocol => '.1.3.6.1.2.1.68.1.3.1.14',
  vrrpOperProtocolDefinition => 'VRRP-MIB::vrrpOperProtocol',
  vrrpOperRowStatus => '.1.3.6.1.2.1.68.1.3.1.15',
  vrrpOperRowStatusDefinition => 'SNMPv2-TC-v1-MIB::RowStatus',
  vrrpOperVirtualMacAddr => '.1.3.6.1.2.1.68.1.3.1.2',
  vrrpOperState => '.1.3.6.1.2.1.68.1.3.1.3',
  vrrpOperStateDefinition => 'VRRP-MIB::vrrpOperState',
  vrrpOperAdminState => '.1.3.6.1.2.1.68.1.3.1.4',
  vrrpOperAdminStateDefinition => 'VRRP-MIB::vrrpOperAdminState',
  vrrpOperPriority => '.1.3.6.1.2.1.68.1.3.1.5',
  vrrpOperIpAddrCount => '.1.3.6.1.2.1.68.1.3.1.6',
  vrrpOperMasterIpAddr => '.1.3.6.1.2.1.68.1.3.1.7',
  vrrpOperPrimaryIpAddr => '.1.3.6.1.2.1.68.1.3.1.8',
  vrrpOperAuthType => '.1.3.6.1.2.1.68.1.3.1.9',
  vrrpOperAuthTypeDefinition => 'VRRP-MIB::vrrpOperAuthType',
  vrrpAssoIpAddrTable => '.1.3.6.1.2.1.68.1.4',
  vrrpAssoIpAddrEntry => '.1.3.6.1.2.1.68.1.4.1',
  vrrpAssoIpAddr => '.1.3.6.1.2.1.68.1.4.1.1',
  vrrpAssoIpAddrRowStatus => '.1.3.6.1.2.1.68.1.4.1.2',
  vrrpAssoIpAddrRowStatusDefinition => 'SNMPv2-TC-v1-MIB::RowStatus',
  vrrpTrapPacketSrc => '.1.3.6.1.2.1.68.1.5',
  vrrpTrapAuthErrorType => '.1.3.6.1.2.1.68.1.6',
  vrrpTrapAuthErrorTypeDefinition => 'VRRP-MIB::vrrpTrapAuthErrorType',
  vrrpStatistics => '.1.3.6.1.2.1.68.2',
  vrrpRouterChecksumErrors => '.1.3.6.1.2.1.68.2.1',
  vrrpRouterVersionErrors => '.1.3.6.1.2.1.68.2.2',
  vrrpRouterVrIdErrors => '.1.3.6.1.2.1.68.2.3',
  vrrpRouterStatsTable => '.1.3.6.1.2.1.68.2.4',
  vrrpRouterStatsEntry => '.1.3.6.1.2.1.68.2.4.1',
  vrrpStatsBecomeMaster => '.1.3.6.1.2.1.68.2.4.1.1',
  vrrpStatsInvalidAuthType => '.1.3.6.1.2.1.68.2.4.1.10',
  vrrpStatsAuthTypeMismatch => '.1.3.6.1.2.1.68.2.4.1.11',
  vrrpStatsPacketLengthErrors => '.1.3.6.1.2.1.68.2.4.1.12',
  vrrpStatsAdvertiseRcvd => '.1.3.6.1.2.1.68.2.4.1.2',
  vrrpStatsAdvertiseIntervalErrors => '.1.3.6.1.2.1.68.2.4.1.3',
  vrrpStatsAuthFailures => '.1.3.6.1.2.1.68.2.4.1.4',
  vrrpStatsIpTtlErrors => '.1.3.6.1.2.1.68.2.4.1.5',
  vrrpStatsPriorityZeroPktsRcvd => '.1.3.6.1.2.1.68.2.4.1.6',
  vrrpStatsPriorityZeroPktsSent => '.1.3.6.1.2.1.68.2.4.1.7',
  vrrpStatsInvalidTypePktsRcvd => '.1.3.6.1.2.1.68.2.4.1.8',
  vrrpStatsAddressListErrors => '.1.3.6.1.2.1.68.2.4.1.9',
  vrrpConformance => '.1.3.6.1.2.1.68.3',
  vrrpMIBCompliances => '.1.3.6.1.2.1.68.3.1',
  vrrpMIBCompliance => '.1.3.6.1.2.1.68.3.1.1',
  vrrpMIBGroups => '.1.3.6.1.2.1.68.3.2',
  vrrpOperGroup => '.1.3.6.1.2.1.68.3.2.1',
  vrrpStatsGroup => '.1.3.6.1.2.1.68.3.2.2',
  vrrpTrapGroup => '.1.3.6.1.2.1.68.3.2.3',
  vrrpNotificationGroup => '.1.3.6.1.2.1.68.3.2.4'
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'VRRP-MIB'} = {
  vrrpOperAdminState => {
    '1' => 'up',
    '2' => 'down'
  },
  vrrpOperAuthType => {
    '1' => 'noAuthentication',
    '2' => 'simpleTextPassword',
    '3' => 'ipAuthenticationHeader'
  },
  vrrpOperProtocol => {
    '1' => 'ip',
    '2' => 'bridge',
    '3' => 'decnet',
    '4' => 'other'
  },
  vrrpOperState => {
    '1' => 'initialize',
    '2' => 'backup',
    '3' => 'master'
  },
  vrrpTrapAuthErrorType => {
    '1' => 'invalidAuthType',
    '2' => 'authTypeMismatch',
    '3' => 'authFailure'
  }
};


package Monitoring::GLPlugin::SNMP::MibsAndOids::WLSXSYSTEMEXTMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'WLSX-SYSTEMEXT-MIB'} = {
  url => '',
  name => 'WLSX-SYSTEMEXT-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::requirements->{'WLSX-SYSTEMEXT-MIB'} = [
  'ARUBA-TC-MIB',
];

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'WLSX-SYSTEMEXT-MIB'} = 
  '1.3.6.1.4.1.14823.2.2.1.2';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'WLSX-SYSTEMEXT-MIB'} = {
  'wlsxSystemExtMIB' => '1.3.6.1.4.1.14823.2.2.1.2',
  'wlsxSystemExtGroup' => '1.3.6.1.4.1.14823.2.2.1.2.1',
  'wlsxSysExtSwitchIp' => '1.3.6.1.4.1.14823.2.2.1.2.1.1',
  'wlsxSysExtHostname' => '1.3.6.1.4.1.14823.2.2.1.2.1.2',
  'wlsxSysExtModelName' => '1.3.6.1.4.1.14823.2.2.1.2.1.3',
  'wlsxSysExtSwitchRole' => '1.3.6.1.4.1.14823.2.2.1.2.1.4',
  'wlsxSysExtSwitchRoleDefinition' => 'ARUBA-TC-MIB::ArubaSwitchRole',
  'wlsxSysExtSwitchMasterIp' => '1.3.6.1.4.1.14823.2.2.1.2.1.5',
  'wlsxSysExtSwitchDate' => '1.3.6.1.4.1.14823.2.2.1.2.1.6',
  'wlsxSysExtSwitchBaseMacaddress' => '1.3.6.1.4.1.14823.2.2.1.2.1.7',
  'wlsxSysExtFanTrayAssemblyNumber' => '1.3.6.1.4.1.14823.2.2.1.2.1.8',
  'wlsxSysExtFanTraySerialNumber' => '1.3.6.1.4.1.14823.2.2.1.2.1.9',
  'wlsxSysExtInternalTemparature' => '1.3.6.1.4.1.14823.2.2.1.2.1.10',
  'wlsxSysExtLicenseSerialNumber' => '1.3.6.1.4.1.14823.2.2.1.2.1.11',
  'wlsxSysExtSwitchLicenseCount' => '1.3.6.1.4.1.14823.2.2.1.2.1.12',
  'wlsxSysExtProcessorTable' => '1.3.6.1.4.1.14823.2.2.1.2.1.13',
  'wlsxSysExtProcessorEntry' => '1.3.6.1.4.1.14823.2.2.1.2.1.13.1',
  'sysExtProcessorID' => '1.3.6.1.4.1.14823.2.2.1.2.1.13.1.1',
  'sysExtProcessorDescr' => '1.3.6.1.4.1.14823.2.2.1.2.1.13.1.2',
  'sysExtProcessorLoad' => '1.3.6.1.4.1.14823.2.2.1.2.1.13.1.3',
  'wlsxSysExtStorageTable' => '1.3.6.1.4.1.14823.2.2.1.2.1.14',
  'wlsxSysExtStorageEntry' => '1.3.6.1.4.1.14823.2.2.1.2.1.14.1',
  'sysExtStorageIndex' => '1.3.6.1.4.1.14823.2.2.1.2.1.14.1.1',
  'sysExtStorageType' => '1.3.6.1.4.1.14823.2.2.1.2.1.14.1.2',
  'sysExtStorageTypeDefinition' => 'WLSX-SYSTEMEXT-MIB::sysExtStorageType',
  'sysExtStorageSize' => '1.3.6.1.4.1.14823.2.2.1.2.1.14.1.3',
  'sysExtStorageUsed' => '1.3.6.1.4.1.14823.2.2.1.2.1.14.1.4',
  'sysExtStorageName' => '1.3.6.1.4.1.14823.2.2.1.2.1.14.1.5',
  'wlsxSysExtMemoryTable' => '1.3.6.1.4.1.14823.2.2.1.2.1.15',
  'wlsxSysExtMemoryEntry' => '1.3.6.1.4.1.14823.2.2.1.2.1.15.1',
  'sysExtMemoryIndex' => '1.3.6.1.4.1.14823.2.2.1.2.1.15.1.1',
  'sysExtMemorySize' => '1.3.6.1.4.1.14823.2.2.1.2.1.15.1.2',
  'sysExtMemoryUsed' => '1.3.6.1.4.1.14823.2.2.1.2.1.15.1.3',
  'sysExtMemoryFree' => '1.3.6.1.4.1.14823.2.2.1.2.1.15.1.4',
  'wlsxSysExtCardTable' => '1.3.6.1.4.1.14823.2.2.1.2.1.16',
  'wlsxSysExtCardEntry' => '1.3.6.1.4.1.14823.2.2.1.2.1.16.1',
  'sysExtCardSlot' => '1.3.6.1.4.1.14823.2.2.1.2.1.16.1.1',
  'sysExtCardType' => '1.3.6.1.4.1.14823.2.2.1.2.1.16.1.2',
  'sysExtCardNumOfPorts' => '1.3.6.1.4.1.14823.2.2.1.2.1.16.1.3',
  'sysExtCardNumOfFastethernetPorts' => '1.3.6.1.4.1.14823.2.2.1.2.1.16.1.4',
  'sysExtCardNumOfGigPorts' => '1.3.6.1.4.1.14823.2.2.1.2.1.16.1.5',
  'sysExtCardSerialNo' => '1.3.6.1.4.1.14823.2.2.1.2.1.16.1.6',
  'sysExtCardAssemblyNo' => '1.3.6.1.4.1.14823.2.2.1.2.1.16.1.7',
  'sysExtCardManufacturingDate' => '1.3.6.1.4.1.14823.2.2.1.2.1.16.1.8',
  'sysExtCardHwRevision' => '1.3.6.1.4.1.14823.2.2.1.2.1.16.1.9',
  'sysExtCardFpgaRevision' => '1.3.6.1.4.1.14823.2.2.1.2.1.16.1.10',
  'sysExtCardSwitchChip' => '1.3.6.1.4.1.14823.2.2.1.2.1.16.1.11',
  'sysExtCardStatus' => '1.3.6.1.4.1.14823.2.2.1.2.1.16.1.12',
  'sysExtCardUserSlot' => '1.3.6.1.4.1.14823.2.2.1.2.1.16.1.13',
  'wlsxSysExtFanTable' => '1.3.6.1.4.1.14823.2.2.1.2.1.17',
  'wlsxSysExtFanEntry' => '1.3.6.1.4.1.14823.2.2.1.2.1.17.1',
  'sysExtFanIndex' => '1.3.6.1.4.1.14823.2.2.1.2.1.17.1.1',
  'sysExtFanStatus' => '1.3.6.1.4.1.14823.2.2.1.2.1.17.1.2',
  'sysExtFanStatusDefinition' => 'ARUBA-TC-MIB::ArubaActiveState',
  'wlsxSysExtPowerSupplyTable' => '1.3.6.1.4.1.14823.2.2.1.2.1.18',
  'wlsxSysExtPowerSupplyEntry' => '1.3.6.1.4.1.14823.2.2.1.2.1.18.1',
  'sysExtPowerSupplyIndex' => '1.3.6.1.4.1.14823.2.2.1.2.1.18.1.1',
  'sysExtPowerSupplyStatus' => '1.3.6.1.4.1.14823.2.2.1.2.1.18.1.2',
  'sysExtPowerSupplyStatusDefinition' => 'ARUBA-TC-MIB::ArubaActiveState',
  'wlsxSysExtSwitchListTable' => '1.3.6.1.4.1.14823.2.2.1.2.1.19',
  'wlsxSysExtSwitchListEntry' => '1.3.6.1.4.1.14823.2.2.1.2.1.19.1',
  'sysExtSwitchIPAddress' => '1.3.6.1.4.1.14823.2.2.1.2.1.19.1.1',
  'sysExtSwitchRole' => '1.3.6.1.4.1.14823.2.2.1.2.1.19.1.2',
  'sysExtSwitchLocation' => '1.3.6.1.4.1.14823.2.2.1.2.1.19.1.3',
  'sysExtSwitchSWVersion' => '1.3.6.1.4.1.14823.2.2.1.2.1.19.1.4',
  'sysExtSwitchStatus' => '1.3.6.1.4.1.14823.2.2.1.2.1.19.1.5',
  'sysExtSwitchName' => '1.3.6.1.4.1.14823.2.2.1.2.1.19.1.6',
  'sysExtSwitchSerNo' => '1.3.6.1.4.1.14823.2.2.1.2.1.19.1.7',
  'wlsxSysExtSwitchLicenseTable' => '1.3.6.1.4.1.14823.2.2.1.2.1.20',
  'wlsxSysExtLicenseEntry' => '1.3.6.1.4.1.14823.2.2.1.2.1.20.1',
  'sysExtLicenseIndex' => '1.3.6.1.4.1.14823.2.2.1.2.1.20.1.1',
  'sysExtLicenseKey' => '1.3.6.1.4.1.14823.2.2.1.2.1.20.1.2',
  'sysExtLicenseInstalled' => '1.3.6.1.4.1.14823.2.2.1.2.1.20.1.3',
  'sysExtLicenseExpires' => '1.3.6.1.4.1.14823.2.2.1.2.1.20.1.4',
  'sysExtLicenseFlags' => '1.3.6.1.4.1.14823.2.2.1.2.1.20.1.5',
  'sysExtLicenseService' => '1.3.6.1.4.1.14823.2.2.1.2.1.20.1.6',
  'wlsxSysExtMMSCompatLevel' => '1.3.6.1.4.1.14823.2.2.1.2.1.21',
  'wlsxSysExtMMSConfigID' => '1.3.6.1.4.1.14823.2.2.1.2.1.22',
  'wlsxSysExtControllerConfigID' => '1.3.6.1.4.1.14823.2.2.1.2.1.23',
  'wlsxSysExtIsMMSConfigUpdateEnabled' => '1.3.6.1.4.1.14823.2.2.1.2.1.24',
  'wlsxSysExtSwitchLastReload' => '1.3.6.1.4.1.14823.2.2.1.2.1.25',
  'wlsxSystemExtTableGenNumberGroup' => '1.3.6.1.4.1.14823.2.2.1.2.2',
  'wlsxSysExtUserTableGenNumber' => '1.3.6.1.4.1.14823.2.2.1.2.2.1',
  'wlsxSysExtAPBssidTableGenNumber' => '1.3.6.1.4.1.14823.2.2.1.2.2.2',
  'wlsxSysExtAPRadioTableGenNumber' => '1.3.6.1.4.1.14823.2.2.1.2.2.3',
  'wlsxSysExtAPTableGenNumber' => '1.3.6.1.4.1.14823.2.2.1.2.2.4',
  'wlsxSysExtSwitchListTableGenNumber' => '1.3.6.1.4.1.14823.2.2.1.2.2.5',
  'wlsxSysExtPortTableGenNumber' => '1.3.6.1.4.1.14823.2.2.1.2.2.6',
  'wlsxSysExtVlanTableGenNumber' => '1.3.6.1.4.1.14823.2.2.1.2.2.7',
  'wlsxSysExtVlanInterfaceTableGenNumber' => '1.3.6.1.4.1.14823.2.2.1.2.2.8',
  'wlsxSysExtLicenseTableGenNumber' => '1.3.6.1.4.1.14823.2.2.1.2.2.9',
  'wlsxSysExtMonAPTableGenNumber' => '1.3.6.1.4.1.14823.2.2.1.2.2.10',
  'wlsxSysExtMonStationTableGenNumber' => '1.3.6.1.4.1.14823.2.2.1.2.2.11',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'WLSX-SYSTEMEXT-MIB'} = {
  'sysExtStorageType' => {
    '1' => 'ram',
    '2' => 'flashMemory',
  },
};



package Monitoring::GLPlugin::SNMP::MibsAndOids::WLSXWLANMIB;

$Monitoring::GLPlugin::SNMP::MibsAndOids::origin->{'WLSX-WLAN-MIB'} = {
  url => '',
  name => 'WLSX-WLAN-MIB',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::mib_ids->{'WLSX-WLAN-MIB'} = 
  '1.3.6.1.4.1.14823.2.2.1.5';

$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'WLSX-WLAN-MIB'} = {
  'wlsxWlanMIB' => '1.3.6.1.4.1.14823.2.2.1.5',
  'wlsxWlanConfigGroup' => '1.3.6.1.4.1.14823.2.2.1.5.1',
  'wlsxWlanStateGroup' => '1.3.6.1.4.1.14823.2.2.1.5.2',
  'wlsxWlanAccessPointInfoGroup' => '1.3.6.1.4.1.14823.2.2.1.5.2.1',
  'wlsxWlanTotalNumAccessPoints' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.1',
  'wlsxWlanTotalNumStationsAssociated' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.2',
  'wlsxWlanAPGroupTable' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.3',
  'wlsxWlanAPGroupEntry' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.3.1',
  'wlanAPGroup' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.3.1.1',
  'wlanAPNumAps' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.3.1.2',
  'wlsxWlanAPTable' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4',
  'wlsxWlanAPEntry' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1',
  'wlanAPMacAddress' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.1',
  'wlanAPIpAddress' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.2',
  'wlanAPName' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.3',
  'wlanAPGroupName' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.4',
  'wlanAPModel' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.5',
  'wlanAPSerialNumber' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.6',
  'wlanAPdot11aAntennaGain' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.7',
  'wlanAPdot11gAntennaGain' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.8',
  'wlanAPNumRadios' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.9',
  'wlanAPEnet1Mode' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.10',
  'wlanAPIpsecMode' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.11',
  'wlanAPUpTime' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.12',
  'wlanAPModelName' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.13',
  'wlanAPLocation' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.14',
  'wlanAPBuilding' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.15',
  'wlanAPFloor' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.16',
  'wlanAPLoc' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.17',
  'wlanAPExternalAntenna' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.18',
  'wlanAPStatus' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.19',
  'wlanAPStatusDefinition' => {
    '1' => 'up',
    '2' => 'down',
  },
  'wlanAPNumBootstraps' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.20',
  'wlanAPNumReboots' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.21',
  'wlanAPUnprovisioned' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.22',
  'wlanAPMonitorMode' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.23',
  'wlanAPFQLNBuilding' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.24',
  'wlanAPFQLNFloor' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.25',
  'wlanAPFQLN' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.26',
  'wlanAPFQLNCampus' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.4.1.27',
  'wlsxWlanRadioTable' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.5',
  'wlsxWlanRadioEntry' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.5.1',
  'wlanAPRadioNumber' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.5.1.1',
  'wlanAPRadioType' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.5.1.2',
  'wlanAPRadioChannel' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.5.1.3',
  'wlanAPRadioTransmitPower' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.5.1.4',
  'wlanAPRadioMode' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.5.1.5',
  'wlanAPRadioUtilization' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.5.1.6',
  'wlanAPRadioNumAssociatedClients' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.5.1.7',
  'wlanAPRadioNumMonitoredClients' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.5.1.8',
  'wlanAPRadioNumActiveBSSIDs' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.5.1.9',
  'wlanAPRadioNumMonitoredBSSIDs' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.5.1.10',
  'wlsxWlanAPBssidTable' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7',
  'wlsxWlanAPBssidEntry' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7.1',
  'wlanAPBSSID' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7.1.1',
  'wlanAPESSID' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7.1.2',
  'wlanAPBssidSlot' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7.1.3',
  'wlanAPBssidPort' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7.1.4',
  'wlanAPBssidPhyType' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7.1.5',
  'wlanAPBssidRogueType' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7.1.6',
  'wlanAPBssidMode' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7.1.7',
  'wlanAPBssidModeDefinition' => 'WLSX-WLAN-MIB::wlanAPBssidMode',
  'wlanAPBssidChannel' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7.1.8',
  'wlanAPBssidUpTime' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7.1.9',
  'wlanAPBssidInactiveTime' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7.1.10',
  'wlanAPBssidLoadBalancing' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7.1.11',
  'wlanAPBssidNumAssociatedStations' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7.1.12',
  'wlanAPBssidAPMacAddress' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7.1.13',
  'wlanAPBssidPhyNumber' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.7.1.14',
  'wlsxWlanESSIDTable' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.8',
  'wlsxWlanESSIDEntry' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.8.1',
  'wlanESSID' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.8.1.1',
  'wlanESSIDNumStations' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.8.1.2',
  'wlanESSIDNumAccessPointsUp' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.8.1.3',
  'wlanESSIDNumAccessPointsDown' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.8.1.4',
  'wlanESSIDEncryptionType' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.8.1.5',
  'wlsxWlanESSIDVlanPoolTable' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.9',
  'wlsxWlanESSIDVlanPoolEntry' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.9.1',
  'wlanESSIDVlanId' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.9.1.1',
  'wlanESSIDVlanPoolStatus' => '1.3.6.1.4.1.14823.2.2.1.5.2.1.9.1.2',
  'wlsxWlanStationInfoGroup' => '1.3.6.1.4.1.14823.2.2.1.5.2.2',
  'wlsxWlanStationTable' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1',
  'wlsxWlanStationEntry' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1',
  'wlanStaPhyAddress' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1.1',
  'wlanStaApBssid' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1.2',
  'wlanStaPhyType' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1.3',
  'wlanStaIsAuthenticated' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1.4',
  'wlanStaIsAssociated' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1.5',
  'wlanStaChannel' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1.6',
  'wlanStaVlanId' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1.7',
  'wlanStaVOIPState' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1.8',
  'wlanStaVOIPProtocol' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1.9',
  'wlanStaTransmitRate' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1.10',
  'wlanStaAssociationID' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1.11',
  'wlanStaAccessPointESSID' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1.12',
  'wlanStaPhyNumber' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1.13',
  'wlanStaRSSI' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1.14',
  'wlanStaUpTime' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.1.1.15',
  'wlsxWlanStaAssociationFailureTable' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.2',
  'wlsxWlanStaAssociationFailureEntry' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.2.1',
  'wlanStaAssocFailureApName' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.2.1.1',
  'wlanStaAssocFailureApEssid' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.2.1.2',
  'wlanStaAssocFailurePhyNum' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.2.1.3',
  'wlanStaAssocFailurePhyType' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.2.1.4',
  'wlanStaAssocFailureElapsedTime' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.2.1.5',
  'wlanStaAssocFailureReason' => '1.3.6.1.4.1.14823.2.2.1.5.2.2.2.1.6',
  'wlsxWlanAssociationInfoGroup' => '1.3.6.1.4.1.14823.2.2.1.5.2.3',
  'wlsxWlanStatsGroup' => '1.3.6.1.4.1.14823.2.2.1.5.3',
  'wlsxWlanAccessPointStatsGroup' => '1.3.6.1.4.1.14823.2.2.1.5.3.1',
  'wlsxWlanAPStatsTable' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1',
  'wlsxWlanAPStatsEntry' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1',
  'wlanAPCurrentChannel' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.1',
  'wlanAPNumClients' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.2',
  'wlanAPTxPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.3',
  'wlanAPTxBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.4',
  'wlanAPRxPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.5',
  'wlanAPRxBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.6',
  'wlanAPTxDeauthentications' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.7',
  'wlanAPRxDeauthentications' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.8',
  'wlanAPChannelThroughput' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.9',
  'wlanAPFrameRetryRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.10',
  'wlanAPFrameLowSpeedRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.11',
  'wlanAPFrameNonUnicastRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.12',
  'wlanAPFrameFragmentationRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.13',
  'wlanAPFrameBandwidthRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.14',
  'wlanAPFrameRetryErrorRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.15',
  'wlanAPChannelErrorRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.16',
  'wlanAPFrameReceiveErrorRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.17',
  'wlanAPRxDataPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.18',
  'wlanAPRxDataBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.19',
  'wlanAPTxDataPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.20',
  'wlanAPTxDataBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.21',
  'wlanAPRxDataPkts64' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.22',
  'wlanAPRxDataBytes64' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.23',
  'wlanAPTxDataPkts64' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.24',
  'wlanAPTxDataBytes64' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.1.1.25',
  'wlsxWlanAPRateStatsTable' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2',
  'wlsxWlanAPRateStatsEntry' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1',
  'wlanAPStatsTotPktsAt1Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.1',
  'wlanAPStatsTotBytesAt1Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.2',
  'wlanAPStatsTotPktsAt2Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.3',
  'wlanAPStatsTotBytesAt2Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.4',
  'wlanAPStatsTotPktsAt5Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.5',
  'wlanAPStatsTotBytesAt5Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.6',
  'wlanAPStatsTotPktsAt11Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.7',
  'wlanAPStatsTotBytesAt11Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.8',
  'wlanAPStatsTotPktsAt6Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.9',
  'wlanAPStatsTotBytesAt6Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.10',
  'wlanAPStatsTotPktsAt12Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.11',
  'wlanAPStatsTotBytesAt12Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.12',
  'wlanAPStatsTotPktsAt18Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.13',
  'wlanAPStatsTotBytesAt18Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.14',
  'wlanAPStatsTotPktsAt24Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.15',
  'wlanAPStatsTotBytesAt24Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.16',
  'wlanAPStatsTotPktsAt36Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.17',
  'wlanAPStatsTotBytesAt36Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.18',
  'wlanAPStatsTotPktsAt48Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.19',
  'wlanAPStatsTotBytesAt48Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.20',
  'wlanAPStatsTotPktsAt54Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.21',
  'wlanAPStatsTotBytesAt54Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.22',
  'wlanAPStatsTotPktsAt9Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.23',
  'wlanAPStatsTotBytesAt9Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.2.1.24',
  'wlsxWlanAPDATypeStatsTable' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.3',
  'wlsxWlanAPDATypeStatsEntry' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.3.1',
  'wlanAPStatsTotDABroadcastPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.3.1.1',
  'wlanAPStatsTotDABroadcastBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.3.1.2',
  'wlanAPStatsTotDAMulticastPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.3.1.3',
  'wlanAPStatsTotDAMulticastBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.3.1.4',
  'wlanAPStatsTotDAUnicastPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.3.1.5',
  'wlanAPStatsTotDAUnicastBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.3.1.6',
  'wlsxWlanAPFrameTypeStatsTable' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.4',
  'wlsxWlanAPFrameTypeStatsEntry' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.4.1',
  'wlanAPStatsTotMgmtPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.4.1.1',
  'wlanAPStatsTotMgmtBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.4.1.2',
  'wlanAPStatsTotCtrlPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.4.1.3',
  'wlanAPStatsTotCtrlBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.4.1.4',
  'wlanAPStatsTotDataPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.4.1.5',
  'wlanAPStatsTotDataBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.4.1.6',
  'wlsxWlanAPPktSizeStatsTable' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.5',
  'wlsxWlanAPPktSizeStatsEntry' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.5.1',
  'wlanAPStatsPkts63Bytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.5.1.1',
  'wlanAPStatsPkts64To127' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.5.1.2',
  'wlanAPStatsPkts128To255' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.5.1.3',
  'wlanAPStatsPkts256To511' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.5.1.4',
  'wlanAPStatsPkts512To1023' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.5.1.5',
  'wlanAPStatsPkts1024To1518' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.5.1.6',
  'wlsxWlanAPChStatsTable' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6',
  'wlsxWlanAPChStatsEntry' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1',
  'wlanAPChannelNumber' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.1',
  'wlanAPChNumStations' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.2',
  'wlanAPChTotPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.3',
  'wlanAPChTotBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.4',
  'wlanAPChTotRetryPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.5',
  'wlanAPChTotFragmentedPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.6',
  'wlanAPChTotPhyErrPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.7',
  'wlanAPChTotMacErrPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.8',
  'wlanAPChNoise' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.9',
  'wlanAPChCoverageIndex' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.10',
  'wlanAPChInterferenceIndex' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.11',
  'wlanAPChFrameRetryRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.12',
  'wlanAPChFrameLowSpeedRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.13',
  'wlanAPChFrameNonUnicastRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.14',
  'wlanAPChFrameFragmentationRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.15',
  'wlanAPChFrameBandwidthRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.16',
  'wlanAPChFrameRetryErrorRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.17',
  'wlanAPChBusyRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.18',
  'wlanAPChNumAPs' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.19',
  'wlanAPChFrameReceiveErrorRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.1.6.1.20',
  'wlsxWlanStationStatsGroup' => '1.3.6.1.4.1.14823.2.2.1.5.3.2',
  'wlsxWlanStationStatsTable' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1',
  'wlsxWlanStationStatsEntry' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1',
  'wlanStaChannelNum' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.1',
  'wlanStaTxPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.2',
  'wlanStaTxBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.3',
  'wlanStaRxPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.4',
  'wlanStaRxBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.5',
  'wlanStaTxBCastPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.6',
  'wlanStaRxBCastBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.7',
  'wlanStaTxMCastPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.8',
  'wlanStaRxMCastBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.9',
  'wlanStaDataPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.10',
  'wlanStaCtrlPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.11',
  'wlanStaNumAssocRequests' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.12',
  'wlanStaNumAuthRequests' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.13',
  'wlanStaTxDeauthentications' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.14',
  'wlanStaRxDeauthentications' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.15',
  'wlanStaFrameRetryRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.16',
  'wlanStaFrameLowSpeedRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.17',
  'wlanStaFrameNonUnicastRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.18',
  'wlanStaFrameFragmentationRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.19',
  'wlanStaFrameBandwidthRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.20',
  'wlanStaFrameRetryErrorRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.21',
  'wlanStaFrameReceiveErrorRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.22',
  'wlanStaTxBCastBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.23',
  'wlanStaTxMCastBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.1.1.24',
  'wlsxWlanStaRateStatsTable' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2',
  'wlsxWlanStaRateStatsEntry' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1',
  'wlanStaTxPktsAt1Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.1',
  'wlanStaTxBytesAt1Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.2',
  'wlanStaTxPktsAt2Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.3',
  'wlanStaTxBytesAt2Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.4',
  'wlanStaTxPktsAt5Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.5',
  'wlanStaTxBytesAt5Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.6',
  'wlanStaTxPktsAt11Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.7',
  'wlanStaTxBytesAt11Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.8',
  'wlanStaTxPktsAt6Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.9',
  'wlanStaTxBytesAt6Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.10',
  'wlanStaTxPktsAt12Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.11',
  'wlanStaTxBytesAt12Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.12',
  'wlanStaTxPktsAt18Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.13',
  'wlanStaTxBytesAt18Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.14',
  'wlanStaTxPktsAt24Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.15',
  'wlanStaTxBytesAt24Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.16',
  'wlanStaTxPktsAt36Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.17',
  'wlanStaTxBytesAt36Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.18',
  'wlanStaTxPktsAt48Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.19',
  'wlanStaTxBytesAt48Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.20',
  'wlanStaTxPktsAt54Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.21',
  'wlanStaTxBytesAt54Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.22',
  'wlanStaRxPktsAt1Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.23',
  'wlanStaRxBytesAt1Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.24',
  'wlanStaRxPktsAt2Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.25',
  'wlanStaRxBytesAt2Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.26',
  'wlanStaRxPktsAt5Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.27',
  'wlanStaRxBytesAt5Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.28',
  'wlanStaRxPktsAt11Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.29',
  'wlanStaRxBytesAt11Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.30',
  'wlanStaRxPktsAt6Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.31',
  'wlanStaRxBytesAt6Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.32',
  'wlanStaRxPktsAt12Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.33',
  'wlanStaRxBytesAt12Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.34',
  'wlanStaRxPktsAt18Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.35',
  'wlanStaRxBytesAt18Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.36',
  'wlanStaRxPktsAt24Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.37',
  'wlanStaRxBytesAt24Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.38',
  'wlanStaRxPktsAt36Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.39',
  'wlanStaRxBytesAt36Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.40',
  'wlanStaRxPktsAt48Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.41',
  'wlanStaRxBytesAt48Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.42',
  'wlanStaRxPktsAt54Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.43',
  'wlanStaRxBytesAt54Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.44',
  'wlanStaTxPktsAt9Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.45',
  'wlanStaTxBytesAt9Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.46',
  'wlanStaRxPktsAt9Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.47',
  'wlanStaRxBytesAt9Mbps' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.2.1.48',
  'wlsxWlanStaDATypeStatsTable' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.3',
  'wlsxWlanStaDATypeStatsEntry' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.3.1',
  'wlanStaTxDABroadcastPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.3.1.1',
  'wlanStaTxDABroadcastBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.3.1.2',
  'wlanStaTxDAMulticastPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.3.1.3',
  'wlanStaTxDAMulticastBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.3.1.4',
  'wlanStaTxDAUnicastPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.3.1.5',
  'wlanStaTxDAUnicastBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.3.1.6',
  'wlsxWlanStaFrameTypeStatsTable' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.4',
  'wlsxWlanStaFrameTypeStatsEntry' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.4.1',
  'wlanStaTxMgmtPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.4.1.1',
  'wlanStaTxMgmtBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.4.1.2',
  'wlanStaTxCtrlPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.4.1.3',
  'wlanStaTxCtrlBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.4.1.4',
  'wlanStaTxDataPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.4.1.5',
  'wlanStaTxDataBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.4.1.6',
  'wlanStaRxMgmtPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.4.1.7',
  'wlanStaRxMgmtBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.4.1.8',
  'wlanStaRxCtrlPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.4.1.9',
  'wlanStaRxCtrlBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.4.1.10',
  'wlanStaRxDataPkts' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.4.1.11',
  'wlanStaRxDataBytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.4.1.12',
  'wlsxWlanStaPktSizeStatsTable' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.5',
  'wlsxWlanStaPktSizeStatsEntry' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.5.1',
  'wlanStaTxPkts63Bytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.5.1.1',
  'wlanStaTxPkts64To127' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.5.1.2',
  'wlanStaTxPkts128To255' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.5.1.3',
  'wlanStaTxPkts256To511' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.5.1.4',
  'wlanStaTxPkts512To1023' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.5.1.5',
  'wlanStaTxPkts1024To1518' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.5.1.6',
  'wlanStaRxPkts63Bytes' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.5.1.7',
  'wlanStaRxPkts64To127' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.5.1.8',
  'wlanStaRxPkts128To255' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.5.1.9',
  'wlanStaRxPkts256To511' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.5.1.10',
  'wlanStaRxPkts512To1023' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.5.1.11',
  'wlanStaRxPkts1024To1518' => '1.3.6.1.4.1.14823.2.2.1.5.3.2.5.1.12',
  'wlsxWlanSwitchStatsGroup' => '1.3.6.1.4.1.14823.2.2.1.5.3.3',
  'wlsxWlanEthStatsTable' => '1.3.6.1.4.1.14823.2.2.1.5.3.3.2',
  'wlsxWlanEthStatsEntry' => '1.3.6.1.4.1.14823.2.2.1.5.3.3.2.1',
  'wlanEthRxRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.3.2.1.1',
  'wlanEthTxRate' => '1.3.6.1.4.1.14823.2.2.1.5.3.3.2.1.2',
};

$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'WLSX-WLAN-MIB'} = {
  'wlanAPBssidMode' => {
    '1' => 'ap',
    '2' => 'am',
  },
};



package Monitoring::GLPlugin::SNMP::CSF;
#our @ISA = qw(Monitoring::GLPlugin::SNMP);
use Digest::MD5 qw(md5_hex);
use strict;

sub create_statefile {
  my ($self, %params) = @_;
  my $extension = "";
  $extension .= $params{name} ? '_'.$params{name} : '';
  if ($self->opts->community) {
    $extension .= md5_hex($self->opts->community);
  }
  $extension =~ s/\//_/g;
  $extension =~ s/\(/_/g;
  $extension =~ s/\)/_/g;
  $extension =~ s/\*/_/g;
  $extension =~ s/\s/_/g;
  if ($self->opts->snmpwalk && ! $self->opts->hostname) {
    return sprintf "%s/%s_%s%s", $self->statefilesdir(),
        'snmpwalk.file'.md5_hex($self->opts->snmpwalk),
        $self->clean_path($self->mode), $self->clean_path(lc $extension);
  } elsif ($self->opts->snmpwalk && $self->opts->hostname eq "walkhost") {
    return sprintf "%s/%s_%s%s", $self->statefilesdir(),
        'snmpwalk.file'.md5_hex($self->opts->snmpwalk),
        $self->clean_path($self->mode), $self->clean_path(lc $extension);
  } else {
    return sprintf "%s/%s_%s%s", $self->statefilesdir(),
        $self->opts->hostname,
        $self->clean_path($self->mode), $self->clean_path(lc $extension);
  }
}



package Monitoring::GLPlugin::SNMP::Item;
our @ISA = qw(Monitoring::GLPlugin::SNMP::CSF Monitoring::GLPlugin::Item Monitoring::GLPlugin::SNMP);
use strict;



package Monitoring::GLPlugin::SNMP::TableItem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::CSF Monitoring::GLPlugin::TableItem Monitoring::GLPlugin::SNMP);
use strict;

sub ensure_index {
  my ($self, $key) = @_;
  $self->{$key} ||= $self->{flat_indices};
}

sub unhex_ip {
  my ($self, $value) = @_;
  if ($value && $value =~ /^0x(\w{8})/) {
    $value = join(".", unpack "C*", pack "H*", $1);
  } elsif ($value && $value =~ /^0x(\w{2} \w{2} \w{2} \w{2})/) {
    $value = $1;
    $value =~ s/ //g;
    $value = join(".", unpack "C*", pack "H*", $value);
  } elsif ($value && $value =~ /^([A-Z0-9]{2} [A-Z0-9]{2} [A-Z0-9]{2} [A-Z0-9]{2})/i) {
    $value = $1;
    $value =~ s/ //g;
    $value = join(".", unpack "C*", pack "H*", $value);
  } elsif ($value && unpack("H8", $value) =~ /(\w{2})(\w{2})(\w{2})(\w{2})/) {
    $value = join(".", map { hex($_) } ($1, $2, $3, $4));
  }
  return $value;
}

sub unhex_mac {
  my ($self, $value) = @_;
  if ($value && $value =~ /^0x(\w{12})/) {
    $value = join(".", unpack "C*", pack "H*", $1);
  } elsif ($value && $value =~ /^0x(\w{2}\s*\w{2}\s*\w{2}\s*\w{2}\s*\w{2}\s*\w{2})/) {
    $value = $1;
    $value =~ s/ //g;
    $value = join(":", unpack "C*", pack "H*", $value);
  } elsif ($value && unpack("H12", $value) =~ /(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})/) {
    $value = join(":", map { hex($_) } ($1, $2, $3, $4, $5, $6));
  }
  return $value;
}

sub unhex_octet_string {
  my ($self, $value) = @_;
  my $original = $value;
  $value =~ s/ //g;
  if ($value && $value =~ /^0x([0-9a-zA-Z]+)$/) {
    $value = join("", unpack "A*", pack "H*", $1);
  } elsif ($value && $value =~ /^([0-9a-zA-Z]+)$/) {
    $value = join("", unpack "A*", pack "H*", $1);
  } else {
    $value = $original;
  }
  return $value;
}



package Monitoring::GLPlugin::UPNP;
our @ISA = qw(Monitoring::GLPlugin);
# ABSTRACT: helper functions to build a upnp-based monitoring plugin

use strict;
use File::Basename;
use Digest::MD5 qw(md5_hex);
use AutoLoader;
our $AUTOLOAD;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

{
  our $mode = undef;
  our $plugin = undef;
  our $blacklist = undef;
  our $session = undef;
  our $rawdata = {};
  our $info = [];
  our $extendedinfo = [];
  our $summary = [];
  our $oidtrace = [];
  our $uptime = 0;
}

sub init {
  my ($self) = @_;
  if ($self->mode =~ /device::walk/) {
  } elsif ($self->mode =~ /device::uptime/) {
    my $info = sprintf 'device is up since %s',
        $self->human_timeticks($self->{uptime});
    $self->add_info($info);
    $self->set_thresholds(warning => '15:', critical => '5:');
    $self->add_message($self->check_thresholds($self->{uptime}), $info);
    $self->add_perfdata(
        label => 'uptime',
        value => $self->{uptime} / 60,
        warning => $self->{warning},
        critical => $self->{critical},
    );
    my ($code, $message) = $self->check_messages(join => ', ', join_all => ', ');
    $Monitoring::GLPlugin::plugin->nagios_exit($code, $message);
  }
}

sub check_upnp_and_model {
  my ($self) = @_;
  if (eval "require SOAP::Lite") {
    require XML::LibXML;
  } else {
    $self->add_critical('could not find SOAP::Lite module');
  }
  $self->{services} = {};
  if (! $self->check_messages()) {
    eval {
      my $igddesc = sprintf "http://%s:%s/igddesc.xml",
          $self->opts->hostname, $self->opts->port;
      my $parser = XML::LibXML->new();
      my $doc = $parser->parse_file($igddesc);
      my $root = $doc->documentElement();
      my $xpc = XML::LibXML::XPathContext->new( $root );
      $xpc->registerNs('n', 'urn:schemas-upnp-org:device-1-0');
      $self->{productname} = $xpc->findvalue('(//n:device)[position()=1]/n:modelName' );
      $self->debug(sprintf "igddesc productname is %s", $self->{productname});
      my @services = ();
      my @servicedescs = $xpc->find('(//n:service)')->get_nodelist;
      foreach my $service (@servicedescs) {
        my $servicetype = undef;
        my $serviceid = undef;
        my $controlurl = undef;
        foreach my $node ($service->nonBlankChildNodes("./*")) {
          $serviceid = $node->textContent if ($node->nodeName eq "serviceId");
          $servicetype = $node->textContent if ($node->nodeName eq "serviceType");
          $controlurl = $node->textContent if ($node->nodeName eq "controlURL");
        }
        if ($serviceid && $controlurl) {
          push(@services, {
              serviceType => $servicetype,
              serviceId => $serviceid,
              controlURL => sprintf('http://%s:%s%s',
                  $self->opts->hostname, $self->opts->port, $controlurl),
          });
          $self->debug(sprintf "found %s service %s",
              $servicetype, $serviceid);
        }
      }
      $self->set_variable('services', \@services);
    };
    if ($@) {
      $self->add_critical($@);
    }
  }
  if (! $self->check_messages()) {
    eval {
      my $service = (grep { $_->{serviceId} =~ /WANIPConn1/ } @{$self->get_variable('services')})[0];
      my $som = SOAP::Lite
          -> proxy($service->{controlURL})
          -> uri($service->{serviceType})
          -> GetStatusInfo();
      $self->{uptime} = $som->valueof("//GetStatusInfoResponse/NewUptime");
      $self->{uptime} /= 1.0;
      $self->debug("WANIPConn1->GetStatusInfo returned uptime");
    };
    if ($@) {
      $self->add_critical("could not get uptime: ".$@);
    }
  }
}

sub create_statefile {
  my ($self, %params) = @_;
  my $extension = "";
  $extension .= $params{name} ? '_'.$params{name} : '';
  if ($self->opts->community) {
    $extension .= md5_hex($self->opts->community);
  }
  $extension =~ s/\//_/g;
  $extension =~ s/\(/_/g;
  $extension =~ s/\)/_/g;
  $extension =~ s/\*/_/g;
  $extension =~ s/\s/_/g;
  if ($^O =~ /MSWin/) {
    $extension =~ s/:/_/g;
  }
  return sprintf "%s/%s_%s%s", $self->statefilesdir(),
      $self->opts->hostname, $self->opts->mode, lc $extension;
}



package Classes::UPNP::AVM::FritzBox7390::Component::InterfaceSubsystem;
our @ISA = qw(Classes::IFMIB::Component::InterfaceSubsystem);
use strict;


sub init {
  my $self = shift;
  if ($self->mode =~ /device::interfaces/) {
    $self->{ifDescr} = "WAN";
    my $service = (grep { $_->{serviceId} =~ /WANIPConn1/ } @{$self->get_variable('services')})[0];
    $self->{ExternalIPAddress} = SOAP::Lite
      -> proxy($service->{controlURL})
      -> uri($service->{serviceType})
      -> GetExternalIPAddress()
      -> result;
    $self->{ConnectionStatus} = SOAP::Lite
      -> proxy($service->{controlURL})
      -> uri($service->{serviceType})
      -> GetStatusInfo()
      -> valueof("//GetStatusInfoResponse/NewConnectionStatus");;
    $service = (grep { $_->{serviceId} =~ /WANCommonIFC1/ } @{$self->get_variable('services')})[0];
    $self->{PhysicalLinkStatus} = SOAP::Lite
      -> proxy($service->{controlURL})
      -> uri($service->{serviceType})
      -> GetCommonLinkProperties()
      -> valueof("//GetCommonLinkPropertiesResponse/NewPhysicalLinkStatus");
    $self->{Layer1UpstreamMaxBitRate} = SOAP::Lite
      -> proxy($service->{controlURL})
      -> uri($service->{serviceType})
      -> GetCommonLinkProperties()
      -> valueof("//GetCommonLinkPropertiesResponse/NewLayer1UpstreamMaxBitRate");
    $self->{Layer1DownstreamMaxBitRate} = SOAP::Lite
      -> proxy($service->{controlURL})
      -> uri($service->{serviceType})
      -> GetCommonLinkProperties()
      -> valueof("//GetCommonLinkPropertiesResponse/NewLayer1DownstreamMaxBitRate");
    $self->{TotalBytesSent} = SOAP::Lite
      -> proxy($service->{controlURL})
      -> uri($service->{serviceType})
      -> GetTotalBytesSent()
      -> result;
    $self->{TotalBytesReceived} = SOAP::Lite
      -> proxy($service->{controlURL})
      -> uri($service->{serviceType})
      -> GetTotalBytesReceived()
      -> result;
    if ($self->mode =~ /device::interfaces::usage/) {
      $self->valdiff({name => $self->{ifDescr}}, qw(TotalBytesSent TotalBytesReceived));
      $self->{delta_ifInBits} = $self->{delta_TotalBytesReceived} * 8;
      $self->{delta_ifOutBits} = $self->{delta_TotalBytesSent} * 8;
      $self->{inputUtilization} = 100 * $self->{delta_ifInBits} /
          ($self->{delta_timestamp} * $self->{Layer1DownstreamMaxBitRate});
      $self->{outputUtilization} = 100 * $self->{delta_ifOutBits} /
          ($self->{delta_timestamp} * $self->{Layer1UpstreamMaxBitRate});
      $self->{maxInputRate} = $self->{Layer1DownstreamMaxBitRate};
      $self->{maxOutputRate} = $self->{Layer1UpstreamMaxBitRate};
      $self->{inputRate} = $self->{delta_ifInBits} / $self->{delta_timestamp};
      $self->{outputRate} = $self->{delta_ifOutBits} / $self->{delta_timestamp};
      $self->override_opt("units", "bit") if ! $self->opts->units;
      $self->{inputRate} /= $self->number_of_bits($self->opts->units);
      $self->{outputRate} /= $self->number_of_bits($self->opts->units);
      $self->{maxInputRate} /= $self->number_of_bits($self->opts->units);
      $self->{maxOutputRate} /= $self->number_of_bits($self->opts->units);
      if ($self->{ConnectionStatus} ne "Connected") {
        $self->{inputUtilization} = 0;
        $self->{outputUtilization} = 0;
        $self->{inputRate} = 0;
        $self->{outputRate} = 0;
        $self->{maxInputRate} = 0;
        $self->{maxOutputRate} = 0;
      }
    } elsif ($self->mode =~ /device::interfaces::operstatus/) {
    } elsif ($self->mode =~ /device::interfaces::list/) {
    } else {
      $self->no_such_mode();
    }
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking interfaces');
  if ($self->mode =~ /device::interfaces::usage/) {
    $self->add_info(sprintf 'interface %s usage is in:%.2f%% (%s) out:%.2f%% (%s)',
        $self->{ifDescr},
        $self->{inputUtilization},
        sprintf("%.2f%s/s", $self->{inputRate}, $self->opts->units),
        $self->{outputUtilization},
        sprintf("%.2f%s/s", $self->{outputRate}, $self->opts->units));
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_usage_in',
        warning => 80,
        critical => 90
    );
    my $in = $self->check_thresholds(
        metric => $self->{ifDescr}.'_usage_in',
        value => $self->{inputUtilization}
    );
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_usage_out',
        warning => 80,
        critical => 90
    );
    my $out = $self->check_thresholds(
        metric => $self->{ifDescr}.'_usage_out',
        value => $self->{outputUtilization}
    );
    my $level = ($in > $out) ? $in : ($out > $in) ? $out : $in;
    $self->add_message($level);
    $self->add_perfdata(
        label => $self->{ifDescr}.'_usage_in',
        value => $self->{inputUtilization},
        uom => '%',
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_usage_out',
        value => $self->{outputUtilization},
        uom => '%',
    );

    my ($inwarning, $incritical) = $self->get_thresholds(
        metric => $self->{ifDescr}.'_usage_in',
    );
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_traffic_in',
        warning => $self->{maxInputRate} / 100 * $inwarning,
        critical => $self->{maxInputRate} / 100 * $incritical
    );
    $self->ade_perfdata(
        label => $self->{ifDescr}.'_traffic_in',
        value => $self->{inputRate},
        uom => $self->opts->units =~ /^(B|KB|MB|GB|TB)$/ ? $self->opts->units : undef,
        places => 2,
        min => 0,
        max => $self->{maxInputRate},
    );
    my ($outwarning, $outcritical) = $self->get_thresholds(
        metric => $self->{ifDescr}.'_usage_out',
    );
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_traffic_out',
        warning => $self->{maxOutputRate} / 100 * $outwarning,
        critical => $self->{maxOutputRate} / 100 * $outcritical,
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_traffic_out',
        value => $self->{outputRate},
        uom => $self->opts->units =~ /^(B|KB|MB|GB|TB)$/ ? $self->opts->units : undef,
        places => 2,
        min => 0,
        max => $self->{maxOutputRate},
    );
  } elsif ($self->mode =~ /device::interfaces::operstatus/) {
    $self->add_info(sprintf 'interface %s%s status is %s',
        $self->{ifDescr}, 
        $self->{ExternalIPAddress} ? " (".$self->{ExternalIPAddress}.")" : "",
        $self->{ConnectionStatus});
    if ($self->{ConnectionStatus} eq "Connected") {
      $self->add_ok();
    } else {
      $self->add_critical();
    }
  } elsif ($self->mode =~ /device::interfaces::list/) {
    printf "%s\n", $self->{ifDescr};
    $self->add_ok("have fun");
  }
}

package Classes::UPNP::AVM::FritzBox7390::Component::SmartHomeSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item Classes::UPNP::AVM::FritzBox7390);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /smarthome::device::list/) {
    $self->update_device_cache(1);
    foreach my $ain (keys %{$self->{device_cache}}) {
      my $name = $self->{device_cache}->{$ain}->{name};
      printf "%s %s\n", $ain, $name;
    }
  } elsif ($self->mode =~ /smarthome::device/) {
    $self->update_device_cache(0);
    my @indices = $self->get_device_indices();
    foreach my $ain (map {$_->[0]} @indices) {
      my %tmp_dev = (
          ain => $ain,
          name => $self->{device_cache}->{$ain}->{name},
          functionbitmask => $self->{device_cache}->{$ain}->{functionbitmask},
      );
      push(@{$self->{smart_home_devices}},
          Classes::UPNP::AVM::FritzBox7390::Component::SmartHomeSubsystem::Device->new(%tmp_dev));
    }
  }
}

sub check {
  my $self = shift;
  foreach (@{$self->{smart_home_devices}}) {
    $_->check();
  }
}

sub create_device_cache_file {
  my $self = shift;
  my $extension = "";
  if ($self->opts->community) {
    $extension .= Digest::MD5::md5_hex($self->opts->community);
  }
  $extension =~ s/\//_/g;
  $extension =~ s/\(/_/g;
  $extension =~ s/\)/_/g;
  $extension =~ s/\*/_/g;
  $extension =~ s/\s/_/g;
  return sprintf "%s/%s_interface_cache_%s", $self->statefilesdir(),
      $self->opts->hostname, lc $extension;
}

sub update_device_cache {
  my $self = shift;
  my $force = shift;
  my $statefile = $self->create_device_cache_file();
  my $update = time - 3600;
  if ($force || ! -f $statefile || ((stat $statefile)[9]) < ($update)) {
    $self->debug('force update of device cache');
    $self->{device_cache} = {};
    my $switchlist = $self->http_get('/webservices/homeautoswitch.lua?switchcmd=getdevicelistinfos');
    $switchlist = join(",", map {
        /<device identifier="(.*?)"/;
        my $ain = $1; $ain =~ s/\s//g;
        /<name>(.*?)<\/name>/; $self->{device_cache}->{$ain}->{name} = $1;
        /functionbitmask="(.*?)"/; $self->{device_cache}->{$ain}->{functionbitmask} = $1;
       $ain;
    } ($switchlist =~ /<device.*?<\/device>/g));
    $self->save_device_cache();
  }
  $self->load_device_cache();
}

sub save_device_cache {
  my $self = shift;
  $self->create_statefilesdir();
  my $statefile = $self->create_device_cache_file();
  my $tmpfile = $self->statefilesdir().'/check_nwc_health_tmp_'.$$;
  my $fh = IO::File->new();
  $fh->open(">$tmpfile");
  $fh->print(Data::Dumper::Dumper($self->{device_cache}));
  $fh->flush();
  $fh->close();
  my $ren = rename $tmpfile, $statefile;
  $self->debug(sprintf "saved %s to %s",
      Data::Dumper::Dumper($self->{device_cache}), $statefile);
}

sub load_device_cache {
  my $self = shift;
  my $statefile = $self->create_device_cache_file();
  if ( -f $statefile) {
    our $VAR1;
    eval {
      require $statefile;
    };
    if($@) {
      printf "rumms\n";
    }
    $self->debug(sprintf "load %s", Data::Dumper::Dumper($VAR1));
    $self->{device_cache} = $VAR1;
    eval {
      foreach (keys %{$self->{device_cache}}) {
        /^[\d\s]+$/ || die "newrelease";
      }
    };
    if($@) {
      $self->{device_cache} = {};
      unlink $statefile;
      delete $INC{$statefile};
      $self->update_device_cache(1);
    }
  }
}

sub get_device_indices {
  my $self = shift;
  my @indices = ();
  foreach my $id (keys %{$self->{device_cache}}) {
    my $name = $self->{device_cache}->{$id}->{name};
    if ($self->opts->name) {
      if ($self->opts->regexp) {
        my $pattern = $self->opts->name;
        if ($name =~ /$pattern/i) {
          push(@indices, [$id]);
        }
      } else {
        if ($self->opts->name =~ /^\d+$/) {
          if ($id == 1 * $self->opts->name) {
            push(@indices, [1 * $self->opts->name]);
          }
        } else {
          if (lc $name eq lc $self->opts->name) {
            push(@indices, [$id]);
          }
        }
      }
    } else {
      push(@indices, [$id]);
    }
  }
  return @indices;
}


package Classes::UPNP::AVM::FritzBox7390::Component::SmartHomeSubsystem::Device;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem Classes::UPNP::AVM::FritzBox7390::Component::SmartHomeSubsystem);
use strict;

sub finish {
  my $self = shift;
  $self->{cometdect} = ($self->{functionbitmask} & 0b000001000000) ? 1 : 0;
  $self->{energy} = ($self->{functionbitmask} & 0b000010000000) ? 1 : 0;
  $self->{temperature} = ($self->{functionbitmask} & 0b000100000000) ? 1 : 0;
  $self->{schaltsteck} = ($self->{functionbitmask} & 0b001000000000) ? 1 : 0;
  $self->{dectrepeater} = ($self->{functionbitmask} & 0b010000000000) ? 1 : 0;
  if ($self->mode =~ /smarthome::device::status/) {
    $self->{connected} = $self->http_get('/webservices/homeautoswitch.lua?switchcmd=getswitchpresent&ain='.$self->{ain});
    $self->{switched} = $self->http_get('/webservices/homeautoswitch.lua?switchcmd=getswitchstate&ain='.$self->{ain});
    chomp $self->{connected};
    chomp $self->{switched};
  } elsif ($self->mode =~ /smarthome::device::energy/ && $self->{energy}) {
    eval {
      $self->{last_watt} = $self->http_get('/webservices/homeautoswitch.lua?switchcmd=getswitchpower&ain='.$self->{ain});
      $self->{last_watt} /= 1000;
    };
  } elsif ($self->mode =~ /smarthome::device::consumption/ && $self->{energy}) {
    eval {
      $self->{kwh} = $self->http_get('/webservices/homeautoswitch.lua?switchcmd=getswitchenergy&ain='.$self->{ain});
      $self->{kwh} /= 1000;
    };
  } elsif ($self->mode =~ /smarthome::device::temperature/ && $self->{temperature}) {
    eval {
      $self->{celsius} = $self->http_get('/webservices/homeautoswitch.lua?switchcmd=gettemperature&ain='.$self->{ain});
      $self->{celsius} /= 10;
    };
  }
}

sub check {
  my $self = shift;
  my $label = $self->{name};
  if ($self->mode =~ /smarthome::device::status/) {
    $self->add_info(sprintf "device %s is %sconnected and switched %s",
        $self->{name}, $self->{connected} ? "" : "not ", $self->{switched} ? "on" : "off");
    if (! $self->{connected} || ! $self->{switched}) {
      $self->add_critical();
    } else {
      $self->add_ok(sprintf "device %s ok", $self->{name});
    }
  } elsif ($self->mode =~ /smarthome::device::energy/ && $self->{energy}) {
    $self->add_info(sprintf "device %s consumes %.4f watts",
        $self->{name}, $self->{last_watt});
    $self->set_thresholds(metric => $label."_watt",
        warning => 80 / 100 * 220 * 10, critical => 90 / 100 * 220 * 10);
    $self->add_message($self->check_thresholds(
        metric => $label."_watt", value => $self->{last_watt}));
    $self->add_perfdata(
        label => $label."_watt",
        value => $self->{last_watt},
    );
  } elsif ($self->mode =~ /smarthome::device::consumption/ && $self->{energy}) {
    $self->add_info(sprintf "device %s consumed %.4f kwh",
        $self->{name}, $self->{kwh});
    $self->set_thresholds(metric => $label."_kwh",
        warning => 1000, critical => 1000);
    $self->add_message($self->check_thresholds(
        metric => $label."_kwh", value => $self->{kwh}));
    $self->add_perfdata(
        label => $label."_kwh",
        value => $self->{kwh},
    );
  } elsif ($self->mode =~ /smarthome::device::temperature/ && $self->{temperature}) {
    $self->add_info(sprintf "device %s temperature is %.4f C",
        $self->{name}, $self->{celsius});
    $self->set_thresholds(metric => $label."_temperature",
        warning => 40, critical => 50);
    $self->add_message($self->check_thresholds(
        metric => $label."_temperature", value => $self->{celsius}));
    $self->add_perfdata(
        label => $label."_temperature",
        value => $self->{celsius},
    );
  }
}
package Classes::UPNP::AVM::FritzBox7390;
our @ISA = qw(Classes::UPNP::AVM);
use strict;

{
  our $sid = undef;
}

sub sid : lvalue {
  my $self = shift;
  $Classes::UPNP::AVM::FritzBox7390::sid;
}

sub init {
  my $self = shift;
  foreach my $module (qw(HTML::TreeBuilder LWP::UserAgent Encode Digest::MD5 JSON)) {
    if (! eval "require $module") {
      $self->add_unknown("could not find $module module");
    }
  }
  if (! $self->check_messages()) {
    if ($self->mode =~ /device::hardware::health/) {
      $self->login();
      $self->analyze_environmental_subsystem();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->login();
      $self->analyze_cpu_subsystem();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->login();
      $self->analyze_mem_subsystem();
      $self->check_mem_subsystem();
    } elsif ($self->mode =~ /device::interfaces/) {
      $self->analyze_and_check_interface_subsystem("Classes::UPNP::AVM::FritzBox7390::Component::InterfaceSubsystem");
    } elsif ($self->mode =~ /device::smarthome/) {
      $self->login();
      $self->analyze_and_check_smarthome_subsystem("Classes::UPNP::AVM::FritzBox7390::Component::SmartHomeSubsystem");
    } else {
      $self->no_such_mode();
    }
    $self->logout();
  }
}

sub login {
  my $self = shift;
  my $ua = LWP::UserAgent->new;
  my $loginurl = sprintf "http://%s/login_sid.lua", $self->opts->hostname;
  my $resp = $ua->get($loginurl);
  my $content = $resp->content();
  my $challenge = ($content =~ /<Challenge>(.*?)<\/Challenge>/ && $1);
  my $input = $challenge . '-' . $self->opts->community;
  Encode::from_to($input, 'ascii', 'utf16le');
  my $challengeresponse = $challenge . '-' . lc(Digest::MD5::md5_hex($input));
  $resp = HTTP::Request->new(POST => $loginurl);
  $resp->content_type("application/x-www-form-urlencoded");
  my $login = "response=$challengeresponse";
  if ($self->opts->username) {
      $login .= "&username=" . $self->opts->username;
  }
  $resp->content($login);
  my $loginresp = $ua->request($resp);
  $content = $loginresp->content();
  $self->sid() = ($content =~ /<SID>(.*?)<\/SID>/ && $1);
  if (! $loginresp->is_success() || ! $self->sid() || $self->sid() =~ /^0+$/) {
    $self->add_critical($loginresp->status_line());
  } else {
    $self->debug("logged in with sid ".$self->sid());
  }
}

sub logout {
  my $self = shift;
  return if ! $self->sid();
  my $ua = LWP::UserAgent->new;
  my $loginurl = sprintf "http://%s/login_sid.lua", $self->opts->hostname;
  my $resp = HTTP::Request->new(POST => $loginurl);
  $resp->content_type("application/x-www-form-urlencoded");
  my $logout = "sid=".$self->sid()."&security:command/logout=1";
  $resp->content($logout);
  my $logoutresp = $ua->request($resp);
  $self->sid() = undef;
  $self->debug("logged out");
}

sub DESTROY {
  my $self = shift;
  $self->logout();
}

sub http_get {
  my $self = shift;
  my $page = shift;
  my $ua = LWP::UserAgent->new;
  if ($page =~ /\?/) {
    $page .= "&sid=".$self->sid();
  } else {
    $page .= "?sid=".$self->sid();
  }
  my $url = sprintf "http://%s/%s", $self->opts->hostname, $page;
  $self->debug("http get ".$url);
  my $resp = $ua->get($url);
  if (! $resp->is_success()) {
    $self->add_critical($resp->status_line());
  } else {
  }
  return $resp->content();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  my $html = $self->http_get('system/ecostat.lua');
  if ($html =~ /uiSubmitLogin/) {
    $self->add_critical("wrong login");
    $self->{cpu_usage} = 0;
  } elsif ($html =~ /StatCPU/) {
    my $cpu = (grep /StatCPU/, split(/\n/, $html))[0];
    my @cpu = ($cpu =~ /= "(.*?)"/ && split(/,/, $1));
    $self->{cpu_usage} = $cpu[0];
  } elsif ($html =~ /uiViewCpu/) {
    $html =~ /Query1 = "(.*?)"/;
    $self->{cpu_usage} = (split(",", $1))[0];
  }
}

sub analyze_mem_subsystem {
  my $self = shift;
  my $html = $self->http_get('system/ecostat.lua');
  if ($html =~ /uiSubmitLogin/) {
    $self->add_critical("wrong login");
    $self->{ram_used} = 0;
  } elsif ($html =~ /StatRAMCacheUsed/) {
    my $ramcacheused = (grep /StatRAMCacheUsed/, split(/\n/, $html))[0];
    my @ramcacheused = ($ramcacheused =~ /= "(.*?)"/ && split(/,/, $1));
    $self->{ram_cache_used} = $ramcacheused[0];
    my $ramphysfree = (grep /StatRAMPhysFree/, split(/\n/, $html))[0];
    my @ramphysfree = ($ramphysfree =~ /= "(.*?)"/ && split(/,/, $1));
    $self->{ram_phys_free} = $ramphysfree[0];
    my $ramstrictlyused = (grep /StatRAMStrictlyUsed/, split(/\n/, $html))[0];
    my @ramstrictlyused = ($ramstrictlyused =~ /= "(.*?)"/ && split(/,/, $1));
    $self->{ram_strictly_used} = $ramstrictlyused[0];
    $self->{ram_used} = $self->{ram_strictly_used} + $self->{ram_cache_used};
  } elsif ($html =~ /uiViewRamValue/) {
    $html =~ /Query1 ="(.*?)"/;
    $self->{ram_free} = (split(",", $1))[0];
    $html =~ /Query2 ="(.*?)"/;
    $self->{ram_dynamic} = (split(",", $1))[0];
    $html =~ /Query3 ="(.*?)"/;
    $self->{ram_fix} = (split(",", $1))[0];
    $self->{ram_used} = $self->{ram_fix} + $self->{ram_dynamic};
  }
}

sub check_cpu_subsystem {
  my $self = shift;
  $self->add_info('checking cpus');
  $self->add_info(sprintf 'cpu usage is %.2f%%', $self->{cpu_usage});
  $self->set_thresholds(warning => 40, critical => 60);
  $self->add_message($self->check_thresholds($self->{cpu_usage}), $self->{info});
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{cpu_usage},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub check_mem_subsystem {
  my $self = shift;
  $self->add_info('checking memory');
  $self->add_info(sprintf 'memory usage is %.2f%%', $self->{ram_used});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{ram_used}), $self->{info});
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{ram_used},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}





package Classes::UPNP::AVM;
our @ISA = qw(Classes::UPNP);
use strict;

sub init {
  my $self = shift;
  if ($self->{productname} =~ /7390/) {
    bless $self, 'Classes::UPNP::AVM::FritzBox7390';
    $self->debug('using Classes::UPNP::AVM::FritzBox7390');
  } else {
    $self->no_such_model();
  }
  if (ref($self) ne "Classes::UPNP::AVM") {
    $self->init();
  }
}

package Classes::UPNP;
our @ISA = qw(Classes::Device);
use strict;

package Server::LinuxLocal;
our @ISA = qw(Classes::Device);
use strict;


sub init {
  my $self = shift;
  if ($self->mode =~ /device::interfaces/) {
    $self->analyze_and_check_interface_subsystem('Server::LinuxLocal::Component::InterfaceSubsystem');
  }
}


package Server::LinuxLocal::Component::InterfaceSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{interfaces} = [];
  if ($self->mode =~ /device::interfaces::list/) {
    foreach (glob "/sys/class/net/*") {
      my $name = $_;
      next if ! -d $name;
      $name =~ s/.*\///g;
      my $tmpif = {
        ifDescr => $name,
      };
      push(@{$self->{interfaces}},
        Server::LinuxLocal::Component::InterfaceSubsystem::Interface->new(%{$tmpif}));
    }
  } else {
    foreach (glob "/sys/class/net/*") {
      my $name = $_;
      $name =~ s/.*\///g;
      if ($self->opts->name) {
        if ($self->opts->regexp) {
          my $pattern = $self->opts->name;
          if ($name !~ /$pattern/i) {
            next;
          }
        } elsif (lc $name ne lc $self->opts->name) {
          next;
        }
      }
      *SAVEERR = *STDERR;
      open ERR ,'>/dev/null';
      *STDERR = *ERR;
      my $tmpif = {
        ifDescr => $name,
        ifIndex => $name,
        ifSpeed => (-f "/sys/class/net/$name/speed" ? do { local (@ARGV, $/) = "/sys/class/net/$name/speed"; my $x = <>; close ARGV; $x; } : undef),
        ifInOctets => do { local (@ARGV, $/) = "/sys/class/net/$name/statistics/rx_bytes"; my $x = <>; close ARGV; $x; },
        ifInDiscards => do { local (@ARGV, $/) = "/sys/class/net/$name/statistics/rx_dropped"; my $x = <>; close ARGV; $x; },
        ifInErrors => do { local (@ARGV, $/) = "/sys/class/net/$name/statistics/rx_errors"; my $x = <>; close ARGV; $x; },
        ifOutOctets => do { local (@ARGV, $/) = "/sys/class/net/$name/statistics/tx_bytes"; my $x = <>; close ARGV; $x; },
        ifOutDiscards => do { local (@ARGV, $/) = "/sys/class/net/$name/statistics/tx_dropped"; my $x = <>; close ARGV; $x; },
        ifOutErrors => do { local (@ARGV, $/) = "/sys/class/net/$name/statistics/tx_errors"; my $x = <>; close ARGV; $x; },
        ifOperStatus => do { local (@ARGV, $/) = "/sys/class/net/$name/operstate"; my $x = <>; close ARGV; $x; },
      };
      *STDERR = *SAVEERR;
      map {
          chomp $tmpif->{$_} if defined $tmpif->{$_}; 
          $tmpif->{$_} =~ s/\s*$//g if defined $tmpif->{$_};
      } keys %{$tmpif};
      $tmpif->{ifOperStatus} = 'down' if $tmpif->{ifOperStatus} ne 'up';
      $tmpif->{ifAdminStatus} = $tmpif->{ifOperStatus};
      if (defined $self->opts->ifspeed) {
        $tmpif->{ifSpeed} = $self->opts->ifspeed * 1024*1024;
      } else {
        $tmpif->{ifSpeed} *= 1024*1024 if defined $tmpif->{ifSpeed};
      }
      if (! defined $tmpif->{ifSpeed}) {
        $self->add_unknown(sprintf "There is no /sys/class/net/%s/speed. Use --ifspeed", $name);
      } else {
        push(@{$self->{interfaces}},
          Server::LinuxLocal::Component::InterfaceSubsystem::Interface->new(%{$tmpif}));
      }
    }
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking interfaces');
  if (scalar(@{$self->{interfaces}}) == 0) {
    $self->add_unknown('no interfaces');
    return;
  }
  if ($self->mode =~ /device::interfaces::list/) {
    foreach (sort {$a->{ifDescr} cmp $b->{ifDescr}} @{$self->{interfaces}}) {
      $_->list();
    }
  } else {
    foreach (@{$self->{interfaces}}) {
      $_->check();
    }
  }
}


package Server::LinuxLocal::Component::InterfaceSubsystem::Interface;
our @ISA = qw(Classes::IFMIB::Component::InterfaceSubsystem::Interface);
use strict;


package Server::WindowsLocal;
our @ISA = qw(Classes::Device);
use strict;


sub init {
  my $self = shift;
  if ($self->mode =~ /device::interfaces/) {
    $self->analyze_and_check_interface_subsystem('Server::WindowsLocal::Component::InterfaceSubsystem');
  }
}


package Server::WindowsLocal::Component::InterfaceSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub merge_by_canonical {
  my ($self, $tmpif, $network_adapters, $network_adapter_configs) = @_;
  $tmpif->{CanonicalName} = $tmpif->{ifDescr};
  $tmpif->{CanonicalName} =~ s/[^0-9a-zA-Z]/_/g;
  $self->debug(sprintf "found interface %s", $tmpif->{CanonicalName});
  if (! exists $network_adapter_configs->{$tmpif->{CanonicalName}}) {
    foreach (keys %{$network_adapters}) {
printf "= %s\n  %s\n", substr($tmpif->{CanonicalName}, 0, length($_)), $_;
      if (substr($tmpif->{CanonicalName}, 0, length($_)) eq $_) {
        $tmpif->{CanonicalName} = $_;
printf "dong\n";
        last;
      }
    }
  }
  if (exists $network_adapters->{$tmpif->{CanonicalName}}) {
    map {
      $tmpif->{$_} = $network_adapters->{$tmpif->{CanonicalName}}->{$_}
    } (qw(Index NetConnectionStatus NetEnabled));
    if (exists $network_adapter_configs->{$tmpif->{Index}}) {
      map {
        $tmpif->{$_} = $network_adapter_configs->{$tmpif->{Index}}->{$_}
      } (qw(InterfaceIndex));
    }
  }
}

sub init {
  my $self = shift;
  $self->{interfaces} = [];
# bits per second
  if ($self->mode =~ /device::interfaces::list/) {
    my $network_adapter_configs = {};
    my $network_adapters = {};
    my $dbh = DBI->connect('dbi:WMI:');
    my $sth = $dbh->prepare("select * from Win32_NetworkAdapter");
    # AdapterType, DeviceID, MACAddress, MaxSpeed, NetConnectionStatus, StatusInfo
    $self->debug("select Description, DeviceID, Index, MACAddress, MaxSpeed, NetConnectionID, NetConnectionStatus, NetEnabled, Speed, Status, StatusInfo from Win32_NetworkAdapter");
    $sth->execute();
    map {
      my $copy = {};
      my $orig = $_;
      map { $copy->{$_} = $orig->{$_} } (qw(Description DeviceID Index MACAddress MaxSpeed Name NetConnectionID NetConnectionStatus NetEnabled Speed Status StatusInfo));
      $copy->{CanonicalName} = unpack("Z*", $_->{Name});
      $copy->{CanonicalName} =~ s/[^0-9a-zA-Z]/_/g;
      $network_adapters->{$copy->{CanonicalName}} = $copy;
printf "network_adapters %s\n", Data::Dumper::Dumper($copy);
printf "network_adapters %s     %d\n", $copy->{CanonicalName}, $copy->{Index};
    } map {
      $_->[0];
    } @{$sth->fetchall_arrayref()};
    $sth->finish();
    $sth = $dbh->prepare("select * from Win32_NetworkAdapterConfiguration");
    # Description, InterfaceIndex, IPAddress, IPEndbled, IPSubnet, MTU
    $self->debug("select * from Win32_NetworkAdapterConfiguration");
    $sth->execute();
    map {
      my $copy = {};
      my $orig = $_;
      map { $copy->{$_} = $orig->{$_} } (qw(Description Index InterfaceIndex MACAddress MTU));
      $network_adapter_configs->{$copy->{Index}} = $copy;
    } map {
      $_->[0];
    } @{$sth->fetchall_arrayref()};
$self->debug("finish");
    $sth->finish();
    $sth = $dbh->prepare("select * from Win32_PerfRawData_Tcpip_NetworkInterface");
    $self->debug("select * from Win32_PerfRawData_Tcpip_NetworkInterface");
    $sth->execute();
    my $index = 0;
    while (my $member_arr = $sth->fetchrow_arrayref()) {
      my $member = $member_arr->[0];
      my $tmpif = {
        ifDescr => unpack("Z*", $member->{Name}),
        ifIndex => $index++,
      };
      $self->merge_by_canonical($tmpif, $network_adapters, $network_adapter_configs);
      push(@{$self->{interfaces}},
        Server::WindowsLocal::Component::InterfaceSubsystem::Interface->new(%{$tmpif}));
    }
    $sth->finish();
  } else {
    my $dbh = DBI->connect('dbi:WMI:');
    my $sth = $dbh->prepare("select * from Win32_PerfRawData_Tcpip_NetworkInterface");
    $sth->execute();
    while (my $member_arr = $sth->fetchrow_arrayref()) {
      my $i = 0;
      my $member = $member_arr->[0];
      my $name = $member->{Name};
      $name =~ s/.*\///g;
      if ($self->opts->name) {
        if ($self->opts->regexp) {
          my $pattern = $self->opts->name;
          if ($name !~ /$pattern/i) {
            next;
          }
        } elsif (lc $name ne lc $self->opts->name) {
          next;
        }
      }
      *SAVEERR = *STDERR;
      open ERR ,'>/dev/null';
      *STDERR = *ERR;
      my $tmpif = {
        ifDescr => $name,
        ifIndex => $name,
        ifSpeed => $member->{CurrentBandwidth}, # bits per second
        ifInOctets => $member->{BytesReceivedPerSec},
        ifInDiscards => $member->{PacketsReceivedDiscarded},
        ifInErrors => $member->{PacketsReceivedErrors},
        ifOutOctets => $member->{BytesSentPerSec},
        ifOutDiscards => $member->{PacketsOutboundDiscarded},
        ifOutErrors => $member->{PacketsOutboundErrors},
        ifOperStatus => 'up', # found no way to get interface status
      };
      *STDERR = *SAVEERR;
      map { 
          chomp $tmpif->{$_} if defined $tmpif->{$_}; 
          $tmpif->{$_} =~ s/\s*$//g if defined $tmpif->{$_};
      } keys %{$tmpif};
      $tmpif->{ifOperStatus} = 'down' if $tmpif->{ifOperStatus} ne 'up';
      $tmpif->{ifAdminStatus} = $tmpif->{ifOperStatus};
      if (defined $self->opts->ifspeed) {
        $tmpif->{ifSpeed} = $self->opts->ifspeed * 1024*1024;
      } else {
        $tmpif->{ifSpeed} *= 1024*1024 if defined $tmpif->{ifSpeed};
      }
      if (! defined $tmpif->{ifSpeed}) {
        $self->add_unknown(sprintf "There is no CurrentBandwidth. Use --ifspeed", $name);
      } else {
        push(@{$self->{interfaces}},
          Server::WindowsLocal::Component::InterfaceSubsystem::Interface->new(%{$tmpif}));
      }
    }
    $sth->finish();
    $sth = $dbh->prepare("select * from Win32_NetworkAdapter");
    $sth->execute();
    while (my $member_arr = $sth->fetchrow_arrayref()) {
    }
    $sth->finish();
    $sth = $dbh->prepare("select * from CIM_NetworkAdapter");
    $sth->execute();
    while (my $member_arr = $sth->fetchrow_arrayref()) {
    }
    $sth->finish();
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking interfaces');
  if (scalar(@{$self->{interfaces}}) == 0) {
    $self->add_unknown('no interfaces');
    return;
  }
  if ($self->mode =~ /device::interfaces::list/) {
    foreach (sort {$a->{ifDescr} cmp $b->{ifDescr}} @{$self->{interfaces}}) {
      $_->list();
    }
  } else {
    foreach (@{$self->{interfaces}}) {
      $_->check();
    }
  }
}


package Server::WindowsLocal::Component::InterfaceSubsystem::Interface;
our @ISA = qw(Classes::IFMIB::Component::InterfaceSubsystem::Interface);
use strict;

sub finish {
  my $self = shift;
  # NetEnabled 1=admin up
  # NetConnectionStatus Disconnected (0)Connecting (1)Connected (2)Disconnecting (3)Hardware Not Present (4)Hardware Disabled (5)Hardware Malfunction (6)Media Disconnected (7)Authenticating (8)Authentication Succeeded (9)Authentication Failed (10)Invalid Address (11)Credentials Required (12)Other (1365535)
  $self->SUPER::finish();
}

package Server::SolarisLocal;
our @ISA = qw(Classes::Device);
use strict;


sub init {
  my $self = shift;
  if ($self->mode =~ /device::interfaces/) {
    $self->analyze_and_check_interface_subsystem('Server::SolarisLocal::Component::InterfaceSubsystem');
  }
}


package Server::SolarisLocal::Component::InterfaceSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub packet_size {
  my $stats = shift;
  if (defined $stats->{opackets64} && $stats->{opackets64} != 0 && defined $stats->{obytes64}) {
    return int($stats->{obytes64} / $stats->{opackets64});
  } elsif (defined $stats->{ipackets64} && $stats->{ipackets64} != 0 && defined $stats->{rbytes64}) {
    return int($stats->{rbytes64} / $stats->{ipackets64});
  } elsif (defined $stats->{opackets} && $stats->{opackets} != 0 && defined $stats->{obytes}) {
    return int($stats->{obytes} / $stats->{opackets});
  } elsif (defined $stats->{ipackets} && $stats->{ipackets} != 0 && defined $stats->{rbytes}) {
    return int($stats->{rbytes} / $stats->{ipackets});
  } else {
    return 0;
  }
}

sub init {
  my $self = shift;
  $self->{kstat} = Sun::Solaris::Kstat->new();
  $self->{interfaces} = [];
  $self->{kstat_interfaces} = {};
  foreach my $module (keys %{$self->{kstat}}) {
    foreach my $instance (keys %{$self->{kstat}->{$module}}) {
      foreach my $name (keys %{$self->{kstat}->{$module}->{$instance}}) {
        next if $name !~ /^$module/;
        if (defined $self->{kstat}->{$module}->{$instance}->{$name}->{ifspeed} ||
            $module eq "lo") {
          if (! defined $self->{packet_size}) {
            my $packet_size = packet_size($self->{kstat}->{$module}->{$instance}->{$name});
            $self->{packet_size} = $packet_size if $packet_size;
          }
          if ($self->filter_name($name)) {
            $self->{kstat_interfaces}->{$name} =
                exists $self->{kstat}->{$module}->{$instance}->{mac} ?
                $self->{kstat}->{$module}->{$instance}->{mac} :
                $self->{kstat}->{$module}->{$instance}->{$name};
          }
        }
      }
    }
  }
  if ($self->mode =~ /device::interfaces::list/) {
    foreach my $name (keys %{$self->{kstat_interfaces}}) {
      my $tmpif = {
        ifDescr => $name,
      };
      push(@{$self->{interfaces}},
        Server::SolarisLocal::Component::InterfaceSubsystem::Interface->new(%{$tmpif}));
    }
  } else {
    foreach my $name (keys %{$self->{kstat_interfaces}}) {
      my $tmpif = {};
      my $stats = $self->{kstat_interfaces}->{$name};
      $tmpif->{ifDescr} = $name;
      $tmpif->{ifSnapTime} = $stats->{snaptime};
      $tmpif->{ifSnapTime} =~ s/\..*//g;
      if (defined $stats->{ifspeed}) {
        $tmpif->{ifSpeed} = $stats->{ifspeed};
      } elsif ($name =~ /^lo/) {
        $tmpif->{ifSpeed} = 10000000000; # assume 10GBit backplane
      }
      if (defined $stats->{rbytes64}) {
        $tmpif->{ifInOctets} = $stats->{rbytes64};
      } elsif (defined $stats->{rbytes}) {
        $tmpif->{ifInOctets} = $stats->{rbytes};
      } elsif (defined $stats->{ipackets} && $self->{packet_size}) {
        $tmpif->{ifInOctets} = $stats->{ipackets} * $self->{packet_size};
      } else {
        $tmpif->{ifInOctets} = 0;
      }
      if (defined $stats->{obytes64}) {
        $tmpif->{ifOutOctets} = $stats->{obytes64};
      } elsif (defined $stats->{obytes}) {
        $tmpif->{ifOutOctets} = $stats->{obytes};
      } elsif (defined $stats->{opackets} && $self->{packet_size}) {
        $tmpif->{ifOutOctets} = $stats->{opackets} * $self->{packet_size};
      } else {
        $tmpif->{ifOutOctets} = 0;
      }
      $tmpif->{ifInErrors} = defined $stats->{ierrors} ? $stats->{ierrors} : 0;
      $tmpif->{ifOutErrors} = defined $stats->{oerrors} ? $stats->{oerrors} : 0;
      $tmpif->{ifInDiscards} = 0;
      $tmpif->{ifOutDiscards} = 0;
      if (defined $self->opts->ifspeed) {
        $tmpif->{ifSpeed} = $self->opts->ifspeed * 1024*1024;
      }
      if (! defined $tmpif->{ifSpeed}) {
        $self->add_unknown(sprintf "There is no /sys/class/net/%s/speed. Use --ifspeed", $name);
      } else {
        push(@{$self->{interfaces}},
          Server::SolarisLocal::Component::InterfaceSubsystem::Interface->new(%{$tmpif}));
      }
    }
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking interfaces');
  if (scalar(@{$self->{interfaces}}) == 0) {
    $self->add_unknown('no interfaces');
    return;
  }
  if ($self->mode =~ /device::interfaces::list/) {
    foreach (sort {$a->{ifDescr} cmp $b->{ifDescr}} @{$self->{interfaces}}) {
      $_->list();
    }
  } else {
    foreach (@{$self->{interfaces}}) {
      $_->check();
    }
  }
}

package Server::SolarisLocal::Component::InterfaceSubsystem::Interface;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  foreach (qw(ifSpeed ifInOctets ifInDiscards ifInErrors ifOutOctets ifOutDiscards ifOutErrors ifSnapTime)) {
    $self->{$_} = 0 if ! defined $self->{$_};
  }
  if ($self->mode =~ /device::interfaces::complete/) {
    # uglatto, but $self->mode is an lvalue
    $Monitoring::GLPlugin::mode = "device::interfaces::operstatus";
    $self->init();
    #if ($self->{ifOperStatus} eq "up") {
      foreach my $mode (qw(device::interfaces::usage
          device::interfaces::errors)) {
        $Monitoring::GLPlugin::mode = $mode;
        $self->init();
      }
    #}
    $Monitoring::GLPlugin::mode = "device::interfaces::complete";
  } elsif ($self->mode =~ /device::interfaces::usage/) {
    $self->valdiff({name => $self->{ifDescr}}, qw(ifInOctets ifOutOctets ifSnapTime));
    $self->{delta_timestamp} = $self->{delta_ifSnapTime};
    $self->{delta_ifInBits} = $self->{delta_ifInOctets} * 8;
    $self->{delta_ifOutBits} = $self->{delta_ifOutOctets} * 8;
    if ($self->{ifSpeed} == 0) {
      # vlan graffl
      $self->{inputUtilization} = 0;
      $self->{outputUtilization} = 0;
      $self->{maxInputRate} = 0;
      $self->{maxOutputRate} = 0;
    } else {
      $self->{inputUtilization} = 100 * $self->{delta_ifInBits} /
          ($self->{delta_timestamp} * $self->{ifSpeed});
      $self->{outputUtilization} = 100 * $self->{delta_ifOutBits} /
          ($self->{delta_timestamp} * $self->{ifSpeed});
      $self->{maxInputRate} = $self->{ifSpeed};
      $self->{maxOutputRate} = $self->{ifSpeed};
    }
    if (defined $self->opts->ifspeed) {
      $self->override_opt('ifspeedin', $self->opts->ifspeed);
      $self->override_opt('ifspeedout', $self->opts->ifspeed);
    }
    if (defined $self->opts->ifspeedin) {
      $self->{inputUtilization} = 100 * $self->{delta_ifInBits} /
          ($self->{delta_timestamp} * $self->opts->ifspeedin);
      $self->{maxInputRate} = $self->opts->ifspeedin;
    }
    if (defined $self->opts->ifspeedout) {
      $self->{outputUtilization} = 100 * $self->{delta_ifOutBits} /
          ($self->{delta_timestamp} * $self->opts->ifspeedout);
      $self->{maxOutputRate} = $self->opts->ifspeedout;
    }
    $self->{inputRate} = $self->{delta_ifInBits} / $self->{delta_timestamp};
    $self->{outputRate} = $self->{delta_ifOutBits} / $self->{delta_timestamp};
    $self->override_opt("units", "bit") if ! $self->opts->units;
    $self->{inputRate} /= $self->number_of_bits($self->opts->units);
    $self->{outputRate} /= $self->number_of_bits($self->opts->units);
    $self->{maxInputRate} /= $self->number_of_bits($self->opts->units);
    $self->{maxOutputRate} /= $self->number_of_bits($self->opts->units);
    if ($self->{ifOperStatus} eq 'down') {
      $self->{inputUtilization} = 0;
      $self->{outputUtilization} = 0;
      $self->{inputRate} = 0;
      $self->{outputRate} = 0;
      $self->{maxInputRate} = 0;
      $self->{maxOutputRate} = 0;
    }
  } elsif ($self->mode =~ /device::interfaces::errors/) {
    $self->valdiff({name => $self->{ifDescr}}, qw(ifInErrors ifOutErrors ifSnapTime));
    $self->{delta_timestamp} = $self->{delta_ifSnapTime};
    $self->{inputErrorRate} = $self->{delta_ifInErrors}
        / $self->{delta_timestamp};
    $self->{outputErrorRate} = $self->{delta_ifOutErrors}
        / $self->{delta_timestamp};
  } elsif ($self->mode =~ /FORCENOTIMPLEMENTEDERROR::device::interfaces::discards/) {
    $self->valdiff({name => $self->{ifDescr}}, qw(ifInDiscards ifOutDiscards));
    $self->{inputDiscardRate} = $self->{delta_ifInDiscards}
        / $self->{delta_timestamp};
    $self->{outputDiscardRate} = $self->{delta_ifOutDiscards}
        / $self->{delta_timestamp};
  } elsif ($self->mode =~ /device::interfaces::operstatus/) {
  }
  return $self;
}

sub check {
  my $self = shift;
  if ($self->mode =~ /device::interfaces::complete/) {
    # uglatto, but $self->mode is an lvalue
    $Monitoring::GLPlugin::mode = "device::interfaces::operstatus";
    $self->check();
    #if ($self->{ifOperStatus} eq "up") {
      foreach my $mode (qw(device::interfaces::usage
          device::interfaces::errors)) {
        $Monitoring::GLPlugin::mode = $mode;
        $self->check();
      }
    #}
    $Monitoring::GLPlugin::mode = "device::interfaces::complete";
  } elsif ($self->mode =~ /device::interfaces::usage/) {
    $self->add_info(sprintf 'interface %s usage is in:%.2f%% (%s) out:%.2f%% (%s)',
        $self->{ifDescr},
        $self->{inputUtilization},
        sprintf("%.2f%s/s", $self->{inputRate}, $self->opts->units),
        $self->{outputUtilization},
        sprintf("%.2f%s/s", $self->{outputRate}, $self->opts->units));
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_usage_in',
        warning => 80,
        critical => 90
    );
    my $in = $self->check_thresholds(
        metric => $self->{ifDescr}.'_usage_in',
        value => $self->{inputUtilization}
    );
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_usage_out',
        warning => 80,
        critical => 90
    );
    my $out = $self->check_thresholds(
        metric => $self->{ifDescr}.'_usage_out',
        value => $self->{outputUtilization}
    );
    my $level = ($in > $out) ? $in : ($out > $in) ? $out : $in;
    $self->add_message($level);
    $self->add_perfdata(
        label => $self->{ifDescr}.'_usage_in',
        value => $self->{inputUtilization},
        uom => '%',
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_usage_out',
        value => $self->{outputUtilization},
        uom => '%',
    );

    my ($inwarning, $incritical) = $self->get_thresholds(
        metric => $self->{ifDescr}.'_usage_in',
    );
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_traffic_in',
        warning => $self->{maxInputRate} / 100 * $inwarning,
        critical => $self->{maxInputRate} / 100 * $incritical
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_traffic_in',
        value => $self->{inputRate},
        uom => $self->opts->units =~ /^(B|KB|MB|GB|TB)$/ ? $self->opts->units : undef,
        places => 2,
        min => 0,
        max => $self->{maxInputRate},
    );
    my ($outwarning, $outcritical) = $self->get_thresholds(
        metric => $self->{ifDescr}.'_usage_out',
    );
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_traffic_out',
        warning => $self->{maxOutputRate} / 100 * $outwarning,
        critical => $self->{maxOutputRate} / 100 * $outcritical,
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_traffic_out',
        value => $self->{outputRate},
        uom => $self->opts->units =~ /^(B|KB|MB|GB|TB)$/ ? $self->opts->units : undef,
        places => 2,
        min => 0,
        max => $self->{maxOutputRate},
    );
  } elsif ($self->mode =~ /device::interfaces::errors/) {
    $self->add_info(sprintf 'interface %s errors in:%.2f/s out:%.2f/s ',
        $self->{ifDescr},
        $self->{inputErrorRate} , $self->{outputErrorRate});
    $self->set_thresholds(warning => 1, critical => 10);
    my $in = $self->check_thresholds($self->{inputErrorRate});
    my $out = $self->check_thresholds($self->{outputErrorRate});
    my $level = ($in > $out) ? $in : ($out > $in) ? $out : $in;
    $self->add_message($level);
    $self->add_perfdata(
        label => $self->{ifDescr}.'_errors_in',
        value => $self->{inputErrorRate},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_errors_out',
        value => $self->{outputErrorRate},
    );
  } elsif ($self->mode =~ /device::interfaces::discards/) {
    $self->add_info(sprintf 'interface %s discards in:%.2f/s out:%.2f/s ',
        $self->{ifDescr},
        $self->{inputDiscardRate} , $self->{outputDiscardRate});
    $self->set_thresholds(warning => 1, critical => 10);
    my $in = $self->check_thresholds($self->{inputDiscardRate});
    my $out = $self->check_thresholds($self->{outputDiscardRate});
    my $level = ($in > $out) ? $in : ($out > $in) ? $out : $in;
    $self->add_message($level);
    $self->add_perfdata(
        label => $self->{ifDescr}.'_discards_in',
        value => $self->{inputDiscardRate},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_discards_out',
        value => $self->{outputDiscardRate},
    );
  }
}

sub list {
  my $self = shift;
  printf "%s\n", $self->{ifDescr};
}

package Classes::Server::Linux;
our @ISA = qw(Classes::Device);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Server::Linux::Component::EnvironmentalSubsystem")
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Server::Linux::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::disk::usage/) {
    $self->analyze_and_check_disk_subsystem("Classes::UCDMIB::Component::DiskSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Server::Linux::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::process::status/) {
    $self->analyze_and_check_process_subsystem("Classes::UCDMIB::Component::ProcessSubsystem");
  } elsif ($self->mode =~ /device::uptime/) {
    $self->analyze_and_check_uptime_subsystem("Classes::HOSTRESOURCESMIB::Component::UptimeSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Server::Linux::Component::CpuSubsystem;
our @ISA = qw(Classes::Server::Linux);
use strict;

sub new {
  my $class = shift;
  my $self = {};
  bless $self, $class;
  $self->init();
  return $self;
}

sub init {
  my $self = shift;
  $self->{cpu_subsystem} =
      Classes::UCDMIB::Component::CpuSubsystem->new();
  $self->{load_subsystem} =
      Classes::UCDMIB::Component::LoadSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{cpu_subsystem}->check();
  $self->{load_subsystem}->check();
}

sub dump {
  my $self = shift;
  $self->{cpu_subsystem}->dump();
  $self->{load_subsystem}->dump();
}



package Classes::Server::Linux::Component::EnvironmentalSubsystem;
our @ISA = qw(Classes::Server::Linux);
use strict;

sub new {
  my $class = shift;
  my $self = {};
  bless $self, $class;
  $self->init();
  return $self;
}

sub init {
  my $self = shift;
  $self->{fan_subsystem} =
      Classes::LMSENSORSMIB::Component::FanSubsystem->new();
  $self->{temperature_subsystem} =
      Classes::LMSENSORSMIB::Component::TemperatureSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{fan_subsystem}->check();
  $self->{temperature_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_ok("environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{fan_subsystem}->dump();
  $self->{temperature_subsystem}->dump();
}


package Classes::Server::Linux::Component::MemSubsystem;
our @ISA = qw(Classes::Server::Linux);
use strict;

sub new {
  my $class = shift;
  my $self = {};
  bless $self, $class;
  $self->init();
  return $self;
}

sub init {
  my $self = shift;
  $self->{mem_subsystem} =
      Classes::UCDMIB::Component::MemSubsystem->new();
  $self->{swap_subsystem} =
      Classes::UCDMIB::Component::SwapSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{mem_subsystem}->check();
  $self->{swap_subsystem}->check();
}

sub dump {
  my $self = shift;
  $self->{mem_subsystem}->dump();
  $self->{swap_subsystem}->dump();
}



package Classes::Bintec::Bibo::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->bulk_is_baeh();
  # there is temperature/sensor information in these mibs
  # mib-sensor.mib mib-box.mib mib-sysped.mib mib-sysiny.mib mibsysx8.mib
  # but i don't have a device which implements them
  $self->add_ok('hardware working fine. at least i hope so, because no checks are implemented');
}


package Classes::Bintec::Bibo::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->bulk_is_baeh();
  $self->get_snmp_tables('BIANCA-BRICK-MIBRES-MIB', [
      ['mem', 'memoryTable', 'Classes::Bintec::Bibo::Component::MemSubsystem::Memory'],
  ]);
}


package Classes::Bintec::Bibo::Component::MemSubsystem::Memory;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish  {
  my $self = shift;
  $self->{usage} = $self->{memoryInuse} /
      $self->{memoryTotal} * 100;
  bless $self, "Classes::Bintec::Bibo::Component::MemSubsystem::Memory::Flash"
      if $self->{memoryType} eq "flash";
  bless $self, "Classes::Bintec::Bibo::Component::MemSubsystem::Memory::Dram"
      if $self->{memoryType} eq "dram";
  bless $self, "Classes::Bintec::Bibo::Component::MemSubsystem::Memory::Dpool"
      if $self->{memoryType} eq "dpool";
}


package Classes::Bintec::Bibo::Component::MemSubsystem::Memory::Flash;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->{memoryDescr} = $self->unhex_octet_string($self->{memoryDescr});
  $self->{memoryDescr} =~ s/\0//g;
  $self->add_info(sprintf '%s usage is %.2f%%',
      $self->{memoryDescr}, $self->{usage});
  my $label = 'memory_'.$self->{memoryDescr}.'_usage';
  $self->set_thresholds(metric => $label, warning => 90, critical => 95);
  $self->add_message($self->check_thresholds(metric => $label, value => $self->{usage}));
  $self->add_perfdata(
      label => $label,
      value => $self->{usage},
      uom => '%',
  );
}


package Classes::Bintec::Bibo::Component::MemSubsystem::Memory::Dram;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->{memoryDescr} = $self->unhex_octet_string($self->{memoryDescr});
  $self->{memoryDescr} =~ s/\0//g;
  $self->add_info(sprintf '%s usage is %.2f%%',
      $self->{memoryDescr}, $self->{usage});
  my $label = 'memory_'.$self->{memoryDescr}.'_usage';
  $self->set_thresholds(metric => $label, warning => 80, critical => 90);
  $self->add_message($self->check_thresholds(metric => $label, value => $self->{usage}));
  $self->add_perfdata(
      label => $label,
      value => $self->{usage},
      uom => '%',
  );
}

package Classes::Bintec::Bibo::Component::MemSubsystem::Memory::Dpool;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf '%s usage is %.2f%%',
      $self->{memoryDescr}, $self->{usage});
  my $label = 'memory_'.$self->{memoryDescr}.'_usage';
  $self->add_perfdata(
      label => $label,
      value => $self->{usage},
      uom => '%',
  );
}


package Classes::Bintec::Bibo::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->bulk_is_baeh();
  $self->get_snmp_tables('BIANCA-BRICK-MIBRES-MIB', [
      ['cpus', 'cpuTable', 'Classes::Bintec::Bibo::Component::CpuSubsystem::Cpu'],
  ]);
}


package Classes::Bintec::Bibo::Component::CpuSubsystem::Cpu;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->valdiff({name => 'cpu'}, qw(cpuTotalIdle));
  $self->{cpuTotalUsage} = 100 - (100 * $self->{delta_cpuTotalIdle} / $self->{delta_timestamp});
  if ($self->{cpuTotalUsage} < 0 || $self->{cpuTotalUsage} > 100 || ! $self->{delta_cpuTotalIdle}) {
    # falls irgendein bloedsinn passiert
    $self->{cpuTotalUsage} = 100 - $self->{cpuLoadIdle60s};
  }
}

sub check {
  my $self = shift;
  my $label = 'cpu_'.$self->{cpuDescr};
  $self->add_info(sprintf 'cpu %d (%s) usage is %.2f%%',
      $self->{cpuNumber},
      $self->{cpuDescr},
      $self->{cpuTotalUsage});
  $self->set_thresholds(metric => $label, warning => '80', critical => '90');
  $self->add_message($self->check_thresholds(
      metric => $label, value => $self->{cpuTotalUsage}));
  $self->add_perfdata(
      label => $label,
      value => $self->{cpuTotalUsage},
      uom => '%',
  );
}

package Classes::Bintec::Bibo;
our @ISA = qw(Classes::Bintec);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Bintec::Bibo::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Bintec::Bibo::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Bintec::Bibo::Component::MemSubsystem");
  } else {
    $self->no_such_mode();
  }
}
package Classes::Bintec;
our @ISA = qw(Classes::Device);
use strict;

package Classes::Cisco::CISCOIPSECFLOWMONITOR::Component::VpnSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCO-IPSEC-FLOW-MONITOR-MIB', [
      ['ciketunnels', 'cikeTunnelTable', 'Classes::Cisco::CISCOIPSECFLOWMONITOR::Component::VpnSubsystem::CikeTunnel',  sub { my $o = shift; $o->{parent} = $self; $self->filter_name($o->{cikeTunRemoteValue})}],
  ]);
}

sub check {
  my $self = shift;
  if (! @{$self->{ciketunnels}}) {
    $self->add_critical(sprintf 'tunnel to %s does not exist',
        $self->opts->name);
  } else {
    foreach (@{$self->{ciketunnels}}) {
      $_->check();
    }
  }
}


package Classes::Cisco::CISCOIPSECFLOWMONITOR::Component::VpnSubsystem::CikeTunnel;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
# cikeTunRemoteValue per --name angegeben, muss active sein
# ansonsten watch-vpns, delta tunnels ueberwachen
  $self->add_info(sprintf 'tunnel to %s is %s',
      $self->{cikeTunRemoteValue}, $self->{cikeTunStatus});
  if ($self->{cikeTunStatus} ne 'active') {
    $self->add_critical();
  } else {
    $self->add_ok();
  }
}

package Classes::Cisco::CISCOENHANCEDMEMPOOLMIB::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCO-ENHANCED-MEMPOOL-MIB', [
      ['mems', 'cempMemPoolTable', 'Classes::Cisco::CISCOENHANCEDMEMPOOLMIB::Component::MemSubsystem::EnhMem'],
  ]);
}

package Classes::Cisco::CISCOENHANCEDMEMPOOLMIB::Component::MemSubsystem::EnhMem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  if (defined $self->{cempMemPoolHCUsed}) {
    $self->{usage} = 100 * $self->{cempMemPoolHCUsed} /
        ($self->{cempMemPoolHCFree} + $self->{cempMemPoolHCUsed});
  } else {
    $self->{usage} = 100 * $self->{cempMemPoolUsed} /
        ($self->{cempMemPoolFree} + $self->{cempMemPoolUsed});
  }
  $self->{type} = $self->{cempMemPoolType} ||= 0;
  $self->{name} = $self->{cempMemPoolName}.'_'.$self->{indices}->[0];
}

sub check {
  my $self = shift;
  $self->add_info(sprintf 'mempool %s usage is %.2f%%',
      $self->{name}, $self->{usage});
  if ($self->{name} =~ /^lsmpi_io/ &&
      $self->get_snmp_object('MIB-2-MIB', 'sysDescr', 0) =~ /IOS.*(XE|ASR1000)/i) {
    # https://supportforums.cisco.com/docs/DOC-16425
    $self->force_thresholds(
        metric => $self->{name}.'_usage',
        warning => 100,
        critical => 100,
    );
  } elsif ($self->{name} =~ /^reserved/ &&
      $self->get_snmp_object('MIB-2-MIB', 'sysDescr', 0) =~ /IOS.*XR/i) {
    # ASR9K "reserved" and "image" are always at 100%
    $self->force_thresholds(
        metric => $self->{name}.'_usage',
        warning => 100,
        critical => 100,
    );
  } elsif ($self->{name} =~ /^image/ &&
      $self->get_snmp_object('MIB-2-MIB', 'sysDescr', 0) =~ /IOS.*XR/i) {
    $self->force_thresholds(
        metric => $self->{name}.'_usage',
        warning => 100,
        critical => 100,
    );
  } else {
    $self->set_thresholds(
        metric => $self->{name}.'_usage',
        warning => 80,
        critical => 90,
    );
  }
  $self->add_message($self->check_thresholds(
      metric => $self->{name}.'_usage',
      value => $self->{usage},
  ));
  $self->add_perfdata(
      label => $self->{name}.'_usage',
      value => $self->{usage},
      uom => '%',
  );
}

package Classes::Cisco::CISCOMEMORYPOOLMIB::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCO-MEMORY-POOL-MIB', [
      ['mems', 'ciscoMemoryPoolTable', 'Classes::Cisco::CISCOMEMORYPOOLMIB::Component::MemSubsystem::Mem'],
  ]);
}

package Classes::Cisco::CISCOMEMORYPOOLMIB::Component::MemSubsystem::Mem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{usage} = 100 * $self->{ciscoMemoryPoolUsed} /
      ($self->{ciscoMemoryPoolFree} + $self->{ciscoMemoryPoolUsed});
  $self->{type} = $self->{ciscoMemoryPoolType} ||= 0;
  $self->{name} = $self->{ciscoMemoryPoolName};
}

sub check {
  my $self = shift;
  $self->add_info(sprintf 'mempool %s usage is %.2f%%',
      $self->{name}, $self->{usage});
  if ($self->{name} =~ /^lsmpi_io/ &&
      $self->get_snmp_object('MIB-2-MIB', 'sysDescr', 0) =~ /IOS.*(XE|ASR1000)/i) {
    # https://supportforums.cisco.com/docs/DOC-16425
    $self->force_thresholds(
        metric => $self->{name}.'_usage',
        warning => 100,
        critical => 100,
    );
  } elsif ($self->{name} eq 'reserved' &&
      $self->get_snmp_object('MIB-2-MIB', 'sysDescr', 0) =~ /IOS.*XR/i) {
    # ASR9K "reserved" and "image" are always at 100%
    $self->force_thresholds(
        metric => $self->{name}.'_usage',
        warning => 100,
        critical => 100,
    );
  } elsif ($self->{name} eq 'image' &&
      $self->get_snmp_object('MIB-2-MIB', 'sysDescr', 0) =~ /IOS.*XR/i) {
    $self->force_thresholds(
        metric => $self->{name}.'_usage',
        warning => 100,
        critical => 100,
    );
  } else {
    $self->set_thresholds(
        metric => $self->{name}.'_usage',
        warning => 80,
        critical => 90,
    );
  }
  $self->add_message($self->check_thresholds(
      metric => $self->{name}.'_usage',
      value => $self->{usage},
  ));
  $self->add_perfdata(
      label => $self->{name}.'_usage',
      value => $self->{usage},
      uom => '%',
  );
}

package Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{fan_subsystem} =
      Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::FanSubsystem->new();
  $self->{powersupply_subsystem} =
      Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::PowersupplySubsystem->new();
  $self->{module_subsystem} =
      Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::ModuleSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{fan_subsystem}->check();
  $self->{powersupply_subsystem}->check();
  $self->{module_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_ok("environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{fan_subsystem}->dump();
  $self->{powersupply_subsystem}->dump();
  $self->{module_subsystem}->dump();
}

package Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::FanSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCO-ENTITY-FRU-CONTROL-MIB', [
    ['fans', 'cefcFanTrayStatusTable', 'Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::FanSubsystem::Fan'],
  ]);
  $self->get_snmp_tables('ENTITY-MIB', [
    ['entities', 'entPhysicalTable', 'Classes::Cisco::CISCOENTITYSENSORMIB::Component::SensorSubsystem::PhysicalEntity'],
  ]);
  @{$self->{entities}} = grep { $_->{entPhysicalClass} eq 'fan' } @{$self->{entities}};
  foreach my $fan (@{$self->{fans}}) {
    foreach my $entity (@{$self->{entities}}) {
      if ($fan->{flat_indices} eq $entity->{entPhysicalIndex}) {
        $fan->{entity} = $entity;
      }
    }
  }
}

package Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::FanSubsystem::Fan;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'fan/tray %s%s status is %s',
      $self->{flat_indices},
      #exists $self->{entity} ? ' ('.$self->{entity}->{entPhysicalDescr}.' idx '.$self->{entity}->{entPhysicalIndex}.' class '.$self->{entity}->{entPhysicalClass}.')' : '',
      exists $self->{entity} ? ' ('.$self->{entity}->{entPhysicalDescr}.')' : '',
      $self->{cefcFanTrayOperStatus});
  if ($self->{cefcFanTrayOperStatus} eq "unknown") {
    $self->add_unknown();
  } elsif ($self->{cefcFanTrayOperStatus} eq "down") {
    $self->add_warning();
  } elsif ($self->{cefcFanTrayOperStatus} eq "warning") {
    $self->add_warning();
  }
}

package Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::ModuleSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCO-ENTITY-FRU-CONTROL-MIB', [
    ['modules', 'cefcModuleTable', 'Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::ModuleSubsystem::Module'],
  ]);
  $self->get_snmp_tables('ENTITY-MIB', [
    ['entities', 'entPhysicalTable', 'Classes::Cisco::CISCOENTITYSENSORMIB::Component::SensorSubsystem::PhysicalEntity'],
  ]);
  @{$self->{entities}} = grep { $_->{entPhysicalClass} eq 'module' } @{$self->{entities}};
  foreach my $module (@{$self->{modules}}) {
    foreach my $entity (@{$self->{entities}}) {
      if ($module->{flat_indices} eq $entity->{entPhysicalIndex}) {
        $module->{entity} = $entity;
      }
    }
  }
}

package Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::ModuleSubsystem::Module;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  my @criticals = qw(failed missing okButPowerOverCritical powerDenied);
  my @warnings = qw(mismatchWithParent mismatchConfig diagFailed
    outOfServiceAdmin outOfServiceEnvTemp powerDown okButPowerOverWarning
    okButAuthFailed);
  $self->add_info(sprintf 'module %s%s admin status is %s, oper status is %s',
      $self->{flat_indices},
      #exists $self->{entity} ? ' ('.$self->{entity}->{entPhysicalDescr}.' idx '.$self->{entity}->{entPhysicalIndex}.' class '.$self->{entity}->{entPhysicalClass}.')' : '',
      exists $self->{entity} ? ' ('.$self->{entity}->{entPhysicalDescr}.')' : '',
      $self->{cefcModuleAdminStatus},
      $self->{cefcModuleOperStatus});
  if ($self->{cefcModuleOperStatus} eq "unknown") {
    $self->add_unknown();
  } elsif (grep $_ eq $self->{cefcModuleOperStatus}, @criticals) {
    $self->add_critical();
  } elsif (grep $_ eq $self->{cefcModuleOperStatus}, @warnings) {
    $self->add_warning();
  }
  # else ok
}

package Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::PowersupplySubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCO-ENTITY-FRU-CONTROL-MIB', [
    ['powersupplies', 'cefcFRUPowerStatusTable', 'Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::PowersupplySubsystem::Powersupply'],
    ['powersupplygroups', 'cefcFRUPowerSupplyGroupTable', 'Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::PowersupplySubsystem::PowersupplyGroup'],
  ]);
  $self->get_snmp_tables('ENTITY-MIB', [
    ['entities', 'entPhysicalTable', 'Classes::Cisco::CISCOENTITYSENSORMIB::Component::SensorSubsystem::PhysicalEntity'],
  ]);
  @{$self->{entities}} = grep { $_->{entPhysicalClass} eq 'powerSupply' } @{$self->{entities}};
  foreach my $supply (@{$self->{powersupplies}}) {
    foreach my $entity (@{$self->{entities}}) {
      if ($supply->{flat_indices} eq $entity->{entPhysicalIndex}) {
        $supply->{entity} = $entity;
      }
    }
  }
}


package Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::PowersupplySubsystem::Powersupply;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'power supply %s%s admin status is %s, oper status is %s',
      $self->{flat_indices},
      #exists $self->{entity} ? ' ('.$self->{entity}->{entPhysicalDescr}.' idx '.$self->{entity}->{entPhysicalIndex}.' class '.$self->{entity}->{entPhysicalClass}.')' : '',
      exists $self->{entity} ? ' ('.$self->{entity}->{entPhysicalDescr}.' )' : '',
      $self->{cefcFRUPowerAdminStatus},
      $self->{cefcFRUPowerOperStatus});
  if ($self->{cefcFRUPowerOperStatus} eq "on") {
  } elsif ($self->{cefcFRUPowerOperStatus} eq "unknown") {
    $self->add_unknown();
  } elsif ($self->{cefcFRUPowerOperStatus} eq "onButFanFail") {
    $self->add_warning();
  } else {
    $self->add_critical();
  }
}


package Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::PowersupplySubsystem::PowersupplyGroup;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;


package Classes::Cisco::CISCOENTITYSENSORMIB::Component::SensorSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  my $sensors = {};
  $self->get_snmp_tables('CISCO-ENTITY-SENSOR-MIB', [
    ['sensors', 'entSensorValueTable', 'Classes::Cisco::CISCOENTITYSENSORMIB::Component::SensorSubsystem::Sensor', sub { my $o = shift; $self->filter_name($o->{entPhysicalIndex})}],
    ['thresholds', 'entSensorThresholdTable', 'Classes::Cisco::CISCOENTITYSENSORMIB::Component::SensorSubsystem::SensorThreshold'],
  ]);
  $self->get_snmp_tables('ENTITY-MIB', [
    ['entities', 'entPhysicalTable', 'Classes::Cisco::CISCOENTITYSENSORMIB::Component::SensorSubsystem::PhysicalEntity'],
  ]);
  @{$self->{sensor_entities}} = grep { $_->{entPhysicalClass} eq 'sensor' } @{$self->{entities}};
  foreach my $sensor (@{$self->{sensors}}) {
    $sensors->{$sensor->{entPhysicalIndex}} = $sensor;
    foreach my $threshold (@{$self->{thresholds}}) {
      if ($sensor->{entPhysicalIndex} eq $threshold->{entPhysicalIndex}) {
        push(@{$sensor->{thresholds}}, $threshold);
      }
    }
    foreach my $entity (@{$self->{sensor_entities}}) {
      if ($sensor->{entPhysicalIndex} eq $entity->{entPhysicalIndex}) {
        $sensor->{entity} = $entity;
      }
    }
  }
}

package Classes::Cisco::CISCOENTITYSENSORMIB::Component::SensorSubsystem::Sensor;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub finish {
  my $self = shift;
  $self->{entPhysicalIndex} = $self->{flat_indices};
  # www.thaiadmin.org%2Fboard%2Findex.php%3Faction%3Ddlattach%3Btopic%3D45832.0%3Battach%3D23494&ei=kV9zT7GHJ87EsgbEvpX6DQ&usg=AFQjCNHuHiS2MR9TIpYtu7C8bvgzuqxgMQ&cad=rja
  # zu klaeren. entPhysicalIndex entspricht dem entPhysicalindex der ENTITY-MIB.
  # In der stehen alle moeglichen Powersupplies etc.
  # Was bedeutet aber dann entSensorMeasuredEntity? gibt's eh nicht in meinen
  # Beispiel-walks
  $self->{thresholds} = [];
  $self->{entSensorMeasuredEntity} ||= 'undef';
}

sub check {
  my $self = shift;
  $self->add_info(sprintf '%s sensor %s%s is %s',
      $self->{entSensorType},
      $self->{entPhysicalIndex},
      exists $self->{entity} ? ' ('.$self->{entity}->{entPhysicalDescr}.')' : '',
      $self->{entSensorStatus});
  if ($self->{entSensorStatus} eq "nonoperational") {
    $self->add_critical();
  } elsif ($self->{entSensorStatus} eq "unknown_10") {
    # these sensors do not exist according to cisco-tools
    return;
  } elsif ($self->{entSensorStatus} eq "unavailable") {
    return;
  }
  my $label = sprintf('sens_%s_%s', $self->{entSensorType}, $self->{entPhysicalIndex});
  my $warningx = ($self->get_thresholds(metric => $label))[0];
  my $criticalx = ($self->get_thresholds(metric => $label))[1];
  if (scalar(@{$self->{thresholds}} == 4)) {
    # sowos gits aa.
    # an entSensorType: voltsAC mied 3249milli, der wou 4 thresholds hod.
    # owa: entSensorThresholdEvaluation: unknown_0,
    # entSensorThresholdSeverity: other
    # entSensorThresholdValue: 3630, entSensorThresholdRelation: lessThan
    # und de andern: entSensorThresholdValue: 3465, 2970, 3135
    # wos wuellsd ejtz do mocha? i dou jednfalls nix. es kinnts me.
  }
  if (scalar(@{$self->{thresholds}} == 2)) {
    # reparaturlauf
    foreach my $idx (0..1) {
      my $otheridx = $idx == 0 ? 1 : 0;
      if (! defined @{$self->{thresholds}}[$idx]->{entSensorThresholdSeverity} &&   
          @{$self->{thresholds}}[$otheridx]->{entSensorThresholdSeverity} eq "minor") {
        @{$self->{thresholds}}[$idx]->{entSensorThresholdSeverity} = "major";
      } elsif (! defined @{$self->{thresholds}}[$idx]->{entSensorThresholdSeverity} &&   
          @{$self->{thresholds}}[$otheridx]->{entSensorThresholdSeverity} eq "minor") {
        @{$self->{thresholds}}[$idx]->{entSensorThresholdSeverity} = "minor";
      }
    }
    my $warning = (map { $_->{entSensorThresholdValue} } 
        grep { $_->{entSensorThresholdSeverity} eq "minor" }
        @{$self->{thresholds}})[0];
    my $critical = (map { $_->{entSensorThresholdValue} } 
        grep { $_->{entSensorThresholdSeverity} eq "major" }
        @{$self->{thresholds}})[0];
    $self->set_thresholds(
        metric => $label,
        warning => $warning, critical => $critical
    );
    if ((defined($criticalx) && 
        $self->check_thresholds(metric => $label, value => $self->{entSensorValue}) == CRITICAL) ||
        (! defined($criticalx) && 
            grep { $_->{entSensorThresholdEvaluation} eq "true" } 
            grep { $_->{entSensorThresholdSeverity} eq "major" } @{$self->{thresholds}})) {
      # eigener schwellwert hat vorrang
      $self->add_critical(sprintf "%s sensor %s threshold evaluation is true (value: %s, major threshold: %s)", 
          $self->{entSensorType},
          $self->{entPhysicalIndex},
          $self->{entSensorValue},
          defined($criticalx) ? $criticalx : $critical
      );
    } elsif ((defined($warningx) && 
        $self->check_thresholds(metric => $label, value => $self->{entSensorValue}) == WARNING) ||
        (! defined($warningx) && 
            grep { $_->{entSensorThresholdEvaluation} eq "true" } 
            grep { $_->{entSensorThresholdSeverity} eq "minor" } @{$self->{thresholds}})) {
      $self->add_warning(sprintf "%s sensor %s threshold evaluation is true (value: %s, minor threshold: %s)", 
          $self->{entSensorType},
          $self->{entPhysicalIndex},
          $self->{entSensorValue},
          defined($warningx) ? $warningx : $warning
      );
    }
    $self->add_perfdata(
        label => $label,
        value => $self->{entSensorValue},
        warning => defined($warningx) ? $warningx : $warning,
        critical => defined($criticalx) ? $criticalx : $critical,
    );
  } elsif (defined $self->{entSensorValue}) {
    if ((defined($criticalx) && 
        $self->check_thresholds(metric => $label, value => $self->{entSensorValue}) == CRITICAL) ||
       (defined($warningx) && 
        $self->check_thresholds(metric => $label, value => $self->{entSensorValue}) == WARNING) ||
       ($self->{entSensorThresholdEvaluation} && $self->{entSensorThresholdEvaluation} eq "true")) {
    }
    if (defined($criticalx) &&
        $self->check_thresholds(metric => $label, value => $self->{entSensorValue}) == CRITICAL) {
      $self->add_critical(sprintf "%s sensor %s threshold evaluation is true (value: %s)",
          $self->{entSensorType},
          $self->{entPhysicalIndex},
          $self->{entSensorValue}
      );
      $self->add_perfdata(
          label => $label,
          value => $self->{entSensorValue},
          critical => $criticalx,
          warning => $warningx,
      );
    } elsif (defined($warningx) &&
        $self->check_thresholds(metric => $label, value => $self->{entSensorValue}) == WARNING) {
      $self->add_warning(sprintf "%s sensor %s threshold evaluation is true (value: %s)",
          $self->{entSensorType},
          $self->{entPhysicalIndex},
          $self->{entSensorValue}
      );
      $self->add_perfdata(
          label => $label,
          value => $self->{entSensorValue},
          critical => $criticalx,
          warning => $warningx,
      );
    } elsif ($self->{entSensorThresholdEvaluation} && $self->{entSensorThresholdEvaluation} eq "true") {
      $self->add_warning(sprintf "%s sensor %s threshold evaluation is true (value: %s)",
          $self->{entSensorType},
          $self->{entPhysicalIndex},
          $self->{entSensorValue}
      );
      $self->add_perfdata(
          label => $label,
          value => $self->{entSensorValue},
          warning => $self->{ciscoEnvMonSensorThreshold},
      );
    } else {
      $self->add_perfdata(
          label => $label,
          value => $self->{entSensorValue},
      );
    }
  } elsif (scalar(grep { $_->{entSensorThresholdEvaluation} eq "true" }
      @{$self->{thresholds}})) {
    $self->add_warning(sprintf "%s sensor %s threshold evaluation is true", 
        $self->{entSensorType},
        $self->{entPhysicalIndex});
  }
}


package Classes::Cisco::CISCOENTITYSENSORMIB::Component::SensorSubsystem::SensorThreshold;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{entPhysicalIndex} = $self->{indices}->[0];
  $self->{entSensorThresholdIndex} = $self->{indices}->[1];
}


package Classes::Cisco::CISCOENTITYSENSORMIB::Component::SensorSubsystem::PhysicalEntity;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{entPhysicalIndex} = $self->{flat_indices};
}



package Classes::Cisco::CISCOENTITYALARMMIB::Component::AlarmSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  my $alarms = {};
  $self->get_snmp_tables('CISCO-ENTITY-ALARM-MIB', [
    ['alarms', 'ceAlarmTable', 'Classes::Cisco::CISCOENTITYSENSORMIB::Component::AlarmSubsystem::Alarm', sub { my $o = shift; $o->{parent} = $self; $self->filter_name($o->{entPhysicalIndex})}],
    ['alarmdescriptionmappings', 'ceAlarmDescrMapTable', 'Classes::Cisco::CISCOENTITYSENSORMIB::Component::AlarmSubsystem::AlarmDescriptionMapping' ],
    ['alarmdescriptions', 'ceAlarmDescrTable', 'Classes::Cisco::CISCOENTITYSENSORMIB::Component::AlarmSubsystem::AlarmDescription' ],
    ['alarmfilterprofiles', 'ceAlarmFilterProfileTable', 'Classes::Cisco::CISCOENTITYSENSORMIB::Component::AlarmSubsystem::AlarmFilterProfile' ],
    ['alarmhistory', 'ceAlarmHistTable', 'Classes::Cisco::CISCOENTITYSENSORMIB::Component::AlarmSubsystem::AlarmHistory', sub { my $o = shift; $o->{parent} = $self; $self->filter_name($o->{entPhysicalIndex})}],
  ]);
  $self->get_snmp_tables('ENTITY-MIB', [
    ['entities', 'entPhysicalTable', 'Classes::Cisco::CISCOENTITYSENSORMIB::Component::AlarmSubsystem::PhysicalEntity'],
  ]);
  $self->get_snmp_objects('CISCO-ENTITY-ALARM-MIB', qw(
      ceAlarmCriticalCount ceAlarmMajorCount ceAlarmMinorCount
      ceAlarmFilterProfileIndexNext
  ));
  foreach (qw(ceAlarmCriticalCount ceAlarmMajorCount ceAlarmMinorCount)) {
    $self->{$_} ||= 0;
  }
  @{$self->{alarms}} = grep { 
      $_->{ceAlarmSeverity} ne 'none' &&
      $_->{ceAlarmSeverity} ne 'info'
  } @{$self->{alarms}};
  foreach my $alarm (@{$self->{alarms}}) {
    foreach my $entity (@{$self->{entities}}) {
      if ($alarm->{entPhysicalIndex} eq $entity->{entPhysicalIndex}) {
        $alarm->{entity} = $entity;
      }
    }
  }
}

sub check {
  my $self = shift;
  if (scalar(@{$self->{alarms}}) == 0) {
    $self->add_info('no alarms');
    $self->add_ok();
  } else {
    foreach (@{$self->{alarms}}) {
      $_->check();
    }
    foreach (@{$self->{alarmhistory}}) {
      $_->check();
    }
    if (! $self->check_messages()) { # blacklisted des ganze glump
      $self->add_info('no alarms');
      $self->add_ok();
    }
  }
}

package Classes::Cisco::CISCOENTITYSENSORMIB::Component::AlarmSubsystem::Alarm;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{entPhysicalIndex} = $self->{flat_indices};
  $self->{ceAlarmTypes} = [];
  if ($self->{ceAlarmList}) {
    my $index = 0;
    foreach my $octet (unpack('H2', $self->{ceAlarmList})) {
      my $hexoctet = hex($octet) & 0xff;
      if ($hexoctet) {
        my $base = 8 * $index;
        foreach my $bit (0..7) {
          my $mask = (2 ** $bit) & 0xff;
          if ($hexoctet & $mask) {
            push(@{$self->{ceAlarmTypes}}, $base + $bit);
          }
        }
      }
      $index++;
    }
  }
  $self->{ceAlarmTypes} = join(",", @{$self->{ceAlarmTypes}}); # weil sonst der drecks-dump nicht funktioniert.
}

sub check {
  my $self = shift;
  my $location = exists $self->{entity} ?
      $self->{entity}->{entPhysicalDescr} : "unknown";
  if (length($self->{ceAlarmTypes})) {
    my @descriptorindexes = map {
        $_->{ceAlarmDescrIndex}
    } grep {
        $self->{entity}->{entPhysicalVendorType} eq $_->{ceAlarmDescrVendorType}
    } @{$self->{parent}->{alarmdescriptionmappings}};
    if (@descriptorindexes) {
      my $ceAlarmDescrIndex = $descriptorindexes[0];
      my @descriptions = grep {
        $_->{ceAlarmDescrIndex} == $ceAlarmDescrIndex;
      } @{$self->{parent}->{alarmdescriptions}};
      foreach my $ceAlarmType (split(",", $self->{ceAlarmTypes})) {
        foreach my $alarmdesc (@descriptions) {
          if ($alarmdesc->{ceAlarmDescrAlarmType} == $ceAlarmType) {
            $self->add_info(sprintf "%s alarm '%s' in entity %d (%s)",
                $alarmdesc->{ceAlarmDescrSeverity},
                $alarmdesc->{ceAlarmDescrText},
                $self->{entPhysicalIndex},
                $location);
            if ($alarmdesc->{ceAlarmDescrSeverity} eq "none") {
              # A value of '0' indicates that there the corresponding physical entity currently is not asserting any alarms.
            } elsif ($alarmdesc->{ceAlarmDescrSeverity} eq "critical") {
              $self->add_critical();
            } elsif ($alarmdesc->{ceAlarmDescrSeverity} eq "major") {
              $self->add_critical();
            } elsif ($alarmdesc->{ceAlarmDescrSeverity} eq "minor") {
              $self->add_warning();
            } elsif ($alarmdesc->{ceAlarmDescrSeverity} eq "info") {
              $self->add_ok();
            }
          }
        }
      }
    }
  }
  delete $self->{parent}; # brauch ma nimmer, daad eh sched bon dump scheebern
}


package Classes::Cisco::CISCOENTITYSENSORMIB::Component::AlarmSubsystem::PhysicalEntity;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{entPhysicalIndex} = $self->{flat_indices};
}

package Classes::Cisco::CISCOENTITYSENSORMIB::Component::AlarmSubsystem::AlarmDescription;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

sub finish {
  my $self = shift;
  $self->{ceAlarmDescrIndex} = $self->{indices}->[0];
  $self->{ceAlarmDescrAlarmType} = $self->{indices}->[1];
}


package Classes::Cisco::CISCOENTITYSENSORMIB::Component::AlarmSubsystem::AlarmDescriptionMapping;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

sub finish {
  my $self = shift;
  $self->{ceAlarmDescrIndex} = $self->{indices}->[0];
}

package Classes::Cisco::CISCOENTITYSENSORMIB::Component::AlarmSubsystem::AlarmFilterProfile;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

package Classes::Cisco::CISCOENTITYSENSORMIB::Component::AlarmSubsystem::AlarmHistory;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

sub finish {
  my $self = shift;
  $self->{ceAlarmHistTimeStamp} = time - $self->uptime() + $self->timeticks($self->{ceAlarmHistTimeStamp});
  $self->{ceAlarmHistTimeStampLocal} = scalar localtime $self->{ceAlarmHistTimeStamp};
}

sub check {
  my $self = shift;
  my $vendortype = "unknown";
  my @entities = grep {
    $_->{entPhysicalIndex} == $self->{ceAlarmHistEntPhysicalIndex};
  } @{$self->{parent}->{entities}};
  if (@entities) {
    $vendortype = $entities[0]->{entPhysicalVendorType};
    $self->{ceAlarmHistEntPhysicalDescr} = $entities[0]->{entPhysicalDescr};
  }
  my @descriptorindexes = map {
      $_->{ceAlarmDescrIndex}
  } grep {
      $vendortype eq $_->{ceAlarmDescrVendorType}
  } @{$self->{parent}->{alarmdescriptionmappings}};
  if (@descriptorindexes) {
    my $ceAlarmDescrIndex = $descriptorindexes[0];
    my @descriptions = grep {
      $_->{ceAlarmDescrIndex} == $ceAlarmDescrIndex;
    } @{$self->{parent}->{alarmdescriptions}};
    foreach my $alarmdesc (@descriptions) {
      if ($alarmdesc->{ceAlarmDescrAlarmType} == $self->{ceAlarmHistAlarmType}) {
        $self->{ceAlarmHistAlarmDescrText} = $alarmdesc->{ceAlarmDescrText};
      }
    }
  }
  delete $self->{parent};
}

package Classes::Cisco::CISCOENVMONMIB::Component::TemperatureSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCO-ENVMON-MIB', [
      ['temperatures', 'ciscoEnvMonTemperatureStatusTable', 'Classes::Cisco::CISCOENVMONMIB::Component::TemperatureSubsystem::Temperature'],
  ]);
}

package Classes::Cisco::CISCOENVMONMIB::Component::TemperatureSubsystem::Temperature;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {};
  foreach (keys %params) {
    $self->{$_} = $params{$_};
  }
  if ($self->{ciscoEnvMonTemperatureStatusValue}) {
    bless $self, $class;
  } else {
    bless $self, $class.'::Simple';
  }
  $self->ensure_index('ciscoEnvMonTemperatureStatusIndex');
  $self->{ciscoEnvMonTemperatureLastShutdown} ||= 0;
  return $self;
}

sub check {
  my $self = shift;
  if ($self->{ciscoEnvMonTemperatureStatusValue} >
      $self->{ciscoEnvMonTemperatureThreshold}) {
    $self->add_info(sprintf 'temperature %d %s is too high (%d of %d max = %s)',
        $self->{ciscoEnvMonTemperatureStatusIndex},
        $self->{ciscoEnvMonTemperatureStatusDescr},
        $self->{ciscoEnvMonTemperatureStatusValue},
        $self->{ciscoEnvMonTemperatureThreshold},
        $self->{ciscoEnvMonTemperatureState});
    if ($self->{ciscoEnvMonTemperatureState} eq 'warning') {
      $self->add_warning();
    } elsif ($self->{ciscoEnvMonTemperatureState} eq 'critical') {
      $self->add_critical();
    }
  } else {
    $self->add_info(sprintf 'temperature %d %s is %d (of %d max = normal)',
        $self->{ciscoEnvMonTemperatureStatusIndex},
        $self->{ciscoEnvMonTemperatureStatusDescr},
        $self->{ciscoEnvMonTemperatureStatusValue},
        $self->{ciscoEnvMonTemperatureThreshold});
  }
  $self->add_perfdata(
      label => sprintf('temp_%s', $self->{ciscoEnvMonTemperatureStatusIndex}),
      value => $self->{ciscoEnvMonTemperatureStatusValue},
      warning => $self->{ciscoEnvMonTemperatureThreshold},
      critical => undef,
  );
}


package Classes::Cisco::CISCOENVMONMIB::Component::TemperatureSubsystem::Temperature::Simple;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->{ciscoEnvMonTemperatureStatusIndex} ||= 0;
  $self->{ciscoEnvMonTemperatureStatusDescr} ||= 0;
  $self->add_info(sprintf 'temperature %d %s is %s',
      $self->{ciscoEnvMonTemperatureStatusIndex},
      $self->{ciscoEnvMonTemperatureStatusDescr},
      $self->{ciscoEnvMonTemperatureState});
  if ($self->{ciscoEnvMonTemperatureState} ne 'normal') {
    if ($self->{ciscoEnvMonTemperatureState} eq 'warning') {
      $self->add_warning();
    } elsif ($self->{ciscoEnvMonTemperatureState} eq 'critical') {
      $self->add_critical();
    }
  } else {
  }
}

package Classes::Cisco::CISCOENVMONMIB::Component::PowersupplySubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCO-ENVMON-MIB', [
      ['supplies', 'ciscoEnvMonSupplyStatusTable', 'Classes::Cisco::CISCOENVMONMIB::Component::PowersupplySubsystem::Powersupply'],
  ]);
}

package Classes::Cisco::CISCOENVMONMIB::Component::PowersupplySubsystem::Powersupply;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->ensure_index('ciscoEnvMonSupplyStatusIndex');
  $self->add_info(sprintf 'powersupply %d (%s) is %s',
      $self->{ciscoEnvMonSupplyStatusIndex},
      $self->{ciscoEnvMonSupplyStatusDescr},
      $self->{ciscoEnvMonSupplyState});
  if ($self->{ciscoEnvMonSupplyState} eq 'notPresent') {
  } elsif ($self->{ciscoEnvMonSupplyState} eq 'warning') {
    $self->add_warning();
  } elsif ($self->{ciscoEnvMonSupplyState} ne 'normal') {
    $self->add_critical();
  }
}

package Classes::Cisco::CISCOENVMONMIB::Component::VoltageSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  my $index = 0;
  $self->get_snmp_tables('CISCO-ENVMON-MIB', [
      ['voltages', 'ciscoEnvMonVoltageStatusTable', 'Classes::Cisco::CISCOENVMONMIB::Component::VoltageSubsystem::Voltage'],
  ]);
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking voltages');
  if (scalar (@{$self->{voltages}}) == 0) {
  } else {
    foreach (@{$self->{voltages}}) {
      $_->check();
    }
  }
}


package Classes::Cisco::CISCOENVMONMIB::Component::VoltageSubsystem::Voltage;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->ensure_index('ciscoEnvMonVoltageStatusIndex');
  $self->add_info(sprintf 'voltage %d (%s) is %s',
      $self->{ciscoEnvMonVoltageStatusIndex},
      $self->{ciscoEnvMonVoltageStatusDescr},
      $self->{ciscoEnvMonVoltageState});
  if ($self->{ciscoEnvMonVoltageState} eq 'notPresent') {
  } elsif ($self->{ciscoEnvMonVoltageState} ne 'normal') {
    $self->add_critical();
  }
  $self->add_perfdata(
      label => sprintf('mvolt_%s', $self->{ciscoEnvMonVoltageStatusIndex}),
      value => $self->{ciscoEnvMonVoltageStatusValue},
      warning => $self->{ciscoEnvMonVoltageThresholdLow},
      critical => $self->{ciscoEnvMonVoltageThresholdHigh},
  );
}

package Classes::Cisco::CISCOENVMONMIB::Component::FanSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCO-ENVMON-MIB', [
      ['fans', 'ciscoEnvMonFanStatusTable', 'Classes::Cisco::CISCOENVMONMIB::Component::FanSubsystem::Fan'],
  ]);
}

package Classes::Cisco::CISCOENVMONMIB::Component::FanSubsystem::Fan;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->ensure_index('ciscoEnvMonFanStatusIndex');
  $self->add_info(sprintf 'fan %d (%s) is %s',
      $self->{ciscoEnvMonFanStatusIndex},
      $self->{ciscoEnvMonFanStatusDescr},
      $self->{ciscoEnvMonFanState});
  if ($self->{ciscoEnvMonFanState} eq 'notPresent') {
  } elsif ($self->{ciscoEnvMonFanState} ne 'normal') {
    $self->add_critical();
  }
}

package Classes::Cisco::CISCOSTACKMIB::Component::StackSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };


sub init {
  my ($self) = @_;
  $self->get_snmp_objects('CISCO-STACK-MIB', qw(sysStatus
      chassisSysType 
      chassisPs1Type chassisPs1Status chassisPs1TestResult
      chassisPs2Type chassisPs2Status chassisPs2TestResult
      chassisPs3Type chassisPs3Status chassisPs3TestResult
      chassisFanStatus chassisFanTestResult
      chassisMinorAlarm chassisMajorAlarm chassisTempAlarm
      chassisModel chassisSerialNumberString
  ));
  $self->get_snmp_tables("CISCO-STACK-MIB", [
      ['components', 'chassisComponentTable', 'Monitoring::GLPlugin::SNMP::TableItem'],
      ['modules', 'moduleTable', 'Classes::Cisco::CISCOSTACKMIB::Component::StackSubsystem::Module'],
  ]);
  if (grep { exists $_->{moduleEntPhysicalIndex} } @{$self->{modules}}) {
    $self->get_snmp_tables('ENTITY-MIB', [
      ['entities', 'entPhysicalTable', 'Monitoring::GLPlugin::TableItem'],
    ]);
    my $entities = {};
    foreach (@{$self->{entities}}) {
      $entities->{$_->{flat_indices}} = $_;
    }
    foreach (@{$self->{modules}}) {
      if (exists $entities->{$_->{moduleEntPhysicalIndex}}) {
        foreach my $key (keys %{$entities->{$_->{moduleEntPhysicalIndex}}}) {
          $_->{$key} = $entities->{$_->{moduleEntPhysicalIndex}}->{$key} if $key =~ /entPhysical/;
        }
      }
    }
    delete $self->{entities};
  }
  $self->{numModules} = scalar(@{$self->{modules}});
  $self->{moduleSerialList} = [map { $_->{moduleSerialNumberString} } @{$self->{modules}}];
  map { $self->{numPorts} += $_->{moduleNumPorts} } @{$self->{modules}};
}

sub check {
  my ($self) = @_;
  if ($self->{chassisSysType} eq 'other' &&
      ! $self->{chassisSerialNumberString} &&
      ! $self->{chassisSerialNumberString}) {
    $self->add_message(defined $self->opts->mitigation() ?
        $self->opts->mitigation() : UNKNOWN,
        'this is probably not a stacked device');
    return;
  }
  foreach (@{$self->{modules}}) {
    $_->check();
  }
  if (defined $self->{sysStatus}) {
    $self->add_info(sprintf 'chassis sys status is %s',
        $self->{sysStatus});
    if ($self->{sysStatus} eq 'minorFault') {
      $self->add_warning();
    } elsif ($self->{sysStatus} eq 'majorFault') {
      $self->add_critical();
    } else {
      $self->add_ok();
    }
  }
  if ($self->{chassisFanStatus} ne 'ok') {
    $self->add_critical();
  }
  $self->add_info(sprintf 'chassis fan status is %s',
      $self->{chassisFanStatus});
  if ($self->{chassisFanStatus} ne 'ok') {
    $self->add_critical();
  }
  $self->add_info(sprintf 'chassis minor alarm is %s',
      $self->{chassisMinorAlarm});
  if ($self->{chassisMinorAlarm} ne 'off') {
    $self->add_warning();
  }
  $self->add_info(sprintf 'chassis major alarm is %s',
      $self->{chassisMajorAlarm});
  if ($self->{chassisMajorAlarm} ne 'off') {
    $self->add_critical();
  }
  $self->add_info(sprintf 'chassis temperature alarm is %s',
      $self->{chassisTempAlarm});
  if ($self->{chassisTempAlarm} ne 'off') {
    $self->add_critical();
  }
  for my $ps (1, 2, 3) {
    if (exists $self->{'chassisPs'.$ps.'Type'}) {
      #next if $self->{'chassisPs'.$ps.'Status'} eq 'other';
      $self->add_info(sprintf 'power supply %d status is %s',
          $ps, $self->{'chassisPs'.$ps.'Status'});
      if ($self->{'chassisPs'.$ps.'Status'} eq 'minorFault') {
        $self->add_warning();
      } elsif ($self->{'chassisPs'.$ps.'Status'} eq 'majorFault') {
        $self->add_critical();
      } else {
        $self->add_ok();
      }
    }
  }
  $self->opts->override_opt('lookback', 1800) if ! $self->opts->lookback;
  $self->valdiff({name => $self->{chassisSerialNumberString}, lastarray => 1},
      qw(moduleSerialList numModules numPorts));
  if (scalar(@{$self->{delta_found_moduleSerialList}}) > 0) {
    $self->add_warning(sprintf '%d new module(s) (%s)',
        scalar(@{$self->{delta_found_moduleSerialList}}),
        join(", ", @{$self->{delta_found_moduleSerialList}}));
  }
  if (scalar(@{$self->{delta_lost_moduleSerialList}}) > 0) {
    $self->add_critical(sprintf '%d module(s) missing (%s)',
        scalar(@{$self->{delta_lost_moduleSerialList}}),
        join(", ", @{$self->{delta_lost_moduleSerialList}}));
  }
  if ($self->{delta_numPorts} > 0) {
    $self->add_warning(sprintf '%d new ports', $self->{delta_numPorts});
  } elsif ($self->{delta_numPorts} < 0) {
    $self->add_critical(sprintf '%d missing ports', abs($self->{delta_numPorts}));
  }
  if (! $self->check_messages()) {
    $self->add_ok('chassis is ok');
  }
  $self->add_info(sprintf 'found %d modules with %d ports',
      $self->{numModules}, $self->{numPorts});
  $self->add_ok();
}

package Classes::Cisco::CISCOSTACKMIB::Component::StackSubsystem::Module;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

sub finish {
  my ($self) = @_;
  $self->{modulePortStatus} = unpack("H*", $self->{modulePortStatus});
}

sub check {
  my ($self) = @_;
  $self->add_info(sprintf 'module %d (serial %s) is %s',
      $self->{moduleIndex}, $self->{moduleSerialNumberString},
      $self->{moduleStatus}
  );
  if ($self->{moduleStatus} ne 'ok') {
    $self->add_critical();
  }
}

package Classes::Cisco::CISCOSTACKWISEMIB::Component::StackSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };


sub init {
  my ($self) = @_;
  $self->get_snmp_objects('CISCO-STACKWISE-MIB', qw(cswMaxSwitchNum
      cswRingRedundant ciscoStackWiseMIBConform cswStackWiseMIBCompliances
  ));
  $self->get_snmp_tables("CISCO-STACKWISE-MIB", [
      ['switches', 'cswSwitchInfoTable', 'Classes::Cisco::CISCOSTACKWISEMIB::Component::StackSubsystem::Switch'],
      ['ports', 'cswStackPortInfoTable', 'Classes::Cisco::CISCOSTACKWISEMIB::Component::StackSubsystem::Port'],
      #['powers', 'cswStackPowerInfoTable', 'Monitoring::GLPlugin::SNMP::TableItem'],
      #['powerports', 'cswStackPowerPortInfoTable', 'Monitoring::GLPlugin::SNMP::TableItem'],
  ]);
  $self->{numSwitches} = scalar(@{$self->{switches}});
  $self->{switchSerialList} = [map { $_->{flat_indices} } @{$self->{switches}}];
  $self->{numPorts} = scalar(@{$self->{ports}});
}

sub check {
  my ($self) = @_;
  foreach (@{$self->{switches}}) {
    $_->check();
  }
  $self->add_info(sprintf 'ring is %sredundant',
      $self->{cswRingRedundant} ne 'true' ? 'not ' : '');
  if ($self->{cswRingRedundant} ne 'true') {
      $self->add_warning();
  }
  $self->opts->override_opt('lookback', 1800) if ! $self->opts->lookback;
  $self->valdiff({name => 'stackwise', lastarray => 1},
      qw(switchSerialList numSwitches));
  if (scalar(@{$self->{delta_found_switchSerialList}}) > 0) {
    $self->add_warning(sprintf '%d new switch(s) (%s)',
        scalar(@{$self->{delta_found_switchSerialList}}),
        join(", ", @{$self->{delta_found_switchSerialList}}));
  }
  if (scalar(@{$self->{delta_lost_switchSerialList}}) > 0) {
    $self->add_critical(sprintf '%d switch(s) missing (%s)',
        scalar(@{$self->{delta_lost_switchSerialList}}),
        join(", ", @{$self->{delta_lost_switchSerialList}}));
  }
  if ($self->{delta_numPorts} > 0) {
    $self->add_warning(sprintf '%d new ports', $self->{delta_numPorts});
  } elsif ($self->{delta_numPorts} < 0) {
    $self->add_critical(sprintf '%d missing ports', abs($self->{delta_numPorts}));
  }
  if (! $self->check_messages()) {
    $self->add_ok('chassis is ok');
  }
  $self->add_info(sprintf 'found %d switches with %d ports',
      $self->{numSwitches}, $self->{numPorts});
  $self->add_ok();
}

package Classes::Cisco::CISCOSTACKWISEMIB::Component::StackSubsystem::Port;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

sub check {
  my ($self) = @_;
  $self->add_info(sprintf 'link to neighbor %s is %s',
      $self->{cswStackPortNeighbor}, $self->{cswStackPortOperStatus}
  );
}

package Classes::Cisco::CISCOSTACKWISEMIB::Component::StackSubsystem::Switch;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

sub check {
  my ($self) = @_;
  $self->add_info(sprintf '%s switch %s is %s',
      $self->{cswSwitchRole}, $self->{flat_indices}, $self->{cswSwitchState}
  );
  $self->add_warning() if $self->{cswSwitchState} ne 'ready';
}

package Classes::Cisco::ASA;
our @ISA = qw(Classes::Cisco);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Cisco::CISCOENTITYALARMMIB::Component::AlarmSubsystem");
    $self->analyze_and_check_environmental_subsystem("Classes::Cisco::CISCOENTITYSENSORMIB::Component::SensorSubsystem");
    $self->analyze_and_check_environmental_subsystem("Classes::ENTITYSENSORMIB::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Cisco::IOS::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Cisco::IOS::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::hsrp/) {
    $self->analyze_and_check_hsrp_subsystem("Classes::HSRP::Component::HSRPSubsystem");
  } elsif ($self->mode =~ /device::users/) {
    $self->analyze_and_check_connection_subsystem("Classes::Cisco::IOS::Component::ConnectionSubsystem");
  } elsif ($self->mode =~ /device::config/) {
    $self->analyze_and_check_config_subsystem("Classes::Cisco::IOS::Component::ConfigSubsystem");
  } elsif ($self->mode =~ /device::interfaces::nat::sessions::count/) {
    $self->analyze_and_check_config_subsystem("Classes::Cisco::IOS::Component::NatSubsystem");
  } elsif ($self->mode =~ /device::interfaces::nat::rejects/) {
    $self->analyze_and_check_config_subsystem("Classes::Cisco::IOS::Component::NatSubsystem");
  } elsif ($self->mode =~ /device::vpn::status/) {
    $self->analyze_and_check_config_subsystem("Classes::Cisco::CISCOIPSECFLOWMONITOR::Component::VpnSubsystem");
  } elsif ($self->mode =~ /device::ha::role/) {
    $self->analyze_and_check_config_subsystem("Classes::Cisco::IOS::Component::HaSubsystem");
  } else {
    $self->no_such_mode();
  }
}


package Classes::Cisco::IOS::Component::HaSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub init {
  my ($self) = @_;
  if ($self->mode =~ /device::ha::role/) {
    $self->get_snmp_tables("CISCO-FIREWALL-MIB", [
      ['resources', 'cfwHardwareStatusTable', 'Classes::Cisco::IOS::Component::HaSubsystem::Resource'],
    ]);
    if (! $self->opts->role()) {
      $self->opts->override_opt('role', 'active'); # active/standby
    }
  }
}


package Classes::Cisco::IOS::Component::HaSubsystem::Resource;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub finish {
  my ($self) = @_;
  ($self->{cfwHardwareInformationShort} = $self->{cfwHardwareInformation}) =~ s/\s*\(this device\).*//g;
  if ($self->{cfwHardwareInformation} =~ /Failover LAN Interface/) {
    bless $self, "Classes::Cisco::IOS::Component::HaSubsystem::Resource::LAN";
  } elsif ($self->{cfwHardwareInformation} =~ /Primary/) {
    bless $self, "Classes::Cisco::IOS::Component::HaSubsystem::Resource::Primary";
  } elsif ($self->{cfwHardwareInformation} =~ /Secondary/) {
    bless $self, "Classes::Cisco::IOS::Component::HaSubsystem::Resource::Secondary";
  }
}

package Classes::Cisco::IOS::Component::HaSubsystem::Resource::Primary;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my ($self) = @_;
  my @roles = split ',', $self->opts->role(); # active,standby for checking the cluster status
  $self->add_info(sprintf "resource %s has status %s (%s)", 
      $self->{cfwHardwareInformationShort},
      $self->{cfwHardwareStatusValue},
      $self->{cfwHardwareStatusDetail});
  if ($self->{cfwHardwareStatusDetail} eq "Failover Off") {
    $self->add_ok();
  } elsif ($self->{cfwHardwareInformation} =~ /this device/) {
    if (grep { "active" eq $_ } @roles) {
      $self->add_ok();
    } else {
      $self->add_critical();
      $self->add_info("this device should be ".$self->opts->role());
      $self->add_critical();
    }
  } else {
    # as seen from Secondary. check the cluster status, not the role
    if ($self->{cfwHardwareStatusValue} eq "error") {
      $self->add_critical_mitigation("Primary has failed");
    } elsif ($self->{cfwHardwareStatusValue} ne "active") {
      $self->add_warning_mitigation("Primary is not the active node");
    } else {
      $self->add_ok("Primary is active");
    }
  }
}

package Classes::Cisco::IOS::Component::HaSubsystem::Resource::Secondary;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my ($self) = @_;
  my @roles = split ',', $self->opts->role(); # active,standby for checking the cluster status
  $self->add_info(sprintf "resource %s has status %s (%s)", 
      $self->{cfwHardwareInformationShort},
      $self->{cfwHardwareStatusValue},
      $self->{cfwHardwareStatusDetail});
  if ($self->{cfwHardwareStatusDetail} eq "Failover Off") {
    $self->add_ok();
  } elsif ($self->{cfwHardwareInformation} =~ /this device/) {
    if (grep { "standby" eq $_ } @roles) {
      $self->add_ok();
    } else {
      $self->add_critical();
      $self->add_info("this device should be ".$self->opts->role());
      $self->add_critical();
    }
  } else {
    # as seen from primary
    if ($self->{cfwHardwareStatusValue} eq "error") {
      $self->add_critical_mitigation("Secondary has failed");
    } elsif ($self->{cfwHardwareStatusValue} ne "standby") {
      $self->add_warning_mitigation("Secondary is not the standby node");
    } else {
      $self->add_ok("Secondary is standby");
    }
  }
}

package Classes::Cisco::IOS::Component::HaSubsystem::Resource::LAN;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my ($self) = @_;
  $self->add_info(sprintf "resource %s has status %s (%s)", 
      $self->{cfwHardwareInformationShort},
      $self->{cfwHardwareStatusValue},
      $self->{cfwHardwareStatusDetail});
  if ($self->{cfwHardwareStatusDetail} eq "Failover Off") {
    $self->add_ok();
  } elsif ($self->{cfwHardwareStatusDetail} =~ /FAILOVER/) {
    $self->add_warning_mitigation("cluster has switched");
  } elsif ($self->{cfwHardwareStatusValue} eq "error") {
    $self->add_warning_mitigation("cluster has lost redundancy");
  } elsif ($self->{cfwHardwareStatusValue} ne "up") {
    $self->add_warning_mitigation("LAN interface has a problem");
  }
}


package Classes::Cisco::IOS::Component::ConfigSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub init {
  my $self = shift;
  $self->get_snmp_objects('CISCO-CONFIG-MAN-MIB', (qw(
      ccmHistoryRunningLastChanged ccmHistoryRunningLastSaved
      ccmHistoryStartupLastChanged)));
  foreach ((qw(ccmHistoryRunningLastChanged ccmHistoryRunningLastSaved
      ccmHistoryStartupLastChanged))) {
    if (! defined $self->{$_}) {
      $self->add_unknown(sprintf "%s is not defined", $_);
    }
    $self->{$_} = time - $self->uptime() + $self->timeticks($self->{$_});
  }
}

sub check {
  my $self = shift;
  my $info;
  my $runningChangedMarginAfterReload = 300;
  $self->add_info('checking config');
  if ($self->check_messages()) {
    return;
  }

  # Set default thresholds: Warning 1 hour, Critical 24 hours
  $self->set_thresholds(warning => 3600, critical => 3600*24);

  # How much is ccmHistoryRunningLastChanged ahead of ccmHistoryStartupLastChanged
  # Note: the saved config could still be identical to the running config.

  # ccmHistoryRunningLastChanged
  # ccmHistoryRunningLastSaved - saving is ANY write (local/remote storage, terminal)
  # ccmHistoryStartupLastChanged 
  my $runningUnchangedDuration = time - $self->{ccmHistoryRunningLastChanged};
  my $startupUnchangedDuration = time - $self->{ccmHistoryStartupLastChanged};

  # If running config has been changed after the startup config
  if ($runningUnchangedDuration < $startupUnchangedDuration) {
    # After a reload the running config is reported to be ahead of the startup config by a few seconds to possibly
    # a few minutes, while neither has been changed. Therefor a reload-margin is used.
    # If running config is reported to have changed within the (5 minute) margin since the last reload
    if (($runningUnchangedDuration + $runningChangedMarginAfterReload) > $self->uptime()) {
      $self->add_ok(sprintf("running config has not changed since reload (using a %d second margin)",
          $runningChangedMarginAfterReload));
    } else {
      # Running config is unsaved since $runningUnchangedDuration
      my $errorlevel = $self->check_thresholds($runningUnchangedDuration);

      if ($errorlevel != OK && defined $self->opts->mitigation()) {
        $errorlevel = $self->opts->mitigation();
      }

      $self->add_info(sprintf "running config is ahead of startup config since %d minutes. changes will be lost in case of a reboot",
          $runningUnchangedDuration / 60);
      $self->add_message($errorlevel);
    }
  } else {
    $self->add_ok("saved config is up to date");
  }
}

sub dump {
  my $self = shift;
  printf "[CONFIG]\n";
  foreach (qw(ccmHistoryRunningLastChanged ccmHistoryRunningLastSaved ccmHistoryStartupLastChanged)) {
    printf "%s: %s (%s)\n", $_, $self->{$_}, scalar localtime $self->{$_};
  }
}

package Classes::Cisco::IOS::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;
use constant PHYS_NAME => 1;
use constant PHYS_ASSET => 2;
use constant PHYS_DESCR => 4;

{
  our $cpmCPUTotalIndex = 0;
  our $uniquify = PHYS_NAME;
}

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCO-PROCESS-MIB', [
      ['cpus', 'cpmCPUTotalTable', 'Classes::Cisco::IOS::Component::CpuSubsystem::Cpu' ],
  ]);
  if (scalar(@{$self->{cpus}}) == 0) {
    # maybe too old. i fake a cpu. be careful. this is a really bad hack
    $self->get_snmp_objects('OLD-CISCO-CPU-MIB', qw(avgBusy1
        avgBusy5 busyPer
    ));
    if (defined $self->{avgBusy1}) {
      push(@{$self->{cpus}},
          Classes::Cisco::IOS::Component::CpuSubsystem::Cpu->new(
              cpmCPUTotalPhysicalIndex => 0, #fake
              cpmCPUTotalIndex => 0, #fake
              cpmCPUTotal5sec => 0, #fake
              cpmCPUTotal5secRev => 0, #fake
              cpmCPUTotal1min => $self->{avgBusy1},
              cpmCPUTotal1minRev => $self->{avgBusy1},
              cpmCPUTotal5min => $self->{avgBusy5},
              cpmCPUTotal5minRev => $self->{avgBusy51},
              cpmCPUMonInterval => 0, #fake
              cpmCPUTotalMonIntervalValue => 0, #fake
              cpmCPUInterruptMonIntervalValue => 0, #fake
      ));
    }
  }
  # same cpmCPUTotalPhysicalIndex found in multiple table rows
  if (scalar(@{$self->{cpus}}) > 1) {
    my %names = ();
    foreach my $cpu (@{$self->{cpus}}) {
      $names{$cpu->{name}}++;
    }
    foreach my $cpu (@{$self->{cpus}}) {
      if ($names{$cpu->{name}} > 1) {
        # more than one cpu points to the same physical entity
        $cpu->{name} .= '.'.$cpu->{flat_indices};
      }
    }
  }
}

package Classes::Cisco::IOS::Component::CpuSubsystem::Cpu;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{cpmCPUTotalIndex} = $self->{flat_indices};
  $self->{cpmCPUTotalPhysicalIndex} = exists $self->{cpmCPUTotalPhysicalIndex} ?
      $self->{cpmCPUTotalPhysicalIndex} : 0;
  if (exists $self->{cpmCPUTotal5minRev}) {
    $self->{usage} = $self->{cpmCPUTotal5minRev};
  } else {
    $self->{usage} = $self->{cpmCPUTotal5min};
  }
  $self->protect_value($self->{cpmCPUTotalIndex}.$self->{cpmCPUTotalPhysicalIndex}, 'usage', 'percent');
  if ($self->{cpmCPUTotalPhysicalIndex}) {
    $self->{entPhysicalName} = $self->get_snmp_object('ENTITY-MIB', 'entPhysicalName', $self->{cpmCPUTotalPhysicalIndex});
    # wichtig fuer gestacktes zeugs, bei dem entPhysicalName doppelt und mehr vorkommen kann
    # This object is a user-assigned asset tracking identifier for the physical entity
    # as specified by a network manager, and provides non-volatile storage of this
    # information. On the first instantiation of an physical entity, the value of
    # entPhysicalAssetID associated with that entity is set to the zero-length string.
    # ...
    # If write access is implemented for an instance of entPhysicalAssetID, and a value
    # is written into the instance, the agent must retain the supplied value in the
    # entPhysicalAssetID instance associated with the same physical entity for as long
    # as that entity remains instantiated. This includes instantiations across all
    # re-initializations/reboots of the network management system, including those
    # which result in a change of the physical entity's entPhysicalIndex value.
    $self->{entPhysicalAssetID} = $self->get_snmp_object('ENTITY-MIB', 'entPhysicalAssetID', $self->{cpmCPUTotalPhysicalIndex});
    $self->{entPhysicalDescr} = $self->get_snmp_object('ENTITY-MIB', 'entPhysicalDescr', $self->{cpmCPUTotalPhysicalIndex});
    $self->{name} = $self->{entPhysicalName} || $self->{entPhysicalDescr};
    # letzter Ausweg, weil auch alle drei get_snmp_object fehlschlagen koennen
    $self->{name} ||= $self->{cpmCPUTotalIndex};
  } else {
    $self->{name} = $self->{cpmCPUTotalIndex};
    # waere besser, aber dann zerlegts wohl zu viele rrdfiles
    #$self->{name} = 'central processor';
  }
  return $self;
}

sub check {
  my $self = shift;
  $self->{label} = $self->{name};
  $self->add_info(sprintf 'cpu %s usage (5 min avg.) is %.2f%%',
      $self->{name}, $self->{usage});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{usage}));
  $self->add_perfdata(
      label => 'cpu_'.$self->{label}.'_usage',
      value => $self->{usage},
      uom => '%',
  );
}

package Classes::Cisco::IOS::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  if ($self->implements_mib('CISCO-ENHANCED-MEMPOOL-MIB')) {
    $self->analyze_and_check_mem_subsystem("Classes::Cisco::CISCOENHANCEDMEMPOOLMIB::Component::MemSubsystem");
    if (! exists $self->{components}->{mem_subsystem} ||
        scalar(@{$self->{components}->{mem_subsystem}->{mems}}) == 0) {
      # satz mix x....
      # der hier: Cisco IOS Software, IOS-XE Software, Catalyst L3 Switch Software (CAT3K_CAA-UNIVERSALK9-M), Version 03.03.02SE RELEASE SOFTWARE (fc2)
      # hat nicht mehr zu bieten als eine einzige oid
      # cempMemBufferNotifyEnabled .1.3.6.1.4.1.9.9.221.1.2.1.0 = INTEGER: 2
      # deshalb:
      $self->analyze_and_check_mem_subsystem("Classes::Cisco::CISCOMEMORYPOOLMIB::Component::MemSubsystem");
    }
  } else {
    $self->analyze_and_check_mem_subsystem("Classes::Cisco::CISCOMEMORYPOOLMIB::Component::MemSubsystem");
  }
}

package Classes::Cisco::IOS::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  #
  # 1.3.6.1.4.1.9.9.13.1.1.0 ciscoEnvMonPresent (irgendein typ of envmon)
  # 
  $self->get_snmp_objects('CISCO-ENVMON-MIB', qw(
      ciscoEnvMonPresent));
  if (! $self->{ciscoEnvMonPresent}) {
    # gibt IOS-Kisten, die haben kein ciscoEnvMonPresent
    $self->{ciscoEnvMonPresent} = $self->implements_mib('CISCO-ENVMON-MIB');
  }
  if ($self->{ciscoEnvMonPresent} && 
      $self->{ciscoEnvMonPresent} ne 'oldAgs') {
    $self->{fan_subsystem} =
        Classes::Cisco::CISCOENVMONMIB::Component::FanSubsystem->new();
    $self->{temperature_subsystem} =
        Classes::Cisco::CISCOENVMONMIB::Component::TemperatureSubsystem->new();
    $self->{powersupply_subsystem} = 
        Classes::Cisco::CISCOENVMONMIB::Component::PowersupplySubsystem->new();
    $self->{voltage_subsystem} =
        Classes::Cisco::CISCOENVMONMIB::Component::VoltageSubsystem->new();
  } elsif ($self->implements_mib('CISCO-ENTITY-FRU-CONTROL-MIB')) {
    $self->{fru_subsystem} =
        Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::EnvironmentalSubsystem->new();
  } elsif ($self->implements_mib('CISCO-ENTITY-SENSOR-MIB')) {
    # (IOS can have ENVMON+ENTITY. Sensors are copies, so not needed)
    $self->{sensor_subsystem} =
        Classes::Cisco::CISCOENTITYSENSORMIB::Component::SensorSubsystem->new();
  } elsif ($self->get_snmp_object('MIB-2-MIB', 'sysDescr', 0) =~ /C1700 Software/) {
    $self->add_ok("environmental hardware working fine");
    $self->add_ok('soho device, hopefully too small to fail');
  } else {
    # last hope
    $self->analyze_and_check_environmental_subsystem("Classes::Cisco::CISCOENTITYALARMMIB::Component::AlarmSubsystem");
    #$self->no_such_mode();
  }
}

sub check {
  my $self = shift;
  if ($self->{ciscoEnvMonPresent} &&
      $self->{ciscoEnvMonPresent} ne 'oldAgs') {
    $self->{fan_subsystem}->check();
    $self->{temperature_subsystem}->check();
    $self->{voltage_subsystem}->check();
    $self->{powersupply_subsystem}->check();
  } elsif ($self->implements_mib('CISCO-ENTITY-FRU-CONTROL-MIB')) {
    $self->{fru_subsystem}->check();
  } elsif ($self->implements_mib('CISCO-ENTITY-SENSOR-MIB')) {
    $self->{sensor_subsystem}->check();
  }
  if (! $self->check_messages()) {
    $self->add_ok("environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  if ($self->{ciscoEnvMonPresent} &&
      $self->{ciscoEnvMonPresent} ne 'oldAgs') {
    $self->{fan_subsystem}->dump();
    $self->{temperature_subsystem}->dump();
    $self->{voltage_subsystem}->dump();
    $self->{powersupply_subsystem}->dump();
  } elsif ($self->implements_mib('CISCO-ENTITY-FRU-CONTROL-MIB')) {
    $self->{fru_subsystem}->dump();
  } elsif ($self->implements_mib('CISCO-ENTITY-SENSOR-MIB')) {
    $self->{sensor_subsystem}->dump();
  }
}

package Classes::Cisco::IOS::Component::ConnectionSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCO-FIREWALL-MIB', [
      ['connectionstates', 'cfwConnectionStatTable', 'Classes::Cisco::IOS::Component::ConnectionSubsystem::ConnectionState'],
  ]);
}

package Classes::Cisco::IOS::Component::ConnectionSubsystem::ConnectionState;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  if ($self->{cfwConnectionStatDescription} !~ /number of connections currently in use/i) {
    $self->add_blacklist(sprintf 'c:%s', $self->{cfwConnectionStatDescription});
    $self->add_info(sprintf '%d connections currently in use',
        $self->{cfwConnectionStatValue}||$self->{cfwConnectionStatCount}, $self->{usage});
  } else {
    $self->add_info(sprintf '%d connections currently in use',
        $self->{cfwConnectionStatValue}, $self->{usage});
    $self->set_thresholds(warning => 500000, critical => 750000);
    $self->add_message($self->check_thresholds($self->{cfwConnectionStatValue}));
    $self->add_perfdata(
        label => 'connections',
        value => $self->{cfwConnectionStatValue},
    );
  }
}

package Classes::Cisco::IOS::Component::NatSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::interfaces::nat::sessions::count/) { 
    $self->get_snmp_objects('CISCO-IETF-NAT-MIB', qw(
        cnatAddrBindNumberOfEntries cnatAddrPortBindNumberOfEntries
    ));
  } elsif ($self->mode =~ /device::interfaces::nat::rejects/) { 
    $self->get_snmp_tables('CISCO-IETF-NAT-MIB', [
        ['protocolstats', 'cnatProtocolStatsTable', 'Classes::Cisco::IOS::Component::NatSubsystem::CnatProtocolStats'],
    ]);
  }
}

sub check {
  my $self = shift;
  if ($self->mode =~ /device::interfaces::nat::sessions::count/) { 
    $self->add_info(sprintf '%d bind entries (%d addr, %d port)',
        $self->{cnatAddrBindNumberOfEntries} + $self->{cnatAddrPortBindNumberOfEntries},
        $self->{cnatAddrBindNumberOfEntries},
        $self->{cnatAddrPortBindNumberOfEntries}
    );
    $self->add_ok();
    $self->add_perfdata(
        label => 'nat_bindings',
        value => $self->{cnatAddrBindNumberOfEntries} + $self->{cnatAddrPortBindNumberOfEntries},
    );
    $self->add_perfdata(
        label => 'nat_addr_bindings',
        value => $self->{cnatAddrBindNumberOfEntries},
    );
    $self->add_perfdata(
        label => 'nat_port_bindings',
        value => $self->{cnatAddrPortBindNumberOfEntries},
    );
  } elsif ($self->mode =~ /device::interfaces::nat::rejects/) {
    foreach (@{$self->{protocolstats}}) {
      $_->check();
    }
  }
}

package Classes::Cisco::IOS::Component::NatSubsystem::CnatProtocolStats;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{cnatProtocolStatsName} = $self->{flat_indices};
  $self->make_symbolic('CISCO-IETF-NAT-MIB', 'cnatProtocolStatsName', $self->{cnatProtocolStatsName});
  $self->valdiff({name => $self->{cnatProtocolStatsName}},
      qw(cnatProtocolStatsInTranslate cnatProtocolStatsOutTranslate cnatProtocolStatsRejectCount));
  $self->{delta_cnatProtocolStatsTranslate} = 
      $self->{delta_cnatProtocolStatsInTranslate} +
      $self->{delta_cnatProtocolStatsOutTranslate};
  $self->{rejects} = $self->{delta_cnatProtocolStatsTranslate} ?
      (100 * $self->{delta_cnatProtocolStatsRejectCount} / 
      $self->{delta_cnatProtocolStatsTranslate}) : 0;
  $self->protect_value($self->{rejects}, 'rejects', 'percent');
}

sub check {
  my $self = shift;
  $self->add_info(sprintf '%.2f%% of all %s packets have been dropped/rejected',
      $self->{rejects}, $self->{cnatProtocolStatsName});
  $self->set_thresholds(warning => 30, critical => 50);
  $self->add_message($self->check_thresholds($self->{rejects}));
}

package Classes::Cisco::IOS::Component::BgpSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCO-BGP4-MIB', [
      ['peers', 'cbgpPeerAddrFamilyPrefixTable', 'Classes::Cisco::IOS::Component::BgpSubsystem::Peer', sub { return $self->filter_name(shift->{cbgpPeerRemoteAddr}) } ],
  ]);
}

sub check {
  my $self = shift;
  if ($self->mode =~ /prefix::count/) {
    if (scalar(@{$self->{peers}}) == 0) {
      $self->add_critical('no peers found');
    } else {
      $self->SUPER::check();
    }
  }
}

package Classes::Cisco::IOS::Component::BgpSubsystem::Peer;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{cbgpPeerAddrFamilyAfi} = pop @{$self->{indices}};
  $self->{cbgpPeerAddrFamilySafi} = pop @{$self->{indices}};
  $self->{cbgpPeerRemoteAddr} = join(".", @{$self->{indices}});
}

sub check {
  my $self = shift;
  if ($self->mode =~ /prefix::count/) {
    $self->add_info(sprintf "peer %s accepted %d prefixes", 
        $self->{cbgpPeerRemoteAddr}, $self->{cbgpPeerAddrAcceptedPrefixes});
    $self->set_thresholds(metric => $self->{cbgpPeerRemoteAddr}.'_accepted_prefixes',
        warning => '1:', critical => '1:');
    $self->add_message($self->check_thresholds(
        metric => $self->{cbgpPeerRemoteAddr}.'_accepted_prefixes',
        value => $self->{cbgpPeerAddrAcceptedPrefixes}));
    $self->add_perfdata(
        label => $self->{cbgpPeerRemoteAddr}.'_accepted_prefixes',
        value => $self->{cbgpPeerAddrAcceptedPrefixes},
    );
  }
}
package Classes::Cisco::IOS;
our @ISA = qw(Classes::Cisco);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::chassis::health/) {
    if ($self->implements_mib('CISCO-STACK-MIB')) {
      $self->analyze_and_check_environmental_subsystem("Classes::Cisco::CISCOSTACKMIB::Component::StackSubsystem");
    } elsif ($self->implements_mib('CISCO-STACKWISE-MIB')) {
      $self->analyze_and_check_environmental_subsystem("Classes::Cisco::CISCOSTACKWISEMIB::Component::StackSubsystem");
    }
    if (! $self->implements_mib('CISCO-STACKWISE-MIB') &&
        !  $self->implements_mib('CISCO-STACK-MIB')) {
      if (defined $self->opts->mitigation()) {
        $self->add_message($self->opts->mitigation(), 'this is not a stacked device');
      } else {
        $self->add_unknown('this is not a stacked device');
      }
    }
  } elsif ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Cisco::IOS::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Cisco::IOS::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Cisco::IOS::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::hsrp/) {
    $self->analyze_and_check_hsrp_subsystem("Classes::HSRP::Component::HSRPSubsystem");
  } elsif ($self->mode =~ /device::users/) {
    $self->analyze_and_check_connection_subsystem("Classes::Cisco::IOS::Component::ConnectionSubsystem");
  } elsif ($self->mode =~ /device::config/) {
    $self->analyze_and_check_config_subsystem("Classes::Cisco::IOS::Component::ConfigSubsystem");
  } elsif ($self->mode =~ /device::interfaces::nat::sessions::count/) {
    $self->analyze_and_check_config_subsystem("Classes::Cisco::IOS::Component::NatSubsystem");
  } elsif ($self->mode =~ /device::interfaces::nat::rejects/) {
    $self->analyze_and_check_config_subsystem("Classes::Cisco::IOS::Component::NatSubsystem");
  } elsif ($self->mode =~ /device::bgp::prefix::count/) {
    $self->analyze_and_check_config_subsystem("Classes::Cisco::IOS::Component::BgpSubsystem");
  } else {
    $self->no_such_mode();
  }
}


package Classes::Cisco::NXOS::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

{
  our $cpmCPUTotalIndex = 0;
}

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCO-PROCESS-MIB', [
      ['cpus', 'cpmCPUTotalTable', 'Classes::Cisco::NXOS::Component::CpuSubsystem::Cpu' ],
  ]);
  if (scalar(@{$self->{cpus}}) == 0) {
    # maybe too old. i fake a cpu. be careful. this is a really bad hack
    my $response = $self->get_request(
        -varbindlist => [
            $Classes::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy1},
            $Classes::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy5},
            $Classes::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{busyPer},
        ]
    );
    if (exists $response->{$Classes::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy1}}) {
      push(@{$self->{cpus}},
          Classes::Cisco::NXOS::Component::CpuSubsystem::Cpu->new(
              cpmCPUTotalPhysicalIndex => 0, #fake
              cpmCPUTotalIndex => 0, #fake
              cpmCPUTotal5sec => 0, #fake
              cpmCPUTotal5secRev => 0, #fake
              cpmCPUTotal1min => $response->{$Classes::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy1}},
              cpmCPUTotal1minRev => $response->{$Classes::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy1}},
              cpmCPUTotal5min => $response->{$Classes::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy5}},
              cpmCPUTotal5minRev => $response->{$Classes::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy5}},
              cpmCPUMonInterval => 0, #fake
              cpmCPUTotalMonIntervalValue => 0, #fake
              cpmCPUInterruptMonIntervalValue => 0, #fake
      ));
    }
  }
}

package Classes::Cisco::NXOS::Component::CpuSubsystem::Cpu;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{cpmCPUTotalIndex} = exists $self->{cpmCPUTotalIndex} ?
      $self->{cpmCPUTotalIndex} :
      $Classes::Cisco::NXOS::Component::CpuSubsystem::cpmCPUTotalIndex++;
  $self->{cpmCPUTotalPhysicalIndex} = exists $self->{cpmCPUTotalPhysicalIndex} ? 
      $self->{cpmCPUTotalPhysicalIndex} : 0;
  if (exists $self->{cpmCPUTotal5minRev}) {
    $self->{usage} = $self->{cpmCPUTotal5minRev};
  } else {
    $self->{usage} = $self->{cpmCPUTotal5min};
  }
  $self->protect_value($self->{cpmCPUTotalIndex}.$self->{cpmCPUTotalPhysicalIndex}, 'usage', 'percent');
  if ($self->{cpmCPUTotalPhysicalIndex}) {
    $self->{entPhysicalName} = $self->get_snmp_object('ENTITY-MIB', 'entPhysicalName', $self->{cpmCPUTotalPhysicalIndex});
    # This object is a user-assigned asset tracking identifier for the physical entity
    # as specified by a network manager, and provides non-volatile storage of this 
    # information. On the first instantiation of an physical entity, the value of
    # entPhysicalAssetID associated with that entity is set to the zero-length string.
    # ...
    # If write access is implemented for an instance of entPhysicalAssetID, and a value
    # is written into the instance, the agent must retain the supplied value in the
    # entPhysicalAssetID instance associated with the same physical entity for as long
    # as that entity remains instantiated. This includes instantiations across all 
    # re-initializations/reboots of the network management system, including those
    # which result in a change of the physical entity's entPhysicalIndex value.
    $self->{entPhysicalAssetID} = $self->get_snmp_object('ENTITY-MIB', 'entPhysicalAssetID', $self->{cpmCPUTotalPhysicalIndex});
    $self->{name} = $self->{entPhysicalName};
    $self->{name} .= ' '.$self->{entPhysicalAssetID} if $self->{entPhysicalAssetID};
    $self->{label} = $self->{entPhysicalName};
    $self->{label} .= ' '.$self->{entPhysicalAssetID} if $self->{entPhysicalAssetID};
  } else {
    $self->{name} = $self->{cpmCPUTotalIndex};
    $self->{label} = $self->{cpmCPUTotalIndex};
  }
  return $self;
}

sub check {
  my $self = shift;
  $self->add_info(sprintf 'cpu %s usage (5 min avg.) is %.2f%%',
      $self->{name}, $self->{usage});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{usage}));
  $self->add_perfdata(
      label => 'cpu_'.$self->{label}.'_usage',
      value => $self->{usage},
      uom => '%',
  );
}


package Classes::Cisco::NXOS::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('CISCO-SYSTEM-EXT-MIB', (qw(
      cseSysMemoryUtilization)));
}

sub check {
  my $self = shift;
  $self->add_info('checking memory');
  if (defined $self->{cseSysMemoryUtilization}) {
    $self->add_info(sprintf 'memory usage is %.2f%%',
        $self->{cseSysMemoryUtilization});
    $self->set_thresholds(warning => 80, critical => 90);
    $self->add_message($self->check_thresholds($self->{cseSysMemoryUtilization}));
    $self->add_perfdata(
        label => 'memory_usage',
        value => $self->{cseSysMemoryUtilization},
        uom => '%',
    );
  } else {
    $self->add_unknown('cannot aquire memory usage');
  }
}


package Classes::Cisco::NXOS::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{sensor_subsystem} =
      Classes::Cisco::CISCOENTITYSENSORMIB::Component::SensorSubsystem->new();
  if ($self->implements_mib('CISCO-ENTITY-FRU-CONTROL-MIB')) {
    $self->{fru_subsystem} = Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::EnvironmentalSubsystem->new();
  }
}

sub check {
  my $self = shift;
  $self->{sensor_subsystem}->check();
  if (exists $self->{fru_subsystem}) {
    $self->{fru_subsystem}->check();
  }
  if (! $self->check_messages()) {
    $self->clear_ok();
    $self->add_ok("environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{sensor_subsystem}->dump();
  if (exists $self->{fru_subsystem}) {
    $self->{fru_subsystem}->dump();
  }
}

package Classes::Cisco::NXOS::Component::FexSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCO-ETHERNET-FABRIC-EXTENDER-MIB', [
    ['fexes', 'cefexConfigTable', 'Classes::Cisco::NXOS::Component::FexSubsystem::Fex'],
  ]);
  if (scalar (@{$self->{fexes}}) == 0) {
   # fallback
    $self->get_snmp_tables('ENTITY-MIB', [
      ['fexes', 'entPhysicalTable', 'Classes::Cisco::NXOS::Component::FexSubsystem::Fex'],
    ]);
    @{$self->{fexes}} = grep {
        $_->{entPhysicalClass} eq 'chassis' && $_->{entPhysicalDescr} =~ /fex/i; 
    } @{$self->{fexes}};
    if (scalar (@{$self->{fexes}}) == 0) {
      $self->get_snmp_tables('ENTITY-MIB', [
        ['fexes', 'entPhysicalTable', 'Classes::Cisco::NXOS::Component::FexSubsystem::Fex'],
      ]);
      # fallback
      my $known_fexes = {};
      @{$self->{fexes}} = grep {
        ! $known_fexes->{$_->{cefexConfigExtenderName}}++;
      } grep {
          $_->{entPhysicalClass} eq 'other' && $_->{entPhysicalDescr} =~ /fex.*cable/i; 
      } @{$self->{fexes}};
    }
  }
}

sub dump {
  my $self = shift;
  foreach (@{$self->{fexes}}) {
    $_->dump();
  }
}

sub check {
  my $self = shift;
  $self->add_info('counting fexes');
  $self->{numOfFexes} = scalar (@{$self->{fexes}});
  $self->{fexNameList} = [map { $_->{cefexConfigExtenderName} } @{$self->{fexes}}];
  if (scalar (@{$self->{fexes}}) == 0) {
    $self->add_unknown('no FEXes found');
  } else {
    # lookback, denn sonst muesste der check is_volatile sein und koennte bei
    # einem kurzen netzausfall fehler schmeissen.
    # empfehlung: check_interval 5 (muss jedesmal die entity-mib durchwalken)
    #             retry_interval 2
    #             max_check_attempts 2
    # --lookback 360
    $self->opts->override_opt('lookback', 1800) if ! $self->opts->lookback;
    $self->valdiff({name => $self->{name}, lastarray => 1},
        qw(fexNameList numOfFexes));
    if (scalar(@{$self->{delta_found_fexNameList}}) > 0) {
      $self->add_warning(sprintf '%d new FEX(es) (%s)',
          scalar(@{$self->{delta_found_fexNameList}}),
          join(", ", @{$self->{delta_found_fexNameList}}));
    }
    if (scalar(@{$self->{delta_lost_fexNameList}}) > 0) {
      $self->add_critical(sprintf '%d FEXes missing (%s)',
          scalar(@{$self->{delta_lost_fexNameList}}),
          join(", ", @{$self->{delta_lost_fexNameList}}));
    }
    $self->add_ok(sprintf 'found %d FEXes', scalar (@{$self->{fexes}}));
    $self->add_perfdata(
        label => 'num_fexes',
        value => $self->{numOfFexes},
    );
  }
}


package Classes::Cisco::NXOS::Component::FexSubsystem::Fex;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{original_cefexConfigExtenderName} = $self->{cefexConfigExtenderName};
  if (exists $self->{entPhysicalClass}) {
    # stammt aus ENTITY-MIB
    if ($self->{entPhysicalDescr} =~ /^FEX[^\d]*(\d+)/i) {
      $self->{cefexConfigExtenderName} = "FEX".$1;
    } else {
      $self->{cefexConfigExtenderName} = $self->{entPhysicalDescr};
    }
  } else {
    # stammt aus CISCO-ETHERNET-FABRIC-EXTENDER-MIB, kann FEX101-J8-VT04.01 heissen
    if ($self->{cefexConfigExtenderName} =~ /^FEX[^\d]*(\d+)/i) {
      $self->{cefexConfigExtenderName} = "FEX".$1;
    }
  }
}

package Classes::Cisco::NXOS;
our @ISA = qw(Classes::Cisco);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->mult_snmp_max_msg_size(10);
    $self->analyze_and_check_environmental_subsystem("Classes::Cisco::NXOS::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::cisco::fex::watch/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Cisco::NXOS::Component::FexSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Cisco::IOS::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Cisco::NXOS::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::config/) {
    $self->analyze_and_check_config_subsystem("Classes::Cisco::IOS::Component::ConfigSubsystem");
  } elsif ($self->mode =~ /device::hsrp/) {
    $self->analyze_and_check_hsrp_subsystem("Classes::HSRP::Component::HSRPSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Cisco::WLC::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('AIRESPACE-SWITCHING-MIB', (qw(
      agentTotalMemory agentFreeMemory)));
  $self->{memory_usage} = $self->{agentFreeMemory} ? 
      ( ($self->{agentTotalMemory} - $self->{agentFreeMemory}) / $self->{agentTotalMemory} * 100) : 100;
}

sub check {
  my $self = shift;
  $self->add_info(sprintf 'memory usage is %.2f%%',
      $self->{memory_usage});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{memory_usage}));
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{memory_usage},
      uom => '%',
  );
}

package Classes::Cisco::WLC::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  my $type = 0;
  $self->get_snmp_objects('AIRESPACE-SWITCHING-MIB', (qw(
      agentCurrentCPUUtilization)));
}

sub check {
  my $self = shift;
  $self->add_info(sprintf 'cpu usage is %.2f%%',
      $self->{agentCurrentCPUUtilization});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{agentCurrentCPUUtilization}));
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{agentCurrentCPUUtilization},
      uom => '%',
  );
}

package Classes::Cisco::WLC::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{ps1_present} = $self->get_snmp_object(
      'AIRESPACE-SWITCHING-MIB', 'agentSwitchInfoPowerSupply1Present', 0);
  $self->{ps1_operational} = $self->get_snmp_object(
      'AIRESPACE-SWITCHING-MIB', 'agentSwitchInfoPowerSupply1Operational', 0);
  $self->{ps2_present} = $self->get_snmp_object(
      'AIRESPACE-SWITCHING-MIB', 'agentSwitchInfoPowerSupply2Present', 0);
  $self->{ps2_operational} = $self->get_snmp_object(
      'AIRESPACE-SWITCHING-MIB', 'agentSwitchInfoPowerSupply2Operational', 0);
  $self->{temp_environment} = $self->get_snmp_object(
      'AIRESPACE-WIRELESS-MIB', 'bsnOperatingTemperatureEnvironment', 0);
  $self->{temp_value} = $self->get_snmp_object(
      'AIRESPACE-WIRELESS-MIB', 'bsnSensorTemperature', 0);
  $self->{temp_alarm_low} = $self->get_snmp_object(
      'AIRESPACE-WIRELESS-MIB', 'bsnTemperatureAlarmLowLimit', 0);
  $self->{temp_alarm_high} = $self->get_snmp_object(
      'AIRESPACE-WIRELESS-MIB', 'bsnTemperatureAlarmHighLimit', 0);
}

sub check {
  my $self = shift;
  #$self->blacklist('t', $self->{cpmCPUTotalPhysicalIndex});
  my $tinfo = sprintf 'temperature is %.2fC (%s env %s-%s)',
      $self->{temp_value}, $self->{temp_environment},
      $self->{temp_alarm_low}, $self->{temp_alarm_high};
  $self->set_thresholds(
      warning => $self->{temp_alarm_low}.':'.$self->{temp_alarm_high},
      critical => $self->{temp_alarm_low}.':'.$self->{temp_alarm_high});
  $self->add_message($self->check_thresholds($self->{temp_value}), $tinfo);
  $self->add_perfdata(
      label => 'temperature',
      value => $self->{temp_value},
  );
  if ($self->{ps1_present} eq "true") {
    if ($self->{ps1_operational} ne "true") {
      $self->add_warning("Powersupply 1 is not operational");
    }
  }
  if ($self->{ps2_present} eq "true") {
    if ($self->{ps2_operational} ne "true") {
      $self->add_warning("Powersupply 2 is not operational");
    }
  }
  my $p1info = sprintf "PS1 is %spresent and %soperational",
      $self->{ps1_present} eq "true" ? "" : "not ",
      $self->{ps1_operational} eq "true" ? "" : "not ";
  my $p2info = sprintf "PS2 is %spresent and %soperational",
      $self->{ps2_present} eq "true" ? "" : "not ",
      $self->{ps2_operational} eq "true" ? "" : "not ";
  $self->add_info($tinfo.", ".$p1info.", ".$p2info);
}

sub dump {
  my $self = shift;
  printf "[TEMPERATURE]\n";
  foreach (qw(temp_environment temp_value temp_alarm_low temp_alarm_high)) {
    if (exists $self->{$_}) {
      printf "%s: %s\n", $_, $self->{$_};
    }
  }
  printf "[PS1]\n";
  foreach (qw(ps1_present ps1_operational)) {
    if (exists $self->{$_}) {
      printf "%s: %s\n", $_, $self->{$_};
    }
  }
  printf "[PS2]\n";
  foreach (qw(ps2_present ps2_operational)) {
    if (exists $self->{$_}) {
      printf "%s: %s\n", $_, $self->{$_};
    }
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package Classes::Cisco::WLC::Component::WlanSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::wlan::aps::clients/) {
    $self->get_snmp_tables('AIRESPACE-WIRELESS-MIB', [
        ['mobilestations', 'bsnMobileStationTable', 'Classes::Cisco::WLC::Component::WlanSubsystem::MobileStation', sub { return $self->filter_name(shift->{bsnMobileStationSsid}) } ],
    ]);
  } else {
    $self->{name} = $self->get_snmp_object('MIB-2-MIB', 'sysName', 0);
    $self->get_snmp_tables('AIRESPACE-WIRELESS-MIB', [
        ['aps', 'bsnAPTable', 'Classes::Cisco::WLC::Component::WlanSubsystem::AP', sub { return $self->filter_name(shift->{bsnAPName}) } ],
        ['ifs', 'bsnAPIfTable', 'Classes::Cisco::WLC::Component::WlanSubsystem::AP' ],
        ['ifloads', 'bsnAPIfLoadParametersTable', 'Classes::Cisco::WLC::Component::WlanSubsystem::IFLoad' ],
    ]);
    $self->assign_loads_to_ifs();
    $self->assign_ifs_to_aps();
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking access points');
  if ($self->mode =~ /device::wlan::aps::clients/) {
    my $ssids = {};
    map { $ssids->{$_->{bsnMobileStationSsid}} += 1 } @{$self->{mobilestations}};
    foreach my $ssid (sort keys %{$ssids}) {
      $self->set_thresholds(metric => $ssid.'_clients',
          warning => '0:', critical => ':0');
      $self->add_message($self->check_thresholds(metric => $ssid.'_clients',
          value => $ssids->{$ssid}),
          sprintf 'SSID %s has %d clients',
          $ssid, $ssids->{$ssid});
      $self->add_perfdata(label => $ssid.'_clients',
          value => $ssids->{$ssid});
    }
  } else {
    $self->{numOfAPs} = scalar (@{$self->{aps}});
    $self->{apNameList} = [map { $_->{bsnAPName} } @{$self->{aps}}];
    if (scalar (@{$self->{aps}}) == 0) {
      $self->add_unknown('no access points found');
      return;
    }
    foreach (@{$self->{aps}}) {
      $_->check();
    }
    if ($self->mode =~ /device::wlan::aps::watch/) {
      $self->opts->override_opt('lookback', 1800) if ! $self->opts->lookback;
      $self->valdiff({name => $self->{name}, lastarray => 1},
          qw(apNameList numOfAPs));
      if (scalar(@{$self->{delta_found_apNameList}}) > 0) {
      #if (scalar(@{$self->{delta_found_apNameList}}) > 0 &&
      #    $self->{delta_timestamp} > $self->opts->lookback) {
        $self->add_warning(sprintf '%d new access points (%s)',
            scalar(@{$self->{delta_found_apNameList}}),
            join(", ", @{$self->{delta_found_apNameList}}));
      }
      if (scalar(@{$self->{delta_lost_apNameList}}) > 0) {
        $self->add_critical(sprintf '%d access points missing (%s)',
            scalar(@{$self->{delta_lost_apNameList}}),
            join(", ", @{$self->{delta_lost_apNameList}}));
      }
      $self->add_ok(sprintf 'found %d access points', scalar (@{$self->{aps}}));
      $self->add_perfdata(
          label => 'num_aps',
          value => scalar (@{$self->{aps}}),
      );
    } elsif ($self->mode =~ /device::wlan::aps::count/) {
      $self->set_thresholds(warning => '10:', critical => '5:');
      $self->add_message($self->check_thresholds(
          scalar (@{$self->{aps}})), 
          sprintf 'found %d access points', scalar (@{$self->{aps}}));
      $self->add_perfdata(
          label => 'num_aps',
          value => scalar (@{$self->{aps}}),
      );
    } elsif ($self->mode =~ /device::wlan::aps::status/) {
      if ($self->opts->report eq "short") {
        $self->clear_ok();
        $self->add_ok('no problems') if ! $self->check_messages();
      }
    } elsif ($self->mode =~ /device::wlan::aps::list/) {
      foreach (@{$self->{aps}}) {
        printf "%s\n", $_->{bsnAPName};
      }
    }
  }
}

sub assign_ifs_to_aps {
  my $self = shift;
  foreach my $ap (@{$self->{aps}}) {
    $ap->{interfaces} = [];
    foreach my $if (@{$self->{ifs}}) {
      if ($if->{flat_indices} eq $ap->{bsnAPDot3MacAddress}.".".$if->{bsnAPIfSlotId}) {
        push(@{$ap->{interfaces}}, $if);
      }
    }
    $ap->{NumOfClients} = 0;
    map {$ap->{NumOfClients} += $_->{bsnAPIfLoadNumOfClients} }
        @{$ap->{interfaces}};
  }
}

sub assign_loads_to_ifs {
  my $self = shift;
  foreach my $if (@{$self->{ifs}}) {
    foreach my $load (@{$self->{ifloads}}) {
      if ($load->{flat_indices} eq $if->{flat_indices}) {
        map { $if->{$_} = $load->{$_} } grep { $_ !~ /indices/ } keys %{$load};
      }
    }
  }
}


package Classes::Cisco::WLC::Component::WlanSubsystem::IF;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;


package Classes::Cisco::WLC::Component::WlanSubsystem::IFLoad;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;


package Classes::Cisco::WLC::Component::WlanSubsystem::AP;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  if ($self->{bsnAPDot3MacAddress} && $self->{bsnAPDot3MacAddress} =~ /0x(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})/) {
    $self->{bsnAPDot3MacAddress} = join(".", map { hex($_) } ($1, $2, $3, $4, $5, $6));
  } elsif ($self->{bsnAPDot3MacAddress} && unpack("H12", $self->{bsnAPDot3MacAddress}) =~ /(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})/) {
    $self->{bsnAPDot3MacAddress} = join(".", map { hex($_) } ($1, $2, $3, $4, $5, $6));
  }
}

sub check {
  my $self = shift;
  $self->add_info(sprintf 'access point %s is %s (%d interfaces with %d clients)',
      $self->{bsnAPName}, $self->{bsnAPOperationStatus},
      scalar(@{$self->{interfaces}}), $self->{NumOfClients});
  if ($self->mode =~ /device::wlan::aps::status/) {
    if ($self->{bsnAPOperationStatus} eq 'disassociating') {
      $self->add_critical();
    } elsif ($self->{bsnAPOperationStatus} eq 'downloading') {
      # das verschwindet hoffentlich noch vor dem HARD-state
      $self->add_warning();
    } elsif ($self->{bsnAPOperationStatus} eq 'associated') {
      $self->add_ok();
    } else {
      $self->add_unknown();
    }
  }
}

package Classes::Cisco::WLC::Component::WlanSubsystem::MobileStation;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{bsnMobileStationMacAddress} = 
      $self->unhex_mac($self->{bsnMobileStationMacAddress});
}
package Classes::Cisco::WLC;
our @ISA = qw(Classes::Cisco);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Cisco::WLC::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Cisco::WLC::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Cisco::WLC::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::wlan/) {
    $self->analyze_and_check_wlan_subsystem("Classes::Cisco::WLC::Component::WlanSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Cisco::PrimeNCS;
our @ISA = qw(Classes::Cisco);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    #$self->analyze_and_check_environmental_subsystem("Classes::Cisco::CISCOENTITYFRUCONTROLMIB::Component::EnvironmentalSubsystem");
    $self->analyze_and_check_environmental_subsystem("Classes::HOSTRESOURCESMIB::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::HOSTRESOURCESMIB::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::HOSTRESOURCESMIB::Component::MemSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Cisco::UCOS;
our @ISA = qw(Classes::Cisco);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::HOSTRESOURCESMIB::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::HOSTRESOURCESMIB::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::HOSTRESOURCESMIB::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::phone::cm/) {
    $self->analyze_and_check_cm_subsystem("Classes::Cisco::CCM::Component::CmSubsystem");
  } elsif ($self->mode =~ /device::phone/) {
    $self->analyze_and_check_phone_subsystem("Classes::Cisco::CCM::Component::PhoneSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Cisco::CCM::Component::PhoneSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('CISCO-CCM-MIB', (qw(
      ccmRegisteredPhones ccmUnregisteredPhones ccmRejectedPhones)));
  if (! defined $self->{ccmRegisteredPhones}) {
    $self->get_snmp_tables('CISCO-CCM-MIB', [
        ['ccms', 'ccmTable', 'Classes::Cisco::CCM::Component::CmSubsystem::Cm'],
    ]);
  }
}

sub check {
  my $self = shift;
  if (! defined $self->{ccmRegisteredPhones}) {
    foreach (qw(ccmRegisteredPhones ccmUnregisteredPhones ccmRejectedPhones)) {
      $self->{$_} = 0;
    }
    if (! scalar(@{$self->{ccms}})) {
      $self->add_ok('cm is down');
    } else {
      $self->add_unknown('unable to count phones');
    }
  }
  $self->add_info(sprintf 'phones: %d registered, %d unregistered, %d rejected',
      $self->{ccmRegisteredPhones},
      $self->{ccmUnregisteredPhones},
      $self->{ccmRejectedPhones});
  $self->set_thresholds(warning => 10, critical => 20);
  $self->add_message($self->check_thresholds($self->{ccmRejectedPhones}));
  $self->add_perfdata(
      label => 'registered',
      value => $self->{ccmRegisteredPhones},
  );
  $self->add_perfdata(
      label => 'unregistered',
      value => $self->{ccmUnregisteredPhones},
  );
  $self->add_perfdata(
      label => 'rejected',
      value => $self->{ccmRejectedPhones},
  );
}

package Classes::Cisco::CCM::Component::CmSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCO-CCM-MIB', [
      ['ccms', 'ccmTable', 'Classes::Cisco::CCM::Component::CmSubsystem::Cm'],
  ]);
}

sub check {
  my $self = shift;
  foreach (@{$self->{ccms}}) {
    $_->check();
  }
  if (! scalar(@{$self->{ccms}})) {
    $self->add_message(
        defined $self->opts->mitigation() ? $self->opts->mitigation() : 2,
        'local callmanager is down');
  }
}


package Classes::Cisco::CCM::Component::CmSubsystem::Cm;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub check {
  my $self = shift;
  $self->add_info(sprintf 'cm %s is %s',
      $self->{ccmName},
      $self->{ccmStatus});
  $self->add_message($self->{ccmStatus} eq 'up' ? OK : CRITICAL);
}

package Classes::Cisco::CCM;
our @ISA = qw(Classes::Cisco);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::HOSTRESOURCESMIB::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::HOSTRESOURCESMIB::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::HOSTRESOURCESMIB::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::phone::cm/) {
    $self->analyze_and_check_cm_subsystem("Classes::Cisco::CCM::Component::CmSubsystem");
  } elsif ($self->mode =~ /device::phone/) {
    $self->analyze_and_check_phone_subsystem("Classes::Cisco::CCM::Component::PhoneSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Cisco::AsyncOS::Component::KeySubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('ASYNCOS-MAIL-MIB', [
      ['keys', 'keyExpirationTable', 'Classes::Cisco::AsyncOS::Component::KeySubsystem::Key'],
  ]);
}

package Classes::Cisco::AsyncOS::Component::KeySubsystem::Key;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->{keyDaysUntilExpire} = int($self->{keySecondsUntilExpire} / 86400);
  if ($self->{keyIsPerpetual} eq 'true') {
    $self->add_info(sprintf 'perpetual key %d (%s) never expires',
        $self->{keyExpirationIndex},
        $self->{keyDescription});
    $self->add_ok();
  } else {
    $self->add_info(sprintf 'key %d (%s) expires in %d days',
        $self->{keyExpirationIndex},
        $self->{keyDescription},
        $self->{keyDaysUntilExpire});
    $self->set_thresholds(warning => '14:', critical => '7:');
    $self->add_message($self->check_thresholds($self->{keyDaysUntilExpire}));
  }
  $self->{keyDescription} =~ s/Ironport//gi;
  $self->{keyDescription} =~ s/^ //;
  $self->{keyDescription} =~ s/ /_/g;
  $self->add_perfdata(
      label => sprintf('lifetime_%s', $self->{keyDescription}),
      value => $self->{keyDaysUntilExpire},
      thresholds => $self->{keyIsPerpetual} eq 'true' ? 0 : 1,
  );
}

package Classes::Cisco::AsyncOS::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('ASYNCOS-MAIL-MIB', (qw(
      perCentMemoryUtilization memoryAvailabilityStatus)));
}

sub check {
  my $self = shift;
  $self->add_info('checking memory');
  $self->add_info(sprintf 'memory usage is %.2f%% (%s)',
      $self->{perCentMemoryUtilization}, $self->{memoryAvailabilityStatus});
  $self->set_thresholds(warning => 80, critical => 90);
  if ($self->check_thresholds($self->{perCentMemoryUtilization})) {
    $self->add_message($self->check_thresholds($self->{perCentMemoryUtilization}));
  } elsif ($self->{memoryAvailabilityStatus} eq 'memoryShortage') {
    $self->add_warning();
    $self->set_thresholds(warning => $self->{perCentMemoryUtilization}, critical => 90);
  } elsif ($self->{memoryAvailabilityStatus} eq 'memoryFull') {
    $self->add_critical();
    $self->set_thresholds(warning => 80, critical => $self->{perCentMemoryUtilization});
  } else {
    $self->add_ok();
  }
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{perCentMemoryUtilization},
      uom => '%',
  );
}

package Classes::Cisco::AsyncOS::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('ASYNCOS-MAIL-MIB', (qw(
      perCentCPUUtilization)));
}

sub check {
  my $self = shift;
  $self->add_info('checking cpus');
  $self->add_info(sprintf 'cpu usage is %.2f%%',
      $self->{perCentCPUUtilization});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{perCentCPUUtilization}));
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{perCentCPUUtilization},
      uom => '%',
  );
}

package Classes::Cisco::AsyncOS::Component::TemperatureSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('ASYNCOS-MAIL-MIB', [
      ['temperatures', 'temperatureTable', 'Classes::Cisco::AsyncOS::Component::TemperatureSubsystem::Temperature'],
  ]);
}

package Classes::Cisco::AsyncOS::Component::TemperatureSubsystem::Temperature;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->set_thresholds(warning => 60, critical => 70);
  $self->add_info(sprintf 'temperature %d (%s) is %s degree C',
        $self->{temperatureIndex},
        $self->{temperatureName},
        $self->{degreesCelsius});
  if ($self->check_thresholds($self->{degreesCelsius})) {
    $self->add_message($self->check_thresholds($self->{degreesCelsius}),
        $self->{info});
  }
  $self->add_perfdata(
      label => sprintf('temp_%s', $self->{temperatureIndex}),
      value => $self->{degreesCelsius},
  );
}

package Classes::Cisco::AsyncOS::Component::PowersupplySubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('ASYNCOS-MAIL-MIB', [
      ['supplies', 'powerSupplyTable', 'Classes::Cisco::AsyncOS::Component::PowersupplySubsystem::Powersupply'],
  ]);
}

package Classes::Cisco::AsyncOS::Component::PowersupplySubsystem::Powersupply;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'powersupply %d (%s) has status %s',
      $self->{powerSupplyIndex},
      $self->{powerSupplyName},
      $self->{powerSupplyStatus});
  if ($self->{powerSupplyStatus} eq 'powerSupplyNotInstalled') {
  } elsif ($self->{powerSupplyStatus} ne 'powerSupplyHealthy') {
    $self->add_critical();
  }
}

package Classes::Cisco::AsyncOS::Component::FanSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('ASYNCOS-MAIL-MIB', [
      ['fans', 'fanTable', 'Classes::Cisco::AsyncOS::Component::FanSubsystem::Fan'],
  ]);
}

package Classes::Cisco::AsyncOS::Component::FanSubsystem::Fan;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'fan %d (%s) has %s rpm',
      $self->{fanIndex},
      $self->{fanName},
      $self->{fanRPMs});
  $self->add_perfdata(
      label => sprintf('fan_c%s', $self->{fanIndex}),
      value => $self->{fanRPMs},
      thresholds => 0,
  );
}

package Classes::Cisco::AsyncOS::Component::RaidSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('ASYNCOS-MAIL-MIB', (qw(
      raidEvents)));
  $self->get_snmp_tables('ASYNCOS-MAIL-MIB', [
      ['raids', 'raidTable', 'Classes::Cisco::AsyncOS::Component::RaidSubsystem::Raid'],
  ]);
}

package Classes::Cisco::AsyncOS::Component::RaidSubsystem::Raid;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'raid %d has status %s',
      $self->{raidIndex},
      $self->{raidStatus});
  if ($self->{raidStatus} eq 'driveHealthy') {
  } elsif ($self->{raidStatus} eq 'driveRebuild') {
    $self->add_warning();
  } elsif ($self->{raidStatus} eq 'driveFailure') {
    $self->add_critical();
  }
}

package Classes::Cisco::AsyncOS::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  #
  # 1.3.6.1.4.1.9.9.13.1.1.0 ciscoEnvMonPresent (irgendein typ of envmon)
  # 
  $self->{fan_subsystem} =
      Classes::Cisco::AsyncOS::Component::FanSubsystem->new();
  $self->{temperature_subsystem} =
      Classes::Cisco::AsyncOS::Component::TemperatureSubsystem->new();
  $self->{powersupply_subsystem} = 
      Classes::Cisco::AsyncOS::Component::PowersupplySubsystem->new();
  $self->{raid_subsystem} = 
      Classes::Cisco::AsyncOS::Component::RaidSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{fan_subsystem}->check();
  $self->{temperature_subsystem}->check();
  $self->{powersupply_subsystem}->check();
  $self->{raid_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_ok("environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{fan_subsystem}->dump();
  $self->{temperature_subsystem}->dump();
  $self->{powersupply_subsystem}->dump();
  $self->{raid_subsystem}->dump();
}

package Classes::Cisco::AsyncOS;
our @ISA = qw(Classes::Cisco);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Cisco::AsyncOS::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Cisco::AsyncOS::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Cisco::AsyncOS::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::licenses::/) {
    $self->analyze_and_check_key_subsystem("Classes::Cisco::AsyncOS::Component::KeySubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Cisco::SB::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  # schaut eher schlecht aus, das zeugs ist nicht main memory wie ueblich
  $self->get_snmp_objects('CISCOSB-SYSMNG-MIB', (qw(
      rlSysmngResourcePerUnitEntry
  )));
  $self->xget_snmp_tables('CISCOSB-SYSMNG-MIB', [
    ['tcamallocs', 'rlSysmngTcamAllocationsTable', 'Monitoring::GLPlugin::SNMP::TableItem'],
    ['resources', 'rlSysmngResourceTable', 'Monitoring::GLPlugin::SNMP::TableItem'],
    ['resourceusage', 'rlSysmngResourceUsageTable', 'Monitoring::GLPlugin::SNMP::TableItem'],
    ['resperunit', 'rlSysmngResourcePerUnitTable', 'Monitoring::GLPlugin::SNMP::TableItem'],
  ]);
}

sub check {
  my $self = shift;
}

package Classes::Cisco::SB::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  my $type = 0;
  $self->get_snmp_objects('CISCOSB-RNDMNG', (qw(
      rlCpuUtilDuringLast5Minutes)));
}

sub check {
  my $self = shift;
  if ($self->{rlCpuUtilDuringLast5Minutes} == 101) {
    $self->add_unknown('cpu measurement disabled');
    return;
  }
  $self->add_info(sprintf 'cpu usage is %.2f%%',
      $self->{rlCpuUtilDuringLast5Minutes});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds(
      $self->{rlCpuUtilDuringLast5Minutes}));
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{rlCpuUtilDuringLast5Minutes},
      uom => '%',
  );
}

package Classes::Cisco::SB::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CISCOSB-HWENVIROMENT', [
      ['fans', 'rlEnvMonFanStatusTable', 'Classes::Cisco::SB::Component::EnvironmentalSubsystem::Fan'],
      ['powersupplies', 'rlEnvMonSupplyStatusTable', 'Classes::Cisco::SB::Component::EnvironmentalSubsystem::Powersupply'],
  ]);
  $self->get_snmp_tables('ENTITY-MIB', [
    ['entities', 'entPhysicalTable', 'Monitoring::GLPlugin::SNMP::TableItem'],
  ]);

}


package Classes::Cisco::SB::Component::EnvironmentalSubsystem::Fan;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'status of fan %s is %s',
      $self->{flat_indices}, $self->{rlEnvMonFanState});
  if ($self->{rlEnvMonFanState} eq 'notPresent') {
  } elsif ($self->{rlEnvMonFanState} eq 'normal') {
    $self->add_ok();
  } elsif ($self->{rlEnvMonFanState} eq 'warning') {
    $self->add_warning();
  } else {
    $self->add_critical();
  }
}

package Classes::Cisco::SB::Component::EnvironmentalSubsystem::Powersupply;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'status of supply %s is %s',
      $self->{flat_indices}, $self->{rlEnvMonSupplyState});
  if ($self->{rlEnvMonSupplyState} eq 'notPresent') {
  } elsif ($self->{rlEnvMonSupplyState} eq 'normal') {
    $self->add_ok();
  } elsif ($self->{rlEnvMonSupplyState} eq 'warning') {
    $self->add_warning();
  } else {
    $self->add_critical();
  }
}


package Classes::Cisco::SB;
our @ISA = qw(Classes::Cisco);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Cisco::SB::Component::EnvironmentalSubsystem");
    if (! $self->check_messages()) {
      $self->clear_messages(0);
      $self->add_ok("environmental hardware working fine");
    }
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Cisco::SB::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->no_such_mode();
    #$self->analyze_and_check_environmental_subsystem("Classes::Cisco::SB::Component::MemSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Cisco;
our @ISA = qw(Classes::Device);
use strict;

use constant trees => (
  '1.3.6.1.2.1',        # mib-2
  '1.3.6.1.4.1.9',      # cisco
  '1.3.6.1.4.1.9.1',      # ciscoProducts
  '1.3.6.1.4.1.9.2',      # local
  '1.3.6.1.4.1.9.3',      # temporary
  '1.3.6.1.4.1.9.4',      # pakmon
  '1.3.6.1.4.1.9.5',      # workgroup
  '1.3.6.1.4.1.9.6',      # otherEnterprises
  '1.3.6.1.4.1.9.7',      # ciscoAgentCapability
  '1.3.6.1.4.1.9.8',      # ciscoConfig
  '1.3.6.1.4.1.9.9',      # ciscoMgmt
  '1.3.6.1.4.1.9.10',      # ciscoExperiment
  '1.3.6.1.4.1.9.11',      # ciscoAdmin
  '1.3.6.1.4.1.9.12',      # ciscoModules
  '1.3.6.1.4.1.9.13',      # lightstream
  '1.3.6.1.4.1.9.14',      # ciscoworks
  '1.3.6.1.4.1.9.15',      # newport
  '1.3.6.1.4.1.9.16',      # ciscoPartnerProducts
  '1.3.6.1.4.1.9.17',      # ciscoPolicy
  '1.3.6.1.4.1.9.18',      # ciscoPolicyAuto
  '1.3.6.1.4.1.9.19',      # ciscoDomains
  '1.3.6.1.4.1.14179.1',   # airespace-switching-mib
  '1.3.6.1.4.1.14179.2',   # airespace-wireless-mib
);

sub init {
  my $self = shift;
  if ($self->{productname} =~ /Cisco NX-OS/i) {
    bless $self, 'Classes::Cisco::NXOS';
    $self->debug('using Classes::Cisco::NXOS');
  } elsif ($self->{productname} =~ /Cisco Controller/i) {
    bless $self, 'Classes::Cisco::WLC';
    $self->debug('using Classes::Cisco::WLC');
  } elsif ($self->{productname} =~ /Cisco.*(IronPort|AsyncOS)/i) {
    bless $self, 'Classes::Cisco::AsyncOS';
    $self->debug('using Classes::Cisco::AsyncOS');
  } elsif ($self->{productname} =~ /Cisco.*Prime Network Control System/i) {
    bless $self, 'Classes::Cisco::PrimeNCS';
    $self->debug('using Classes::Cisco::PrimeNCS');
  } elsif ($self->{productname} =~ /UCOS /i) {
    bless $self, 'Classes::Cisco::UCOS';
    $self->debug('using Classes::Cisco::UCOS');
  } elsif ($self->{productname} =~ /Cisco (PIX|Adaptive) Security Appliance/i) {
    bless $self, 'Classes::Cisco::ASA';
    $self->debug('using Classes::Cisco::ASA');
  } elsif ($self->{productname} =~ /Cisco/i) {
    bless $self, 'Classes::Cisco::IOS';
    $self->debug('using Classes::Cisco::IOS');
  } elsif ($self->{productname} =~ /Fujitsu Intelligent Blade Panel 30\/12/i) {
    bless $self, 'Classes::Cisco::IOS';
    $self->debug('using Classes::Cisco::IOS');
  } elsif ($self->get_snmp_object('MIB-2-MIB', 'sysObjectID', 0) eq '1.3.6.1.4.1.9.1.1348') {
    bless $self, 'Classes::Cisco::CCM';
    $self->debug('using Classes::Cisco::CCM');
  } elsif ($self->get_snmp_object('MIB-2-MIB', 'sysObjectID', 0) eq '1.3.6.1.4.1.9.1.746') {
    bless $self, 'Classes::Cisco::CCM';
    $self->debug('using Classes::Cisco::CCM');
  } elsif ($self->get_snmp_object('MIB-2-MIB', 'sysObjectID', 0) =~ /.1.3.6.1.4.1.9.6.1.83/) {
    bless $self, 'Classes::Cisco::SB';
    $self->debug('using Classes::Cisco::SB');
  }
  if (ref($self) ne "Classes::Cisco") {
    $self->init();
  } else {
    $self->no_such_mode();
  }
}

package Classes::OneOS::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('ONEACCESS-SYS-MIB', [
    ['comps', 'oacExpIMSysHwComponentsTable', 'Classes::OneOS::Component::EnvironmentalSubsystem::Comp' ],
  ]);
}

sub check {
  my $self = shift;
  $self->add_ok("environmental hardware working fine, at least i hope so. this device did not implement any kind of hardware health status. use -vv to see a list of components");
}


package Classes::OneOS::Component::EnvironmentalSubsystem::Comp;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  my $label = sprintf 'usage', $self->{flat_indices};
  $self->add_info(sprintf '%s %s %s',
      $self->{flat_indices}, $self->{oacExpIMSysHwcTypeDefinition},
      $self->{oacExpIMSysHwcDescription});
}
package Classes::OneOS::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('ONEACCESS-SYS-MIB', (qw(
      oacSysCpuUsed)));
}

sub check {
  my $self = shift;
  $self->add_info('checking cpu');
  $self->add_info(sprintf 'cpu usage is %.2f%%',
      $self->{oacSysCpuUsed});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{oacSysCpuUsed}));
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{oacSysCpuUsed},
      uom => '%',
  );
}

package Classes::OneOS::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('ONEACCESS-SYS-MIB', (qw(
      oacSysMemoryUsed)));
}

sub check {
  my $self = shift;
  $self->add_info('checking memory');
  $self->add_info(sprintf 'memory usage is %.2f%%',
      $self->{oacSysMemoryUsed});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{oacSysMemoryUsed}));
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{oacSysMemoryUsed},
      uom => '%',
  );
}
package Classes::OneOS;
our @ISA = qw(Classes::Device);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::OneOS::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::OneOS::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::OneOS::Component::MemSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Nortel::S5::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('S5-CHASSIS-MIB', [
    ['comps', 's5ChasComTable', 'Classes::Nortel::S5::Component::EnvironmentalSubsystem::Comp' ],
  ]);
}

sub check {
  my $self = shift;
  foreach (@{$self->{comps}}) {
    $_->check();
  }
  $self->reduce_messages("environmental hardware working fine");
}


package Classes::Nortel::S5::Component::EnvironmentalSubsystem::Comp;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{s5ChasComShortDescr} = $self->{s5ChasComDescr};
}

sub check {
  my $self = shift;
  $self->add_info(sprintf 'component %s/%s status is %s (admin %s)',
      $self->{flat_indices}, $self->{s5ChasComShortDescr},
      $self->{s5ChasComOperState}, $self->{s5ChasComAdminState});
  if ($self->{s5ChasComOperState} eq 'removed') {
  } elsif ($self->{s5ChasComAdminState} eq 'disable') {
  } elsif (grep { $self->{s5ChasComOperState} eq $_ }
      (qw(normal resetInProg testing disabled))) {
    $self->add_ok();
  } elsif (grep { $self->{s5ChasComOperState} eq $_ }
      (qw(warning nonFatalErr))) {
    $self->add_warning();
  } elsif (grep { $self->{s5ChasComOperState} eq $_ }
      (qw(fatalErr))) {
    $self->add_critical();
  } else {
    $self->add_unknown();
  }
}
package Classes::Nortel::S5::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('S5-CHASSIS-MIB', [
    ['utils', 's5ChasUtilTable', 'Classes::Nortel::S5::Component::CpuSubsystem::Cpu' ],
  ]);
}


package Classes::Nortel::S5::Component::CpuSubsystem::Cpu;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  my $label = sprintf 'cpu_%s_usage', $self->{flat_indices};
  $self->add_info(sprintf 'cpu %s usage was %.2f%%(1min) %.2f%%(10min)',
      $self->{flat_indices},,
      $self->{s5ChasUtilCPUUsageLast1Minute},
      $self->{s5ChasUtilCPUUsageLast10Minutes});
  $self->set_thresholds(metric => $label.'_10m', warning => 80, critical => 90);
  $self->add_message($self->check_thresholds(
      metric => $label.'_10m', value => $self->{s5ChasUtilCPUUsageLast10Minutes}));
  $self->add_perfdata(
      label => $label.'_1m',
      value => $self->{s5ChasUtilCPUUsageLast1Minute},
      uom => '%',
  );
  $self->add_perfdata(
      label => $label.'_10m',
      value => $self->{s5ChasUtilCPUUsageLast10Minutes},
      uom => '%',
  );
}
package Classes::Nortel::S5::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('S5-CHASSIS-MIB', [
    ['utils', 's5ChasUtilTable', 'Classes::Nortel::S5::Component::MemSubsystem::Mem' ],
  ]);
}


package Classes::Nortel::S5::Component::MemSubsystem::Mem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{s5ChasUtilMemoryUsage} = 100 - 
      ($self->{s5ChasUtilMemoryAvailableMB} /
      $self->{s5ChasUtilMemoryTotalMB} * 100);
}

sub check {
  my $self = shift;
  my $label = sprintf 'memory_%s_usage', $self->{flat_indices};
  $self->add_info(sprintf 'memory %s usage is %.2f%%',
      $self->{flat_indices},,
      $self->{s5ChasUtilMemoryUsage});
  $self->set_thresholds(metric => $label, warning => 80, critical => 90);
  $self->add_message($self->check_thresholds(
      metric => $label, value => $self->{s5ChasUtilMemoryUsage}));
  $self->add_perfdata(
      label => $label,
      value => $self->{s5ChasUtilMemoryUsage},
      uom => '%',
  );
}
# 3fach indexiert, als tabelle ausgeben und durchnumerieren
package Classes::Nortel::S5;
our @ISA = qw(Classes::Device);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Nortel::S5::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Nortel::S5::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Nortel::S5::Component::MemSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Nortel;
our @ISA = qw(Classes::Device);
use strict;

sub init {
  my $self = shift;
  if ($self->implements_mib('S5-CHASSIS-MIB')) {
    bless $self, 'Classes::Nortel::S5';
    $self->debug('using Classes::Nortel::S5');
  } elsif ($self->implements_mib('RAPID-CITY-MIB')) {
    # synoptics wird von bay networks gekauft
    # bay networks wird von nortel gekauft
    # und alles was ich da an testdaten habe, ist muell. lauter
    # dreck aus einer rcPortTable, aber nix fan, nix temp, nix cpu
    bless $self, 'Classes::RAPIDCITYMIB';
    $self->debug('using Classes::RAPID-CITY-MIB');
  }
  if (ref($self) ne "Classes::Nortel") {
    $self->init();
  }
}

package Classes::Juniper::NetScreen::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('NETSCREEN-RESOURCE-MIB', (qw(
      nsResCpuAvg)));
}

sub check {
  my $self = shift;
  $self->add_info('checking cpus');
  $self->add_info(sprintf 'cpu usage is %.2f%%', $self->{nsResCpuAvg});
  $self->set_thresholds(warning => 50, critical => 90);
  $self->add_message($self->check_thresholds($self->{nsResCpuAvg}));
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{nsResCpuAvg},
      uom => '%',
  );
}
package Classes::Juniper::NetScreen::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('NETSCREEN-RESOURCE-MIB', (qw(
      nsResMemAllocate nsResMemLeft nsResMemFrag)));
  my $mem_total = $self->{nsResMemAllocate} + $self->{nsResMemLeft};
  $self->{mem_usage} = $self->{nsResMemAllocate} / $mem_total * 100;
}

sub check {
  my $self = shift;
  $self->add_info('checking memory');
  if (defined $self->{mem_usage}) {
    $self->add_info(sprintf 'memory usage is %.2f%%', $self->{mem_usage});
    $self->set_thresholds(warning => 80,
        critical => 90);
    $self->add_message($self->check_thresholds($self->{mem_usage}));
    $self->add_perfdata(
        label => 'memory_usage',
        value => $self->{mem_usage},
        uom => '%',
    );
  } else {
    $self->add_unknown('cannot aquire memory usage');
  }
}

package Classes::Juniper::NetScreen::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects("NETSCREEN-CHASSIS-MIB", (qw(
      sysBatteryStatus)));
  $self->get_snmp_tables("NETSCREEN-CHASSIS-MIB", [
      ['fans', 'nsFanTable', 'Classes::Juniper::NetScreen::Component::EnvironmentalSubsystem::Fan'],
      ['power', 'nsPowerTable', 'Classes::Juniper::NetScreen::Component::EnvironmentalSubsystem::Power'],
      ['slots', 'nsSlotTable', 'Classes::Juniper::NetScreen::Component::EnvironmentalSubsystem::Slot'],
      ['temperatures', 'nsTemperatureTable', 'Classes::Juniper::NetScreen::Component::EnvironmentalSubsystem::Temperature'],
  ]);
}

sub check {
  my $self = shift;
  foreach (@{$self->{fans}}, @{$self->{power}}, @{$self->{slots}}, @{$self->{temperatures}}) {
    $_->check();
  }
}


package Classes::Juniper::NetScreen::Component::EnvironmentalSubsystem::Fan;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf "fan %s (%s) is %s",
      $self->{nsFanId}, $self->{nsFanDesc}, $self->{nsFanStatus});
  if ($self->{nsFanStatus} eq "notInstalled") {
  } elsif ($self->{nsFanStatus} eq "good") {
    $self->add_ok();
  } elsif ($self->{nsFanStatus} eq "fail") {
    $self->add_warning();
  }
}


package Classes::Juniper::NetScreen::Component::EnvironmentalSubsystem::Power;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf "power supply %s (%s) is %s",
      $self->{nsPowerId}, $self->{nsPowerDesc}, $self->{nsPowerStatus});
  if ($self->{nsPowerStatus} eq "good") {
    $self->add_ok();
  } elsif ($self->{nsPowerStatus} eq "fail") {
    $self->add_warning();
  }
}


package Classes::Juniper::NetScreen::Component::EnvironmentalSubsystem::Slot;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{nsSlotSN} =~ s/^\s+//g;
}

sub check {
  my $self = shift;
  $self->add_info(sprintf "%s slot %s (%s) is %s",
      $self->{nsSlotType}, $self->{nsSlotId}, $self->{nsSlotSN}, $self->{nsSlotStatus});
  if ($self->{nsSlotStatus} eq "good") {
    $self->add_ok();
  } elsif ($self->{nsSlotStatus} eq "fail") {
    $self->add_warning();
  }
}


package Classes::Juniper::NetScreen::Component::EnvironmentalSubsystem::Temperature;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf "temperature %s (%s) is %sC",
      $self->{nsTemperatureId}, $self->{nsTemperatureDesc}, $self->{nsTemperatureCur});
  $self->add_ok();
  $self->add_perfdata(
      label => 'temp_'.$self->{nsTemperatureId},
      value => $self->{nsTemperatureCur},
  );
}

package Classes::Juniper::NetScreen;
our @ISA = qw(Classes::Juniper);
use strict;

use constant trees => (
  '1.3.6.1.2.1',        # mib-2
  '1.3.6.1.2.1.105',
);

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Juniper::NetScreen::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Juniper::NetScreen::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Juniper::NetScreen::Component::EnvironmentalSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Juniper::IVE::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('JUNIPER-IVE-MIB', (qw(
      iveMemoryUtil iveSwapUtil)));
}

sub check {
  my $self = shift;
  $self->add_info('checking memory');
  $self->add_info(sprintf 'memory usage is %.2f%%, swap usage is %.2f%%',
      $self->{iveMemoryUtil}, $self->{iveSwapUtil});
  $self->set_thresholds(warning => 90, critical => 95);
  $self->add_message($self->check_thresholds($self->{iveMemoryUtil}),
      sprintf 'memory usage is %.2f%%', $self->{iveMemoryUtil});
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{iveMemoryUtil},
      uom => '%',
  );
  $self->set_thresholds(warning => 5, critical => 10);
  $self->add_message($self->check_thresholds($self->{iveSwapUtil}),
      sprintf 'swap usage is %.2f%%', $self->{iveSwapUtil});
  $self->add_perfdata(
      label => 'swap_usage',
      value => $self->{iveSwapUtil},
      uom => '%',
  );
}

package Classes::Juniper::IVE::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('JUNIPER-IVE-MIB', (qw(
      iveCpuUtil)));
}

sub check {
  my $self = shift;
  $self->add_info('checking cpus');
  $self->add_info(sprintf 'cpu usage is %.2f%%', $self->{iveCpuUtil});
  # http://www.juniper.net/techpubs/software/ive/guides/howtos/SA-IC-MAG-SNMP-Monitoring-Guide.pdf
  $self->set_thresholds(warning => 50, critical => 90);
  $self->add_message($self->check_thresholds($self->{iveCpuUtil}));
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{iveCpuUtil},
      uom => '%',
  );
}

package Classes::Juniper::IVE::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{disk_subsystem} =
      Classes::Juniper::IVE::Component::DiskSubsystem->new();
  $self->get_snmp_objects('JUNIPER-IVE-MIB', (qw(
      iveTemperature fanDescription psDescription raidDescription)));
}

sub check {
  my $self = shift;
  $self->{disk_subsystem}->check();
  $self->add_info(sprintf "temperature is %.2f deg", $self->{iveTemperature});
  $self->set_thresholds(warning => 70, critical => 75);
  $self->check_thresholds(0);
  $self->add_perfdata(
      label => 'temperature',
      value => $self->{iveTemperature},
      warning => $self->{warning},
      critical => $self->{critical},
  ) if $self->{iveTemperature};
  if ($self->{fanDescription} && $self->{fanDescription} =~ /(failed)|(threshold)/) {
    $self->add_critical($self->{fanDescription});
  }
  if ($self->{psDescription} && $self->{psDescription} =~ /failed/) {
    $self->add_critical($self->{psDescription});
  }
  if ($self->{raidDescription} && $self->{raidDescription} =~ /(failed)|(unknown)/) {
    $self->add_critical($self->{raidDescription});
  }
  if (! $self->check_messages()) {
    $self->add_ok("environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{disk_subsystem}->dump();
}

package Classes::Juniper::IVE::Component::DiskSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('JUNIPER-IVE-MIB', (qw(
      diskFullPercent)));
}

sub check {
  my $self = shift;
  $self->add_info('checking disks');
  $self->add_info(sprintf 'disk is %.2f%% full',
      $self->{diskFullPercent});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{diskFullPercent}));
  $self->add_perfdata(
      label => 'disk_usage',
      value => $self->{diskFullPercent},
      uom => '%',
  );
}

package Classes::Juniper::IVE::Component::UserSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('JUNIPER-IVE-MIB', (qw(
      iveSSLConnections iveVPNTunnels 
      signedInWebUsers signedInMailUsers meetingUserCount
      iveConcurrentUsers clusterConcurrentUsers)));
  foreach (qw(
      iveSSLConnections iveVPNTunnels 
      signedInWebUsers signedInMailUsers meetingUserCount
      iveConcurrentUsers clusterConcurrentUsers)) {
    $self->{$_} = 0 if ! defined $self->{$_};
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking memory');
  $self->add_info(sprintf 'Users: sslconns=%d cluster=%d, node=%d, web=%d, mail=%d, meeting=%d',
      $self->{iveSSLConnections},
      $self->{clusterConcurrentUsers},
      $self->{iveConcurrentUsers},
      $self->{signedInWebUsers},
      $self->{signedInMailUsers},
      $self->{meetingUserCount});
  $self->add_ok();
  $self->add_perfdata(
      label => 'sslconns',
      value => $self->{iveSSLConnections},
  );
  $self->add_perfdata(
      label => 'web_users',
      value => $self->{signedInWebUsers},
  );
  $self->add_perfdata(
      label => 'mail_users',
      value => $self->{signedInMailUsers},
  );
  $self->add_perfdata(
      label => 'meeting_users',
      value => $self->{meetingUserCount},
  );
  $self->add_perfdata(
      label => 'concurrent_users',
      value => $self->{iveConcurrentUsers},
  );
  $self->add_perfdata(
      label => 'cluster_concurrent_users',
      value => $self->{clusterConcurrentUsers},
  );
}
package Classes::Juniper::IVE;
our @ISA = qw(Classes::Juniper);
use strict;

use constant trees => (
  '1.3.6.1.2.1',        # mib-2
  '1.3.6.1.2.1.105',
);

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Juniper::IVE::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Juniper::IVE::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Juniper::IVE::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::users/) {
    $self->analyze_and_check_user_subsystem("Classes::Juniper::IVE::Component::UserSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Juniper::SRX::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('JUNIPER-MIB', [
    ['leds', 'jnxLEDTable', 'Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Led'],
    ['operatins', 'jnxOperatingTable', 'Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Operating'],
    ['containers', 'jnxContainersTable', 'Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Container'],
    ['fru', 'jnxFruTable', 'Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Fru'],
    ['redun', 'jnxRedundancyTable', 'Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Redundancy'],
    ['contents', 'jnxContentsTable', 'Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Content'],
    ['filled', 'jnxFilledTable', 'Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Fille'],
  ]);
  $self->merge_tables("operatins", "filled", "fru", "contents");
}

package Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Led;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

sub check {
  my $self = shift;
  $self->add_info(sprintf 'led %s is %s', $self->{jnxLEDDescr},
      $self->{jnxLEDState});
  if ($self->{jnxLEDState} eq 'yellow') {
    $self->add_warning();
  } elsif ($self->{jnxLEDState} eq 'red') {
    $self->add_critical();
  } elsif ($self->{jnxLEDState} eq 'amber') {
    $self->add_critical();
  } elsif ($self->{jnxLEDState} eq 'green') {
    $self->add_ok();
  }
}

package Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Container;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

package Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Fru;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

package Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Redundancy;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

package Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Content;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

package Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Fille;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);



package Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Operating;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

sub finish {
  my $self = shift;
  if ($self->{jnxOperatingDescr} =~ /Routing Engine$/) {
    bless $self, "Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Engine";
  }
}

package Classes::Juniper::SRX::Component::EnvironmentalSubsystem::Engine;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

sub check {
  my $self = shift;
  $self->add_info(sprintf '%s temperature is %.2f',
      $self->{jnxOperatingDescr}, $self->{jnxOperatingTemp});
  my $label = 'temp_'.$self->{jnxOperatingDescr};
  $self->set_thresholds(metric => $label, warning => 50, critical => 60);
  $self->add_message($self->check_thresholds(metric => $label, 
      value => $self->{jnxOperatingTemp}));
  $self->add_perfdata(
      label => $label,
      value => $self->{jnxOperatingTemp},
  );
}

package Classes::Juniper::SRX::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('JUNIPER-MIB', [
    ['operatins', 'jnxOperatingTable', 'Classes::Juniper::SRX::Component::CpuSubsystem::OperatingItem', sub { shift->{jnxOperatingDescr} =~ /engine/i; }],
# siehe memory
#    ['objects', 'jnxJsSPUMonitoringObjectsTable ', 'Classes::Juniper::SRX::Component::CpuSubsystem::OperatingItem2'],
  ]);
}

package Classes::Juniper::SRX::Component::CpuSubsystem::OperatingItem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

sub check {
  my $self = shift;
  $self->add_info(sprintf '%s cpu usage is %.2f%%',
      $self->{jnxOperatingDescr}, $self->{jnxOperatingCPU});
  my $label = 'cpu_'.$self->{jnxOperatingDescr}.'_usage';
  $self->set_thresholds(metric => $label, warning => 50, critical => 90);
  $self->add_message($self->check_thresholds(metric => $label, 
      value => $self->{jnxOperatingCPU}));
  $self->add_perfdata(
      label => $label,
      value => $self->{jnxOperatingCPU},
      uom => '%',
  );
}

package Classes::Juniper::SRX::Component::CpuSubsystem::OperatingItem2;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

sub check {
  my $self = shift;
  $self->add_info(sprintf 'cpu usage is %.2f%%', $self->{jnxJsSPUMonitoringCPUUsage});
  $self->set_thresholds(warning => 50, critical => 90);
  $self->add_message($self->check_thresholds($self->{jnxJsSPUMonitoringCPUUsage}));
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{jnxJsSPUMonitoringCPUUsage},
      uom => '%',
  );
}
package Classes::Juniper::SRX::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('JUNIPER-MIB', qw(jnxBoxKernelMemoryUsedPercent));
  $self->get_snmp_tables('JUNIPER-MIB', [
    ['operatins', 'jnxOperatingTable', 'Classes::Juniper::SRX::Component::MemSubsystem::OperatingItem', sub { shift->{jnxOperatingDescr} =~ /engine/i; }],
# nearly no documentytion exists for this
#    ['objects', 'jnxJsSPUMonitoringObjectsTable ', 'Classes::Juniper::SRX::Component::MemSubsystem::OperatingItem2'],
  ]);
}

sub check {
  my $self = shift;
  $self->SUPER::check();
  if (exists $self->{jnxBoxKernelMemoryUsedPercent}) {
    $self->add_info(sprintf 'kernel memory usage is %.2f%%',
        $self->{jnxBoxKernelMemoryUsedPercent});
    $self->set_thresholds(metric => 'kernel_memory_usage',
        warning => 90, critical => 95);
    $self->add_message($self->check_thresholds(metric => 'kernel_memory_usage', 
        value => $self->{jnxBoxKernelMemoryUsedPercent}));
    $self->add_perfdata(
        label => 'kernel_memory_usage',
        value => $self->{jnxBoxKernelMemoryUsedPercent},
        uom => '%',
    );
  }
}


package Classes::Juniper::SRX::Component::MemSubsystem::OperatingItem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

sub check {
  my $self = shift;
  $self->add_info(sprintf '%s buffer usage is %.2f%%',
      $self->{jnxOperatingDescr}, $self->{jnxOperatingBuffer});
  my $label = 'buffer_'.$self->{jnxOperatingDescr}.'_usage';
  $self->set_thresholds(metric => $label, warning => 90, critical => 95);
  $self->add_message($self->check_thresholds(metric => $label, 
      value => $self->{jnxOperatingBuffer}));
  $self->add_perfdata(
      label => $label,
      value => $self->{jnxOperatingBuffer},
      uom => '%',
  );
}

package Classes::Juniper::SRX::Component::MemSubsystem::OperatingItem2;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

sub check {
  my $self = shift;
  $self->add_info(sprintf 'cpu usage is %.2f%%', $self->{jnxJsSPUMonitoringCPUUsage});
  $self->set_thresholds(warning => 50, critical => 90);
  $self->add_message($self->check_thresholds($self->{jnxJsSPUMonitoringCPUUsage}));
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{jnxJsSPUMonitoringCPUUsage},
      uom => '%',
  );
}
package Classes::Juniper::SRX;
our @ISA = qw(Classes::Juniper);
use strict;


sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Juniper::SRX::Component::EnvironmentalSubsystem");
    $self->{components}->{hostresource_subsystem} =
        Classes::HOSTRESOURCESMIB::Component::EnvironmentalSubsystem->new();
    foreach (@{$self->{components}->{hostresource_subsystem}->{disk_subsystem}->{storages}}) {
      if (exists $_->{device} && $_->{device} =~ /^\/dev\/md/) {
        $_->blacklist();
      }
    }
    $self->{components}->{hostresource_subsystem}->check();
    $self->{components}->{hostresource_subsystem}->dump()
        if $self->opts->verbose >= 2;
    $self->clear_ok();
    if (! $self->check_messages()) {
      $self->add_ok("environmental hardware working fine");
    }
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Juniper::SRX::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Juniper::SRX::Component::MemSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Juniper;
our @ISA = qw(Classes::Device);
use strict;

use constant trees => (
    '1.3.6.1.4.1.4874.',
    '1.3.6.1.4.1.3224.',
);

sub init {
  my $self = shift;
  if ($self->{productname} =~ /NetScreen/i) {
    bless $self, 'Classes::Juniper::NetScreen';
    $self->debug('using Classes::Juniper::NetScreen');
  } elsif ($self->{productname} =~ /Juniper.*MAG\-\d+/i) {
    # Juniper Networks,Inc,MAG-4610,7.2R10
    bless $self, 'Classes::Juniper::IVE';
    $self->debug('using Classes::Juniper::IVE');
  }
  if (ref($self) ne "Classes::Juniper") {
    $self->init();
  }
}

package Classes::AlliedTelesyn;
our @ISA = qw(Classes::Device);
use strict;

sub init {
  my $self = shift;
  $self->no_such_mode();
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::AlliedTelesyn::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::AlliedTelesyn::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::AlliedTelesyn::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::hsrp/) {
    $self->analyze_and_check_hsrp_subsystem("Classes::HSRP::Component::HSRPSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Fortigate::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('FORTINET-FORTIGATE-MIB', (qw(
      fgSysMemUsage)));
}

sub check {
  my $self = shift;
  $self->add_info('checking memory');
  if (defined $self->{fgSysMemUsage}) {
    $self->add_info(sprintf 'memory usage is %.2f%%',
        $self->{fgSysMemUsage});
    $self->set_thresholds(warning => 80, critical => 90);
    $self->add_message($self->check_thresholds($self->{fgSysMemUsage}));
    $self->add_perfdata(
        label => 'memory_usage',
        value => $self->{fgSysMemUsage},
        uom => '%',
    );
  } else {
    $self->add_unknown('cannot aquire memory usage');
  }
}

package Classes::Fortigate::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  my %params = @_;
  my $type = 0;
  $self->get_snmp_objects('FORTINET-FORTIGATE-MIB', (qw(
      fgSysCpuUsage)));
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking cpus');
  $self->add_info(sprintf 'cpu usage is %.2f%%', $self->{fgSysCpuUsage});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{fgSysCpuUsage}));
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{fgSysCpuUsage},
      uom => '%',
  );
}

package Classes::Fortigate::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{sensor_subsystem} =
      Classes::Fortigate::Component::SensorSubsystem->new();
  $self->{disk_subsystem} =
      Classes::Fortigate::Component::DiskSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{sensor_subsystem}->check();
  $self->{disk_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_ok("environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{sensor_subsystem}->dump();
  $self->{disk_subsystem}->dump();
}

package Classes::Fortigate::Component::SensorSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('FORTINET-FORTIGATE-MIB', [
      ['sensors', 'fgHwSensorTable', 'Classes::Fortigate::Component::SensorSubsystem::Sensor'],
  ]);
}

package Classes::Fortigate::Component::SensorSubsystem::Sensor;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'sensor %s alarm status is %s',
      $self->{fgHwSensorEntName},
      $self->{fgHwSensorEntValueStatus});
  if ($self->{fgHwSensorEntValueStatus} && $self->{fgHwSensorEntValueStatus} eq "true") {
    $self->add_critical();
  }
  if ($self->{fgHwSensorEntValue}) {
    $self->add_perfdata(
        label => sprintf('sensor_%s', $self->{fgHwSensorEntName}),
        value => $self->{swSensorValue},
    );
  }
}

package Classes::Fortigate;
our @ISA = qw(Classes::Brocade);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Fortigate::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Fortigate::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Fortigate::Component::MemSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::FabOS::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  foreach (qw(swMemUsage swMemUsageLimit1 swMemUsageLimit3 swMemPollingInterval
      swMemNoOfRetries swMemAction)) {
    $self->{$_} = $self->valid_response('SW-MIB', $_, 0);
  }
  $self->get_snmp_objects('SW-MIB', (qw(
      swFwFabricWatchLicense)));
}

sub check {
  my $self = shift;
  $self->add_info('checking memory');
  if (defined $self->{swMemUsage}) {
    $self->add_info(sprintf 'memory usage is %.2f%%',
        $self->{swMemUsage});
    $self->set_thresholds(warning => $self->{swMemUsageLimit1},
        critical => $self->{swMemUsageLimit3});
    $self->add_message($self->check_thresholds($self->{swMemUsage}));
    $self->add_perfdata(
        label => 'memory_usage',
        value => $self->{swMemUsage},
        uom => '%',
    );
  } elsif ($self->{swFwFabricWatchLicense} eq 'swFwNotLicensed') {
    $self->add_unknown('please install a fabric watch license');
  } else {
    my $swFirmwareVersion = $self->get_snmp_object('SW-MIB', 'swFirmwareVersion');
    if ($swFirmwareVersion && $swFirmwareVersion =~ /^v6/) {
      $self->add_ok('memory usage is not implemented');
    } else {
      $self->add_unknown('cannot aquire memory usage');
    }
  }
}

package Classes::FabOS::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  foreach (qw(swCpuUsage swCpuNoOfRetries swCpuUsageLimit swCpuPollingInterval
      swCpuAction)) {
    $self->{$_} = $self->valid_response('SW-MIB', $_, 0);
  }
  $self->get_snmp_objects('SW-MIB', (qw(
      swFwFabricWatchLicense)));
}

sub check {
  my $self = shift;
  $self->add_info('checking cpus');
  if (defined $self->{swCpuUsage}) {
    $self->add_info(sprintf 'cpu usage is %.2f%%', $self->{swCpuUsage});
    $self->set_thresholds(warning => $self->{swCpuUsageLimit},
        critical => $self->{swCpuUsageLimit});
    $self->add_message($self->check_thresholds($self->{swCpuUsage}));
    $self->add_perfdata(
        label => 'cpu_usage',
        value => $self->{swCpuUsage},
        uom => '%',
    );
  } elsif ($self->{swFwFabricWatchLicense} eq 'swFwNotLicensed') {
    $self->add_unknown('please install a fabric watch license');
  } else {
    my $swFirmwareVersion = $self->get_snmp_object('SW-MIB', 'swFirmwareVersion');
    if ($swFirmwareVersion && $swFirmwareVersion =~ /^v6/) {
      $self->add_ok('cpu usage is not implemented');
    } else {
      $self->add_unknown('cannot aquire cpu usage');
    }
  }
}

package Classes::FabOS::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{sensor_subsystem} =
      Classes::FabOS::Component::SensorSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{sensor_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_ok("environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{sensor_subsystem}->dump();
}

package Classes::FabOS::Component::SensorSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->bulk_is_baeh();
  $self->get_snmp_tables('SW-MIB', [
      ['sensors', 'swSensorTable', 'Classes::FabOS::Component::SensorSubsystem::Sensor'],
  ]);
}

package Classes::FabOS::Component::SensorSubsystem::Sensor;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub check {
  my $self = shift;
  $self->add_info(sprintf '%s sensor %s (%s) is %s',
      $self->{swSensorType},
      $self->{swSensorIndex},
      $self->{swSensorInfo},
      $self->{swSensorStatus});
  if ($self->{swSensorStatus} eq "faulty") {
    $self->add_critical();
  } elsif ($self->{swSensorStatus} eq "absent") {
  } elsif ($self->{swSensorStatus} eq "unknown") {
    $self->add_critical();
  } else {
    if ($self->{swSensorStatus} eq "nominal") {
      #$self->add_ok();
    } else {
      $self->add_critical();
    }
    $self->add_perfdata(
        label => sprintf('sensor_%s_%s', 
            $self->{swSensorType}, $self->{swSensorIndex}),
        value => $self->{swSensorValue},
    ) if $self->{swSensorType} ne "power-supply";
  }
}


package Classes::FabOS::Component::SensorSubsystem::SensorThreshold;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(entSensorThresholdRelation entSensorThresholdValue
      entSensorThresholdSeverity entSensorThresholdNotificationEnable
      entSensorThresholdEvaluation indices)) {
    $self->{$param} = $params{$param};
  }
  $self->{entPhysicalIndex} = $params{indices}[0];
  $self->{entSensorThresholdIndex} = $params{indices}[1];
  bless $self, $class;
  return $self;
}

package Classes::FabOS;
our @ISA = qw(Classes::Brocade);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::FabOS::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::FabOS::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::FabOS::Component::MemSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::HH3C::Component::EntitySubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

package Classes::HH3C::Component::EnvironmentalSubsystem;
our @ISA = qw(Classes::HH3C::Component::EntitySubsystem);
use strict;

sub init {
  my $self = shift;

  $self->get_entities('Classes::HH3C::Component::EnvironmentalSubsystem::EntityState');

  my $i = 0;
  foreach my $h ($self->get_sub_table('HH3C-ENTITY-EXT-MIB', [ 'hh3cEntityExtErrorStatus' ])) {
    foreach (keys %$h) {
      next if $_ =~ /indices/;
      @{$self->{entities}}[$i]->{$_} = $h->{$_};
    }
    $i++;
  }
}

sub check {
  my $self = shift;

  $self->add_info('checking entities');
  if (scalar (@{$self->{entities}}) == 0) {
    $self->add_unknown('no entities found');
  } else {
    foreach (@{$self->{entities}}) {
      $_->check();
    }
    if (! $self->check_messages()) {
      $self->add_ok("environmental hardware working fine");
    }
  }
}

package Classes::HH3C::Component::EnvironmentalSubsystem::EntityState;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf '%s (%s) is %s',
      $self->{entPhysicalDescr},
      $self->{entPhysicalClass},
      $self->{hh3cEntityExtErrorStatus});

  if ($self->{hh3cEntityExtErrorStatus} eq "normal") {
    $self->add_ok();
  } elsif (
    $self->{hh3cEntityExtErrorStatus} eq "entityAbsent" or
    $self->{hh3cEntityExtErrorStatus} =~ /^sfp/
  ) {
    $self->add_warning();
  } else {
    $self->add_critical();
  }
}
package Classes::HH3C::Component::MemSubsystem;
our @ISA = qw(Classes::HH3C::Component::EntitySubsystem);
use strict;

sub init {
  my $self = shift;

  $self->get_entities('Classes::HH3C::Component::MemSubsystem::EntityState',
    sub { my $o = shift; $o->{entPhysicalClass} eq 'module' and $o->{entPhysicalName} =~ /board/i; } );

  foreach ($self->get_sub_table('HH3C-ENTITY-EXT-MIB', [ 'hh3cEntityExtMemAvgUsage' ])) {
    push @{$self->{entityext}}, $_;
  }

  $self->join_table($self->{entities}, $self->{entityext});
}

sub check {
  my $self = shift;

  $self->add_info('checking board');
  if (scalar (@{$self->{entities}}) == 0) {
    $self->add_unknown('no board found');
  } else {
    my $i = 0;
    foreach (@{$self->{entities}}) {
      $_->check($i++);
    }
  }
}

package Classes::HH3C::Component::MemSubsystem::EntityState;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  my $id = shift;

  $self->add_info(sprintf 'Memory %s usage is %s%%',
      $id,
      $self->{hh3cEntityExtMemAvgUsage});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{hh3cEntityExtMemAvgUsage}));
  $self->add_perfdata(
      label => 'memory_'.$id.'_usage',
      value => $self->{hh3cEntityExtMemAvgUsage},
      uom => '%',
  );
}
package Classes::HH3C::Component::CpuSubsystem;
our @ISA = qw(Classes::HH3C::Component::EntitySubsystem);
use strict;

sub init {
  my $self = shift;

  $self->get_entities('Classes::HH3C::Component::CpuSubsystem::EntityState',
    sub { my $o = shift; $o->{entPhysicalClass} eq 'module' and $o->{entPhysicalName} =~ /board/i; } );

  foreach ($self->get_sub_table('HH3C-ENTITY-EXT-MIB', [ 'hh3cEntityExtCpuAvgUsage' ])) {
    push @{$self->{entityext}}, $_;
  }

  $self->join_table($self->{entities}, $self->{entityext});
}

sub check {
  my $self = shift;

  $self->add_info('checking board');
  if (scalar (@{$self->{entities}}) == 0) {
    $self->add_unknown('no board found');
  } else {
    my $i = 0;
    foreach (@{$self->{entities}}) {
      $_->check($i++);
    }
  }
}

package Classes::HH3C::Component::CpuSubsystem::EntityState;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  my $id = shift;

  $self->add_info(sprintf 'CPU %s usage is %s%%',
      $id,
      $self->{hh3cEntityExtCpuAvgUsage});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{hh3cEntityExtCpuAvgUsage}));
  $self->add_perfdata(
      label => 'cpu_'.$id.'_usage',
      value => $self->{hh3cEntityExtCpuAvgUsage},
      uom => '%',
  );
}
# HP Huawei 3Com
package Classes::HH3C;
our @ISA = qw(Classes::Device);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::HH3C::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::HH3C::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::HH3C::Component::MemSubsystem");
  } else {
    $self->no_such_mode();
  }
}
package Classes::Huawei::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('ENTITY-MIB', [
    ['modules', 'entPhysicalTable',
        'Classes::Huawei::Component::EnvironmentalSubsystem::Module',
        sub { my $o = shift; $o->{entPhysicalClass} eq 'module' },
        ['entPhysicalClass', 'entPhysicalDescr', 'entPhysicalName']],
    ['fans', 'entPhysicalTable',
        'Classes::Huawei::Component::EnvironmentalSubsystem::Fan', 
        sub { my $o = shift; $o->{entPhysicalClass} eq 'fan' },
        ['entPhysicalClass', 'entPhysicalDescr', 'entPhysicalName']],
    ['powersupplies', 'entPhysicalTable',
        'Classes::Huawei::Component::EnvironmentalSubsystem::Powersupply',
        sub { my $o = shift; $o->{entPhysicalClass} eq 'powerSupply' },
       ['entPhysicalClass', 'entPhysicalDescr', 'entPhysicalName']],
  ]);
  $self->get_snmp_tables('HUAWEI-ENTITY-EXTENT-MIB', [
    ['fanstates', 'hwFanStatusTable', 'Monitoring::GLPlugin::SNMP::TableItem'],
  ]);
  foreach (qw(modules fans powersupplies)) {
    $self->get_snmp_tables('HUAWEI-ENTITY-EXTENT-MIB', [
      ['entitystates', 'hwEntityStateTable',
      'Monitoring::GLPlugin::SNMP::TableItem'],
    ]);
    $self->merge_tables($_, "entitystates");
  }
  $self->merge_tables_with_code("fans", "fanstates", sub {
    my $fan = shift;
    my $fanstate = shift;
    return ($fan->{entPhysicalName} eq sprintf("FAN %d/%d",
        $fanstate->{hwEntityFanSlot}, $fanstate->{hwEntityFanSn})) ? 1 : 0;
  });
}


package Classes::Huawei::Component::EnvironmentalSubsystem::Fan;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'fan %s is %s, state is %s, admin status is %s, oper status is %s',
      $self->{entPhysicalName}, $self->{hwEntityFanPresent},
      $self->{hwEntityFanState},
      $self->{hwEntityAdminStatus}, $self->{hwEntityOperStatus});
  if ($self->{hwEntityFanPresent} eq 'present') {
    if ($self->{hwEntityFanState} ne 'normal') {
      $self->add_warning();
    }
    $self->add_perfdata(
        label => 'rpm_'.$self->{entPhysicalName},
        value => $self->{hwEntityFanSpeed},
        uom => '%',
    );
  }
}

package Classes::Huawei::Component::EnvironmentalSubsystem::Powersupply;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'powersupply %s has admin status is %s, oper status is %s',
      $self->{entPhysicalName},
      $self->{hwEntityAdminStatus}, $self->{hwEntityOperStatus});
  if ($self->{hwEntityOperStatus} eq 'down' ||
      $self->{hwEntityOperStatus} eq 'offline') {
    $self->add_warning();
  }
}

package Classes::Huawei::Component::EnvironmentalSubsystem::Module;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{name} = $self->{entPhysicalName};
}

sub check {
  my $self = shift;
  #my $id = shift;
  $self->add_info(sprintf 'module %s admin status is %s, oper status is %s',
      $self->{name}, $self->{hwEntityAdminStatus}, $self->{hwEntityOperStatus});
  $self->add_info(sprintf 'module %s temperature is %.2f',
      $self->{name}, $self->{hwEntityTemperature});
  $self->set_thresholds(
      metric => 'temp_'.$self->{name},
      warning => $self->{hwEntityTemperatureLowThreshold}.':'.$self->{hwEntityTemperatureThreshold},
      critical => $self->{hwEntityTemperatureLowThreshold}.':'.$self->{hwEntityTemperatureThreshold},
  );
  $self->add_message(
      $self->check_thresholds(
          metric => 'temp_'.$self->{name},
          value => $self->{hwEntityTemperature}
  ));
  $self->add_perfdata(
      label => 'temp_'.$self->{name},
      value => $self->{hwEntityTemperature},
  );
  $self->add_info(sprintf 'module %s fault light is %s',
      $self->{name}, $self->{hwEntityFaultLight});
}


package Classes::Huawei::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('ENTITY-MIB', [
    ['entities', 'entPhysicalTable', 'Classes::Huawei::Component::CpuSubsystem::Cpu', sub { my $o = shift; $o->{entPhysicalClass} eq 'module' }, ['entPhysicalClass', 'entPhysicalDescr', 'entPhysicalName']],
  ]);
  $self->get_snmp_tables('HUAWEI-ENTITY-EXTENT-MIB', [
    ['entitystates', 'hwEntityStateTable', 'Monitoring::GLPlugin::SNMP::TableItem', undef, ['hwEntityCpuUsage', 'hwEntityCpuUsageThreshold']],
  ]);
  $self->merge_tables("entities", "entitystates");
}


package Classes::Huawei::Component::CpuSubsystem::Cpu;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{name} = $self->{entPhysicalName};
}

sub check {
  my $self = shift;
  my $id = shift;
  $self->add_info(sprintf 'CPU %s usage is %s%%',
      $self->{name}, $self->{hwEntityCpuUsage});
  $self->set_thresholds(
      metric => 'cpu_'.$self->{name},
      warning => $self->{hwEntityCpuUsageThreshold},
      critical => $self->{hwEntityCpuUsageThreshold},
  );
  $self->add_message(
      $self->check_thresholds(
          metric => 'cpu_'.$self->{name},
          value => $self->{hwEntityCpuUsage}
  ));
  $self->add_perfdata(
      label => 'cpu_'.$self->{name},
      value => $self->{hwEntityCpuUsage},
      uom => '%',
  );
}

package Classes::Huawei::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('ENTITY-MIB', [
    ['entities', 'entPhysicalTable', 'Classes::Huawei::Component::MemSubsystem::Mem', sub { my $o = shift; $o->{entPhysicalClass} eq 'module' }, ['entPhysicalClass', 'entPhysicalDescr', 'entPhysicalName']],
  ]);
  $self->get_snmp_tables('HUAWEI-ENTITY-EXTENT-MIB', [
    ['entitystates', 'hwEntityStateTable', 'Monitoring::GLPlugin::SNMP::TableItem', undef, ['hwEntityMemUsage', 'hwEntityMemUsageThreshold', 'hwEntityMemSizeMega']],
  ]);
  $self->merge_tables("entities", "entitystates");
}


package Classes::Huawei::Component::MemSubsystem::Mem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{name} = $self->{entPhysicalName};
}

sub check {
  my $self = shift;
  my $id = shift;
  $self->add_info(sprintf 'Memory %s usage is %s%% (of %dMB)',
      $self->{name}, $self->{hwEntityMemUsage}, $self->{hwEntityMemSizeMega});
  $self->set_thresholds(
      metric => 'cpu_'.$self->{name},
      warning => $self->{hwEntityMemUsageThreshold},
      critical => $self->{hwEntityMemUsageThreshold},
  );
  $self->add_message(
      $self->check_thresholds(
          metric => 'cpu_'.$self->{name},
          value => $self->{hwEntityMemUsage}
  ));
  $self->add_perfdata(
      label => 'cpu_'.$self->{name},
      value => $self->{hwEntityMemUsage},
      uom => '%',
  );
}

package Classes::Huawei::CloudEngine;
our @ISA = qw(Classes::Huawei);
use strict;

sub init {
  my $self = shift;
my $work_in_progress = {
#$Monitoring::GLPlugin::SNMP::MibsAndOids::mibs_and_oids->{'HUAWEI-ENTITY-EXTENT-MIB'} = {
    hwEntityExtentMIB => '1.3.6.1.4.1.2011.5.25.31',
    hwEntityExtObjects => '1.3.6.1.4.1.2011.5.25.31.1',
    hwEntityState => '1.3.6.1.4.1.2011.5.25.31.1.1',
    hwEntityStateTable => '1.3.6.1.4.1.2011.5.25.31.1.1.1',
    hwEntityStateEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1',
    hwEntityAdminStatus => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.1',
    hwEntityAdminStatusDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::HwAdminState',
    hwEntityOperStatus => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.2',
    hwEntityOperStatusDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::HwOperState',
    hwEntityStandbyStatus => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.3',
    hwEntityStandbyStatusDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::HwStandbyStatus',
    hwEntityAlarmLight => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.4',
    hwEntityCpuUsage => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.5',
    hwEntityCpuUsageThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.6',
    hwEntityMemUsage => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.7',
    hwEntityMemUsageThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.8',
    hwEntityMemSize => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.9',
    hwEntityUpTime => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.10',
    hwEntityTemperature => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.11',
    hwEntityTemperatureThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.12',
    hwEntityVoltage => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.13',
    hwEntityVoltageLowThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.14',
    hwEntityVoltageHighThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.15',
    hwEntityTemperatureLowThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.16',
    hwEntityOpticalPower => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.17',
    hwEntityCurrent => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.18',
    hwEntityMemSizeMega => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.19',
    hwEntityPortType => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.20',
    hwEntityPortTypeDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityPortType',
    hwEntityDuplex => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.21',
    hwEntityDuplexDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityDuplex',
    hwEntityOpticalPowerRx => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.22',
    hwEntityCpuUsageLowThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.23',
    hwEntityBoardPower => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.24',
    hwEntityCpuFrequency => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.25',
    hwEntitySupportFlexCard => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.26',
    hwEntitySupportFlexCardDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntitySupportFlexCard',
    hwEntityBoardClass => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.27',
    hwEntityBoardClassDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityBoardClass',
    hwNseOpmStatus => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.28',
    hwEntityCpuMaxUsage => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.29',
    hwEntityCPUType => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.30',
    hwEntityMemoryType => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.31',
    hwEntityFlashSize => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.32',
    hwEntityIfUpTimes => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.33',
    hwEntityIfDownTimes => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.34',
    hwEntityCPUAvgUsage => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.35',
    hwEntityMemoryAvgUsage => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.36',
    hwEntityMemUsed => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.37',
    hwEntityTotalFanNum => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.38',
    hwEntityNomalFanNum => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.39',
    hwEntityTotalPwrNum => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.40',
    hwEntityNomalPwrNum => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.41',
    hwEntityFaultLight => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.42',
    hwEntityFaultLightDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityFaultLight',
    hwEntityBoardName => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.43',
    hwEntityBoardDescription => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.44',
    hwEntity5MinCpuUsage => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.45',
    hwEntityStartMode => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.46',
    hwEntityStartModeDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityStartMode',
    hwEntitySplitAttribute => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.47',
    hwEntityFaultLightKeepTime => '1.3.6.1.4.1.2011.5.25.31.1.1.1.1.48',
    hwRUModuleInfoTable => '1.3.6.1.4.1.2011.5.25.31.1.1.2',
    hwRUModuleInfoEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.2.1',
    hwEntityBomId => '1.3.6.1.4.1.2011.5.25.31.1.1.2.1.1',
    hwEntityBomEnDesc => '1.3.6.1.4.1.2011.5.25.31.1.1.2.1.2',
    hwEntityBomLocalDesc => '1.3.6.1.4.1.2011.5.25.31.1.1.2.1.3',
    hwEntityManufacturedDate => '1.3.6.1.4.1.2011.5.25.31.1.1.2.1.4',
    hwEntityManufactureCode => '1.3.6.1.4.1.2011.5.25.31.1.1.2.1.5',
    hwEntityCLEICode => '1.3.6.1.4.1.2011.5.25.31.1.1.2.1.6',
    hwEntityUpdateLog => '1.3.6.1.4.1.2011.5.25.31.1.1.2.1.7',
    hwEntityArchivesInfoVersion => '1.3.6.1.4.1.2011.5.25.31.1.1.2.1.8',
    hwEntityOpenBomId => '1.3.6.1.4.1.2011.5.25.31.1.1.2.1.9',
    hwEntityIssueNum => '1.3.6.1.4.1.2011.5.25.31.1.1.2.1.10',
    hwEntityBoardType => '1.3.6.1.4.1.2011.5.25.31.1.1.2.1.11',
    hwOpticalModuleInfoTable => '1.3.6.1.4.1.2011.5.25.31.1.1.3',
    hwOpticalModuleInfoEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1',
    hwEntityOpticalMode => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.1',
    hwEntityOpticalModeDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityOpticalMode',
    hwEntityOpticalWaveLength => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.2',
    hwEntityOpticalTransDistance => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.3',
    hwEntityOpticalVendorSn => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.4',
    hwEntityOpticalTemperature => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.5',
    hwEntityOpticalVoltage => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.6',
    hwEntityOpticalBiasCurrent => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.7',
    hwEntityOpticalRxPower => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.8',
    hwEntityOpticalTxPower => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.9',
    hwEntityOpticalType => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.10',
    hwEntityOpticalTypeDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityOpticalType',
    hwEntityOpticalTransBW => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.11',
    hwEntityOpticalFiberType => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.12',
    hwEntityOpticalFiberTypeDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityOpticalFiberType',
    hwEntityOpticalRxLowThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.13',
    hwEntityOpticalRxHighThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.14',
    hwEntityOpticalTxLowThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.15',
    hwEntityOpticalTxHighThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.16',
    hwEntityOpticalPlug => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.17',
    hwEntityOpticalPlugDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityOpticalPlug',
    hwEntityOpticalDirectionType => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.18',
    hwEntityOpticalDirectionTypeDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityOpticalDirectionType',
    hwEntityOpticalUserEeprom => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.19',
    hwEntityOpticalRxLowWarnThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.20',
    hwEntityOpticalRxHighWarnThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.21',
    hwEntityOpticalTxLowWarnThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.22',
    hwEntityOpticalTxHighWarnThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.23',
    hwEntityOpticalVenderName => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.24',
    hwEntityOpticalVenderPn => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.25',
    hwEntityOpticalAuthenticationStatus => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.26',
    hwEntityOpticalAuthenticationStatusDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityOpticalAuthenticationStatus',
    hwEntityOpticalTunableType => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.27',
    hwEntityOpticalTunableTypeDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityOpticalTunableType',
    hwEntityOpticalWaveLengthDecimal => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.28',
    hwEntityOpticalTunableModuleChannel => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.29',
    hwEntityOpticalWaveBand => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.30',
    hwEntityOpticalWaveBandDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityOpticalWaveBand',
    hwEntityOpticalLaneBiasCurrent => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.31',
    hwEntityOpticalLaneRxPower => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.32',
    hwEntityOpticalLaneTxPower => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.33',
    hwEntityOpticalVendorOUI => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.34',
    hwEntityOpticalVendorRev => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.35',
    hwEntityOpticalGponSN => '1.3.6.1.4.1.2011.5.25.31.1.1.3.1.36',
    hwMonitorInputTable => '1.3.6.1.4.1.2011.5.25.31.1.1.4',
    hwMonitorInputEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.4.1',
    hwMonitorInputIndex => '1.3.6.1.4.1.2011.5.25.31.1.1.4.1.1',
    hwMonitorInputName => '1.3.6.1.4.1.2011.5.25.31.1.1.4.1.2',
    hwMonitorInputState => '1.3.6.1.4.1.2011.5.25.31.1.1.4.1.3',
    hwMonitorInputStateEnable => '1.3.6.1.4.1.2011.5.25.31.1.1.4.1.4',
    hwMonitorInputRowStatus => '1.3.6.1.4.1.2011.5.25.31.1.1.4.1.5',
    hwMonitorOutputTable => '1.3.6.1.4.1.2011.5.25.31.1.1.5',
    hwMonitorOutputEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.5.1',
    hwMonitorOutputIndex => '1.3.6.1.4.1.2011.5.25.31.1.1.5.1.1',
    hwMonitorOutputRuleIndex => '1.3.6.1.4.1.2011.5.25.31.1.1.5.1.2',
    hwMonitorOutputMask => '1.3.6.1.4.1.2011.5.25.31.1.1.5.1.3',
    hwMonitorOutputKey => '1.3.6.1.4.1.2011.5.25.31.1.1.5.1.4',
    hwMonitorOutputRowStatus => '1.3.6.1.4.1.2011.5.25.31.1.1.5.1.5',
    hwEntPowerUsedInfoTable => '1.3.6.1.4.1.2011.5.25.31.1.1.6',
    hwEntPowerUsedInfoEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.6.1',
    hwEntPowerUsedInfoBoardName => '1.3.6.1.4.1.2011.5.25.31.1.1.6.1.1',
    hwEntPowerUsedInfoBoardType => '1.3.6.1.4.1.2011.5.25.31.1.1.6.1.2',
    hwEntPowerUsedInfoBoardSlot => '1.3.6.1.4.1.2011.5.25.31.1.1.6.1.3',
    hwEntPowerUsedInfoPower => '1.3.6.1.4.1.2011.5.25.31.1.1.6.1.4',
    hwVirtualCableTestTable => '1.3.6.1.4.1.2011.5.25.31.1.1.7',
    hwVirtualCableTestEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.7.1',
    hwVirtualCableTestIfIndex => '1.3.6.1.4.1.2011.5.25.31.1.1.7.1.1',
    hwVirtualCableTestPairStatus => '1.3.6.1.4.1.2011.5.25.31.1.1.7.1.2',
    hwVirtualCableTestPairStatusDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwVirtualCableTestPairStatus',
    hwVirtualCableTestPairLength => '1.3.6.1.4.1.2011.5.25.31.1.1.7.1.3',
    hwVirtualCableTestOperation => '1.3.6.1.4.1.2011.5.25.31.1.1.7.1.4',
    hwVirtualCableTestOperationDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwVirtualCableTestOperation',
    hwVirtualCableTestLastTime => '1.3.6.1.4.1.2011.5.25.31.1.1.7.1.5',
    hwVirtualCableTestPairAStatus => '1.3.6.1.4.1.2011.5.25.31.1.1.7.1.6',
    hwVirtualCableTestPairAStatusDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwVirtualCableTestPairAStatus',
    hwVirtualCableTestPairBStatus => '1.3.6.1.4.1.2011.5.25.31.1.1.7.1.7',
    hwVirtualCableTestPairBStatusDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwVirtualCableTestPairBStatus',
    hwVirtualCableTestPairCStatus => '1.3.6.1.4.1.2011.5.25.31.1.1.7.1.8',
    hwVirtualCableTestPairCStatusDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwVirtualCableTestPairCStatus',
    hwVirtualCableTestPairDStatus => '1.3.6.1.4.1.2011.5.25.31.1.1.7.1.9',
    hwVirtualCableTestPairDStatusDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwVirtualCableTestPairDStatus',
    hwVirtualCableTestPairALength => '1.3.6.1.4.1.2011.5.25.31.1.1.7.1.10',
    hwVirtualCableTestPairBLength => '1.3.6.1.4.1.2011.5.25.31.1.1.7.1.11',
    hwVirtualCableTestPairCLength => '1.3.6.1.4.1.2011.5.25.31.1.1.7.1.12',
    hwVirtualCableTestPairDLength => '1.3.6.1.4.1.2011.5.25.31.1.1.7.1.13',
    hwTemperatureThresholdTable => '1.3.6.1.4.1.2011.5.25.31.1.1.8',
    hwTemperatureThresholdEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.8.1',
    hwEntityTempSlotId => '1.3.6.1.4.1.2011.5.25.31.1.1.8.1.1',
    hwEntityTempI2CId => '1.3.6.1.4.1.2011.5.25.31.1.1.8.1.2',
    hwEntityTempAddr => '1.3.6.1.4.1.2011.5.25.31.1.1.8.1.3',
    hwEntityTempChannel => '1.3.6.1.4.1.2011.5.25.31.1.1.8.1.4',
    hwEntityTempStatus => '1.3.6.1.4.1.2011.5.25.31.1.1.8.1.5',
    hwEntityTempStatusDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityTempStatus',
    hwEntityTempValue => '1.3.6.1.4.1.2011.5.25.31.1.1.8.1.6',
    hwEntityTempMinorAlmThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.8.1.7',
    hwEntityTempMajorAlmThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.8.1.8',
    hwEntityTempFatalAlmThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.8.1.9',
    hwVoltageInfoTable => '1.3.6.1.4.1.2011.5.25.31.1.1.9',
    hwVoltageInfoEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.9.1',
    hwEntityVolSlot => '1.3.6.1.4.1.2011.5.25.31.1.1.9.1.1',
    hwEntityVolI2CId => '1.3.6.1.4.1.2011.5.25.31.1.1.9.1.2',
    hwEntityVolAddr => '1.3.6.1.4.1.2011.5.25.31.1.1.9.1.3',
    hwEntityVolChannel => '1.3.6.1.4.1.2011.5.25.31.1.1.9.1.4',
    hwEntityVolStatus => '1.3.6.1.4.1.2011.5.25.31.1.1.9.1.5',
    hwEntityVolStatusDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityVolStatus',
    hwEntityVolRequired => '1.3.6.1.4.1.2011.5.25.31.1.1.9.1.6',
    hwEntityVolCurValue => '1.3.6.1.4.1.2011.5.25.31.1.1.9.1.7',
    hwEntityVolRatio => '1.3.6.1.4.1.2011.5.25.31.1.1.9.1.8',
    hwEntityVolLowAlmMajor => '1.3.6.1.4.1.2011.5.25.31.1.1.9.1.9',
    hwEntityVolLowAlmFatal => '1.3.6.1.4.1.2011.5.25.31.1.1.9.1.10',
    hwEntityVolHighAlmMajor => '1.3.6.1.4.1.2011.5.25.31.1.1.9.1.11',
    hwEntityVolHighAlmFatal => '1.3.6.1.4.1.2011.5.25.31.1.1.9.1.12',
    hwFanStatusTable => '1.3.6.1.4.1.2011.5.25.31.1.1.10',
    hwFanStatusEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.10.1',
    hwEntityFanSlot => '1.3.6.1.4.1.2011.5.25.31.1.1.10.1.1',
    hwEntityFanSn => '1.3.6.1.4.1.2011.5.25.31.1.1.10.1.2',
    hwEntityFanReg => '1.3.6.1.4.1.2011.5.25.31.1.1.10.1.3',
    hwEntityFanRegDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityFanReg',
    hwEntityFanSpdAdjMode => '1.3.6.1.4.1.2011.5.25.31.1.1.10.1.4',
    hwEntityFanSpdAdjModeDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityFanSpdAdjMode',
    hwEntityFanSpeed => '1.3.6.1.4.1.2011.5.25.31.1.1.10.1.5',
    hwEntityFanPresent => '1.3.6.1.4.1.2011.5.25.31.1.1.10.1.6',
    hwEntityFanPresentDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityFanPresent',
    hwEntityFanState => '1.3.6.1.4.1.2011.5.25.31.1.1.10.1.7',
    hwEntityFanStateDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityFanState',
    hwEntityFanDesc => '1.3.6.1.4.1.2011.5.25.31.1.1.10.1.8',
    hwEntityGlobalPara => '1.3.6.1.4.1.2011.5.25.31.1.1.11',
    hwEntityServiceType => '1.3.6.1.4.1.2011.5.25.31.1.1.11.1',
    hwEntityServiceTypeDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityServiceType',
    hwDeviceServiceType => '1.3.6.1.4.1.2011.5.25.31.1.1.11.2',
    hwEntityManufacturerOUI => '1.3.6.1.4.1.2011.5.25.31.1.1.11.3',
    hwPortBip8StatisticsTable => '1.3.6.1.4.1.2011.5.25.31.1.1.12',
    hwPortBip8StatisticsEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.12.1',
    hwPhysicalPortBip8StatisticsEB => '1.3.6.1.4.1.2011.5.25.31.1.1.12.1.1',
    hwPhysicalPortBip8StatisticsES => '1.3.6.1.4.1.2011.5.25.31.1.1.12.1.2',
    hwPhysicalPortBip8StatisticsSES => '1.3.6.1.4.1.2011.5.25.31.1.1.12.1.3',
    hwPhysicalPortBip8StatisticsUAS => '1.3.6.1.4.1.2011.5.25.31.1.1.12.1.4',
    hwPhysicalPortBip8StatisticsBBE => '1.3.6.1.4.1.2011.5.25.31.1.1.12.1.5',
    hwPhysicalPortSpeed => '1.3.6.1.4.1.2011.5.25.31.1.1.12.1.6',
    hwStorageEntTable => '1.3.6.1.4.1.2011.5.25.31.1.1.13',
    hwStorageEntEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.13.1',
    hwStorageEntIndex => '1.3.6.1.4.1.2011.5.25.31.1.1.13.1.1',
    hwStorageEntType => '1.3.6.1.4.1.2011.5.25.31.1.1.13.1.2',
    hwStorageEntSpace => '1.3.6.1.4.1.2011.5.25.31.1.1.13.1.3',
    hwStorageEntSpaceFree => '1.3.6.1.4.1.2011.5.25.31.1.1.13.1.4',
    hwStorageEntName => '1.3.6.1.4.1.2011.5.25.31.1.1.13.1.5',
    hwStorageEntDescr => '1.3.6.1.4.1.2011.5.25.31.1.1.13.1.6',
    hwSystemPowerTable => '1.3.6.1.4.1.2011.5.25.31.1.1.14',
    hwSystemPowerEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.14.1',
    hwSystemPowerDeviceID => '1.3.6.1.4.1.2011.5.25.31.1.1.14.1.1',
    hwSystemPowerTotalPower => '1.3.6.1.4.1.2011.5.25.31.1.1.14.1.2',
    hwSystemPowerUsedPower => '1.3.6.1.4.1.2011.5.25.31.1.1.14.1.3',
    hwSystemPowerRemainPower => '1.3.6.1.4.1.2011.5.25.31.1.1.14.1.4',
    hwSystemPowerReservedPower => '1.3.6.1.4.1.2011.5.25.31.1.1.14.1.5',
    hwBatteryInfoTable => '1.3.6.1.4.1.2011.5.25.31.1.1.15',
    hwBatteryInfoEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.15.1',
    hwBatteryState => '1.3.6.1.4.1.2011.5.25.31.1.1.15.1.1',
    hwBatteryStateDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwBatteryState',
    hwBatteryTemperatureLow => '1.3.6.1.4.1.2011.5.25.31.1.1.15.1.2',
    hwBatteryTemperatureHigh => '1.3.6.1.4.1.2011.5.25.31.1.1.15.1.3',
    hwBatteryRemainPercent => '1.3.6.1.4.1.2011.5.25.31.1.1.15.1.4',
    hwBatteryRemainTime => '1.3.6.1.4.1.2011.5.25.31.1.1.15.1.5',
    hwBatteryElecTimes => '1.3.6.1.4.1.2011.5.25.31.1.1.15.1.6',
    hwBatteryLifeThreshold => '1.3.6.1.4.1.2011.5.25.31.1.1.15.1.7',
    hwGPSLocationInfo => '1.3.6.1.4.1.2011.5.25.31.1.1.16',
    hwGPSLongitude => '1.3.6.1.4.1.2011.5.25.31.1.1.16.1',
    hwGPSLatitude => '1.3.6.1.4.1.2011.5.25.31.1.1.16.2',
    hwGPSVelocity => '1.3.6.1.4.1.2011.5.25.31.1.1.16.3',
    hwAdmPortTable => '1.3.6.1.4.1.2011.5.25.31.1.1.17',
    hwAdmPortEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.17.1',
    hwAdmPortDescription => '1.3.6.1.4.1.2011.5.25.31.1.1.17.1.1',
    hwPwrStatusTable => '1.3.6.1.4.1.2011.5.25.31.1.1.18',
    hwPwrStatusEntry => '1.3.6.1.4.1.2011.5.25.31.1.1.18.1',
    hwEntityPwrSlot => '1.3.6.1.4.1.2011.5.25.31.1.1.18.1.1',
    hwEntityPwrSn => '1.3.6.1.4.1.2011.5.25.31.1.1.18.1.2',
    hwEntityPwrReg => '1.3.6.1.4.1.2011.5.25.31.1.1.18.1.3',
    hwEntityPwrRegDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityPwrReg',
    hwEntityPwrMode => '1.3.6.1.4.1.2011.5.25.31.1.1.18.1.4',
    hwEntityPwrModeDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityPwrMode',
    hwEntityPwrPresent => '1.3.6.1.4.1.2011.5.25.31.1.1.18.1.5',
    hwEntityPwrPresentDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityPwrPresent',
    hwEntityPwrState => '1.3.6.1.4.1.2011.5.25.31.1.1.18.1.6',
    hwEntityPwrStateDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityPwrState',
    hwEntityPwrCurrent => '1.3.6.1.4.1.2011.5.25.31.1.1.18.1.7',
    hwEntityPwrVoltage => '1.3.6.1.4.1.2011.5.25.31.1.1.18.1.8',
    hwEntityPwrDesc => '1.3.6.1.4.1.2011.5.25.31.1.1.18.1.9',
    hwEntityPhysicalSpecTable => '1.3.6.1.4.1.2011.5.25.31.1.2',
    hwEntityPhysicalSpecRack => '1.3.6.1.4.1.2011.5.25.31.1.2.1',
    hwEntityPhysicalSpecFrame => '1.3.6.1.4.1.2011.5.25.31.1.2.2',
    hwEntityPhysicalSpecSlot => '1.3.6.1.4.1.2011.5.25.31.1.2.3',
    hwEntityPhysicalSpecBoard => '1.3.6.1.4.1.2011.5.25.31.1.2.4',
    hwEntityPhysicalSpecSubSlot => '1.3.6.1.4.1.2011.5.25.31.1.2.5',
    hwEntityPhysicalSpecSubBoard => '1.3.6.1.4.1.2011.5.25.31.1.2.6',
    hwEntityPhysicalSpecPort => '1.3.6.1.4.1.2011.5.25.31.1.2.7',
    hwEntityPhysicalSpecEmu => '1.3.6.1.4.1.2011.5.25.31.1.2.8',
    hwEntityPhysicalSpecPowerframe => '1.3.6.1.4.1.2011.5.25.31.1.2.9',
    hwEntityPhysicalSpecPowermodule => '1.3.6.1.4.1.2011.5.25.31.1.2.10',
    hwEntityPhysicalSpecBattery => '1.3.6.1.4.1.2011.5.25.31.1.2.11',
    hwEntityExtTraps => '1.3.6.1.4.1.2011.5.25.31.2',
    hwEntityExtTrapsPrefix => '1.3.6.1.4.1.2011.5.25.31.2.0',
    hwEntityExtTrapObject => '1.3.6.1.4.1.2011.5.25.31.2.1',
    hwEntityExtTrapBaseSoftwareVersion => '1.3.6.1.4.1.2011.5.25.31.2.1.1',
    hwEntityExtTrapBoardSoftwareVersion => '1.3.6.1.4.1.2011.5.25.31.2.1.2',
    hwPhysicalName => '1.3.6.1.4.1.2011.5.25.31.2.1.3',
    hwEntityExtTrap => '1.3.6.1.4.1.2011.5.25.31.2.2',
    hwDevicePowerInfoObjects => '1.3.6.1.4.1.2011.5.25.31.3',
    hwDevicePowerInfoTotalPower => '1.3.6.1.4.1.2011.5.25.31.3.1',
    hwDevicePowerInfoUsedPower => '1.3.6.1.4.1.2011.5.25.31.3.2',
    hwEntityExtConformance => '1.3.6.1.4.1.2011.5.25.31.4',
    hwEntityExtCompliances => '1.3.6.1.4.1.2011.5.25.31.4.1',
    hwEntityExtGroups => '1.3.6.1.4.1.2011.5.25.31.4.2',
    hwPnpObjects => '1.3.6.1.4.1.2011.5.25.31.5',
    hwPnpInfo => '1.3.6.1.4.1.2011.5.25.31.5.1',
    hwHardwareCapaSequenceNo => '1.3.6.1.4.1.2011.5.25.31.5.1.1',
    hwAlarmPnPSequenceNo => '1.3.6.1.4.1.2011.5.25.31.5.1.2',
    hwPnpTraps => '1.3.6.1.4.1.2011.5.25.31.5.2',
    hwPnpOperateTable => '1.3.6.1.4.1.2011.5.25.31.5.3',
    hwPnpOperateEntry => '1.3.6.1.4.1.2011.5.25.31.5.3.1',
    hwFileGeneIndex => '1.3.6.1.4.1.2011.5.25.31.5.3.1.1',
    hwFileGeneOperState => '1.3.6.1.4.1.2011.5.25.31.5.3.1.2',
    hwFileGeneOperStateDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwFileGeneOperState',
    hwFileGeneResourceType => '1.3.6.1.4.1.2011.5.25.31.5.3.1.3',
    hwFileGeneResourceTypeDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwFileGeneResourceType',
    hwFileGeneResourceID => '1.3.6.1.4.1.2011.5.25.31.5.3.1.4',
    hwFileGeneDestinationFile => '1.3.6.1.4.1.2011.5.25.31.5.3.1.5',
    hwFileGeneRowStatus => '1.3.6.1.4.1.2011.5.25.31.5.3.1.6',
    hwSystemGlobalObjects => '1.3.6.1.4.1.2011.5.25.31.6',
    hwEntitySystemNetID => '1.3.6.1.4.1.2011.5.25.31.6.1',
    hwEntitySoftwareName => '1.3.6.1.4.1.2011.5.25.31.6.2',
    hwEntitySoftwareVersion => '1.3.6.1.4.1.2011.5.25.31.6.3',
    hwEntitySoftwareVendor => '1.3.6.1.4.1.2011.5.25.31.6.4',
    hwEntitySystemModel => '1.3.6.1.4.1.2011.5.25.31.6.5',
    hwEntitySystemTime => '1.3.6.1.4.1.2011.5.25.31.6.6',
    hwEntitySystemMacAddress => '1.3.6.1.4.1.2011.5.25.31.6.7',
    hwEntitySystemReset => '1.3.6.1.4.1.2011.5.25.31.6.8',
    hwEntitySystemResetDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntitySystemReset',
    hwEntitySystemHealthInterval => '1.3.6.1.4.1.2011.5.25.31.6.9',
    hwEntitySystemNEId => '1.3.6.1.4.1.2011.5.25.31.6.10',
    hwEntitySystemServiceType => '1.3.6.1.4.1.2011.5.25.31.6.11',
    hwHeartbeatObjects => '1.3.6.1.4.1.2011.5.25.31.7',
    hwHeartbeatConfig => '1.3.6.1.4.1.2011.5.25.31.7.1',
    hwEntityHeartbeatOnOff => '1.3.6.1.4.1.2011.5.25.31.7.1.1',
    hwEntityHeartbeatOnOffDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwEntityHeartbeatOnOff',
    hwEntityHeartbeatPeriod => '1.3.6.1.4.1.2011.5.25.31.7.1.2',
    hwHeartbeatTrapPrefix => '1.3.6.1.4.1.2011.5.25.31.7.2',
    hwPreDisposeObjects => '1.3.6.1.4.1.2011.5.25.31.8',
    hwPreDisposeInfo => '1.3.6.1.4.1.2011.5.25.31.8.1',
    hwPreDisposeSequenceNo => '1.3.6.1.4.1.2011.5.25.31.8.1.1',
    hwPreDisposedTraps => '1.3.6.1.4.1.2011.5.25.31.8.2',
    hwPreDisposeConfigTable => '1.3.6.1.4.1.2011.5.25.31.8.3',
    hwPreDisposeConfigEntry => '1.3.6.1.4.1.2011.5.25.31.8.3.1',
    hwDisposeSlot => '1.3.6.1.4.1.2011.5.25.31.8.3.1.1',
    hwDisposeCardId => '1.3.6.1.4.1.2011.5.25.31.8.3.1.2',
    hwDisposeSbom => '1.3.6.1.4.1.2011.5.25.31.8.3.1.3',
    hwDisposeRowStatus => '1.3.6.1.4.1.2011.5.25.31.8.3.1.4',
    hwDisposeOperState => '1.3.6.1.4.1.2011.5.25.31.8.3.1.5',
    hwDisposeOperStateDefinition => 'HUAWEI-ENTITY-EXTENT-MIB::hwDisposeOperState',
    hwPreDisposeEntInfoTable => '1.3.6.1.4.1.2011.5.25.31.8.4',
    hwPreDisposeEntInfoEntry => '1.3.6.1.4.1.2011.5.25.31.8.4.1',
    hwDisposeEntPhysicalIndex => '1.3.6.1.4.1.2011.5.25.31.8.4.1.1',
    hwDisposeEntPhysicalDescr => '1.3.6.1.4.1.2011.5.25.31.8.4.1.2',
    hwDisposeEntPhysicalVendorType => '1.3.6.1.4.1.2011.5.25.31.8.4.1.3',
    hwDisposeEntPhysicalContainedIn => '1.3.6.1.4.1.2011.5.25.31.8.4.1.4',
    hwDisposeEntPhysicalClass => '1.3.6.1.4.1.2011.5.25.31.8.4.1.5',
    hwDisposeEntPhysicalParentRelPos => '1.3.6.1.4.1.2011.5.25.31.8.4.1.6',
    hwDisposeEntPhysicalName => '1.3.6.1.4.1.2011.5.25.31.8.4.1.7',
    hwOSPUnifyManageObjects => '1.3.6.1.4.1.2011.5.25.31.9',
    hwEntityExtOSPTrapsPrefix => '1.3.6.1.4.1.2011.5.25.31.9.1',
};

my $definitions_work_in_progress = {
#$Monitoring::GLPlugin::SNMP::MibsAndOids::definitions->{'HUAWEI-ENTITY-EXTENT-MIB'} = {
    HwAdminState => {
      '1' => 'notSupported',
      '2' => 'locked',
      '3' => 'shuttingDown',
      '4' => 'unlocked',
      '11' => 'up',
      '12' => 'down',
      '13' => 'loopback',
    },
    HwOperState => {
      '1' => 'notSupported',
      '2' => 'disabled',
      '3' => 'enabled',
      '4' => 'offline',
      '11' => 'up',
      '12' => 'down',
      '13' => 'connect',
      '15' => 'protocolUp',
      '16' => 'linkUp',
      '17' => 'linkDown',
    },
    HwStandbyStatus => {
      '1' => 'notSupported',
      '2' => 'hotStandby',
      '3' => 'coldStandby',
      '4' => 'providingService',
    },
    hwEntitySupportFlexCard => {
      '1' => 'notSupported',
      '2' => 'flexible',
      '3' => 'unflexible',
      '4' => 'dummy',
    },
    hwEntityDuplex => {
      '1' => 'notSupported',
      '2' => 'full',
      '3' => 'half',
    },
    hwEntityVolStatus => {
      '1' => 'normal',
      '2' => 'major',
      '3' => 'fatal',
    },
    hwDisposeOperState => {
      '1' => 'opSuccess',
      '2' => 'opInProgress',
      '3' => 'opDevNotSupportPredispose',
      '4' => 'opCardNotSupportPredispose',
      '5' => 'opAlreadyPredispose',
      '6' => 'opCardConflict',
      '7' => 'opDevOperationError',
    },
    hwEntityFanReg => {
      '1' => 'yes',
      '2' => 'no',
    },
    hwVirtualCableTestPairAStatus => {
      '1' => 'normal',
      '2' => 'abnormalOpen',
      '3' => 'abnormalShort',
      '4' => 'abnormalOpenShort',
      '5' => 'abnormalCrossTalk',
      '6' => 'unknown',
      '7' => 'notSupport',
    },
    hwFileGeneResourceType => {
      '1' => 'pnpcard',
      '2' => 'pnpsubcard',
      '3' => 'pnphardcapability',
      '4' => 'pnpPreDisposeCapability',
      '5' => 'pnpframe',
      '6' => 'pnpdevtype',
      '7' => 'pnpalarm',
    },
    hwEntityOpticalDirectionType => {
      '1' => 'notSupported',
      '2' => 'twoFiberBidirection',
      '3' => 'oneFiberBidirection',
      '4' => 'twoFiberTwoPortBidirection',
    },
    hwEntityPortType => {
      '1' => 'notSupported',
      '2' => 'copper',
      '3' => 'fiber100',
      '4' => 'fiber1000',
      '5' => 'fiber10000',
      '6' => 'opticalnotExist',
      '7' => 'optical',
    },
    hwEntityTempStatus => {
      '1' => 'normal',
      '2' => 'minor',
      '3' => 'major',
      '4' => 'fatal',
    },
    hwEntityOpticalFiberType => {
      '0' => 'unknown',
      '1' => 'sc',
      '2' => 'style1CopperConnector',
      '3' => 'style2CopperConnector',
      '4' => 'bncTnc',
      '5' => 'coaxialHeaders',
      '6' => 'fiberJack',
      '7' => 'lc',
      '8' => 'mtRj',
      '9' => 'mu',
      '10' => 'sg',
      '11' => 'opticalPigtail',
      '12' => 'mpo',
      '20' => 'hssdcII',
      '21' => 'copperPigtail',
    },
    hwEntityPwrState => {
      '1' => 'supply',
      '2' => 'notSupply',
      '3' => 'sleep',
      '4' => 'unknown',
    },
    hwEntityPwrPresent => {
      '1' => 'present',
      '2' => 'absent',
    },
    hwVirtualCableTestOperation => {
      '1' => 'startTest',
      '2' => 'resetTestValue',
      '3' => 'readyStartTest',
    },
    hwEntityStartMode => {
      '1' => 'notSupported',
      '2' => 'cold',
      '3' => 'warm',
      '4' => 'unknown',
    },
    hwFileGeneOperState => {
      '1' => 'opInProgress',
      '2' => 'opSuccess',
      '3' => 'opGetFileError',
      '4' => 'opInvalidDestName',
      '5' => 'opNoFlashSpace',
      '6' => 'opWriteFileError',
      '7' => 'opDestoryError',
    },
    hwEntityPwrMode => {
      '1' => 'unknown',
      '2' => 'dc',
      '3' => 'ac',
    },
    hwEntityOpticalPlug => {
      '0' => 'notSupported',
      '1' => 'true',
      '2' => 'false',
    },
    hwEntityFanState => {
      '1' => 'normal',
      '2' => 'abnormal',
    },
    hwEntityBoardClass => {
      '1' => 'notSupported',
      '2' => 'mpu',
      '3' => 'lpu',
      '4' => 'sfu',
      '5' => 'icu',
      '6' => 'ecu',
      '7' => 'fan',
      '8' => 'power',
      '9' => 'lcd',
      '10' => 'pmu',
      '11' => 'cmu',
    },
    hwVirtualCableTestPairCStatus => {
      '1' => 'normal',
      '2' => 'abnormalOpen',
      '3' => 'abnormalShort',
      '4' => 'abnormalOpenShort',
      '5' => 'abnormalCrossTalk',
      '6' => 'unknown',
      '7' => 'notSupport',
    },
    hwEntityPwrReg => {
      '1' => 'yes',
      '2' => 'no',
    },
    hwEntityFaultLight => {
      '1' => 'notSupported',
      '2' => 'normal',
      '3' => 'underRepair',
    },
    hwEntityFanPresent => {
      '1' => 'present',
      '2' => 'absent',
    },
    hwEntityFanSpdAdjMode => {
      '1' => 'auto',
      '2' => 'manual',
      '3' => 'unknown',
    },
    hwVirtualCableTestPairBStatus => {
      '1' => 'normal',
      '2' => 'abnormalOpen',
      '3' => 'abnormalShort',
      '4' => 'abnormalOpenShort',
      '5' => 'abnormalCrossTalk',
      '6' => 'unknown',
      '7' => 'notSupport',
    },
    hwEntitySystemReset => {
      '1' => 'normal',
      '2' => 'restart',
    },
    hwEntityOpticalAuthenticationStatus => {
      '0' => 'unknown',
      '1' => 'authenticated',
      '2' => 'unauthenticated',
    },
    hwEntityOpticalWaveBand => {
      '0' => 'unknown',
      '1' => 'clBand',
      '2' => 'cBand',
      '3' => 'lBand',
      '4' => 'c32Band',
      '5' => 'ramancBand',
      '6' => 'ramanlBand',
      '7' => 'cwdmBand',
      '8' => 'smcBand',
      '9' => 'c96bBand',
      '10' => 'c192bBand',
    },
    hwEntityOpticalMode => {
      '1' => 'notSupported',
      '2' => 'singleMode',
      '3' => 'multiMode5',
      '4' => 'multiMode6',
      '5' => 'noValue',
    },
    hwVirtualCableTestPairStatus => {
      '1' => 'normal',
      '2' => 'abnormalOpen',
      '3' => 'abnormalShort',
      '4' => 'abnormalOpenShort',
      '5' => 'abnormalCrossTalk',
      '6' => 'unknown',
      '7' => 'notSupport',
    },
    hwBatteryState => {
      '1' => 'charge',
      '2' => 'discharge',
      '3' => 'full',
      '4' => 'abnormal',
    },
    hwEntityServiceType => {
      '1' => 'sslvpn',
      '2' => 'firewall',
      '3' => 'loadBalance',
      '4' => 'ipsec',
      '5' => 'netstream',
      '6' => 'wlan',
    },
    hwEntityOpticalType => {
      '0' => 'unknown',
      '1' => 'sc',
      '2' => 'gbic',
      '3' => 'sfp',
      '4' => 'esfp',
      '5' => 'rj45',
      '6' => 'xfp',
      '7' => 'xenpak',
      '8' => 'transponder',
      '9' => 'cfp',
      '10' => 'smb',
      '11' => 'sfpplus',
      '12' => 'cxp',
      '13' => 'qsfp',
      '14' => 'qsfpplus',
      '15' => 'cfp2',
      '16' => 'dwdmsfp',
    },
    hwVirtualCableTestPairDStatus => {
      '1' => 'normal',
      '2' => 'abnormalOpen',
      '3' => 'abnormalShort',
      '4' => 'abnormalOpenShort',
      '5' => 'abnormalCrossTalk',
      '6' => 'unknown',
      '7' => 'notSupport',
    },
    hwEntityHeartbeatOnOff => {
      '1' => 'on',
      '2' => 'off',
    },
    hwEntityOpticalTunableType => {
      '1' => 'notSupported',
      '2' => 'notTunable',
      '3' => 'tunable',
      '4' => 'supportTunableType',
    },
};
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Huawei::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Huawei::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Huawei::Component::MemSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Huawei;
our @ISA = qw(Classes::Device);
use strict;

sub init {
  my $self = shift;
  my $sysobj = $self->get_snmp_object('MIB-2-MIB', 'sysObjectID', 0);
  if ($sysobj =~ /^\.*1\.3\.6\.1\.4\.1\.2011\.2\.239/) {
    bless $self, 'Classes::Huawei::CloudEngine';
    $self->debug('using Classes::Huawei::CloudEngine');
  }
  if (ref($self) ne "Classes::Huawei") {
    $self->init();
  }
}

package Classes::HP::Procurve::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('NETSWITCH-MIB', [
      ['mem', 'hpLocalMemTable', 'Classes::HP::Procurve::Component::MemSubsystem::Memory'],
  ]);
}

sub check {
  my $self = shift;
  $self->add_info('checking memory');
  if (scalar (@{$self->{mem}}) == 0) {
  } else {
    foreach (@{$self->{mem}}) {
      $_->check();
    }
  }
}


package Classes::HP::Procurve::Component::MemSubsystem::Memory;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->{usage} = $self->{hpLocalMemAllocBytes} / 
      $self->{hpLocalMemTotalBytes} * 100;
  $self->add_info(sprintf 'memory %s usage is %.2f',
      $self->{hpLocalMemSlotIndex}, $self->{usage});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{usage}));
  $self->add_perfdata(
      label => 'memory_'.$self->{hpLocalMemSlotIndex}.'_usage',
      value => $self->{usage},
      uom => '%',
  );
}

package Classes::HP::Procurve::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('STATISTICS-MIB', (qw(
      hpSwitchCpuStat)));
  if (! defined $self->{hpSwitchCpuStat}) {
    $self->get_snmp_objects('OLD-STATISTICS-MIB', (qw(
        hpSwitchCpuStat)));
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking cpus');
  $self->add_info(sprintf 'cpu usage is %.2f%%', $self->{hpSwitchCpuStat});
  $self->set_thresholds(warning => 80, critical => 90); # maybe lower, because the switching is done in hardware
  $self->add_message($self->check_thresholds($self->{hpSwitchCpuStat}));
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{hpSwitchCpuStat},
      uom => '%',
  );
}

package Classes::HP::Procurve::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->analyze_and_check_sensor_subsystem('Classes::HP::Procurve::Component::SensorSubsystem');
  if (! $self->check_messages()) {
    $self->add_ok("environmental hardware working fine");
  }
}


package Classes::HP::Procurve::Component::SensorSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('HP-ICF-CHASSIS-MIB', [
      ['sensors', 'hpicfSensorTable', 'Classes::HP::Procurve::Component::SensorSubsystem::Sensor'],
  ]);
}

sub check {
  my $self = shift;
  $self->add_info('checking sensors');
  if (scalar (@{$self->{sensors}}) == 0) {
    $self->add_ok('no sensors');
  } else {
    foreach (@{$self->{sensors}}) {
      $_->check();
    }
  }
}


package Classes::HP::Procurve::Component::SensorSubsystem::Sensor;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'sensor %s (%s) is %s',
      $self->{hpicfSensorIndex},
      $self->{hpicfSensorDescr},
      $self->{hpicfSensorStatus});
  if ($self->{hpicfSensorStatus} eq "notPresent") {
  } elsif ($self->{hpicfSensorStatus} eq "bad") {
    $self->add_critical();
  } elsif ($self->{hpicfSensorStatus} eq "warning") {
    $self->add_warning();
  } elsif ($self->{hpicfSensorStatus} eq "good") {
    #$self->add_ok();
  } else {
    $self->add_unknown();
  }
}

package Classes::HP::Procurve;
our @ISA = qw(Classes::HP);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::HP::Procurve::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::HP::Procurve::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::HP::Procurve::Component::MemSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::HP;
our @ISA = qw(Classes::Device);
use strict;

use constant trees => (
    '1.3.6.1.4.1.11.2.14.11.1.2', # HP-ICF-CHASSIS
    '1.3.6.1.2.1.1.7.11.12.9', # STATISTICS-MIB (old?)
    '1.3.6.1.2.1.1.7.11.12.1', # NETSWITCH-MIB (old?)
    '1.3.6.1.4.1.11.2.14.11.5.1.9', # STATISTICS-MIB
    '1.3.6.1.4.1.11.2.14.11.5.1.1', # NETSWITCH-MIB

);

sub init {
  my $self = shift;
  if ($self->{productname} =~ /Procurve/i ||
      ($self->implements_mib('HP-ICF-CHASSIS') &&
      $self->implements_mib('NETSWITCH-MIB'))) {
    bless $self, 'Classes::HP::Procurve';
    $self->debug('using Classes::HP::Procurve');
  }
  if (ref($self) ne "Classes::HP") {
    $self->init();
  }
}

package Classes::MEOS;
our @ISA = qw(Classes::Brocade);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_and_check_environmental_subsystem();
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_and_check_cpu_subsystem("Classes::UCDMIB::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_and_check_mem_subsystem("Classes::UCDMIB::Component::MemSubsystem");
  } else {
    $self->no_such_mode();
  }
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem1} =
      Classes::FCMGMT::Component::EnvironmentalSubsystem->new();
  $self->{components}->{environmental_subsystem2} =
      Classes::FCEOS::Component::EnvironmentalSubsystem->new();
}

sub check_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem1}->check();
  $self->{components}->{environmental_subsystem2}->check();
  if ($self->check_messages()) {
    $self->clear_ok();
  }
  $self->{components}->{environmental_subsystem1}->dump()
      if $self->opts->verbose >= 2;
  $self->{components}->{environmental_subsystem2}->dump()
      if $self->opts->verbose >= 2;
}

package Classes::Brocade;
our @ISA = qw(Classes::Device);
use strict;

sub init {
  my $self = shift;
  if ($self->mode !~ /device::uptime/) {
    foreach ($self->get_snmp_table_objects(
        'ENTITY-MIB', 'entPhysicalTable', undef, ['entPhysicalDescr'])) {
      if ($_->{entPhysicalDescr} =~ /Brocade/) {
        $self->{productname} = "FabOS";
      }
    }
    my $swFirmwareVersion = $self->get_snmp_object('SW-MIB', 'swFirmwareVersion');
    if ($swFirmwareVersion && $swFirmwareVersion =~ /^v6/) {
      $self->{productname} = "FabOS"
    }
  }
  if ($self->{productname} =~ /EMC\s*DS.*4700M/i) {
    bless $self, 'Classes::MEOS';
    $self->debug('using Classes::MEOS');
  } elsif ($self->{productname} =~ /EMC\s*DS-24M2/i) {
    bless $self, 'Classes::MEOS';
    $self->debug('using Classes::MEOS');
  } elsif ($self->{productname} =~ /FabOS/i) {
    bless $self, 'Classes::FabOS';
    $self->debug('using Classes::FabOS');
  } elsif ($self->{productname} =~ /ICX6|FastIron/i) {
    bless $self, 'Classes::Foundry';
    $self->debug('using Classes::Foundry');
  } elsif ($self->implements_mib('SW-MIB')) {
    bless $self, 'Classes::FabOS';
    $self->debug('using Classes::FabOS');
  }
  if (ref($self) ne "Classes::Brocade") {
    $self->init();
  } else {
    $self->no_such_mode();
  }
}

package Classes::SecureOS;
our @ISA = qw(Classes::Device);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    # not sure if this works fa25239716cb74c672f8dd390430dc4056caffa7
    if ($self->implements_mib('FCMGMT-MIB')) {
      $self->analyze_and_check_environmental_subsystem("Classes::FCMGMT::Component::EnvironmentalSubsystem");
    }
    if ($self->implements_mib('HOST-RESOURCES-MIB')) {
      $self->analyze_and_check_environmental_subsystem("Classes::HOSTRESOURCESMIB::Component::EnvironmentalSubsystem");
    }
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::UCDMIB::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::UCDMIB::Component::MemSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::HSRP::Component::HSRPSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{groups} = [];
  if ($self->mode =~ /device::hsrp/) {
    foreach ($self->get_snmp_table_objects(
        'CISCO-HSRP-MIB', 'cHsrpGrpTable')) {
      my $group = Classes::HSRP::Component::HSRPSubsystem::Group->new(%{$_});
      if ($self->filter_name($group->{name})) {
        push(@{$self->{groups}}, $group);
      }
    }
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking hsrp groups');
  if ($self->mode =~ /device::hsrp::list/) {
    foreach (@{$self->{groups}}) {
      $_->list();
    }
  } elsif ($self->mode =~ /device::hsrp/) {
    if (scalar (@{$self->{groups}}) == 0) {
      $self->add_unknown('no hsrp groups');
    } else {
      foreach (@{$self->{groups}}) {
        $_->check();
      }
    }
  }
}


package Classes::HSRP::Component::HSRPSubsystem::Group;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub finish {
  my $self = shift;
  my %params = @_;
  $self->{ifIndex} = $params{indices}->[0];
  $self->{cHsrpGrpNumber} = $params{indices}->[1];
  $self->{name} = $self->{cHsrpGrpNumber}.':'.$self->{ifIndex};
  if ($self->mode =~ /device::hsrp::state/) {
    if (! $self->opts->role()) {
      $self->opts->override_opt('role', 'active');
    }
  }
  return $self;
}

sub check {
  my $self = shift;
  if ($self->mode =~ /device::hsrp::state/) {
    $self->add_info(sprintf 'hsrp group %s (interface %s) state is %s (active router is %s, standby router is %s)',
        $self->{cHsrpGrpNumber}, $self->{ifIndex},
        $self->{cHsrpGrpStandbyState},
        $self->{cHsrpGrpActiveRouter}, $self->{cHsrpGrpStandbyRouter});
    my @roles = split ',', $self->opts->role();
    if (grep $_ eq $self->{cHsrpGrpStandbyState}, @roles) {
      if ($self->{cHsrpGrpStandbyRouter} eq '0.0.0.0') {
        $self->add_message(
          defined $self->opts->mitigation() ? $self->opts->mitigation() : 1,
          sprintf 'standby hsrp router missing in group %s (interface %s)',
          $self->{cHsrpGrpNumber}, $self->{ifIndex}
        );
      } else {
        $self->add_ok();
      }
    } else {
      $self->add_critical(
          sprintf 'state in group %s (interface %s) is %s instead of %s',
              $self->{cHsrpGrpNumber}, $self->{ifIndex},
              $self->{cHsrpGrpStandbyState},
              $self->opts->role());
    }
  } elsif ($self->mode =~ /device::hsrp::failover/) {
    $self->add_info(sprintf 'hsrp group %s/%s: active node is %s, standby node is %s',
        $self->{cHsrpGrpNumber}, $self->{ifIndex},
        $self->{cHsrpGrpActiveRouter}, $self->{cHsrpGrpStandbyRouter});
    if (my $laststate = $self->load_state( name => $self->{name} )) {
      if ($laststate->{active} ne $self->{cHsrpGrpActiveRouter}) {
        $self->add_critical(sprintf 'hsrp group %s/%s: active node %s --> %s',
            $self->{cHsrpGrpNumber}, $self->{ifIndex},
            $laststate->{active}, $self->{cHsrpGrpActiveRouter});
      }
      if ($laststate->{standby} ne $self->{cHsrpGrpStandbyRouter}) {
        $self->add_warning(sprintf 'hsrp group %s/%s: standby node %s --> %s',
            $self->{cHsrpGrpNumber}, $self->{ifIndex},
            $laststate->{standby}, $self->{cHsrpGrpStandbyRouter});
      }
      if (($laststate->{active} eq $self->{cHsrpGrpActiveRouter}) &&
          ($laststate->{standby} eq $self->{cHsrpGrpStandbyRouter})) {
        $self->add_ok();
      }
    } else {
      $self->add_ok('initializing....');
    }
    $self->save_state( name => $self->{name}, save => {
        active => $self->{cHsrpGrpActiveRouter},
        standby => $self->{cHsrpGrpStandbyRouter},
    });
  }
}

sub list {
  my $self = shift;
  printf "%s %s %s %s\n", $self->{name}, $self->{cHsrpGrpVirtualIpAddr},
      $self->{cHsrpGrpActiveRouter}, $self->{cHsrpGrpStandbyRouter};
}

package Classes::HSRP;
our @ISA = qw(Classes::Device);
use strict;

package Classes::IFMIB::Component::LinkAggregation;
our @ISA = qw(Classes::IFMIB);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my $self = {};
  bless $self, $class;
  $self->init();
  return $self;
}

sub init {
  my $self = shift;
  if ($self->opts->name) {
    my @ifs = split(",", $self->opts->name);
    $self->{name} = shift @ifs;
    if ($self->opts->regexp) {
      $self->opts->override_opt('name',
          sprintf "(%s)", join("|", map { sprintf "(%s)", $_ } @ifs));
    } else {
      $self->opts->override_opt('name',
          sprintf "(%s)", join("|", map { sprintf "(^%s\$)", $_ } @ifs));
      $self->opts->override_opt('regexp', 1);
    }
    $self->{components}->{interface_subsystem} =
        Classes::IFMIB::Component::InterfaceSubsystem->new();
  } else {
    #error, must have a name
  }
  if ($self->mode =~ /device::interfaces::aggregation::availability/) {
    $self->{num_if} = scalar(@{$self->{components}->{interface_subsystem}->{interfaces}});
    $self->{down_if} = [grep { $_->{ifOperStatus} eq "down" } @{$self->{components}->{interface_subsystem}->{interfaces}}];
    $self->{num_down_if} = scalar(@{$self->{down_if}});
    $self->{num_up_if} = $self->{num_if} - $self->{num_down_if};
    $self->{availability} = $self->{num_if} ? (100 * $self->{num_up_if} / $self->{num_if}) : 0;
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking link aggregation');
  if (scalar(@{$self->{components}->{interface_subsystem}->{interfaces}}) == 0) {
    $self->add_unknown('no interfaces');
    return;
  }
  if ($self->mode =~ /device::interfaces::aggregation::availability/) {
    my $down_info = scalar(@{$self->{down_if}}) ?
        sprintf " (down: %s)", join(", ", map { $_->{ifDescr} } @{$self->{down_if}}) : "";
    $self->add_info(sprintf 'aggregation %s availability is %.2f%% (%d of %d)%s',
        $self->{name},
        $self->{availability}, $self->{num_up_if}, $self->{num_if},
        $down_info);
    my $cavailability = $self->{num_if} ? (100 * 1 / $self->{num_if}) : 0;
    $cavailability = $cavailability == int($cavailability) ? $cavailability + 1: int($cavailability + 1.0);
    $self->set_thresholds(
        metric => 'aggr_'.$self->{name}.'_availability',
        warning => '100:',
        critical => $cavailability.':'
    );
    $self->add_message($self->check_thresholds(
        metric => 'aggr_'.$self->{name}.'_availability',
        value => $self->{availability}
    ));
    $self->add_perfdata(
        label => 'aggr_'.$self->{name}.'_availability',
        value => $self->{availability},
        uom => '%',
    );
  }
}


package Classes::IFMIB::Component::InterfaceSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my ($self) = @_;
  $self->{interfaces} = [];
  $self->{etherstats} = [];
  #$self->session_translate(['-octetstring' => 1]);
  if ($self->mode =~ /device::interfaces::list/) {
    $self->update_interface_cache(1);
    foreach my $ifIndex (keys %{$self->{interface_cache}}) {
      my $ifDescr = $self->{interface_cache}->{$ifIndex}->{ifDescr};
      my $ifName = $self->{interface_cache}->{$ifIndex}->{ifName} || '________';
      my $ifAlias = $self->{interface_cache}->{$ifIndex}->{ifAlias} || '________';
      push(@{$self->{interfaces}},
          Classes::IFMIB::Component::InterfaceSubsystem::Interface->new(
              ifIndex => $ifIndex,
              ifDescr => $ifDescr,
              ifName => $ifName,
              ifAlias => $ifAlias,
              indices => [$ifIndex],
              flat_indices => $ifIndex,
          ));
    }
    my @indices = $self->get_interface_indices();
    # die sind mit etherStatsDataSource verknuepft
  } elsif ($self->mode =~ /device::interfaces/) {
    $self->update_interface_cache(0);
    #next if $self->opts->can('name') && $self->opts->name && 
    #    $self->opts->name ne $_->{ifDescr};
    # if limited search
    # name is a number -> get_table with extra param
    # name is a regexp -> list of names -> list of numbers
    my @indices = $self->get_interface_indices();
    my @etherpatterns = map {
        '('.$_.')';
    } map {
        s/\./\\./g; $_;
    } map {
        '.1.3.6.1.2.1.2.2.1.1.'.$_;
    } map {
        $_->[0];
    } @indices;
    if (scalar(@indices) > 0) {
      foreach ($self->get_snmp_table_objects(
          'IFMIB', 'ifTable+ifXTable', \@indices)) {
        push(@{$self->{interfaces}},
            Classes::IFMIB::Component::InterfaceSubsystem::Interface->new(%{$_}));
      }
      if ($self->mode =~ /device::interfaces::etherstats/) {

        $self->override_opt('name', '^('.join('|', @etherpatterns).')$');
        $self->override_opt('regexp', 1);
        # key=etherStatsDataSource-//-index, value=index
        $self->update_entry_cache(0, 'RMON-MIB', 'etherStatsTable', 'etherStatsDataSource');
        # Value von etherStatsDataSource ist ifIndex              
        foreach my $etherstat ($self->get_snmp_table_objects_with_cache(
            'RMON-MIB', 'etherStatsTable', 'etherStatsDataSource')) {
          foreach my $interface (@{$self->{interfaces}}) {
            if ('.1.3.6.1.2.1.2.2.1.1.'.$interface->{ifIndex} eq $etherstat->{etherStatsDataSource}) {
              foreach my $key (grep /^ether/, keys %{$etherstat}) {
                $interface->{$key} = $etherstat->{$key};
              }
              $interface->init_etherstats;
              last;
            }
          }
        }
        @{$self->{interfaces}} = grep {
            exists $_->{etherStatsDataSource};
        } @{$self->{interfaces}};
      }
    }
  }
}

sub check {
  my ($self) = @_;
  $self->add_info('checking interfaces');
  if (scalar(@{$self->{interfaces}}) == 0) {
    $self->add_unknown('no interfaces');
    return;
  }
  if ($self->mode =~ /device::interfaces::list/) {
    foreach (sort {$a->{ifIndex} <=> $b->{ifIndex}} @{$self->{interfaces}}) {
    #foreach (sort @{$self->{interfaces}}) {
      $_->list();
    }
    $self->add_ok("have fun");
  } elsif ($self->mode =~ /device::interfaces::availability/) {
    foreach (@{$self->{interfaces}}) {
      $_->check();
    }
    my $num_interfaces = scalar(@{$self->{interfaces}});
    my $up_interfaces =
        scalar(grep { $_->{ifAdminStatus} eq "up" } @{$self->{interfaces}});
    my $available_interfaces =
        scalar(grep { $_->{ifAvailable} eq "true" } @{$self->{interfaces}});
    $self->add_info(sprintf "%d of %d (%d adm. up) interfaces are available",
        $available_interfaces, $num_interfaces, $up_interfaces);
    $self->set_thresholds(warning => "3:", critical => "2:");
    $self->add_message($self->check_thresholds($available_interfaces));
    $self->add_perfdata(
        label => 'num_interfaces',
        value => $num_interfaces,
        thresholds => 0,
    );
    $self->add_perfdata(
        label => 'available_interfaces',
        value => $available_interfaces,
    );

    printf "%s\n", $self->{info};
    printf "<table style=\"border-collapse:collapse; border: 1px solid black;\">";
    printf "<tr>";
    foreach (qw(Index Descr Type Speed AdminStatus OperStatus Duration Available)) {
      printf "<th style=\"text-align: right; padding-left: 4px; padding-right: 6px;\">%s</th>", $_;
    }
    printf "</tr>";
    my $unique = {};
    foreach (@{$self->{interfaces}}) {
      if (exists $unique->{$_->{ifDescr}}) {
        $unique->{$_->{ifDescr}}++;
      } else {
        $unique->{$_->{ifDescr}} = 0;
      }
    }
    foreach (sort {$a->{ifIndex} <=> $b->{ifIndex}} @{$self->{interfaces}}) {
      if ($unique->{$_->{ifDescr}}) {
        $_->{ifDescr} .= ' '.$_->{ifIndex};
      }
      printf "<tr>";
      printf "<tr style=\"border: 1px solid black;\">";
      foreach my $attr (qw(ifIndex ifDescr ifType ifSpeedText ifAdminStatus ifOperStatus ifStatusDuration ifAvailable)) {
        if ($_->{ifAvailable} eq "false") {
          printf "<td style=\"text-align: right; padding-left: 4px; padding-right: 6px;\">%s</td>", $_->{$attr};
        } else {
          printf "<td style=\"text-align: right; padding-left: 4px; padding-right: 6px; background-color: #00ff33;\">%s</td>", $_->{$attr};
        }
      }
      printf "</tr>";
    }
    printf "</table>\n";
    printf "<!--\nASCII_NOTIFICATION_START\n";
    my $column_length = {};
    foreach (qw(ifIndex ifDescr ifType ifSpeed ifAdminStatus ifOperStatus Duration ifAvailable ifSpeedText ifStatusDuration)) {
      $column_length->{$_} = length($_);
    }
    foreach (sort {$a->{ifIndex} <=> $b->{ifIndex}} @{$self->{interfaces}}) {
      if ($unique->{$_->{ifDescr}}) {
        $_->{ifDescr} .= ' '.$_->{ifIndex};
      }
      foreach my $attr (qw(ifIndex ifDescr ifType ifSpeedText ifAdminStatus ifOperStatus ifStatusDuration ifAvailable)) {
        if (length($_->{$attr}) > $column_length->{$attr}) {
          $column_length->{$attr} = length($_->{$attr});
        }
      }
    }
    foreach (qw(ifIndex ifDescr ifType ifSpeed ifAdminStatus ifOperStatus Duration ifStatusDuration ifAvailable ifSpeedText)) {
      $column_length->{$_} = "%".($column_length->{$_} + 3)."s I";
    }
    $column_length->{ifSpeed} = $column_length->{ifSpeedText};
    $column_length->{Duration} = $column_length->{ifStatusDuration};
    foreach (qw(ifIndex ifDescr ifType ifSpeed ifAdminStatus ifOperStatus Duration ifAvailable)) {
      printf $column_length->{$_}, $_;
    }
    printf "\n";
    foreach (sort {$a->{ifIndex} <=> $b->{ifIndex}} @{$self->{interfaces}}) {
      if ($unique->{$_->{ifDescr}}) {
        $_->{ifDescr} .= ' '.$_->{ifIndex};
      }
      foreach my $attr (qw(ifIndex ifDescr ifType ifSpeedText ifAdminStatus ifOperStatus ifStatusDuration ifAvailable)) {
        printf $column_length->{$attr}, $_->{$attr};
      }
      printf "\n";
    }
    printf "ASCII_NOTIFICATION_END\n-->\n";
  } else {
    if (scalar (@{$self->{interfaces}}) == 0) {
    } else {
      my $unique = {};
      foreach (@{$self->{interfaces}}) {
        if (exists $unique->{$_->{ifDescr}}) {
          $unique->{$_->{ifDescr}}++;
        } else {
          $unique->{$_->{ifDescr}} = 0;
        }
      }
      foreach (sort {$a->{ifIndex} <=> $b->{ifIndex}} @{$self->{interfaces}}) {
        if ($unique->{$_->{ifDescr}}) {
          $_->{ifDescr} .= ' '.$_->{ifIndex};
        }
        $_->check();
      }
      if ($self->opts->report eq "short") {
        $self->clear_ok();
        $self->add_ok('no problems') if ! $self->check_messages();
      }
    }
  }
}

sub update_interface_cache {
  my ($self) = @_;
  my $force = shift;
  my $statefile = $self->create_interface_cache_file();
  $self->get_snmp_objects('IFMIB', qw(ifTableLastChange));
  # "The value of sysUpTime at the time of the last creation or
  # deletion of an entry in the ifTable. If the number of
  # entries has been unchanged since the last re-initialization
  # of the local network management subsystem, then this object
  # contains a zero value."
  $self->{ifTableLastChange} ||= 0;
  $self->{ifCacheLastChange} = -f $statefile ? (stat $statefile)[9] : 0;
  $self->{bootTime} = time - $self->uptime();
  $self->{ifTableLastChange} = $self->{bootTime} + $self->timeticks($self->{ifTableLastChange});
  my $update_deadline = time - 3600;
  my $must_update = 0;
  if ($self->{ifCacheLastChange} < $update_deadline) {
    # file older than 1h or file does not exist
    $must_update = 1;
    $self->debug(sprintf 'interface cache is older than 1h (%s < %s)',
        scalar localtime $self->{ifCacheLastChange}, scalar localtime $update_deadline);
  }
  if ($self->{ifTableLastChange} >= $self->{ifCacheLastChange}) {
    $must_update = 1;
    $self->debug(sprintf 'interface table changes newer than cache file (%s >= %s)',
        scalar localtime $self->{ifCacheLastChange}, scalar localtime $self->{ifCacheLastChange});
  }
  if ($force) {
    $must_update = 1;
    $self->debug(sprintf 'interface table update forced');
  }
  if ($must_update) {
    $self->debug('update of interface cache');
    $self->{interface_cache} = {};
    foreach ($self->get_snmp_table_objects('MINI-IFMIB', 'ifTable+ifXTable', [-1])) {
      # neuerdings index+descr, weil die drecksscheiss allied telesyn ports
      # alle gleich heissen
      # und noch so ein hirnbrand: --mode list-interfaces
      # 000003 Adaptive Security Appliance 'GigabitEthernet0/0' interface
      # ....
      # der ASA-schlonz ist ueberfluessig, also brauchen wir eine hintertuer
      # um die namen auszuputzen
      if ($self->opts->name2 && $self->opts->name2 =~ /\(\.\*\?*\)/) {
        if ($_->{ifDescr} =~ $self->opts->name2) {
          $_->{ifDescr} = $1;
        }
      }
      $self->{interface_cache}->{$_->{ifIndex}}->{ifDescr} = unpack("Z*", $_->{ifDescr});
      $self->{interface_cache}->{$_->{ifIndex}}->{ifName} = unpack("Z*", $_->{ifName}) if exists $_->{ifName};
      $self->{interface_cache}->{$_->{ifIndex}}->{ifAlias} = unpack("Z*", $_->{ifAlias}) if exists $_->{ifAlias};
    }
    $self->save_interface_cache();
  }
  $self->load_interface_cache();
}

sub save_interface_cache {
  my ($self) = @_;
  $self->create_statefilesdir();
  my $statefile = $self->create_interface_cache_file();
  my $tmpfile = $self->statefilesdir().'/check_nwc_health_tmp_'.$$;
  my $fh = IO::File->new();
  $fh->open(">$tmpfile");
  $fh->print(Data::Dumper::Dumper($self->{interface_cache}));
  $fh->flush();
  $fh->close();
  my $ren = rename $tmpfile, $statefile;
  $self->debug(sprintf "saved %s to %s",
      Data::Dumper::Dumper($self->{interface_cache}), $statefile);

}

sub load_interface_cache {
  my ($self) = @_;
  my $statefile = $self->create_interface_cache_file();
  if ( -f $statefile) {
    our $VAR1;
    eval {
      require $statefile;
    };
    if($@) {
      printf "rumms\n";
    }
    $self->debug(sprintf "load %s", Data::Dumper::Dumper($VAR1));
    $self->{interface_cache} = $VAR1;
    eval {
      foreach (keys %{$self->{interface_cache}}) {
        /^\d+$/ || die "newrelease";
      }
    };
    if($@) {
      $self->{interface_cache} = {};
      unlink $statefile;
      delete $INC{$statefile};
      $self->update_interface_cache(1);
    }
  }
}

sub get_interface_indices {
  my ($self) = @_;
  my @indices = ();
  foreach my $ifIndex (keys %{$self->{interface_cache}}) {
    my $ifDescr = $self->{interface_cache}->{$ifIndex}->{ifDescr};
    my $ifAlias = $self->{interface_cache}->{$ifIndex}->{ifAlias} || '________';
    # Check ifDescr (using --name)
    if ($self->opts->name) {
      if ($self->opts->regexp) {
        my $pattern = $self->opts->name;
        if ($ifDescr =~ /$pattern/i) {
          push(@indices, [$ifIndex]);
        }
      } else {
        if ($self->opts->name =~ /^\d+$/) {
          if ($ifIndex == 1 * $self->opts->name) {
            push(@indices, [1 * $self->opts->name]);
          }
        } else {
          if (lc $ifDescr eq lc $self->opts->name) {
            push(@indices, [$ifIndex]);
          }
        }
      }
    # Check ifAlias (using --name3)
    } elsif ($self->opts->name3) {
      if ($self->opts->regexp) {
        my $pattern = $self->opts->name3;
        if ($ifAlias =~ /$pattern/i) {
          push(@indices, [$ifIndex]);
        }
      } else {
        if (lc $ifAlias eq lc $self->opts->name3) {
          push(@indices, [$ifIndex]);
        }
      }
    # take all interfaces
    } else {
      push(@indices, [$ifIndex]);
    }
  }
  return @indices;
}


package Classes::IFMIB::Component::InterfaceSubsystem::EtherStat;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my ($self) = @_;
  #printf "%s\n", Data::Dumper::Dumper($self);
}

package Classes::IFMIB::Component::InterfaceSubsystem::Interface;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my ($self) = @_;
  foreach my $key (keys %{$self}) {
    next if $key !~ /^if/;
    $self->{$key} = 0 if ! defined $self->{$key};
  }
  $self->{ifDescr} = unpack("Z*", $self->{ifDescr}); # windows has trailing nulls
  if ($self->opts->name2 && $self->opts->name2 =~ /\(\.\*\?*\)/) {
    if ($self->{ifDescr} =~ $self->opts->name2) {
      $self->{ifDescr} = $1;
    }
  }
  # Manche Stinkstiefel haben ifName, ifHighSpeed und z.b. ifInMulticastPkts,
  # aber keine ifHC*Octets. Gesehen bei Cisco Switch Interface Nul0 o.ae.
  if ($self->{ifName} && defined $self->{ifHCInOctets} && 
      defined $self->{ifHCOutOctets} && $self->{ifHCInOctets} ne "noSuchObject") {
    $self->{ifAlias} ||= $self->{ifName};
    $self->{ifName} = unpack("Z*", $self->{ifName});
    $self->{ifAlias} = unpack("Z*", $self->{ifAlias});
    $self->{ifAlias} =~ s/\|/!/g if $self->{ifAlias};
    bless $self, 'Classes::IFMIB::Component::InterfaceSubsystem::Interface::64bit';
  }
  if ($self->{ifPhysAddress}) {
    $self->{ifPhysAddress} = join(':', unpack('(H2)*', $self->{ifPhysAddress})); 
  }
  $self->init();
}

sub init {
  my ($self) = @_;
  if ($self->mode =~ /device::interfaces::complete/) {
    # uglatto, but $self->mode is an lvalue
    $Monitoring::GLPlugin::mode = "device::interfaces::operstatus";
    $self->init();
    if ($self->{ifOperStatus} eq "up") {
      foreach my $mode (qw(device::interfaces::usage
          device::interfaces::errors device::interfaces::discards)) {
        $Monitoring::GLPlugin::mode = $mode;
        $self->init();
      }
    }
    $Monitoring::GLPlugin::mode = "device::interfaces::complete";
  } elsif ($self->mode =~ /device::interfaces::usage/) {
    $self->valdiff({name => $self->{ifIndex}.'#'.$self->{ifDescr}}, qw(ifInOctets ifOutOctets));
    $self->{delta_ifInBits} = $self->{delta_ifInOctets} * 8;
    $self->{delta_ifOutBits} = $self->{delta_ifOutOctets} * 8;
    if ($self->{ifSpeed} == 0) {
      # vlan graffl
      $self->{inputUtilization} = 0;
      $self->{outputUtilization} = 0;
      $self->{maxInputRate} = 0;
      $self->{maxOutputRate} = 0;
    } else {
      $self->{inputUtilization} = 100 * $self->{delta_ifInBits} /
          ($self->{delta_timestamp} * $self->{ifSpeed});
      $self->{outputUtilization} = 100 * $self->{delta_ifOutBits} /
          ($self->{delta_timestamp} * $self->{ifSpeed});
      $self->{maxInputRate} = $self->{ifSpeed};
      $self->{maxOutputRate} = $self->{ifSpeed};
    }
    if (defined $self->opts->ifspeed) {
      $self->override_opt('ifspeedin', $self->opts->ifspeed);
      $self->override_opt('ifspeedout', $self->opts->ifspeed);
    }
    if (defined $self->opts->ifspeedin) {
      $self->{inputUtilization} = 100 * $self->{delta_ifInBits} /
          ($self->{delta_timestamp} * $self->opts->ifspeedin);
      $self->{maxInputRate} = $self->opts->ifspeedin;
    }
    if (defined $self->opts->ifspeedout) {
      $self->{outputUtilization} = 100 * $self->{delta_ifOutBits} /
          ($self->{delta_timestamp} * $self->opts->ifspeedout);
      $self->{maxOutputRate} = $self->opts->ifspeedout;
    }
    $self->{inputRate} = $self->{delta_ifInBits} / $self->{delta_timestamp};
    $self->{outputRate} = $self->{delta_ifOutBits} / $self->{delta_timestamp};
    $self->override_opt("units", "bit") if ! $self->opts->units;
    $self->{inputRate} /= $self->number_of_bits($self->opts->units);
    $self->{outputRate} /= $self->number_of_bits($self->opts->units);
    $self->{maxInputRate} /= $self->number_of_bits($self->opts->units);
    $self->{maxOutputRate} /= $self->number_of_bits($self->opts->units);
    if ($self->{ifOperStatus} eq 'down') {
      $self->{inputUtilization} = 0;
      $self->{outputUtilization} = 0;
      $self->{inputRate} = 0;
      $self->{outputRate} = 0;
      $self->{maxInputRate} = 0;
      $self->{maxOutputRate} = 0;
    }
  } elsif ($self->mode =~ /device::interfaces::errors/) {
    $self->valdiff({name => $self->{ifDescr}}, qw(ifInErrors ifOutErrors));
    $self->{inputErrorRate} = $self->{delta_ifInErrors} 
        / $self->{delta_timestamp};
    $self->{outputErrorRate} = $self->{delta_ifOutErrors} 
        / $self->{delta_timestamp};
  } elsif ($self->mode =~ /device::interfaces::discards/) {
    $self->valdiff({name => $self->{ifDescr}}, qw(ifInDiscards ifOutDiscards));
    $self->{inputDiscardRate} = $self->{delta_ifInDiscards} 
        / $self->{delta_timestamp};
    $self->{outputDiscardRate} = $self->{delta_ifOutDiscards} 
        / $self->{delta_timestamp};
  } elsif ($self->mode =~ /device::interfaces::operstatus/) {
  } elsif ($self->mode =~ /device::interfaces::availability/) {
    $self->{ifStatusDuration} = 
        $self->uptime() - $self->timeticks($self->{ifLastChange});
    $self->opts->override_opt('lookback', 1800) if ! $self->opts->lookback;
    if ($self->{ifAdminStatus} eq "down") {
      $self->{ifAvailable} = "true";
    } elsif ($self->{ifAdminStatus} eq "up" && $self->{ifOperStatus} ne "up" &&
        $self->{ifStatusDuration} > $self->opts->lookback) {
      # and ifLastChange schon ein wenig laenger her
      $self->{ifAvailable} = "true";
    } else {
      $self->{ifAvailable} = "false";
    }
    my $gb = 1000 * 1000 * 1000;
    my $mb = 1000 * 1000;
    my $kb = 1000;
    my $speed = $self->{ifHighSpeed} ? 
        ($self->{ifHighSpeed} * $mb) : $self->{ifSpeed};
    if ($speed >= $gb) {
      $self->{ifSpeedText} = sprintf "%.2fGB", $speed / $gb;
    } elsif ($speed >= $mb) {
      $self->{ifSpeedText} = sprintf "%.2fMB", $speed / $mb;
    } elsif ($speed >= $kb) {
      $self->{ifSpeedText} = sprintf "%.2fKB", $speed / $kb;
    } else {
      $self->{ifSpeedText} = sprintf "%.2fB", $speed;
    }
    $self->{ifSpeedText} =~ s/\.00//g;
  }
  return $self;
}

sub init_etherstats {
  my ($self) = @_;
  if ($self->mode =~ /device::interfaces::etherstats/) {
    $self->valdiff({name => $self->{ifDescr}}, qw(etherStatsBroadcastPkts
        etherStatsCRCAlignErrors etherStatsCollisions etherStatsDropEvents
        etherStatsFragments etherStatsJabbers etherStatsMulticastPkts 
        etherStatsOctets etherStatsOversizePkts etherStatsPkts
        etherStatsUndersizePkts));
    for my $stat (qw(etherStatsBroadcastPkts etherStatsCRCAlignErrors
        etherStatsCollisions etherStatsDropEvents etherStatsFragments
        etherStatsJabbers etherStatsMulticastPkts etherStatsOversizePkts
        etherStatsUndersizePkts)) {
      $self->{$stat.'Percent'} = $self->{delta_etherStatsPkts} ?
          100 * $self->{'delta_'.$stat} / $self->{delta_etherStatsPkts} : 0;
    }
  }
  return $self;
}

sub check {
  my ($self) = @_;
  my $full_descr = sprintf "%s%s",
      $self->{ifDescr},
      $self->{ifAlias} && $self->{ifAlias} ne $self->{ifDescr} ?
          " (alias ".$self->{ifAlias}.")" : "";
  if ($self->mode =~ /device::interfaces::complete/) {
    # uglatto, but $self->mode is an lvalue
    $Monitoring::GLPlugin::mode = "device::interfaces::operstatus";
    $self->check();
    if ($self->{ifOperStatus} eq "up") {
      foreach my $mode (qw(device::interfaces::usage
          device::interfaces::errors device::interfaces::discards)) {
        $Monitoring::GLPlugin::mode = $mode;
        $self->check();
      }
    }
    $Monitoring::GLPlugin::mode = "device::interfaces::complete";
  } elsif ($self->mode =~ /device::interfaces::usage/) {
    $self->add_info(sprintf 'interface %s usage is in:%.2f%% (%s) out:%.2f%% (%s)%s',
        $full_descr,
        $self->{inputUtilization}, 
        sprintf("%.2f%s/s", $self->{inputRate}, $self->opts->units),
        $self->{outputUtilization},
        sprintf("%.2f%s/s", $self->{outputRate}, $self->opts->units),
        $self->{ifOperStatus} eq 'down' ? ' (down)' : '');
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_usage_in',
        warning => 80,
        critical => 90
    );
    my $in = $self->check_thresholds(
        metric => $self->{ifDescr}.'_usage_in',
        value => $self->{inputUtilization}
    );
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_usage_out',
        warning => 80,
        critical => 90
    );
    my $out = $self->check_thresholds(
        metric => $self->{ifDescr}.'_usage_out',
        value => $self->{outputUtilization}
    );
    my $level = ($in > $out) ? $in : ($out > $in) ? $out : $in;
    $self->add_message($level);
    $self->add_perfdata(
        label => $self->{ifDescr}.'_usage_in',
        value => $self->{inputUtilization},
        uom => '%',
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_usage_out',
        value => $self->{outputUtilization},
        uom => '%',
    );
    my ($inwarning, $incritical) = $self->get_thresholds(
        metric => $self->{ifDescr}.'_usage_in',
    );
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_traffic_in',
        warning => $self->{maxInputRate} / 100 * $inwarning,
        critical => $self->{maxInputRate} / 100 * $incritical
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_traffic_in',
        value => $self->{inputRate},
        uom => $self->opts->units =~ /^(B|KB|MB|GB|TB)$/ ? $self->opts->units : undef,
        places => 2,
        min => 0,
        max => $self->{maxInputRate},
    );
    my ($outwarning, $outcritical) = $self->get_thresholds(
        metric => $self->{ifDescr}.'_usage_out',
    );
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_traffic_out',
        warning => $self->{maxOutputRate} / 100 * $outwarning,
        critical => $self->{maxOutputRate} / 100 * $outcritical,
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_traffic_out',
        value => $self->{outputRate},
        uom => $self->opts->units =~ /^(B|KB|MB|GB|TB)$/ ? $self->opts->units : undef,
        places => 2,
        min => 0,
        max => $self->{maxOutputRate},
    );
  } elsif ($self->mode =~ /device::interfaces::errors/) {
    $self->add_info(sprintf 'interface %s errors in:%.2f/s out:%.2f/s ',
        $full_descr,
        $self->{inputErrorRate} , $self->{outputErrorRate});
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_errors_in',
        warning => 1,
        critical => 10
    );
    my $in = $self->check_thresholds(
        metric => $self->{ifDescr}.'_errors_in',
        value => $self->{inputErrorRate}
    );
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_errors_out',
        warning => 1,
        critical => 10
    );
    my $out = $self->check_thresholds(
        metric => $self->{ifDescr}.'_errors_out',
        value => $self->{outputErrorRate}
    );
    my $level = ($in > $out) ? $in : ($out > $in) ? $out : $in;
    $self->add_message($level);
    $self->add_perfdata(
        label => $self->{ifDescr}.'_errors_in',
        value => $self->{inputErrorRate},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_errors_out',
        value => $self->{outputErrorRate},
    );
  } elsif ($self->mode =~ /device::interfaces::discards/) {
    $self->add_info(sprintf 'interface %s discards in:%.2f/s out:%.2f/s ',
        $full_descr,
        $self->{inputDiscardRate} , $self->{outputDiscardRate});
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_discards_in',
        warning => 1,
        critical => 10
    );
    my $in = $self->check_thresholds(
        metric => $self->{ifDescr}.'_discards_in',
        value => $self->{inputDiscardRate}
    );
    $self->set_thresholds(
        metric => $self->{ifDescr}.'_discards_out',
        warning => 1,
        critical => 10
    );
    my $out = $self->check_thresholds(
        metric => $self->{ifDescr}.'_discards_out',
        value => $self->{outputDiscardRate}
    );
    my $level = ($in > $out) ? $in : ($out > $in) ? $out : $in;
    $self->add_message($level);
    $self->add_perfdata(
        label => $self->{ifDescr}.'_discards_in',
        value => $self->{inputDiscardRate},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_discards_out',
        value => $self->{outputDiscardRate},
    );
  } elsif ($self->mode =~ /device::interfaces::operstatus/) {
    #rfc2863
    #(1)   if ifAdminStatus is not down and ifOperStatus is down then a
    #     fault condition is presumed to exist on the interface.
    #(2)   if ifAdminStatus is down, then ifOperStatus will normally also
    #     be down (or notPresent) i.e., there is not (necessarily) a
    #     fault condition on the interface.
    # --warning onu,anu
    # Admin: admindown,admin
    # Admin: --warning 
    #        --critical admindown
    # !ad+od  ad+!(od*on)
    # warn & warnbitfield
#    if ($self->opts->critical) {
#      if ($self->opts->critical =~ /^u/) {
#      } elsif ($self->opts->critical =~ /^u/) {
#      }
#    }
#    if ($self->{ifOperStatus} ne 'up') {
#      }
#    } 
    $self->add_info(sprintf '%s is %s/%s',
        $full_descr,
        $self->{ifOperStatus}, $self->{ifAdminStatus});
    $self->add_ok();
    if ($self->{ifOperStatus} eq 'down' && $self->{ifAdminStatus} ne 'down') {
      $self->add_critical(
          sprintf 'fault condition is presumed to exist on %s',
          $full_descr);
    }
    if ($self->{ifAdminStatus} eq 'down') {
      $self->add_message(
          defined $self->opts->mitigation() ? $self->opts->mitigation() : 2,
          sprintf '%s is admin down', $full_descr);
    }
  } elsif ($self->mode =~ /device::interfaces::availability/) {
    $self->{ifStatusDuration} = 
        $self->human_timeticks($self->{ifStatusDuration});
    $self->add_info(sprintf '%s is %savailable (%s/%s, since %s)',
        $self->{ifDescr}, ($self->{ifAvailable} eq "true" ? "" : "un"),
        $self->{ifOperStatus}, $self->{ifAdminStatus},
        $self->{ifStatusDuration});
  } elsif ($self->mode =~ /device::interfaces::etherstats/) {
    for my $stat (qw(etherStatsBroadcastPkts etherStatsCRCAlignErrors
        etherStatsCollisions etherStatsDropEvents etherStatsFragments
        etherStatsJabbers etherStatsMulticastPkts etherStatsOversizePkts
        etherStatsUndersizePkts)) {
      my $label = $stat.'Percent';
      $label =~ s/^etherStats//g;
      $label =~ s/(?:\b|(?<=([a-z])))([A-Z][a-z]+)/(defined($1) ? "_" : "") . lc($2)/eg;
      $label = $self->{ifDescr}.'_'.$label;
      $self->add_info(sprintf 'interface %s %s is %.2f%%',
          $full_descr, $stat.'Percent', $self->{$stat.'Percent'});
      $self->set_thresholds(
          metric => $label,
          warning => 1,
          critical => 10
      );
      $self->add_message(
          $self->check_thresholds(metric => $label, value => $self->{$stat.'Percent'}));
      $self->add_perfdata(
          label => $label,
          value => $self->{$stat.'Percent'},
          uom => '%',
      );
    }
  }
}

sub list {
  my ($self) = @_;
  if ($self->mode =~ /device::interfaces::listdetail/) {
    my $cL2L3IfModeOper = $self->get_snmp_object('CISCO-L2L3-INTERFACE-CONFIG-MIB', 'cL2L3IfModeOper', $self->{ifIndex}) || "unknown";
    my $vlanTrunkPortDynamicStatus = $self->get_snmp_object('CISCO-VTP-MIB', 'vlanTrunkPortDynamicStatus', $self->{ifIndex}) || "unknown";
    printf "%06d %s %s %s %s\n", $self->{ifIndex}, $self->{ifDescr}, $self->{ifAlias},
        $cL2L3IfModeOper, $vlanTrunkPortDynamicStatus;
  } else {
    printf "%06d %s\n", $self->{ifIndex}, $self->{ifDescr};
  }
}


package Classes::IFMIB::Component::InterfaceSubsystem::Interface::64bit;
our @ISA = qw(Classes::IFMIB::Component::InterfaceSubsystem::Interface);
use strict;

sub init {
  my ($self) = @_;
  if ($self->mode =~ /device::interfaces::usage/) {
    $self->valdiff({name => $self->{ifIndex}.'#'.$self->{ifDescr}}, qw(ifHCInOctets ifHCOutOctets));
    $self->{delta_ifInBits} = $self->{delta_ifHCInOctets} * 8;
    $self->{delta_ifOutBits} = $self->{delta_ifHCOutOctets} * 8;
    # ifSpeed = Bits/sec
    # ifHighSpeed = 1000000Bits/sec
    if ($self->{ifSpeed} == 0) {
      # vlan graffl
      $self->{inputUtilization} = 0;
      $self->{outputUtilization} = 0;
      $self->{maxInputRate} = 0;
      $self->{maxOutputRate} = 0;
    } elsif ($self->{ifSpeed} == 4294967295) {
      $self->{inputUtilization} = 100 * $self->{delta_ifInBits} /
          ($self->{delta_timestamp} * $self->{ifHighSpeed} * 1000000);
      $self->{outputUtilization} = 100 * $self->{delta_ifOutBits} /
          ($self->{delta_timestamp} * $self->{ifHighSpeed} * 1000000);
      $self->{maxInputRate} = $self->{ifHighSpeed} * 1000000;
      $self->{maxOutputRate} = $self->{ifHighSpeed} * 1000000;
    } else {
      $self->{inputUtilization} = 100 * $self->{delta_ifInBits} /
          ($self->{delta_timestamp} * $self->{ifSpeed});
      $self->{outputUtilization} = 100 * $self->{delta_ifOutBits} /
          ($self->{delta_timestamp} * $self->{ifSpeed});
      $self->{maxInputRate} = $self->{ifSpeed};
      $self->{maxOutputRate} = $self->{ifSpeed};
    }
    if (defined $self->opts->ifspeed) {
      $self->override_opt('ifspeedin', $self->opts->ifspeed);
      $self->override_opt('ifspeedout', $self->opts->ifspeed);
    }
    if (defined $self->opts->ifspeedin) {
      $self->{inputUtilization} = 100 * $self->{delta_ifInBits} /
          ($self->{delta_timestamp} * $self->opts->ifspeedin);
      $self->{maxInputRate} = $self->opts->ifspeedin;
    }
    if (defined $self->opts->ifspeedout) {
      $self->{outputUtilization} = 100 * $self->{delta_ifOutBits} /
          ($self->{delta_timestamp} * $self->opts->ifspeedout);
      $self->{maxOutputRate} = $self->opts->ifspeedout;
    }
    $self->{inputRate} = $self->{delta_ifInBits} / $self->{delta_timestamp};
    $self->{outputRate} = $self->{delta_ifOutBits} / $self->{delta_timestamp};
    $self->override_opt("units", "bit") if ! $self->opts->units;
    $self->{inputRate} /= $self->number_of_bits($self->opts->units);
    $self->{outputRate} /= $self->number_of_bits($self->opts->units);
    $self->{maxInputRate} /= $self->number_of_bits($self->opts->units);
    $self->{maxOutputRate} /= $self->number_of_bits($self->opts->units);
    if ($self->{ifOperStatus} eq 'down') {
      $self->{inputUtilization} = 0;
      $self->{outputUtilization} = 0;
      $self->{inputRate} = 0;
      $self->{outputRate} = 0;
      $self->{maxInputRate} = 0;
      $self->{maxOutputRate} = 0;
    }
  } else {
    $self->SUPER::init();
  }
  return $self;
}

package Classes::IFMIB;
our @ISA = qw(Classes::Device);
use strict;

package Classes::IPFORWARDMIB::Component::RoutingSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

# ipRouteTable		1.3.6.1.2.1.4.21 
# replaced by
# ipForwardTable	1.3.6.1.2.1.4.24.2
# deprecated by
# ipCidrRouteTable	1.3.6.1.2.1.4.24.4
# deprecated by the ip4/6-neutral
# inetCidrRouteTable	1.3.6.1.2.1.4.24.7

sub init {
  my $self = shift;
  $self->{interfaces} = [];
  $self->get_snmp_tables('IP-FORWARD-MIB', [
      ['routes', 'inetCidrRouteTable', 'Classes::IPFORWARDMIB::Component::RoutingSubsystem::inetCidrRoute' ],
  ]);
  if (! @{$self->{routes}}) {
    $self->get_snmp_tables('IP-FORWARD-MIB', [
        ['routes', 'ipCidrRouteTable', 'Classes::IPFORWARDMIB::Component::RoutingSubsystem::ipCidrRoute',
            sub {
              my $o = shift;
              if ($o->opts->name && $o->opts->name =~ /\//) {
                my ($dest, $cidr) = split(/\//, $o->opts->name);
                my $bits = ( 2 ** (32 - $cidr) ) - 1;
                my ($full_mask) = unpack("N", pack("C4", split(/\./, '255.255.255.255')));
                my $netmask = join('.', unpack("C4", pack("N", ($full_mask ^ $bits))));
                return defined $o->{ipCidrRouteDest} && (
                    $o->filter_namex($dest, $o->{ipCidrRouteDest}) &&
                    $o->filter_namex($netmask, $o->{ipCidrRouteMask}) &&
                    $o->filter_name2($o->{ipCidrRouteNextHop})
                );
              } else {
                return defined $o->{ipCidrRouteDest} && (
                    $o->filter_name($o->{ipCidrRouteDest}) &&
                    $o->filter_name2($o->{ipCidrRouteNextHop})
                );
              }
            }
        ],
    ]);
  }
  # deprecated
  #$self->get_snmp_tables('IP-FORWARD-MIB', [
  #    ['routes', 'ipForwardTable', 'Classes::IPFORWARDMIB::Component::RoutingSubsystem::Route' ],
  #]);
  #$self->get_snmp_tables('IP-MIB', [
  #    ['routes', 'ipRouteTable', 'Classes::IPFORWARDMIB::Component::RoutingSubsystem::Route' ],
  #]);
}

sub check {
  my $self = shift;
  $self->add_info('checking routes');
  if ($self->mode =~ /device::routes::list/) {
    foreach (@{$self->{routes}}) {
      $_->list();
    }
    $self->add_ok("have fun");
  } elsif ($self->mode =~ /device::routes::count/) {
    if (! $self->opts->name && $self->opts->name2) {
      $self->add_info(sprintf "found %d routes via next hop %s",
          scalar(@{$self->{routes}}), $self->opts->name2);
    } elsif ($self->opts->name && ! $self->opts->name2) {
      $self->add_info(sprintf "found %d routes to dest %s",
          scalar(@{$self->{routes}}), $self->opts->name);
    } elsif ($self->opts->name && $self->opts->name2) {
      $self->add_info(sprintf "found %d routes to dest %s via hop %s",
          scalar(@{$self->{routes}}), $self->opts->name, $self->opts->name2);
    } else {
      $self->add_info(sprintf "found %d routes",
          scalar(@{$self->{routes}}));
    }
    $self->set_thresholds(warning => '1:', critical => '1:');
    $self->add_message($self->check_thresholds(scalar(@{$self->{routes}})));
    $self->add_perfdata(
        label => 'routes',
        value => scalar(@{$self->{routes}}),
    );
  }
}


package Classes::IPFORWARDMIB::Component::RoutingSubsystem::Route;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

package Classes::IPFORWARDMIB::Component::RoutingSubsystem::ipRoute;
our @ISA = qw(Classes::IPFORWARDMIB::Component::RoutingSubsystem::Route);

package Classes::IPFORWARDMIB::Component::RoutingSubsystem::ipCidrRoute;
our @ISA = qw(Classes::IPFORWARDMIB::Component::RoutingSubsystem::Route);

sub finish {
  my $self = shift;
  if (! defined $self->{ipCidrRouteDest}) {
    # we can reconstruct a few attributes from the index
    # one customer only made ipCidrRouteStatus visible
    $self->{ipCidrRouteDest} = join(".", map { $self->{indices}->[$_] } (0, 1, 2, 3));
    $self->{ipCidrRouteMask} = join(".", map { $self->{indices}->[$_] } (4, 5, 6, 7));
    $self->{ipCidrRouteTos} = $self->{indices}->[8];
    $self->{ipCidrRouteNextHop} = join(".", map { $self->{indices}->[$_] } (9, 10, 11, 12));
    $self->{ipCidrRouteType} = "other"; # maybe not, who cares
    $self->{ipCidrRouteProto} = "other"; # maybe not, who cares
  }
}

sub list {
  my $self = shift;
  printf "%16s %16s %16s %11s %7s\n", 
      $self->{ipCidrRouteDest}, $self->{ipCidrRouteMask},
      $self->{ipCidrRouteNextHop}, $self->{ipCidrRouteProto},
      $self->{ipCidrRouteType};
}

package Classes::IPFORWARDMIB::Component::RoutingSubsystem::inetCidrRoute;
our @ISA = qw(Classes::IPFORWARDMIB::Component::RoutingSubsystem::Route);

sub finish {
  my $self = shift;
  # http://www.mibdepot.com/cgi-bin/vendor_index.cgi?r=ietf_rfcs
  # INDEX { inetCidrRouteDestType, inetCidrRouteDest, inetCidrRoutePfxLen, inetCidrRoutePolicy, inetCidrRouteNextHopType, inetCidrRouteNextHop }
  $self->{inetCidrRouteDestType} = $self->mibs_and_oids_definition(
      'RFC4001-MIB', 'inetAddressType', $self->{indices}->[0]);
  if ($self->{inetCidrRouteDestType} eq "ipv4") {
    $self->{inetCidrRouteDest} = $self->mibs_and_oids_definition(
      'RFC4001-MIB', 'inetAddress', $self->{indices}->[1],
      $self->{indices}->[2], $self->{indices}->[3], $self->{indices}->[4]);
  } elsif ($self->{inetCidrRouteDestType} eq "ipv4") {
    $self->{inetCidrRoutePfxLen} = $self->mibs_and_oids_definition(
      'RFC4001-MIB', 'inetAddress', $self->{indices}->[1],
      $self->{indices}->[2], $self->{indices}->[3], $self->{indices}->[4]);
    
  }
}

package Classes::IPFORWARDMIB;
our @ISA = qw(Classes::Device);
use strict;

package Classes::IPMIB::Component::RoutingSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{interfaces} = [];
  $self->get_snmp_tables('IP-MIB', [
      ['routes', 'ipRouteTable', 'Classes::IPMIB::Component::RoutingSubsystem::Route' ],
  ]);
}

sub check {
  my $self = shift;
  $self->add_info('checking routes');
  if ($self->mode =~ /device::routes::list/) {
    foreach (@{$self->{routes}}) {
      $_->list();
    }
    $self->add_ok("have fun");
  }
}


package Classes::IPMIB::Component::RoutingSubsystem::Route;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);

package Classes::IPMIB;
our @ISA = qw(Classes::Device);
use strict;

package Classes::VRRPMIB::Component::VRRPSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use Data::Dumper;
use strict;

sub init {
  my $self = shift;
  $self->{groups} = [];
  $self->{assoc} = ();
  if ($self->mode =~ /device::vrrp/) {
    foreach ($self->get_snmp_table_objects(
  'VRRP-MIB', 'vrrpAssoIpAddrTable')) {
      my %entry = %{$_};
      my @index = @{$entry{indices}};
      my $key = shift(@index).'.'.shift(@index);
      my $ip = join ".", @index;
      push @{$self->{assoc}{$key}}, $ip;
    }
    foreach ($self->get_snmp_table_objects(
       'VRRP-MIB', 'vrrpOperTable')) {
      my %entry = %{$_};
      my $key = $entry{indices}->[0].".".$entry{indices}->[1];
      $entry{'vrrpAssocIpAddr'} = defined $self->{assoc}{$key} ? $self->{assoc}{$key} : [];

      my $group = Classes::VRRPMIB::Component::VRRPSubsystem::Group->new(%entry);
      if ($self->filter_name($group->{name}) &&
          $group->{'vrrpOperAdminState'} eq 'up') {
        push(@{$self->{groups}}, $group);
      }
    }
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking vrrp groups');
  if ($self->mode =~ /device::vrrp::list/) {
    foreach (@{$self->{groups}}) {
      $_->list();
    }
  } elsif ($self->mode =~ /device::vrrp/) {
    if (scalar (@{$self->{groups}}) == 0) {
      $self->add_unknown('no vrrp groups');
    } else {
      foreach (@{$self->{groups}}) {
        $_->check();
      }
    }
  }
}


package Classes::VRRPMIB::Component::VRRPSubsystem::Group;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;
use Data::Dumper;

sub finish {
  my $self = shift;
  my %params = @_;
  $self->{ifIndex} = $params{indices}->[0];
  $self->{vrrpGrpNumber} = $params{indices}->[1];
  $self->{name} = $self->{vrrpGrpNumber}.':'.$self->{ifIndex};
  if ($self->mode =~ /device::vrrp::state/) {
    if (! $self->opts->role()) {
      $self->opts->override_opt('role', 'master');
    }
  }
  return $self;
}

sub check {
  my $self = shift;
  if ($self->mode =~ /device::vrrp::state/) {
    $self->add_info(sprintf 'vrrp group %s (interface %s) state is %s (active router is %s)',
        $self->{vrrpGrpNumber}, $self->{ifIndex},
        $self->{vrrpOperState},
        $self->{vrrpOperMasterIpAddr});
    my @roles = split ',', $self->opts->role();
    if (grep $_ eq $self->{vrrpOperState}, @roles) {
      $self->add_ok();
    } else {
      $self->add_critical(
          sprintf 'state in group %s (interface %s) is %s instead of %s',
              $self->{vrrpGrpNumber}, $self->{ifIndex},
              $self->{vrrpOperState},
              $self->opts->role());
    }
  } elsif ($self->mode =~ /device::vrrp::failover/) {
    $self->add_info(sprintf 'vrrp group %s/%s: active node is %s',
        $self->{vrrpGrpNumber}, $self->{ifIndex},
        $self->{vrrpOperMasterIpAddr});
    if (my $laststate = $self->load_state( name => $self->{name} )) {
      if ($laststate->{state} ne $self->{vrrpOperState}) {
        $self->add_critical(sprintf 'vrrp group %s/%s: switched %s --> %s',
        $self->{vrrpGrpNumber}, $self->{ifIndex},
        $laststate->{state}, $self->{vrrpOperState});
      } elsif ($laststate->{state} !~ /^(master|backup)$/) {
        $self->add_critical(sprintf 'vrrp group %s/%s: in state %s',
        $self->{vrrpGrpNumber}, $self->{ifIndex}, $self->{vrrpOperState});
      } else {
        $self->add_ok();
      }
    } else {
      $self->add_ok('initializing....');
    }
    $self->save_state( name => $self->{name}, save => {
        state => $self->{vrrpOperState}
    });
  }
}
sub list {
  my $self = shift;
  printf "name(grp:if)=%s state=%s/%s master=%s ips=%s\n",
      $self->{name}, $self->{vrrpOperState}, $self->{vrrpOperAdminState},
      $self->{vrrpOperMasterIpAddr},
      join ",", sort @{$self->{vrrpAssocIpAddr}};
}
package Classes::VRRPMIB;
our @ISA = qw(Classes::Device);
use strict;
package Classes::HOSTRESOURCESMIB::Component::DiskSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('HOST-RESOURCES-MIB', [
      ['storages', 'hrStorageTable', 'Classes::HOSTRESOURCESMIB::Component::DiskSubsystem::Storage', sub { return shift->{hrStorageType} eq 'hrStorageFixedDisk' } ],
  ]);
}

package Classes::HOSTRESOURCESMIB::Component::DiskSubsystem::Storage;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  if ($self->{hrStorageDescr} =~ /(.*?),*\s+mounted on:\s+(.*)/) {
    my ($dev, $mnt) = ($1, $2);
    if ($dev =~ /^dev/) {
      $self->{name} = 'devfs_'.$mnt;
      $self->{device} = 'devfs';
      $self->{mountpoint} = $mnt;
    } else {
      $self->{name} = $dev.'_'.$mnt;
      $self->{device} = $dev;
      $self->{mountpoint} = $mnt;
    }
  } else {
    $self->{name} = $self->{hrStorageDescr};
  }
  if ($self->{hrStorageDescr} eq "/dev" || $self->{hrStorageDescr} =~ /^devfs/ ||
      $self->{hrStorageDescr} =~ /.*cdrom.*/ || $self->{hrStorageSize} == 0) {
    $self->{special} = 1;
  } else {
    $self->{special} = 0;
  }
}

sub check {
  my $self = shift;
  my $free = 100;
  eval {
     $free = 100 - 100 * $self->{hrStorageUsed} / $self->{hrStorageSize};
  };
  $self->add_info(sprintf 'storage %s (%s) has %.2f%% free space left',
      $self->{hrStorageIndex},
      $self->{hrStorageDescr},
      $free);
  if ($self->{special}) {
    # /dev is usually full, so we ignore it. size 0 is virtual crap
    $self->set_thresholds(metric => sprintf('%s_free_pct', $self->{name}),
        warning => '0:', critical => '0:');
  } else {
    $self->set_thresholds(metric => sprintf('%s_free_pct', $self->{name}),
        warning => '10:', critical => '5:');
  }
  $self->add_message($self->check_thresholds(metric => sprintf('%s_free_pct', $self->{name}),
      value => $free));
  $self->add_perfdata(
      label => sprintf('%s_free_pct', $self->{name}),
      value => $free,
      uom => '%',
  );
}

package Classes::HOSTRESOURCESMIB::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{disk_subsystem} =
      Classes::HOSTRESOURCESMIB::Component::DiskSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{disk_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_ok("environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{disk_subsystem}->dump();
}

package Classes::HOSTRESOURCESMIB::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  my $idx = 0;
  $self->get_snmp_tables('HOST-RESOURCES-MIB', [
      ['cpus', 'hrProcessorTable', 'Classes::HOSTRESOURCESMIB::Component::CpuSubsystem::Cpu'],
  ]);
  foreach (@{$self->{cpus}}) {
    $_->{hrProcessorIndex} = $idx++;
  }
}

package Classes::HOSTRESOURCESMIB::Component::CpuSubsystem::Cpu;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'cpu %s is %.2f%%',
      $self->{hrProcessorIndex},
      $self->{hrProcessorLoad});
  $self->set_thresholds(warning => '80', critical => '90');
  $self->add_message($self->check_thresholds($self->{hrProcessorLoad}));
  $self->add_perfdata(
      label => sprintf('cpu_%s_usage', $self->{hrProcessorIndex}),
      value => $self->{hrProcessorLoad},
      uom => '%',
  );
}

package Classes::HOSTRESOURCESMIB::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('HOST-RESOURCES-MIB', [
      ['storagesram', 'hrStorageTable', 'Classes::HOSTRESOURCESMIB::Component::MemSubsystem::Ram', sub { return shift->{hrStorageType} eq 'hrStorageRam' } ],
  ]);
}

package Classes::HOSTRESOURCESMIB::Component::MemSubsystem::Ram;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  my $used = 100;
  eval {
     $used = 100 * $self->{hrStorageUsed} / $self->{hrStorageSize};
  };
  $self->add_info(sprintf 'memory %s (%s) usage is %.2f%%',
      $self->{hrStorageIndex},
      $self->{hrStorageDescr},
      $used);
  my $label = sprintf 'memory_%s_usage', $self->{hrStorageDescr};
  $self->set_thresholds(metric => $label, warning => '10:', critical => '5:');
  $self->add_message($self->check_thresholds(metric => $label,
      value => $used));
  $self->add_perfdata(
      label => $label,
      value => $used,
      uom => '%',
  );
}

package Classes::HOSTRESOURCESMIB::Component::UptimeSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  my $hrSystemUptime = $self->get_snmp_object('HOST-RESOURCES-MIB', 'hrSystemUptime');
  $self->{uptime} = $self->timeticks($hrSystemUptime);
  $self->debug(sprintf 'uptime: %s', $self->{uptime});
  $self->debug(sprintf 'up since: %s',
      scalar localtime (time - $self->{uptime}));
}

sub check {
  my $self = shift;
  $self->add_info(sprintf 'device is up since %s',
      $self->human_timeticks($self->{uptime}));
  $self->set_thresholds(warning => '15:', critical => '5:');
  $self->add_message($self->check_thresholds($self->{uptime} / 60));
  $self->add_perfdata(
      label => 'uptime',
      value => $self->{uptime} / 60,
      places => 0,
  );
}

package Classes::HOSTRESOURCESMIB;
our @ISA = qw(Classes::Device);
use strict;

package Classes::LMSENSORSMIB::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{fan_subsystem} =
      Classes::LMSENSORSMIB::Component::FanSubsystem->new();
  $self->{temperature_subsystem} =
      Classes::LMSENSORSMIB::Component::TemperatureSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{temperature_subsystem}->check();
}

sub dump {
  my $self = shift;
  $self->{temperature_subsystem}->dump();
}

package Classes::LMSENSORSMIB::Component::FanSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('LM-SENSORS-MIB', [
      ['fans', 'lmFanSensorsTable', 'Classes::LMSENSORSMIB::Component::FanSubsystem::Fan'],
  ]);
}

package Classes::LMSENSORSMIB::Component::FanSubsystem::Fan;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->{ciscoEnvMonFanStatusIndex} ||= 0;
  $self->add_info(sprintf 'fan %d is %s',
      $self->{lmFanSensorsDevice},
      $self->{lmFanSensorsValue});
  $self->add_ok();
}

package Classes::LMSENSORSMIB::Component::TemperatureSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('LM-SENSORS-MIB', [
      ['temperatures', 'lmTempSensorsTable', 'Classes::LMSENSORSMIB::Component::TemperatureSubsystem::Temperature'],
  ]);
}

package Classes::LMSENSORSMIB::Component::TemperatureSubsystem::Temperature;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{lmTempSensorsValue} /= 1000;
}

sub check {
  my $self = shift;
  $self->{ciscoEnvMonTemperatureStatusIndex} ||= 0;
  $self->add_info(sprintf 'temp %s is %.2fC',
      $self->{lmTempSensorsDevice},
      $self->{lmTempSensorsValue});
  $self->add_ok();
  $self->add_perfdata(
      label => sprintf('temp_%s', $self->{lmTempSensorsDevice}),
      value => $self->{lmTempSensorsValue},
  );
}

package Classes::LMSENSORSMIB;
our @ISA = qw(Classes::Device);
use strict;

package Classes::ENTITYSENSORMIB;
our @ISA = qw(Classes::Device);
use strict;

package Classes::ENTITYSENSORMIB::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('ENTITY-MIB', [
    ['entities', 'entPhysicalTable', 'Monitoring::GLPlugin::TableItem', sub { my $o = shift; $o->{entPhysicalClass} eq 'sensor';}],
  ]);
  $self->get_snmp_tables('ENTITY-SENSOR-MIB', [
    ['sensors', 'entPhySensorTable', 'Classes::ENTITYSENSORMIB::Component::EnvironmentalSubsystem::Sensor' ],
  ]);
  if (! @{$self->{entities}}) {
    $self->fake_names();
  }
  foreach (@{$self->{sensors}}) {
    $_->{entPhySensorEntityName} = shift(@{$self->{entities}})->{entPhysicalName} unless $_->{entPhySensorEntityName};;
  }
  delete $self->{entities};
}

sub check {
  my $self = shift;
  foreach (@{$self->{sensors}}) {
    $_->check();
  }
  if (! $self->check_messages()) {
    $self->add_ok("environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  foreach (@{$self->{sensors}}) {
    $_->dump();
  }
}

sub fake_names {
  # das ist hoffentlich ein ausnahmefall. 
  # z.b. cisco asa hat keine entPhysicalTable, aber entPhySensorTable
  my $self = shift;
  my $no_has_entities_names = {};
  foreach (@{$self->{sensors}}) {
    if (! exists $no_has_entities_names->{$_->{entPhySensorType}}) {
      $no_has_entities_names->{$_->{entPhySensorType}} = {};
    }
    if (! exists $no_has_entities_names->{$_->{entPhySensorType}}->{$_->{entPhySensorUnitsDisplay}}) {
      $no_has_entities_names->{$_->{entPhySensorType}}->{$_->{entPhySensorUnitsDisplay}} = 1;
    } else {
      $no_has_entities_names->{$_->{entPhySensorType}}->{$_->{entPhySensorUnitsDisplay}}++;
    }
    if ($_->{entPhySensorType} eq "truthvalue") {
      $_->{entPhySensorEntityName} = sprintf "%s %s",
          $_->{entPhySensorUnitsDisplay},
          $_->{entPhySensorValue};
    } else {
      $_->{entPhySensorEntityName} = sprintf "%s %s",
          $_->{entPhySensorUnitsDisplay},
          $no_has_entities_names->{$_->{entPhySensorType}}->{$_->{entPhySensorUnitsDisplay}};
    }
    $_->{entPhySensorEntityName} =~ s/\s+/_/g;
  }
}

package Classes::ENTITYSENSORMIB::Component::EnvironmentalSubsystem::Sensor;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;


sub finish {
  my $self = shift;
  if ($self->{entPhySensorPrecision} && $self->{entPhySensorValue}) {
    $self->{entPhySensorValue} /= 10 ** $self->{entPhySensorPrecision};
  }
  if ($self->{entPhySensorType} eq 'rpm') {
    bless $self, 'Classes::ENTITYSENSORMIB::Component::EnvironmentalSubsystem::Sensor::Fan';
  } elsif ($self->{entPhySensorType} eq 'celsius') {
    bless $self, 'Classes::ENTITYSENSORMIB::Component::EnvironmentalSubsystem::Sensor::Temperature';
  }
}

sub check {
  my $self = shift;
  if ($self->{entPhySensorOperStatus} ne 'ok') {
    $self->add_info(sprintf '%s sensor %s has status %s',
        $self->{entPhySensorType},
        $self->{entPhySensorEntityName},
        $self->{entPhySensorOperStatus});
    if ($self->{entPhySensorOperStatus} eq 'nonoperational') {
      $self->add_critical();
    } else {
      $self->add_unknown();
    }
  } else {
    $self->add_info(sprintf "%s sensor %s reports %s%s",
        $self->{entPhySensorType},
        $self->{entPhySensorEntityName},
        $self->{entPhySensorValue},
        $self->{entPhySensorUnitsDisplay}
    );
    #$self->add_ok();
  }
}


package Classes::ENTITYSENSORMIB::Component::EnvironmentalSubsystem::Sensor::Temperature;
our @ISA = qw(Classes::ENTITYSENSORMIB::Component::EnvironmentalSubsystem::Sensor);
use strict;

sub rename {
  my $self = shift;
}

sub check {
  my $self = shift;
  $self->SUPER::check();
  my $label = $self->{entPhySensorEntityName};
  $label =~ s/[Tt]emperature\s*@\s*(.*)/$1/;
  $self->add_perfdata(
    label => 'temp_'.$label,
    value => $self->{entPhySensorValue},
  );
}

package Classes::ENTITYSENSORMIB::Component::EnvironmentalSubsystem::Sensor::Fan;
our @ISA = qw(Classes::ENTITYSENSORMIB::Component::EnvironmentalSubsystem::Sensor);
use strict;

sub check {
  my $self = shift;
  $self->SUPER::check();
  my $label = $self->{entPhySensorEntityName};
  $label =~ s/ RPM$//g;
  $label =~ s/Fan #(\d+)/$1/g;
  $self->add_perfdata(
    label => 'fan_'.$label,
    value => $self->{entPhySensorValue},
  );
}


package Classes::OSPF::Component::NeighborSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->establish_snmp_secondary_session();
  $self->get_snmp_tables('OSPF-MIB', [
    ['nbr', 'ospfNbrTable', 'Classes::OSPF::Component::NeighborSubsystem::Neighbor', , sub { my $o = shift; return $self->filter_name($o->{ospfNbrIpAddr}) && $self->filter_name2($o->{ospfNbrRtrId}) }],
  ]);
  if (! @{$self->{nbr}}) {
    $self->add_unknown("no neighbors found");
  }
}

sub check {
  my $self = shift;
  if ($self->mode =~ /device::ospf::neighbor::list/) {
    foreach (@{$self->{nbr}}) {
      printf "%s %s %s\n", $_->{name}, $_->{ospfNbrRtrId}, $_->{ospfNbrState};
    }
    $self->add_ok("have fun");
  } else {
    map { $_->check(); } @{$self->{nbr}};
  }
}

package Classes::OSPF::Component::NeighborSubsystem::Neighbor;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;
# Index: ospfNbrIpAddr, ospfNbrAddressLessIndex

sub finish {
  my $self = shift;
  $self->{name} = $self->{ospfNbrIpAddr} || $self->{ospfNbrAddressLessIndex}
}

sub check {
  my $self = shift;
  $self->add_info(sprintf "neighbor %s (Id %s) has status %s",
      $self->{name}, $self->{ospfNbrRtrId}, $self->{ospfNbrState});
  if ($self->{ospfNbrState} ne "full" && $self->{ospfNbrState} ne "twoWay") {
    $self->add_critical();
  } else {
    $self->add_ok();
  }
}

# eventuell: warning, wenn sich die RouterId ndert
package Classes::OSPF;
our @ISA = qw(Classes::Device);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::ospf::neighbor/) {
    $self->analyze_and_check_neighbor_subsystem("Classes::OSPF::Component::NeighborSubsystem");
  } else {
    $self->no_such_mode();
  }
}


package Classes::OSPF::Component::AreaSubsystem;
our @ISA = qw(Monitoring::GLPlugin::Item);
use strict;

package Classes::OSPF::Component::AreaSubsystem::Area;
our @ISA = qw(Monitoring::GLPlugin::TableItem);
use strict;
# Index: ospfAreaId

package Classes::OSPF::Component::HostSubsystem::Host;
our @ISA = qw(Monitoring::GLPlugin::TableItem);
use strict;
# Index: ospfHostIpAddress, ospfHostTOS

package Classes::OSPF::Component::InterfaceSubsystem::Interface;
our @ISA = qw(Monitoring::GLPlugin::TableItem);
use strict;
# Index: ospfIfIpAddress, ospfAddressLessIf




package Classes::BGP::Component::PeerSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

our $errorcodes = {
  0 => {
    0 => 'No Error',
  },
  1 => {
    0 => 'MESSAGE Header Error',
    1 => 'Connection Not Synchronized',
    2 => 'Bad Message Length',
    3 => 'Bad Message Type',
  },
  2 => {
    0 => 'OPEN Message Error',
    1 => 'Unsupported Version Number',
    2 => 'Bad Peer AS',
    3 => 'Bad BGP Identifier',
    4 => 'Unsupported Optional Parameter',
    5 => '[Deprecated => see Appendix A]',
    6 => 'Unacceptable Hold Time',
  },
  3 => {
    0 => 'UPDATE Message Error',
    1 => 'Malformed Attribute List',
    2 => 'Unrecognized Well-known Attribute',
    3 => 'Missing Well-known Attribute',
    4 => 'Attribute Flags Error',
    5 => 'Attribute Length Error',
    6 => 'Invalid ORIGIN Attribute',
    7 => '[Deprecated => see Appendix A]',
    8 => 'Invalid NEXT_HOP Attribute',
    9 => 'Optional Attribute Error',
   10 => 'Invalid Network Field',
   11 => 'Malformed AS_PATH',
  },
  4 => {
    0 => 'Hold Timer Expired',
  },
  5 => {
    0 => 'Finite State Machine Error',
  },
  6 => {
    0 => 'Cease',
    1 => 'Maximum Number of Prefixes Reached',
    2 => 'Administrative Shutdown',
    3 => 'Peer De-configured',
    4 => 'Administrative Reset',
    5 => 'Connection Rejected',
    6 => 'Other Configuration Change',
    7 => 'Connection Collision Resolution',
    8 => 'Out of Resources',
  },
};

sub init {
  my $self = shift;
  $self->{peers} = [];
  if ($self->mode =~ /device::bgp::peer::(list|count|watch)/) {
    $self->update_entry_cache(1, 'BGP4-MIB', 'bgpPeerTable', 'bgpPeerRemoteAddr');
  }
  foreach ($self->get_snmp_table_objects_with_cache(
      'BGP4-MIB', 'bgpPeerTable', 'bgpPeerRemoteAddr')) {
    if ($self->filter_name($_->{bgpPeerRemoteAddr})) {
      push(@{$self->{peers}},
          Classes::BGP::Component::PeerSubsystem::Peer->new(%{$_}));
    }
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking bgp peers');
  if ($self->mode =~ /peer::list/) {
    foreach (sort {$a->{bgpPeerRemoteAddr} cmp $b->{bgpPeerRemoteAddr}} @{$self->{peers}}) {
      printf "%s\n", $_->{bgpPeerRemoteAddr};
      #$_->list();
    }
    $self->add_ok("have fun");
  } elsif ($self->mode =~ /peer::count/) {
    $self->add_info(sprintf "found %d peers", scalar(@{$self->{peers}}));
    $self->set_thresholds(warning => '1:', critical => '1:');
    $self->add_message($self->check_thresholds(scalar(@{$self->{peers}})));
    $self->add_perfdata(
        label => 'peers',
        value => scalar(@{$self->{peers}}),
    );
  } elsif ($self->mode =~ /peer::watch/) {
    # take a snapshot of the peer list. -> good baseline
    # warning if there appear peers, mitigate to ok
    # critical if warn/crit percent disappear
    $self->{numOfPeers} = scalar (@{$self->{peers}});
    $self->{peerNameList} = [map { $_->{bgpPeerRemoteAddr} } @{$self->{peers}}];
    $self->opts->override_opt('lookback', 3600) if ! $self->opts->lookback;
    if ($self->opts->reset) {
      my $statefile = $self->create_statefile(name => 'bgppeerlist', lastarray => 1);
      unlink $statefile if -f $statefile;
    }
    $self->valdiff({name => 'bgppeerlist', lastarray => 1},
        qw(peerNameList numOfPeers));
    my $problem = 0;
    if ($self->opts->warning || $self->opts->critical) {
      $self->set_thresholds(warning => $self->opts->warning,
          critical => $self->opts->critical);
      my $before = $self->{numOfPeers} - scalar(@{$self->{delta_found_peerNameList}}) + scalar(@{$self->{delta_lost_peerNameList}});
      # use own delta_numOfPeers, because the glplugin version treats
      # negative deltas as overflows
      $self->{delta_numOfPeers} = $self->{numOfPeers} - $before;
      if ($self->opts->units && $self->opts->units eq "%") {
        my $delta_pct = $before ? (($self->{delta_numOfPeers} / $before) * 100) : 0;
        $self->add_message($self->check_thresholds($delta_pct),
          sprintf "%.2f%% delta, before: %d, now: %d", $delta_pct, $before, $self->{numOfPeers});
        $problem = $self->check_thresholds($delta_pct);
      } else {
        $self->add_message($self->check_thresholds($self->{delta_numOfPeers}),
          sprintf "%d delta, before: %d, now: %d", $self->{delta_numOfPeers}, $before, $self->{numOfPeers});
        $problem = $self->check_thresholds($self->{delta_numOfPeers});
      }
      if (scalar(@{$self->{delta_found_peerNameList}}) > 0) {
        $self->add_ok(sprintf 'found: %s',
            join(", ", @{$self->{delta_found_peerNameList}}));
      }
      if (scalar(@{$self->{delta_lost_peerNameList}}) > 0) {
        $self->add_ok(sprintf 'lost: %s',
            join(", ", @{$self->{delta_lost_peerNameList}}));
      }
    } else {
      if (scalar(@{$self->{delta_found_peerNameList}}) > 0) {
        $self->add_warning(sprintf '%d new bgp peers (%s)',
            scalar(@{$self->{delta_found_peerNameList}}),
            join(", ", @{$self->{delta_found_peerNameList}}));
        $problem = 1;
      }
      if (scalar(@{$self->{delta_lost_peerNameList}}) > 0) {
        $self->add_critical(sprintf '%d bgp peers missing (%s)',
            scalar(@{$self->{delta_lost_peerNameList}}),
            join(", ", @{$self->{delta_lost_peerNameList}}));
        $problem = 2;
      }
      $self->add_ok(sprintf 'found %d bgp peers', scalar (@{$self->{peers}}));
    }
    if ($problem) { # relevant only for lookback=9999 and support contract customers
      $self->valdiff({name => 'bgppeerlist', lastarray => 1, freeze => 1},
          qw(peerNameList numOfPeers));
    } else {
      $self->valdiff({name => 'bgppeerlist', lastarray => 1, freeze => 2},
          qw(peerNameList numOfPeers));
    }
    $self->add_perfdata(
        label => 'num_peers',
        value => scalar (@{$self->{peers}}),
    );
  } else {
    if (scalar(@{$self->{peers}}) == 0) {
      $self->add_unknown('no peers');
      return;
    }
    # es gibt
    # kleine installation: 1 peer zu 1 as, evt 2. as als fallback
    # grosse installation: n peer zu 1 as, alternative routen zum provider
    #                      n peer zu m as, mehrere provider, mehrere alternativrouten
    # 1 ausfall on 4 peers zu as ist egal
    my $as_numbers = {};
    foreach (@{$self->{peers}}) {
      $_->check();
      if (! exists $as_numbers->{$_->{bgpPeerRemoteAs}}->{peers}) {
        $as_numbers->{$_->{bgpPeerRemoteAs}}->{peers} = [];
        $as_numbers->{$_->{bgpPeerRemoteAs}}->{availability} = 100;
      }
      push(@{$as_numbers->{$_->{bgpPeerRemoteAs}}->{peers}}, $_);
    }
    if ($self->opts->name2) {
      $self->clear_ok();
      $self->clear_critical();
      if ($self->opts->name2 eq "_ALL_") {
        $self->opts->override_opt("name2", join(",", keys %{$as_numbers}));
      }
      foreach my $as (split(",", $self->opts->name2)) {
        my $asname = "";
        if ($as =~ /(\d+)=(\w+)/) {
          $as = $1;
          $asname = $2;
        }
        if (exists $as_numbers->{$as}) {
          my $num_peers = scalar(@{$as_numbers->{$as}->{peers}});
          my $num_ok_peers = scalar(grep { $_->{bgpPeerFaulty} == 0 } @{$as_numbers->{$as}->{peers}});
          my $num_admdown_peers = scalar(grep { $_->{bgpPeerAdminStatus} eq "stop" } @{$as_numbers->{$as}->{peers}});
          $as_numbers->{$as}->{availability} = 100 * $num_ok_peers / $num_peers;
          $self->set_thresholds(warning => "100:", critical => "50:");
          $self->add_message($self->check_thresholds($as_numbers->{$as}->{availability}),
              sprintf "%d from %d connections to %s are up (%.2f%%%s)",
              $num_ok_peers, $num_peers, $asname ? $asname : "AS".$as,
              $as_numbers->{$as}->{availability},
              $num_admdown_peers ? sprintf(", but %d are admin down and counted as up!", $num_admdown_peers) : "");
        } else {
          $self->add_critical(sprintf 'found no peer for %s', $asname ? $asname : "AS".$as);
        }
      }
    }
    if ($self->opts->report eq "short") {
      $self->clear_ok();
      $self->add_ok('no problems') if ! $self->check_messages();
    }
  }
}


package Classes::BGP::Component::PeerSubsystem::Peer;
our @ISA = qw(Classes::BGP::Component::PeerSubsystem);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {};
  foreach(keys %params) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  $self->{bgpPeerLastError} |= "00 00";
  my $errorcode = 0;
  my $subcode = 0;
  if (lc $self->{bgpPeerLastError} =~ /([0-9a-f]+)\s+([0-9a-f]+)/) {
    $errorcode = hex($1) * 1;
    $subcode = hex($2) * 1;
  }
  $self->{bgpPeerLastError} = $Classes::BGP::Component::PeerSubsystem::errorcodes->{$errorcode}->{$subcode};
  $self->{bgpPeerRemoteAsName} = "";
  $self->{bgpPeerRemoteAsImportant} = 0; # if named in --name2
  $self->{bgpPeerFaulty} = 0;
  my @parts = gmtime($self->{bgpPeerFsmEstablishedTime});
  $self->{bgpPeerFsmEstablishedTime} = sprintf ("%dd, %dh, %dm, %ds",@parts[7,2,1,0]);

  return $self;
}

sub check {
  my $self = shift;
  if ($self->opts->name2) {
    foreach my $as (split(",", $self->opts->name2)) {
      if ($as =~ /(\d+)=(\w+)/) {
        $as = $1;
        $self->{bgpPeerRemoteAsName} = ", ".$2;
      } else {
        $self->{bgpPeerRemoteAsName} = "";
      }
      if ($as eq "_ALL_" || $as == $self->{bgpPeerRemoteAs}) {
        $self->{bgpPeerRemoteAsImportant} = 1;
      }
    }
  } else {
    $self->{bgpPeerRemoteAsImportant} = 1;
  }
  if ($self->{bgpPeerState} eq "established") {
    $self->add_ok(sprintf "peer %s (AS%s) state is %s since %s",
        $self->{bgpPeerRemoteAddr},
        $self->{bgpPeerRemoteAs}.$self->{bgpPeerRemoteAsName},
        $self->{bgpPeerState},
        $self->{bgpPeerFsmEstablishedTime}
    );
  } elsif ($self->{bgpPeerAdminStatus} eq "stop") {
    # admin down is by default critical, but can be mitigated
    $self->add_message(
        defined $self->opts->mitigation() ? $self->opts->mitigation() :
            $self->{bgpPeerRemoteAsImportant} ? WARNING : OK,
        sprintf "peer %s (AS%s) state is %s (is admin down)",
        $self->{bgpPeerRemoteAddr},
        $self->{bgpPeerRemoteAs}.$self->{bgpPeerRemoteAsName},
        $self->{bgpPeerState}
    );
    $self->{bgpPeerFaulty} =
        defined $self->opts->mitigation() && $self->opts->mitigation() eq "ok" ? 0 :
        $self->{bgpPeerRemoteAsImportant} ? 1 : 0;
  } else {
    # bgpPeerLastError may be undef, at least under the following circumstances
    # bgpPeerRemoteAsName is "", bgpPeerAdminStatus is "start",
    # bgpPeerState is "active"
    $self->add_message($self->{bgpPeerRemoteAsImportant} ? CRITICAL : OK,
        sprintf "peer %s (AS%s) state is %s (last error: %s)",
        $self->{bgpPeerRemoteAddr},
        $self->{bgpPeerRemoteAs}.$self->{bgpPeerRemoteAsName},
        $self->{bgpPeerState},
        $self->{bgpPeerLastError}||"no error"
    );
    $self->{bgpPeerFaulty} = $self->{bgpPeerRemoteAsImportant} ? 1 : 0;
  }
}


package Classes::BGP;
our @ISA = qw(Classes::Device);
use strict;

package Classes::FCMGMT::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{sensor_subsystem} =
      Classes::FCMGMT::Component::SensorSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{sensor_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_ok("environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{sensor_subsystem}->dump();
}

package Classes::FCMGMT::Component::SensorSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('FCMGMT-MIB', [
      ['sensors', 'fcConnUnitSensorTable', 'Classes::FCMGMT::Component::SensorSubsystem::Sensor'],
  ]);
  foreach (@{$self->{sensors}}) {
    $_->{fcConnUnitSensorIndex} ||= $_->{flat_indices};
  }
}

package Classes::FCMGMT::Component::SensorSubsystem::Sensor;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf '%s sensor %s (%s) is %s (%s)',
      $self->{fcConnUnitSensorType},
      $self->{fcConnUnitSensorIndex},
      $self->{fcConnUnitSensorInfo},
      $self->{fcConnUnitSensorStatus},
      $self->{fcConnUnitSensorMessage});
  if ($self->{fcConnUnitSensorStatus} ne "ok") {
    $self->add_critical();
  } else {
    #$self->add_ok();
  }
}

package Classes::FCMGMT;
our @ISA = qw(Classes::Device);
use strict;

package Classes::FCEOS::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub overall_init {
  my $self = shift;
  $self->get_snmp_objects('FCEOS-MIB', (qw(
      fcEosSysOperStatus)));
}

sub init {
  my $self = shift;
  $self->{fru_subsystem} =
      Classes::FCEOS::Component::FruSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{fru_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_ok("environmental hardware working fine");
  } else {
    if ($self->{fcEosSysOperStatus} eq "operational") {
      $self->clear_critical();
      $self->clear_warning();
    } elsif ($self->{fcEosSysOperStatus} eq "major-failure") {
      $self->add_critical("major device failure");
    } else {
      $self->add_warning($self->{fcEosSysOperStatus});
    }
  }
}

package Classes::FCEOS::Component::FruSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('FCEOS-MIB', [
      ['frus', 'fcEosFruTable', 'Classes::FCEOS::Component::FruSubsystem::Fcu'],
  ]);
}

package Classes::FCEOS::Component::FruSubsystem::Fcu;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf '%s fru (pos %s) is %s',
      $self->{fcEosFruCode},
      $self->{fcEosFruPosition},
      $self->{fcEosFruStatus});
  if ($self->{fcEosFruStatus} eq "failed") {
    $self->add_critical();
  } else {
    #$self->add_ok();
  }
}

package Classes::FCEOS;
our @ISA = qw(Classes::Device);
use strict;

package Classes::UCDMIB::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('UCD-SNMP-MIB', (qw(
      memTotalSwap memAvailSwap memTotalReal memAvailReal memBuffer memCached
      memMinimumSwap memSwapError memSwapErrorMsg)));

  # basically buffered memory can always be freed up (filesystem cache)
  # https://kc.mcafee.com/corporate/index?page=content&id=KB73175
  my $mem_available = $self->{memAvailReal};
  foreach (qw(memBuffer memCached)) {
    $mem_available += $self->{$_} if defined($self->{$_});
  }

  # calc memory (no swap)
  $self->{mem_usage} = 100 - ($mem_available * 100 / $self->{memTotalReal});
}

sub check {
  my $self = shift;
  $self->add_info('checking memory');
  if (defined $self->{mem_usage}) {
    $self->add_info(sprintf 'memory usage is %.2f%%',
        $self->{mem_usage});
    $self->set_thresholds(
        metric => 'memory_usage',
        warning => 80,
        critical => 90);
    $self->add_message($self->check_thresholds(
        metric => 'memory_usage',
        value => $self->{mem_usage}));
    $self->add_perfdata(
        label => 'memory_usage',
        value => $self->{mem_usage},
        uom => '%',
    );
  } else {
    $self->add_unknown('cannot aquire memory usage');
  }
}

package Classes::UCDMIB::Component::SwapSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('UCD-SNMP-MIB', (qw(
      memTotalSwap memAvailSwap memMinimumSwap
      memSwapError memSwapErrorMsg)));

  # calc swap usage
  eval {
    $self->{swap_usage} = 100 - ($self->{memAvailSwap} * 100 / $self->{memTotalSwap});
  };
}

sub check {
  my $self = shift;
  if (defined $self->{'swap_usage'}) {
    $self->add_info(sprintf 'swap usage is %.2f%%',
        $self->{swap_usage});
    $self->set_thresholds(
      metric => 'swap_usage',
      warning => int(100 - ($self->{memMinimumSwap} * 100 / $self->{memTotalSwap})),
      critical => int(100 - ($self->{memMinimumSwap} * 100 / $self->{memTotalSwap}))
    );
    $self->add_message($self->check_thresholds(
        metric => 'swap_usage',
        value => $self->{swap_usage}));
    $self->add_perfdata(
        label => 'swap_usage',
        value => $self->{swap_usage},
        uom => '%',
    );
    if ($self->{'memSwapError'} eq 'error') {
      $self->add_critical('SwapError: ' . $self->{'memSwapErrorMsg'});
    }
  } else {
    # $self->add_unknown('cannot aquire swap usage');
    # This system does not use swap
  }
}

package Classes::UCDMIB::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('UCD-SNMP-MIB', (qw(
      ssCpuUser ssCpuSystem ssCpuIdle ssCpuRawUser ssCpuRawSystem ssCpuRawIdle
      ssCpuRawNice ssCpuRawWait ssCpuRawKernel ssCpuRawInterrupt)));
  $self->valdiff({name => 'cpu'}, qw(
      ssCpuRawUser ssCpuRawSystem ssCpuRawIdle ssCpuRawNice ssCpuRawWait
      ssCpuRawKernel ssCpuRawInterrupt));
  my $cpu_total = 0;
  # not every kernel/snmpd supports every counters
  foreach (qw(delta_ssCpuRawUser delta_ssCpuRawSystem delta_ssCpuRawIdle
    delta_ssCpuRawNice delta_ssCpuRawWait delta_ssCpuRawKernel
    delta_ssCpuRawInterrupt)) {
    $cpu_total += $self->{$_} if defined($self->{$_});
  }

  # main cpu usage (total - idle)
  $self->{cpu_usage} =
      $cpu_total == 0 ? 0 : (100 - ($self->{delta_ssCpuRawIdle} / $cpu_total) * 100);

  # additional metrics (all but idle)
  if (defined $self->{delta_ssCpuRawUser}) {
    $self->{user_usage} =
        $cpu_total == 0 ? 0 : ($self->{delta_ssCpuRawUser} / $cpu_total) * 100;
  }
  if (defined $self->{delta_ssCpuRawSystem}) {
    $self->{system_usage} =
        $cpu_total == 0 ? 0 : ($self->{delta_ssCpuRawSystem} / $cpu_total) * 100;
  }
  if (defined $self->{delta_ssCpuRawNice}) {
    $self->{nice_usage} =
        $cpu_total == 0 ? 0 : ($self->{delta_ssCpuRawNice} / $cpu_total) * 100;
  }
  if (defined $self->{delta_ssCpuRawWait}) {
    $self->{wait_usage} =
        $cpu_total == 0 ? 0 : ($self->{delta_ssCpuRawWait} / $cpu_total) * 100;
  }
  if (defined $self->{delta_ssCpuRawKernel}) {
    $self->{kernel_usage} =
        $cpu_total == 0 ? 0 : ($self->{delta_ssCpuRawKernel} / $cpu_total) * 100;
  }
  if (defined $self->{delta_ssCpuRawInterrupt}) {
    $self->{interrupt_usage} =
        $cpu_total == 0 ? 0 : ($self->{delta_ssCpuRawInterrupt} / $cpu_total) * 100;
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking cpus');
  foreach (qw(cpu user system nice wait kernel interrupt)) {
    my $key = $_ . '_usage';
    if (defined($self->{$key})) {
      $self->add_info(sprintf '%s: %.2f%%',
          $_ . ($_ eq 'cpu' ? ' (total)' : ''),
	  $self->{$key});
      $self->set_thresholds(
          metric => $key,
          warning => 50,
          critical => 90);
      $self->add_message($self->check_thresholds(
          metric => $key,
          value => $self->{$key}));
      $self->add_perfdata(
          label => $key,
          value => $self->{$key},
          uom => '%',
      );
    }
  }
}
package Classes::UCDMIB::Component::LoadSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  my %params = @_;
  my $type = 0;
  $self->get_snmp_tables('UCD-SNMP-MIB', [
      ['loads', 'laTable', 'Classes::UCDMIB::Component::LoadSubsystem::Load'],
  ]);
}

sub check {
  my $self = shift;
  $self->add_info('checking loads');
  foreach (@{$self->{loads}}) {
    $_->check();
  }
}

sub dump {
  my $self = shift;
  foreach (@{$self->{loads}}) {
    $_->dump();
  }
}


package Classes::UCDMIB::Component::LoadSubsystem::Load;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;
use Data::Dumper;

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->set_thresholds(
      metric => lc $self->{laNames},
      warning => $self->{laConfig},
      critical => $self->{laConfig}
  );
  $self->add_info(
      sprintf '%s is %.2f%s',
      lc $self->{laNames}, $self->{laLoad},
      $self->{'laErrorFlag'} eq 'error'
          ? sprintf ' (%s)', $self->{'laErrMessage'}
          : ''
  );
  if ($self->{'laErrorFlag'} eq 'error') {
    $self->add_critical();
  } else {
    $self->add_message($self->check_thresholds(
        metric => lc $self->{laNames},
        value => $self->{laLoad}));
  }
  $self->add_perfdata(
      label => lc $self->{laNames},
      value => $self->{laLoad},
  );
}

package Classes::UCDMIB::Component::DiskSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('UCD-SNMP-MIB', [
      ['disks', 'dskTable', 'Classes::UCDMIB::Component::DiskSubsystem::Disk',
          sub {
            my $self = shift;
            # limit disk checks to specific disks. could be improvied by
            # checking the path first and then request the table by indizes
            if ($self->opts->name) {
              if ($self->opts->regexp) {
                my $pattern = $self->opts->name;
                return $self->{dskTotal} && $self->{dskPath} =~ /$pattern/i;
              } else {
                return $self->{dskTotal} && grep { $_ eq $self->{dskPath} }
                    split ',', $self->opts->name;
              }
            } else {
              return $self->{dskTotal} &&
                  $self->{dskDevice} !~ /^(sysfs|proc|udev|devpts|rpc_pipefs|nfsd|devfs)$/;
            }
          }
      ],
  ]);
}

sub check {
  my $self = shift;
  $self->add_info('checking disks');
  if (scalar(@{$self->{disks}}) == 0) {
    $self->add_unknown('no disks');
    return;
  }
  foreach (@{$self->{disks}}) {
    $_->check();
  }
}

package Classes::UCDMIB::Component::DiskSubsystem::Disk;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;

  # use 32bit counter first
  my $avail = $self->{dskAvail};
  my $total = $self->{dskTotal};
  my $used = $self->{dskUsed};

  # support large disks if 64bit counter are present
  if (defined $self->{dskAvailHigh} && defined $self->{dskAvailLow}
      && $self->{dskAvailHigh} > 0) {
    $avail = $self->{dskAvailHigh} * 2**32 + $self->{dskAvailLow};
  }
  if (defined $self->{dskTotalHigh} && defined $self->{dskTotalLow}
      && $self->{dskTotalHigh} > 0) {
    $total = $self->{dskTotalHigh} * 2**32 + $self->{dskTotalLow};
  }
  if (defined $self->{dskUsedHigh} && defined $self->{dskUsedLow}
      && $self->{dskUsedHigh} > 0) {
    $used = $self->{dskUsedHigh} * 2**32 + $self->{dskUsedLow};
  }

  # calc free space left
  my $free = 100 * $avail / $total;

  # define + set threshold
  my $warn = '10:';
  my $crit = '5:';
  my $warn_used = int($total * 0.9);
  my $crit_used = int($total * 0.95);

  # set threshold based on snmp response
  if ($self->{dskMinPercent} >= 0) {
    $warn = sprintf '%d:', $self->{dskMinPercent};
    $crit = $warn;
    $warn_used = int($total * (1 - $self->{dskMinPercent}/100));
    $crit_used = $warn_used;
  } elsif ($self->{dskMinimum} >= 0) {
    $warn = sprintf '%f:', $self->{dskMinimum} / $total;
    $crit = $warn;
    $warn_used = $total - $self->{dskMinimum};
    $crit_used = $warn_used;
  }

  # now set the thresholds
  $self->set_thresholds(metric => sprintf('%s_free_pct', $self->{dskPath}),
      warning => $warn, critical => $crit);

  # display human readable free space message
  my $spaceleft = int($avail/1024);
  $spaceleft =~ s/(?<=\d)(?=(?:\d\d\d)+\b)/,/g;
  $self->add_info(sprintf '%s has %s MB left (%.2f%%)%s',
      $self->{dskPath}, $spaceleft, $free,
      $self->{dskErrorFlag} eq 'error'
          ? sprintf ' - %s', $self->{dskErrorMsg}
          : '');

  # raise critical error if errorflag is set
  if ($self->{dskErrorFlag} eq 'error') {
    $self->add_critical();
  } else {
    # otherwise check thresholds
    $self->add_message($self->check_thresholds(
        metric => sprintf('%s_free_pct', $self->{dskPath}),
        value => $free));
  }

  # add performance data
  $self->add_perfdata(
      label => sprintf('%s_free_pct', $self->{dskPath}),
      value => $free,
      uom => '%',
  );

  # add additional perfdata and map thresholds if they have been changed
  # via commandline arguments (just for perfdata display
  my @thresholds = $self->get_thresholds(
      metric => sprintf('%s_free_pct', $self->{dskPath}));
  if ($warn ne $thresholds[0] && $thresholds[0] =~ m/^(\d+):$/) {
    $warn_used = int($total * (1 - $1/100));
  }
  if ($crit ne $thresholds[1] && $thresholds[1] =~ m/^(\d+):$/) {
    $crit_used = int($total * (1 - $1/100));
  }
  $self->add_perfdata(
      label => sprintf('%s_used_kb', $self->{dskPath}),
      value => $used,
      uom => 'kb',
      min => 0,
      max => $total,
      warning => $warn_used,
      critical => $crit_used
  );
}

package Classes::UCDMIB::Component::ProcessSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('UCD-SNMP-MIB', [
      ['processes', 'prTable', 'Classes::UCDMIB::Component::ProcessSubsystem::Process',
        sub {
          my $self = shift;
          # limit process checks to specific names. could be improvied by
          # checking the names first and then request the table by indizes
          if ($self->opts->name) {
            if ($self->opts->regexp) {
              my $pattern = $self->opts->name;
              return $self->{prNames} =~ /$pattern/i;
            } else {
              return grep { $_ eq $self->{prNames} }
                  split ',', $self->opts->name;
            }
          } else {
            return 1;
          }
        }
      ]
  ]);
}

sub check {
  my $self = shift;
  $self->add_info('checking processes');
  if (scalar(@{$self->{processes}}) == 0) {
    $self->add_unknown('no processes');
    return;
  }
  foreach (@{$self->{processes}}) {
    $_->check();
  }
}

package Classes::UCDMIB::Component::ProcessSubsystem::Process;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf '%s: %d%s',
      $self->{prNames},
      $self->{prCount},
      $self->{prErrorFlag} eq 'error'
          ? sprintf ' (%s)', $self->{prErrMessage}
          : '');
  my $threshold = sprintf '%u:%s',
      !$self->{prMin} && !$self->{prMax} ? 1 : $self->{prMin},
      $self->{prMax} && $self->{prMax} >= $self->{prMin} ? $self->{prMax} : '';
  $self->set_thresholds(
      metric => $self->{prNames},
      warning => $threshold,
      critical => $threshold);
  if ($self->{prErrorFlag} eq 'error') {
    $self->add_critical();
  } else {
    $self->add_message($self->check_thresholds(
        metric => $self->{prNames},
        value => $self->{prCount}));
  }
  $self->add_perfdata(
      label => $self->{prNames},
      value => $self->{prCount}
  );
}

package Classes::UCDMIB;
our @ISA = qw(Classes::Device);
use strict;

package Classes::F5::F5BIGIP::Component::LTMSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

{
  our $max_l4_connections = 10000000;
}

sub max_l4_connections : lvalue {
  my $self = shift;
  $Classes::F5::F5BIGIP::Component::LTMSubsystem::max_l4_connections;
}

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    sysProductVersion => $params{sysProductVersion},
    sysPlatformInfoMarketingName => $params{sysPlatformInfoMarketingName},
  };
  if ($self->{sysProductVersion} =~ /^4/) {
    bless $self, "Classes::F5::F5BIGIP::Component::LTMSubsystem4";
    $self->debug("use Classes::F5::F5BIGIP::Component::LTMSubsystem4");
  } else {
    bless $self, "Classes::F5::F5BIGIP::Component::LTMSubsystem9";
    $self->debug("use Classes::F5::F5BIGIP::Component::LTMSubsystem9");
  }
  # tables can be huge
  $self->mult_snmp_max_msg_size(10);
  $self->set_max_l4_connections();
  $self->init();
  return $self;
}

sub set_max_l4_connections {
  my $self = shift;
  if ($self->{sysPlatformInfoMarketingName} && 
      $self->{sysPlatformInfoMarketingName} =~ /BIG-IP\s*(\d+)/i) {
    if ($1 =~ /^(1500)$/) {
      $self->max_l4_connections() = 1500000;
    } elsif ($1 =~ /^(1600)$/) {
      $self->max_l4_connections() = 3000000;
    } elsif ($1 =~ /^(2000|2200)$/) {
      $self->max_l4_connections() = 5000000;
    } elsif ($1 =~ /^(3400)$/) {
      $self->max_l4_connections() = 4000000;
    } elsif ($1 =~ /^(3600|8800|8400)$/) {
      $self->max_l4_connections() = 8000000;
    } elsif ($1 =~ /^(4000|4200)$/) {
      $self->max_l4_connections() = 10000000;
    } elsif ($1 =~ /^(8900|8950)$/) {
      $self->max_l4_connections() = 12000000;
    } elsif ($1 =~ /^(5000|5050|5200|5250|7000|7050|7200|7250|11050)$/) {
      $self->max_l4_connections() = 24000000;
    } elsif ($1 =~ /^(10000|10050|10200|10250)$/) {
      $self->max_l4_connections() = 36000000;
    } elsif ($1 =~ /^(10350|12250)$/) {
      $self->max_l4_connections() = 80000000;
    } elsif ($1 =~ /^(11000)$/) {
      $self->max_l4_connections() = 30000000;
    }
  } elsif ($self->{sysPlatformInfoMarketingName} && 
      $self->{sysPlatformInfoMarketingName} =~ /Viprion\s*(\d+)/i) {
    if ($1 =~ /^(2100)$/) {
      $self->max_l4_connections() = 12000000;
    } elsif ($1 =~ /^(2150)$/) {
      $self->max_l4_connections() = 24000000;
    } elsif ($1 =~ /^(2200|2250|2400)$/) {
      $self->max_l4_connections() = 48000000;
    } elsif ($1 =~ /^(4300)$/) {
      $self->max_l4_connections() = 36000000;
    } elsif ($1 =~ /^(4340|4800)$/) {
      $self->max_l4_connections() = 72000000;
    }
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking ltm pools');
  if (scalar(@{$self->{pools}}) == 0) {
    $self->add_unknown('no pools');
    return;
  }
  if ($self->mode =~ /pool::list/) {
    foreach (sort {$a->{ltmPoolName} cmp $b->{ltmPoolName}} @{$self->{pools}}) {
      printf "%s\n", $_->{ltmPoolName};
      #$_->list();
    }
  } else {
    foreach (@{$self->{pools}}) {
      $_->check();
    }
  }
}


package Classes::F5::F5BIGIP::Component::LTMSubsystem9;
our @ISA = qw(Classes::F5::F5BIGIP::Component::LTMSubsystem Monitoring::GLPlugin::SNMP::TableItem);
use strict;

#
# A node is an ip address (may belong to more than one pool)
# A pool member is an ip:port combination
#

sub init {
  my $self = shift;
  # ! merge ltmPoolStatus, ltmPoolMemberStatus, bec. ltmPoolAvailabilityState is deprecated
  if ($self->mode =~ /pool::list/) {
    $self->update_entry_cache(1, 'F5-BIGIP-LOCAL-MIB', 'ltmPoolStatusTable', 'ltmPoolStatusName');
    $self->update_entry_cache(1, 'F5-BIGIP-LOCAL-MIB', 'ltmPoolTable', 'ltmPoolName');
    $self->update_entry_cache(1, 'F5-BIGIP-LOCAL-MIB', 'ltmPoolMbrStatusTable', 'ltmPoolMbrStatusPoolName');
    $self->update_entry_cache(1, 'F5-BIGIP-LOCAL-MIB', 'ltmPoolMemberTable', 'ltmPoolMemberPoolName');
    $self->update_entry_cache(1, 'F5-BIGIP-LOCAL-MIB', 'ltmPoolStatTable', 'ltmPoolStatName');
  }
  my @auxpools = ();
  foreach ($self->get_snmp_table_objects_with_cache(
      'F5-BIGIP-LOCAL-MIB', 'ltmPoolStatusTable', 'ltmPoolStatusName')) {
    push(@auxpools, $_);
  }
  if (! grep { $self->filter_name($_->{ltmPoolStatusName}) } @auxpools) {
    #$self->add_unknown("did not find any pools");
    $self->{pools} = [];
    return;
  }
  my @auxstats = ();
  foreach ($self->get_snmp_table_objects_with_cache(
      'F5-BIGIP-LOCAL-MIB', 'ltmPoolStatTable', 'ltmPoolStatName')) {
    push(@auxstats, $_) if $self->filter_name($_->{ltmPoolStatName});
  }
  foreach ($self->get_snmp_table_objects_with_cache(
      'F5-BIGIP-LOCAL-MIB', 'ltmPoolTable', 'ltmPoolName')) {
    foreach my $auxpool (@auxpools) {
      if ($_->{ltmPoolName} eq $auxpool->{ltmPoolStatusName}) {
        foreach my $key (keys %{$auxpool}) {
          $_->{$key} = $auxpool->{$key};
        }
      }
    }
    foreach my $auxstat (@auxstats) {
      if ($_->{ltmPoolName} eq $auxstat->{ltmPoolStatName}) {
        foreach my $key (keys %{$auxstat}) {
          $_->{$key} = $auxstat->{$key};
        }
      }
    }
    push(@{$self->{pools}},
        Classes::F5::F5BIGIP::Component::LTMSubsystem9::LTMPool->new(%{$_}));
  }
  my @auxpoolmbrstatus = ();
  foreach ($self->get_snmp_table_objects_with_cache(
      'F5-BIGIP-LOCAL-MIB', 'ltmPoolMbrStatusTable', 'ltmPoolMbrStatusPoolName')) {
    next if ! defined $_->{ltmPoolMbrStatusPoolName};
    $_->{ltmPoolMbrStatusAddr} = $self->unhex_ip($_->{ltmPoolMbrStatusAddr});
    push(@auxpoolmbrstatus, $_);
  }
  my @auxpoolmemberstat = ();
  foreach ($self->get_snmp_table_objects_with_cache(
      'F5-BIGIP-LOCAL-MIB', 'ltmPoolMemberStatTable', 'ltmPoolMemberStatPoolName')) {
    $_->{ltmPoolMemberStatAddr} = $self->unhex_ip($_->{ltmPoolMemberStatAddr});
    push(@auxpoolmemberstat, $_);
    # ltmPoolMemberStatAddr is deprecated, use ltmPoolMemberStatNodeName
  }
  foreach ($self->get_snmp_table_objects_with_cache(
      'F5-BIGIP-LOCAL-MIB', 'ltmPoolMemberTable', 'ltmPoolMemberPoolName')) {
    $_->{ltmPoolMemberAddr} = $self->unhex_ip($_->{ltmPoolMemberAddr});
    foreach my $auxmbr (@auxpoolmbrstatus) {
      if ($_->{ltmPoolMemberPoolName} eq $auxmbr->{ltmPoolMbrStatusPoolName} &&
          $_->{ltmPoolMemberPort} eq $auxmbr->{ltmPoolMbrStatusPort} &&
          $_->{ltmPoolMemberAddrType} eq $auxmbr->{ltmPoolMbrStatusAddrType} &&
          $_->{ltmPoolMemberAddr} eq $auxmbr->{ltmPoolMbrStatusAddr}) {
        foreach my $key (keys %{$auxmbr}) {
          next if $key =~ /.*indices$/;
          $_->{$key} = $auxmbr->{$key};
        }
      }
    }
    foreach my $auxmember (@auxpoolmemberstat) {
      if ($_->{ltmPoolMemberPoolName} eq $auxmember->{ltmPoolMemberStatPoolName} &&
          $_->{ltmPoolMemberPort} eq $auxmember->{ltmPoolMemberStatPort} &&
          $_->{ltmPoolMemberNodeName} eq $auxmember->{ltmPoolMemberStatNodeName}) {
        foreach my $key (keys %{$auxmember}) {
          next if $key =~ /.*indices$/;
          $_->{$key} = $auxmember->{$key};
        }
      }
    }
    push(@{$self->{poolmembers}},
        Classes::F5::F5BIGIP::Component::LTMSubsystem9::LTMPoolMember->new(%{$_}));
  }
  # ltmPoolMemberNodeName may be the same as ltmPoolMemberAddr
  # there is a chance to learn the actual hostname via ltmNodeAddrStatusName
  # so if there ia a member with name==addr, we get the addrstatus table
  my $need_name_from_addr = 0;
  foreach my $poolmember (@{$self->{poolmembers}}) {
    if ($poolmember->{ltmPoolMemberNodeName} eq $poolmember->{ltmPoolMemberAddr}) {
      $need_name_from_addr = 1;
    }
  }
  if ($need_name_from_addr) {
    my @auxnodeaddrstatus = ();
    foreach ($self->get_snmp_table_objects(
        'F5-BIGIP-LOCAL-MIB', 'ltmNodeAddrStatusTable')) {
      $_->{ltmNodeAddrStatusAddr} = $self->unhex_ip($_->{ltmNodeAddrStatusAddr});
      push(@auxnodeaddrstatus, $_);
    }
    foreach my $poolmember (@{$self->{poolmembers}}) {
      foreach my $auxaddr (@auxnodeaddrstatus) {
        if ($poolmember->{ltmPoolMemberAddrType} eq $auxaddr->{ltmNodeAddrStatusAddrType} &&
            $poolmember->{ltmPoolMemberAddr} eq $auxaddr->{ltmNodeAddrStatusAddr}) {
          $poolmember->{ltmNodeAddrStatusName} = $auxaddr->{ltmNodeAddrStatusName};
          last;
          # needed later, if ltmNodeAddrStatusName is an ip-address. LTMPoolMember::finish
        }
      }
    }
  } else {
    foreach my $poolmember (@{$self->{poolmembers}}) {
      # because later we use ltmNodeAddrStatusName
      $poolmember->{ltmNodeAddrStatusName} = $poolmember->{ltmPoolMemberNodeName};
      my $x = 1;
    }
  }
  foreach my $poolmember (@{$self->{poolmembers}}) {
    $poolmember->rename();
  }
  $self->assign_members_to_pools();
}

sub assign_members_to_pools {
  my $self = shift;
  foreach my $pool (@{$self->{pools}}) {
    foreach my $poolmember (@{$self->{poolmembers}}) {
      if ($poolmember->{ltmPoolMemberPoolName} eq $pool->{ltmPoolName}) {
        $poolmember->{ltmPoolMonitorRule} = $pool->{ltmPoolMonitorRule};
        push(@{$pool->{members}}, $poolmember);
      }
    }
    if (! defined $pool->{ltmPoolMemberCnt}) {
      $pool->{ltmPoolMemberCnt} = scalar(@{$pool->{members}}) ;
      $self->debug("calculate ltmPoolMemberCnt");
    }
    $pool->{completeness} = $pool->{ltmPoolMemberCnt} ?
        $pool->{ltmPoolActiveMemberCnt} / $pool->{ltmPoolMemberCnt} * 100
        : 0;
  }
}


package Classes::F5::F5BIGIP::Component::LTMSubsystem9::LTMPool;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub finish {
  my $self = shift;
  $self->{ltmPoolMemberMonitorRule} ||= $self->{ltmPoolMonitorRule};
  $self->{members} = [];
}

sub check {
  my $self = shift;
  if ($self->mode =~ /device::lb::pool::comple/) {
    my $pool_info = sprintf "pool %s is %s, avail state is %s, active members: %d of %d, connections: %d",
        $self->{ltmPoolName},
        $self->{ltmPoolStatusEnabledState}, $self->{ltmPoolStatusAvailState},
        $self->{ltmPoolActiveMemberCnt}, $self->{ltmPoolMemberCnt}, $self->{ltmPoolStatServerCurConns};
    $self->add_info($pool_info);
    if ($self->{ltmPoolActiveMemberCnt} == 1) {
      # only one member left = no more redundancy!!
      $self->set_thresholds(
          metric => sprintf('pool_%s_completeness', $self->{ltmPoolName}),
          warning => "100:", critical => "51:");
    } else {
      $self->set_thresholds(
          metric => sprintf('pool_%s_completeness', $self->{ltmPoolName}),
          warning => "51:", critical => "26:");
    }
    $self->add_message($self->check_thresholds(
        metric => sprintf('pool_%s_completeness', $self->{ltmPoolName}),
        value => $self->{completeness}));
    if ($self->{ltmPoolMinActiveMembers} > 0 &&
        $self->{ltmPoolActiveMemberCnt} < $self->{ltmPoolMinActiveMembers}) {
      $self->annotate_info(sprintf("not enough active members (%d, min is %d)",
              $self->{ltmPoolName}, $self->{ltmPoolActiveMemberCnt},
              $self->{ltmPoolMinActiveMembers}));
      $self->add_message(defined $self->opts->mitigation() ? $self->opts->mitigation() : CRITICAL);
    }
    if ($self->check_messages() || $self->mode  =~ /device::lb::pool::co.*tions/) {
      foreach my $member (@{$self->{members}}) {
        $member->check();
      }
    }
    $self->add_perfdata(
        label => sprintf('pool_%s_completeness', $self->{ltmPoolName}),
        value => $self->{completeness},
        uom => '%',
    );
    $self->add_perfdata(
        label => sprintf('pool_%s_servercurconns', $self->{ltmPoolName}),
        value => $self->{ltmPoolStatServerCurConns},
        warning => undef, critical => undef,
    );
    if ($self->opts->report eq "html") {
      printf "%s - %s%s\n", $self->status_code($self->check_messages()), $pool_info, $self->perfdata_string() ? " | ".$self->perfdata_string() : "";
      $self->suppress_messages();
      $self->draw_html_table();
    }
  } elsif ($self->mode =~ /device::lb::pool::connections/) {
    foreach my $member (@{$self->{members}}) {
      $member->check();
    }
  }
}

sub draw_html_table {
  my $self = shift;
  if ($self->mode =~ /device::lb::pool::comple/) {
    my @headers = qw(Node Port Enabled Avail Reason);
    my @columns = qw(ltmPoolMemberNodeName ltmPoolMemberPort ltmPoolMbrStatusEnabledState ltmPoolMbrStatusAvailState ltmPoolMbrStatusDetailReason);
    if ($self->mode =~ /device::lb::pool::complections/) {
      push(@headers, "Connections");
      push(@headers, "ConnPct");
      push(@columns, "ltmPoolMemberStatServerCurConns");
      push(@columns, "ltmPoolMemberStatServerPctConns");
      foreach my $member (@{$self->{members}}) {
        $member->{ltmPoolMemberStatServerPctConns} = sprintf "%.5f", $member->{ltmPoolMemberStatServerPctConns};
      }
    }
    printf "<table style=\"border-collapse:collapse; border: 1px solid black;\">";
    printf "<tr>";
    foreach (@headers) {
      printf "<th style=\"text-align: left; padding-left: 4px; padding-right: 6px;\">%s</th>", $_;
    }
    printf "</tr>";
    foreach (sort {$a->{ltmPoolMemberNodeName} cmp $b->{ltmPoolMemberNodeName}} @{$self->{members}}) {
      printf "<tr>";
      printf "<tr style=\"border: 1px solid black;\">";
      foreach my $attr (@columns) {
        if ($_->{ltmPoolMbrStatusEnabledState} eq "enabled") {
          if ($_->{ltmPoolMbrStatusAvailState} eq "green") {
            printf "<td style=\"text-align: left; padding-left: 4px; padding-right: 6px; background-color: #33ff00;\">%s</td>", $_->{$attr};
          } else {
            printf "<td style=\"text-align: left; padding-left: 4px; padding-right: 6px; background-color: #f83838;\">%s</td>", $_->{$attr};
          }
        } else {
          printf "<td style=\"text-align: left; padding-left: 4px; padding-right: 6px; background-color: #acacac;\">%s</td>", $_->{$attr};
        }
      }
      printf "</tr>";
    }
    printf "</table>\n";
    printf "<!--\nASCII_NOTIFICATION_START\n";
    foreach (@headers) {
      printf "%20s", $_;
    }
    printf "\n";
    foreach (sort {$a->{ltmPoolMemberNodeName} cmp $b->{ltmPoolMemberNodeName}} @{$self->{members}}) {
      foreach my $attr (@columns) {
        printf "%20s", $_->{$attr};
      }
      printf "\n";
    }
    printf "ASCII_NOTIFICATION_END\n-->\n";
  } elsif ($self->mode =~ /device::lb::pool::complections/) {
  }
}

package Classes::F5::F5BIGIP::Component::LTMSubsystem9::LTMPoolMember;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub max_l4_connections {
  my $self = shift;
  $Classes::F5::F5BIGIP::Component::LTMSubsystem::max_l4_connections;
}

sub finish {
  my $self = shift;
  if ($self->mode =~ /device::lb::pool::comple/) {
    $self->{ltmPoolMemberNodeName} ||= $self->{ltmPoolMemberAddr};
  }
  if (! exists $self->{ltmPoolMemberStatPoolName}) {
    # if ltmPoolMbrStatusDetailReason: Forced down
    #    ltmPoolMbrStatusEnabledState: disabled
    # then we have no ltmPoolMemberStat*
    $self->{ltmPoolMemberStatServerCurConns} = 0;
  }
  if ($self->mode =~ /device::lb::pool::co.*ctions/) {
    # in rare cases we suddenly get noSuchInstance for ltmPoolMemberConnLimit
    # looks like shortly before a member goes down, all attributes get noSuchInstance
    #  except ltmPoolMemberStatAddr, ltmPoolMemberAddr,ltmPoolMemberStatusAddr
    # after a while, the member appears again, but Forced down and without Stats (see above)
    $self->protect_value($self->{ltmPoolMemberAddr},
        'ltmPoolMemberConnLimit', 'positive');
    $self->protect_value($self->{ltmPoolMemberAddr},
        'ltmPoolMemberStatServerCurConns', 'positive');
    if (! $self->{ltmPoolMemberConnLimit}) {
      $self->{ltmPoolMemberConnLimit} = $self->max_l4_connections();
    }
    $self->{ltmPoolMemberStatServerPctConns} = 
        100 * $self->{ltmPoolMemberStatServerCurConns} /
        $self->{ltmPoolMemberConnLimit};
  }
}

sub rename {
  my $self = shift;
  if ($self->{ltmPoolMemberNodeName} eq $self->{ltmPoolMemberAddr} &&
      $self->{ltmNodeAddrStatusName}) {
    $self->{ltmPoolMemberNodeName} = $self->{ltmNodeAddrStatusName};
  }
}

sub check {
  my $self = shift;
  if ($self->mode =~ /device::lb::pool::comple.*/) {
    if ($self->{ltmPoolMbrStatusEnabledState} eq "enabled") {
      if ($self->{ltmPoolMbrStatusAvailState} ne "green") {
        # info only, because it would ruin thresholds in the pool
        $self->add_ok(sprintf 
            "member %s:%s is %s/%s (%s)",
            $self->{ltmPoolMemberNodeName},
            $self->{ltmPoolMemberPort},
            $self->{ltmPoolMemberMonitorState},
            $self->{ltmPoolMbrStatusAvailState},
            $self->{ltmPoolMbrStatusDetailReason});
      }
    }
  }
  if ($self->mode =~ /device::lb::pool::co.*ctions/) {
    my $label = $self->{ltmPoolMemberNodeName}.'_'.$self->{ltmPoolMemberPort};
    $self->set_thresholds(metric => $label.'_connections_pct', warning => "85", critical => "95");
    $self->add_info(sprintf "member %s:%s has %d connections (from max %dM)",
        $self->{ltmPoolMemberNodeName},
        $self->{ltmPoolMemberPort},
        $self->{ltmPoolMemberStatServerCurConns},
        $self->{ltmPoolMemberConnLimit} / 1000000);
    $self->add_message($self->check_thresholds(metric => $label.'_connections_pct', value => $self->{ltmPoolMemberStatServerPctConns}));
    $self->add_perfdata(
        label => $label.'_connections_pct',
        value => $self->{ltmPoolMemberStatServerPctConns},
        uom => '%',
    );
    $self->add_perfdata(
        label => $label.'_connections',
        value => $self->{ltmPoolMemberStatServerCurConns},
        warning => undef, critical => undef,
    );
  }
}


package Classes::F5::F5BIGIP::Component::LTMSubsystem4;
our @ISA = qw(Classes::F5::F5BIGIP::Component::LTMSubsystem Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub init {
  my $self = shift;
  foreach ($self->get_snmp_table_objects(
      'LOAD-BAL-SYSTEM-MIB', 'poolTable')) {
    if ($self->filter_name($_->{poolName})) {
      push(@{$self->{pools}},
          Classes::F5::F5BIGIP::Component::LTMSubsystem4::LTMPool->new(%{$_}));
    }
  }
  foreach ($self->get_snmp_table_objects(
      'LOAD-BAL-SYSTEM-MIB', 'poolMemberTable')) {
    if ($self->filter_name($_->{poolMemberPoolName})) {
      push(@{$self->{poolmembers}},
          Classes::F5::F5BIGIP::Component::LTMSubsystem4::LTMPoolMember->new(%{$_}));
    }
  }
  $self->assign_members_to_pools();
}

sub assign_members_to_pools {
  my $self = shift;
  foreach my $pool (@{$self->{pools}}) {
    foreach my $poolmember (@{$self->{poolmembers}}) {
      if ($poolmember->{poolMemberPoolName} eq $pool->{poolName}) {
        push(@{$pool->{members}}, $poolmember);
      }
    }
    if (! defined $pool->{poolMemberQty}) {
      $pool->{poolMemberQty} = scalar(@{$pool->{members}}) ;
      $self->debug("calculate poolMemberQty");
    }
    $pool->{completeness} = $pool->{poolMemberQty} ?
        $pool->{poolActiveMemberCount} / $pool->{poolMemberQty} * 100
        : 0;
  }
}


package Classes::F5::F5BIGIP::Component::LTMSubsystem4::LTMPool;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub finish {
  my $self = shift;
  $self->{members} = [];
}

sub check {
  my $self = shift;
  $self->add_info(sprintf 'pool %s active members: %d of %d', $self->{poolName},
      $self->{poolActiveMemberCount},
      $self->{poolMemberQty});
  if ($self->{poolActiveMemberCount} == 1) {
    # only one member left = no more redundancy!!
    $self->set_thresholds(warning => "100:", critical => "51:");
  } else {
    $self->set_thresholds(warning => "51:", critical => "26:");
  }
  $self->add_message($self->check_thresholds($self->{completeness}));
  if ($self->{poolMinActiveMembers} > 0 &&
      $self->{poolActiveMemberCount} < $self->{poolMinActiveMembers}) {
    $self->add_nagios(
        defined $self->opts->mitigation() ? $self->opts->mitigation() : CRITICAL,
        sprintf("pool %s has not enough active members (%d, min is %d)", 
            $self->{poolName}, $self->{poolActiveMemberCount}, 
            $self->{poolMinActiveMembers})
    );
  }
  $self->add_perfdata(
      label => sprintf('pool_%s_completeness', $self->{poolName}),
      value => $self->{completeness},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}


package Classes::F5::F5BIGIP::Component::LTMSubsystem4::LTMPoolMember;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

package Classes::F5::F5BIGIP::Component::DiskSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('F5-BIGIP-SYSTEM-MIB', [
      ['disks', 'sysPhysicalDiskTable', 'Classes::F5::F5BIGIP::Component::DiskSubsystem::Disk'],
  ]);
}

package Classes::F5::F5BIGIP::Component::DiskSubsystem::Disk;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'disk %s is %s',
      $self->{sysPhysicalDiskName},
      $self->{sysPhysicalDiskArrayStatus});
  if ($self->{sysPhysicalDiskArrayStatus} eq 'failed' && $self->{sysPhysicalDiskIsArrayMember} eq 'false') {
    $self->add_critical();
  } elsif ($self->{sysPhysicalDiskArrayStatus} eq 'failed' && $self->{sysPhysicalDiskIsArrayMember} eq 'true') {
    $self->add_warning();
  }
  # diskname CF* usually has status unknown 
}

package Classes::F5::F5BIGIP::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('F5-BIGIP-SYSTEM-MIB', (qw(
      sysStatMemoryTotal sysStatMemoryUsed sysHostMemoryTotal sysHostMemoryUsed)));
  $self->{stat_mem_usage} = ($self->{sysStatMemoryUsed} / $self->{sysStatMemoryTotal}) * 100;
  $self->{host_mem_usage} = ($self->{sysHostMemoryUsed} / $self->{sysHostMemoryTotal}) * 100;
}

sub check {
  my $self = shift;
  $self->add_info('checking memory');
  $self->add_info(sprintf 'tmm memory usage is %.2f%%',
      $self->{stat_mem_usage});
  $self->set_thresholds(warning => 80, critical => 90, metric => 'tmm_usage');
  $self->add_message($self->check_thresholds(metric => 'tmm_usage', value => $self->{stat_mem_usage}));
  $self->add_perfdata(
      label => 'tmm_usage',
      value => $self->{stat_mem_usage},
      uom => '%',
  );
  $self->add_info(sprintf 'host memory usage is %.2f%%',
      $self->{host_mem_usage});
  $self->set_thresholds(warning => 100, critical => 100, metric => 'host_usage');
  $self->add_message($self->check_thresholds(metric => 'host_usage', value => $self->{host_mem_usage}));
  $self->add_perfdata(
      label => 'host_usage',
      value => $self->{host_mem_usage},
      uom => '%',
  );
}

package Classes::F5::F5BIGIP::Component::PowersupplySubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('F5-BIGIP-SYSTEM-MIB', [
      ['powersupplies', 'sysChassisPowerSupplyTable', 'Classes::F5::F5BIGIP::Component::PowersupplySubsystem::Powersupply'],
  ]);
}

package Classes::F5::F5BIGIP::Component::PowersupplySubsystem::Powersupply;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'chassis powersupply %d is %s',
      $self->{sysChassisPowerSupplyIndex},
      $self->{sysChassisPowerSupplyStatus});
  if ($self->{sysChassisPowerSupplyStatus} eq 'notpresent') {
  } else {
    if ($self->{sysChassisPowerSupplyStatus} ne 'good') {
      $self->add_critical();
    }
  }
}

package Classes::F5::F5BIGIP::Component::TemperatureSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('F5-BIGIP-SYSTEM-MIB', [
      ['temperatures', 'sysChassisTempTable', 'Classes::F5::F5BIGIP::Component::TemperatureSubsystem::Temperature'],
  ]);
}

package Classes::F5::F5BIGIP::Component::TemperatureSubsystem::Temperature;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'chassis temperature %d is %sC',
      $self->{sysChassisTempIndex},
      $self->{sysChassisTempTemperature});
  $self->add_perfdata(
      label => sprintf('temp_%s', $self->{sysChassisTempIndex}),
      value => $self->{sysChassisTempTemperature},
  );
}

package Classes::F5::F5BIGIP::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub new {
  my $class = shift;
  my $self = {};
  bless $self, $class;
  if ($self->mode =~ /load/) {
    $self->overall_init();
  } else {
    $self->init();
  }
  return $self;
}

sub overall_init {
  my $self = shift;
  $self->get_snmp_objects('F5-BIGIP-SYSTEM-MIB', (qw(
      sysStatTmTotalCycles sysStatTmIdleCycles sysStatTmSleepCycles)));
  $self->valdiff({name => 'cpu'}, qw(sysStatTmTotalCycles sysStatTmIdleCycles sysStatTmSleepCycles ));
  my $delta_used_cycles = $self->{delta_sysStatTmTotalCycles} -
     ($self->{delta_sysStatTmIdleCycles} + $self->{delta_sysStatTmSleepCycles});
  $self->{cpu_usage} =  $self->{delta_sysStatTmTotalCycles} ?
      (($delta_used_cycles / $self->{delta_sysStatTmTotalCycles}) * 100) : 0;
}

sub init {
  my $self = shift;
  $self->get_snmp_tables('F5-BIGIP-SYSTEM-MIB', [
      ['cpus', 'sysCpuTable', 'Classes::F5::F5BIGIP::Component::CpuSubsystem::Cpu'],
  ]);
}

sub check {
  my $self = shift;
  $self->add_info('checking cpus');
  if ($self->mode =~ /load/) {
    $self->add_info(sprintf 'tmm cpu usage is %.2f%%',
        $self->{cpu_usage});
    $self->set_thresholds(warning => 80, critical => 90);
    $self->add_message($self->check_thresholds($self->{cpu_usage}));
    $self->add_perfdata(
        label => 'cpu_tmm_usage',
        value => $self->{cpu_usage},
        uom => '%',
    );
    return;
  }
  foreach (@{$self->{cpus}}) {
    $_->check();
  }
}


package Classes::F5::F5BIGIP::Component::CpuSubsystem::Cpu;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'cpu %d has %dC (%drpm)',
      $self->{sysCpuIndex},
      $self->{sysCpuTemperature},
      $self->{sysCpuFanSpeed});
  $self->add_perfdata(
      label => sprintf('temp_c%s', $self->{sysCpuIndex}),
      value => $self->{sysCpuTemperature},
      thresholds => 0,
  );
  $self->add_perfdata(
      label => sprintf('fan_c%s', $self->{sysCpuIndex}),
      value => $self->{sysCpuFanSpeed},
      thresholds => 0,
  );
}

package Classes::F5::F5BIGIP::Component::FanSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('F5-BIGIP-SYSTEM-MIB', [
      ['fans', 'sysChassisFanTable', 'Classes::F5::F5BIGIP::Component::FanSubsystem::Fan'],
  ]);
}

package Classes::F5::F5BIGIP::Component::FanSubsystem::Fan;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'chassis fan %d is %s (%drpm)',
      $self->{sysChassisFanIndex},
      $self->{sysChassisFanStatus},
      $self->{sysChassisFanSpeed});
  if ($self->{sysChassisFanStatus} eq 'notpresent') {
  } else {
    if ($self->{sysChassisFanStatus} ne 'good') {
      $self->add_critical();
    }
    $self->add_perfdata(
        label => sprintf('fan_%s', $self->{sysChassisFanIndex}),
        value => $self->{sysChassisFanSpeed},
    );
  }
}

package Classes::F5::F5BIGIP::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub new {
  my $class = shift;
  my $self = {};
  bless $self, $class;
  $self->init();
  return $self;
}

sub init {
  my $self = shift;
  $self->{cpu_subsystem} =
      Classes::F5::F5BIGIP::Component::CpuSubsystem->new();
  $self->{fan_subsystem} =
      Classes::F5::F5BIGIP::Component::FanSubsystem->new();
  $self->{temperature_subsystem} =
      Classes::F5::F5BIGIP::Component::TemperatureSubsystem->new();
  $self->{powersupply_subsystem} = 
      Classes::F5::F5BIGIP::Component::PowersupplySubsystem->new();
  $self->{disk_subsystem} = 
      Classes::F5::F5BIGIP::Component::DiskSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{cpu_subsystem}->check();
  $self->{fan_subsystem}->check();
  $self->{temperature_subsystem}->check();
  $self->{powersupply_subsystem}->check();
  $self->{disk_subsystem}->check();
  $self->reduce_messages("environmental hardware working fine");
}

sub dump {
  my $self = shift;
  $self->{cpu_subsystem}->dump();
  $self->{fan_subsystem}->dump();
  $self->{temperature_subsystem}->dump();
  $self->{powersupply_subsystem}->dump();
  $self->{disk_subsystem}->dump();
}

package Classes::F5::F5BIGIP;
our @ISA = qw(Classes::F5);
use strict;

sub init {
  my $self = shift;
  # gets 11.* and 9.*
  $self->{sysProductVersion} = $self->get_snmp_object('F5-BIGIP-SYSTEM-MIB', 'sysProductVersion');
  $self->{sysPlatformInfoMarketingName} = $self->get_snmp_object('F5-BIGIP-SYSTEM-MIB', 'sysPlatformInfoMarketingName');
  if (! defined $self->{sysProductVersion} ||
      $self->{sysProductVersion} !~ /^((9)|(10)|(11))/) {
    $self->{sysProductVersion} = "4";
  }
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::F5::F5BIGIP::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::F5::F5BIGIP::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::F5::F5BIGIP::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::lb/) {
    $self->analyze_and_check_ltm_subsystem();
  } else {
    $self->no_such_mode();
  }
}

sub analyze_ltm_subsystem {
  my $self = shift;
  $self->{components}->{ltm_subsystem} =
      Classes::F5::F5BIGIP::Component::LTMSubsystem->new('sysProductVersion' => $self->{sysProductVersion}, sysPlatformInfoMarketingName => $self->{sysPlatformInfoMarketingName});
}

package Classes::F5;
our @ISA = qw(Classes::Device);
use strict;

use constant trees => (
    '1.3.6.1.4.1.3375.1.2.1.1.1', # F5-3DNS-MIB
    '1.3.6.1.4.1.3375', # F5-BIGIP-COMMON-MIB
    '1.3.6.1.4.1.3375.2.2', # F5-BIGIP-LOCAL-MIB
    '1.3.6.1.4.1.3375.2.1', # F5-BIGIP-SYSTEM-MIB
    '1.3.6.1.4.1.3375.1.1.1.1', # LOAD-BAL-SYSTEM-MIB
    '1.3.6.1.4.1.2021', # UCD-SNMP-MIB
);

sub init {
  my $self = shift;
  if ($self->{productname} =~ /Linux.*((el6.f5.x86_64)|(el5.1.0.f5app)) .*/i) {
    bless $self, 'Classes::F5::F5BIGIP';
    $self->debug('using Classes::F5::F5BIGIP');
  }
  if (ref($self) ne "Classes::F5") {
    $self->init();
  }
}

package Classes::CheckPoint::Firewall1::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{disk_subsystem} =
      Classes::CheckPoint::Firewall1::Component::DiskSubsystem->new();
  $self->{temperature_subsystem} =
      Classes::CheckPoint::Firewall1::Component::TemperatureSubsystem->new();
  $self->{fan_subsystem} =
      Classes::CheckPoint::Firewall1::Component::FanSubsystem->new();
  $self->{voltage_subsystem} =
      Classes::CheckPoint::Firewall1::Component::VoltageSubsystem->new();
  $self->{powersupply_subsystem} =
      Classes::CheckPoint::Firewall1::Component::PowersupplySubsystem->new();
}

sub check {
  my $self = shift;
  $self->{disk_subsystem}->check();
  $self->{temperature_subsystem}->check();
  $self->{fan_subsystem}->check();
  $self->{voltage_subsystem}->check();
  $self->{powersupply_subsystem}->check();
  if (! $self->check_messages()) {
    $self->clear_ok(); # too much noise
    $self->add_ok("environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{disk_subsystem}->dump();
  $self->{temperature_subsystem}->dump();
  $self->{fan_subsystem}->dump();
  $self->{voltage_subsystem}->dump();
  $self->{powersupply_subsystem}->dump();
}

package Classes::CheckPoint::Firewall1::Component::TemperatureSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CHECKPOINT-MIB', [
      ['temperatures', 'tempertureSensorTable', 'Classes::CheckPoint::Firewall1::Component::TemperatureSubsystem::Temperature'],
  ]);
}

sub check {
  my $self = shift;
  foreach (@{$self->{temperatures}}) {
    $_->check();
  }
}


package Classes::CheckPoint::Firewall1::Component::TemperatureSubsystem::Temperature;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub check {
  my $self = shift;
  $self->add_info(sprintf 'temperature %s is %s (%d %s)', 
      $self->{tempertureSensorName}, $self->{tempertureSensorStatus},
      $self->{tempertureSensorValue}, $self->{tempertureSensorUnit});
  if ($self->{tempertureSensorStatus} eq 'normal') {
    $self->add_ok();
  } elsif ($self->{tempertureSensorStatus} eq 'abnormal') {
    $self->add_critical();
  } else {
    $self->add_unknown();
  }
  $self->set_thresholds(warning => 60, critical => 70);
  $self->add_perfdata(
      label => 'temperature_'.$self->{tempertureSensorName},
      value => $self->{tempertureSensorValue},
  );
}

package Classes::CheckPoint::Firewall1::Component::FanSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CHECKPOINT-MIB', [
      ['fans', 'fanSpeedSensorTable', 'Classes::CheckPoint::Firewall1::Component::FanSubsystem::Fan'],
  ]);
}

sub check {
  my $self = shift;
  foreach (@{$self->{fans}}) {
    $_->check();
  }
}


package Classes::CheckPoint::Firewall1::Component::FanSubsystem::Fan;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'fan %s is %s (%d %s)', 
      $self->{fanSpeedSensorName}, $self->{fanSpeedSensorStatus},
      $self->{fanSpeedSensorValue}, $self->{fanSpeedSensorUnit});
  if ($self->{fanSpeedSensorStatus} eq 'normal') {
    $self->add_ok();
  } elsif ($self->{fanSpeedSensorStatus} eq 'abnormal') {
    $self->add_critical();
  } else {
    $self->add_unknown();
  }
  $self->set_thresholds(warning => 60, critical => 70);
  $self->add_perfdata(
      label => 'fan'.$self->{fanSpeedSensorName}.'_rpm',
      value => $self->{fanSpeedSensorValue},
  );
}

package Classes::CheckPoint::Firewall1::Component::VoltageSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CHECKPOINT-MIB', [
      ['voltages', 'voltageSensorTable', 'Classes::CheckPoint::Firewall1::Component::VoltageSubsystem::Voltage'],
  ]);
}

sub check {
  my $self = shift;
  foreach (@{$self->{voltages}}) {
    $_->check();
  }
}


package Classes::CheckPoint::Firewall1::Component::VoltageSubsystem::Voltage;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'voltage %s is %s (%.2f %s)', 
      $self->{voltageSensorName}, $self->{voltageSensorStatus},
      $self->{voltageSensorValue}, $self->{voltageSensorUnit});
  if ($self->{voltageSensorStatus} eq 'normal') {
    $self->add_ok();
  } elsif ($self->{voltageSensorStatus} eq 'abnormal') {
    $self->add_critical();
  } else {
    $self->add_unknown();
  }
  $self->set_thresholds(warning => 60, critical => 70);
  $self->add_perfdata(
      label => 'voltage'.$self->{voltageSensorName}.'_rpm',
      value => $self->{voltageSensorValue},
  );
}

package Classes::CheckPoint::Firewall1::Component::PowersupplySubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CHECKPOINT-MIB', [
      ['powersupplies', 'powerSupplyTable', 'Classes::CheckPoint::Firewall1::Component::PowersupplySubsystem::Powersupply'],
  ]);
}

package Classes::CheckPoint::Firewall1::Component::PowersupplySubsystem::Powersupply;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'power supply %d status is %s', 
      $self->{powerSupplyIndex},
      $self->{powerSupplyStatus});
  if ($self->{powerSupplyStatus} eq 'Up') {
    $self->add_ok();
  } elsif ($self->{powerSupplyStatus} eq 'Down') {
    $self->add_critical();
  } else {
    $self->add_unknown();
  }
}
package Classes::CheckPoint::Firewall1::Component::DiskSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('HOST-RESOURCES-MIB', [
      ['storages', 'hrStorageTable', 'Classes::HOSTRESOURCESMIB::Component::DiskSubsystem::Storage', sub { return shift->{hrStorageType} eq 'hrStorageFixedDisk'}],
  ]);
  $self->get_snmp_tables('CHECKPOINT-MIB', [
      ['volumes', 'raidVolumeTable', 'Classes::CheckPoint::Firewall1::Component::DiskSubsystem::Volume'],
      ['disks', 'raidDiskTable', 'Classes::CheckPoint::Firewall1::Component::DiskSubsystem::Disk'],
      ['multidisks', 'multiDiskTable', 'Classes::CheckPoint::Firewall1::Component::DiskSubsystem::MultiDisk'],
  ]);
  $self->get_snmp_objects('CHECKPOINT-MIB', (qw(diskPercent)));
}

sub check {
  my $self = shift;
  $self->add_info('checking disks');
  if (@{$self->{multidisks}}) {
    foreach (@{$self->{multidisks}}) {
      $_->check();
    }
  } elsif (@{$self->{storages}}) {
    foreach (@{$self->{storages}}) {
      $_->check();
    }
  } else {
    my $free = 100 - $self->{diskPercent};
    $self->add_info(sprintf 'disk has %.2f%% free space left', $free);
    $self->set_thresholds(warning => '10:', critical => '5:');
    $self->add_message($self->check_thresholds($free));
    $self->add_perfdata(
        label => 'disk_free',
        value => $free,
        uom => '%',
    );
  }
  foreach (@{$self->{volumes}}) {
    $_->check();
  }
  foreach (@{$self->{disks}}) {
    $_->check();
  }
}


package Classes::CheckPoint::Firewall1::Component::DiskSubsystem::Volume;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'volume %s with %d disks is %s',
      $self->{raidVolumeID},
      $self->{numOfDisksOnRaid},
      $self->{raidVolumeState});
  if ($self->{raidVolumeState} eq 'degraded') {
    $self->add_warning();
  } elsif ($self->{raidVolumeState} eq 'failed') {
    $self->add_critical();
  } else {
    $self->add_ok();
  }
  
}


package Classes::CheckPoint::Firewall1::Component::DiskSubsystem::Disk;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'disk %s (vol %s) is %s',
      $self->{raidDiskIndex},
      $self->{raidDiskVolumeID},
      $self->{raidDiskState});
  # warning/critical comes from the volume
}

package Classes::CheckPoint::Firewall1::Component::DiskSubsystem::MultiDisk;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  my $label = sprintf 'disk_%s_free', $self->{multiDiskName};
  $self->add_info(sprintf 'disk %s (%s) has %.2f%% free space',
      $self->{multiDiskIndex},
      $self->{multiDiskName},
      $self->{multiDiskFreeTotalPercent});
    $self->set_thresholds(metric => $label, warning => '10:', critical => '5:');
    $self->add_message($self->check_thresholds(metric => $label, value => $self->{multiDiskFreeTotalPercent}));
    $self->add_perfdata(
        label => $label,
        value => $self->{multiDiskFreeTotalPercent},
        uom => '%',
    );
}

package Classes::CheckPoint::Firewall1::Component::MngmtSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::mngmt::status/) {
    $self->get_snmp_objects('CHECKPOINT-MIB', (qw(
        mgStatShortDescr mgStatLongDescr)));
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking mngmt');
  if ($self->mode =~ /device::mngmt::status/) {
    if (! defined $self->{mgStatShortDescr}) {
      $self->add_unknown('management mib is not implemented');
    } elsif ($self->{mgStatShortDescr} ne 'OK') {
      $self->add_critical(sprintf 'status of management is %s', $self->{mgStatLongDescr});
    } else {
      $self->add_ok(sprintf 'status of management is %s', $self->{mgStatLongDescr});
    }
  }
}

package Classes::CheckPoint::Firewall1::Component::SvnSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::svn::status/) {
    $self->get_snmp_objects('CHECKPOINT-MIB', (qw(
        svnStatShortDescr svnStatLongDescr)));
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking svn');
  if ($self->mode =~ /device::svn::status/) {
    if ($self->{svnStatShortDescr} ne 'OK') {
      $self->add_critical(sprintf 'status of svn is %s', $self->{svnStatLongDescr});
    } else {
      $self->add_ok(sprintf 'status of svn is %s', $self->{svnStatLongDescr});
    }
  }
}

package Classes::CheckPoint::Firewall1::Component::FwSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('CHECKPOINT-MIB', (qw(
      fwModuleState fwPolicyName fwNumConn)));
  if ($self->mode =~ /device::fw::policy::installed/) {
  } elsif ($self->mode =~ /device::fw::policy::connections/) {
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking fw module');
  if ($self->{fwModuleState} ne 'Installed') {
    $self->add_critical(sprintf 'fw module is %s', $self->{fwPolicyName});
  } elsif ($self->mode =~ /device::fw::policy::installed/) {
    if (! $self->opts->name()) {
      $self->add_unknown('please specify a policy with --name');
    } elsif ($self->{fwPolicyName} eq $self->opts->name()) {
      $self->add_ok(sprintf 'fw policy is %s', $self->{fwPolicyName});
    } else {
      $self->add_critical(sprintf 'fw policy is %s, expected %s',
          $self->{fwPolicyName}, $self->opts->name());
    }
  } elsif ($self->mode =~ /device::fw::policy::connections/) {
    $self->set_thresholds(warning => 20000, critical => 23000);
    $self->add_message($self->check_thresholds($self->{fwNumConn}),
        sprintf 'policy %s has %s open connections',
            $self->{fwPolicyName}, $self->{fwNumConn});
    $self->add_perfdata(
        label => 'fw_policy_numconn',
        value => $self->{fwNumConn},
    );
  }
}

package Classes::CheckPoint::Firewall1::Component::HaSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub init {
  my $self = shift;
  if ($self->mode =~ /device::ha::role/) {
  $self->get_snmp_objects('CHECKPOINT-MIB', (qw(
      haStarted haState haStatShort)));
    if (! $self->opts->role()) {
      $self->opts->override_opt('role', 'active');
    }
  }
}

sub check {
  my $self = shift;
  chomp($self->{haState});
  $self->add_info('checking ha');
  $self->add_info(sprintf 'ha %sstarted, role is %s, status is %s', 
      $self->{haStarted} eq 'yes' ? '' : 'not ', 
      $self->{haState}, $self->{haStatShort});
  if ($self->{haStarted} eq 'yes') {
    if ($self->{haStatShort} ne 'OK') {
      $self->add_message(
          defined $self->opts->mitigation() ? $self->opts->mitigation() : CRITICAL,
          $self->{info});
    } elsif ($self->{haState} ne $self->opts->role()) {
      $self->add_message(
          defined $self->opts->mitigation() ? $self->opts->mitigation() : WARNING,
          $self->{info});
      $self->add_message(
          defined $self->opts->mitigation() ? $self->opts->mitigation() : WARNING,
          sprintf "expected role %s", $self->opts->role())
    } else {
      $self->add_ok();
    }
  } else {
    $self->add_message(
        defined $self->opts->mitigation() ? $self->opts->mitigation() : WARNING,
        'ha was not started');
  }
}

package Classes::CheckPoint::Firewall1::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('CHECKPOINT-MIB', (qw(
      procUsage)));
  $self->{procQueue} = $self->valid_response('CHECKPOINT-MIB', 'procQueue');
}

sub check {
  my $self = shift;
  $self->add_info('checking cpus');
  $self->add_info(sprintf 'cpu usage is %.2f%%', $self->{procUsage});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{procUsage}));
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{procUsage},
      uom => '%',
  );
  if (defined $self->{procQueue}) {
    $self->add_perfdata(
        label => 'cpu_queue_length',
        value => $self->{procQueue},
        thresholds => 0,
    );
  }
}

package Classes::CheckPoint::Firewall1::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('CHECKPOINT-MIB', (qw(
      memTotalReal64 memFreeReal64)));
  $self->{memory_usage} = $self->{memFreeReal64} ? 
      ( ($self->{memTotalReal64} - $self->{memFreeReal64}) / $self->{memTotalReal64} * 100) : 100;
}

sub check {
  my $self = shift;
  $self->add_info(sprintf 'memory usage is %.2f%%', $self->{memory_usage});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{memory_usage}));
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{memory_usage},
      uom => '%',
  );
}

package Classes::CheckPoint::Firewall1;
our @ISA = qw(Classes::CheckPoint);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::CheckPoint::Firewall1::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::CheckPoint::Firewall1::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::CheckPoint::Firewall1::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::ha::/) {
    $self->analyze_and_check_ha_subsystem("Classes::CheckPoint::Firewall1::Component::HaSubsystem");
  } elsif ($self->mode =~ /device::fw::/) {
    $self->analyze_and_check_fw_subsystem("Classes::CheckPoint::Firewall1::Component::FwSubsystem");
  } elsif ($self->mode =~ /device::svn::/) {
    $self->analyze_and_check_svn_subsystem("Classes::CheckPoint::Firewall1::Component::SvnSubsystem");
  } elsif ($self->mode =~ /device::mngmt::/) {
    # not sure if this works fa25239716cb74c672f8dd390430dc4056caffa7
    $self->analyze_and_check_mngmt_subsystem("Classes::CheckPoint::Firewall1::Component::MngmtSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::CheckPoint::VSX::Component::FwSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('CHECKPOINT-MIB', (qw(
      fwModuleState fwPolicyName)));
  if ($self->mode =~ /device::fw::policy::installed/) {
  } elsif ($self->mode =~ /device::fw::policy::connections/) {
    $self->get_snmp_tables('CHECKPOINT-MIB', [
      ['vsxs', 'vsxCountersTable', 'Classes::CheckPoint::VSX::Component::FwSubsystem::Vsx'],
      ['vsxstatus', 'vsxStatusTable', 'Monitoring::GLPlugin::SNMP::TableItem'],
    ]);
    foreach my $vsx (@{$self->{vsxs}}) {
      foreach my $vsxstatus (@{$self->{vsxstatus}}) {
        if ($vsx->{vsxCountersVSId} eq $vsxstatus->{vsxStatusVSId}) {
          map {
              $vsx->{$_} = $vsxstatus->{$_}
          } grep {
              /^vsx/
          } keys %{$vsxstatus};
        }
      }
    }
    delete $self->{vsxstatus};
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking fw module');
  if ($self->{fwModuleState} ne 'Installed') {
    $self->add_critical(sprintf 'fw module is %s', $self->{fwPolicyName});
  } elsif ($self->mode =~ /device::fw::policy::installed/) {
    if (! $self->opts->name()) {
      $self->add_unknown('please specify a policy with --name');
    } elsif ($self->{fwPolicyName} eq $self->opts->name()) {
      $self->add_ok(sprintf 'fw policy is %s', $self->{fwPolicyName});
    } else {
      $self->add_critical(sprintf 'fw policy is %s, expected %s',
          $self->{fwPolicyName}, $self->opts->name());
    }
  } elsif ($self->mode =~ /device::fw::policy::connections/) {
    $self->{sumNumConn} = 0;
    map { $self->{fwNumConn} += $_->{vsxCountersConnNum} } @{$self->{vsxs}};
    $self->set_thresholds(metric => 'fwNumConn',
        warning => 20000, critical => 23000);
    $self->add_message($self->check_thresholds(
        metric => 'fwNumConn',
        value => $self->{fwNumConn}),
        sprintf 'policy %s has %s open connections',
            $self->{fwPolicyName}, $self->{fwNumConn});
    $self->add_perfdata(
        label => 'fw_policy_numconn',
        value => $self->{fwNumConn},
    );
    $self->SUPER::check();
  }
}

package Classes::CheckPoint::VSX::Component::FwSubsystem::Vsx;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  my $label = sprintf 'vsx_%s_numconn', $self->{vsxStatusVsName};
  $self->set_thresholds(metric => $label,
      warning => 20000, critical => 23000);
  $self->add_message($self->check_thresholds(
      metric => $label,
      value => $self->{vsxCountersConnNum}),
      sprintf 'vsx %s has %s open connections',
          $self->{vsxStatusVsName}, $self->{vsxCountersConnNum});
  $self->add_perfdata(
      label => $label,
      value => $self->{vsxCountersConnNum},
  );
}

package Classes::CheckPoint::VSX;
our @ISA = qw(Classes::CheckPoint);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::CheckPoint::Firewall1::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::CheckPoint::Firewall1::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::CheckPoint::Firewall1::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::ha::/) {
    $self->analyze_and_check_ha_subsystem("Classes::CheckPoint::Firewall1::Component::HaSubsystem");
  } elsif ($self->mode =~ /device::fw::/) {
    $self->analyze_and_check_fw_subsystem("Classes::CheckPoint::VSX::Component::FwSubsystem");
  } elsif ($self->mode =~ /device::svn::/) {
    $self->analyze_and_check_svn_subsystem("Classes::CheckPoint::Firewall1::Component::SvnSubsystem");
  } elsif ($self->mode =~ /device::mngmt::/) {
    # not sure if this works fa25239716cb74c672f8dd390430dc4056caffa7
    $self->analyze_and_check_mngmt_subsystem("Classes::CheckPoint::Firewall1::Component::MngmtSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::CheckPoint::Gaia;
our @ISA = qw(Classes::CheckPoint::Firewall1);
use strict;

sub xinit {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::CheckPoint::Firewall1::Component::EnvironmentalSubsystem");
    $self->no_such_mode();
  }
}

package Classes::CheckPoint;
our @ISA = qw(Classes::Device);
use strict;

use constant trees => (
    '1.3.6.1.4.1.2620', # CHECKPOINT-MIB
);

sub init {
  my $self = shift;
  if (defined $self->get_snmp_object('CHECKPOINT-MIB', 'vsxVsInstalled')) {
    bless $self, 'Classes::CheckPoint::VSX';
    $self->debug('using Classes::CheckPoint::VSX');
  #} elsif ($self->get_snmp_object('CHECKPOINT-MIB', 'fwProduct') || $self->{productname} =~ /(FireWall\-1\s)|(cpx86_64)|(Linux.*\dcp )/i) {
  } elsif ($self->get_snmp_object('CHECKPOINT-MIB', 'fwProduct')) {
    bless $self, 'Classes::CheckPoint::Firewall1';
    $self->debug('using Classes::CheckPoint::Firewall1');
  } elsif ($self->get_snmp_object('CHECKPOINT-MIB', 'mgProdName')) {
    bless $self, 'Classes::CheckPoint::Firewall1';
    $self->debug('using Classes::CheckPoint::Firewall1');
  } elsif ($self->get_snmp_object('CHECKPOINT-MIB', 'osName') && $self->get_snmp_object('CHECKPOINT-MIB', 'osName') =~ /gaia/i) {
    bless $self, 'Classes::CheckPoint::Gaia';
    $self->debug('using Classes::CheckPoint::Gaia');
  } else {
    $self->no_such_model();
  }
  if (ref($self) ne "Classes::CheckPoint") {
    $self->init();
  }
}

package Classes::Clavister::Firewall1::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;
use Data::Dumper;

sub init {
  my $self = shift;
  $self->get_snmp_tables('CLAVISTER-MIB', [
      ['sensor', 'clvHWSensorEntry', 'Classes::Clavister::Firewall1::Component::HWSensor'],
  ]);
}

sub check {
  my $self = shift;
  foreach (@{$self->{sensor}}) {
    $_->check();
  }
}


package Classes::Clavister::Firewall1::Component::HWSensor;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  if ($self->{clvHWSensorName} =~ /Fan/i) {
    $self->add_info(sprintf '%s is running (%d %s)', 
        $self->{clvHWSensorName}, $self->{clvHWSensorValue}, $self->{clvHWSensorUnit});
    $self->set_thresholds(warning => "6000:7500", critical => "1000:10000");
    $self->add_message($self->check_thresholds($self->{clvHWSensorValue}));
    $self->add_perfdata(
        label => $self->{clvHWSensorName}.'_rpm',
        value => $self->{clvHWSensorValue},
    );
  } elsif ($self->{clvHWSensorName} =~ /Temp/i) {
    $self->add_info(sprintf '%s is running (%d %s)',
        $self->{clvHWSensorName}, $self->{clvHWSensorValue}, $self->{clvHWSensorUnit});
    $self->set_thresholds(warning => 60, critical => 70);
    $self->add_message($self->check_thresholds($self->{clvHWSensorValue}));
    $self->add_perfdata(
        label => $self->{clvHWSensorName}.'_'.$self->{clvHWSensorUnit},
        value => $self->{clvHWSensorValue},
    );
  }
}

package Classes::Clavister::Firewall1::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('CLAVISTER-MIB', (qw(
      clvSysCpuLoad)));
}

sub check {
  my $self = shift;
  $self->add_info('checking cpus');
  $self->add_info(sprintf 'cpu usage is %.2f%%', $self->{clvSysCpuLoad});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{clvSysCpuLoad}));
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{clvSysCpuLoad},
      uom => '%',
  );
}

package Classes::Clavister::Firewall1::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('CLAVISTER-MIB', (qw(
      clvSysMemUsage)));
}

sub check {
  my $self = shift;
  $self->add_info(sprintf 'memory usage is %.2f%%', $self->{clvSysMemUsage});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{clvSysMemUsage}));
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{clvSysMemUsage},
      uom => '%',
  );
}

package Classes::Clavister::Firewall1;
our @ISA = qw(Classes::Clavister);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Clavister::Firewall1::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Clavister::Firewall1::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Clavister::Firewall1::Component::MemSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Clavister;
our @ISA = qw(Classes::Device);
use strict;

use constant trees => (
    '1.3.6.1.4.1.5089', # CLAVISTER-MIB
);

sub init {
  my $self = shift;
  if ($self->{productname} =~ /Clavister/i) {
    bless $self, 'Classes::Clavister::Firewall1';
    $self->debug('using Classes::Clavister::Firewall1');
  }
  if (ref($self) ne "Classes::Clavister") {
    $self->init();
  }
}

package Classes::SGOS::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  # https://kb.bluecoat.com/index?page=content&id=KB3069
  # Memory pressure simply is the percentage of physical memory less free and reclaimable memory, of total memory. So, for example, if there is no free or reclaimable memory in the system, then memory pressure is at 100%.
  # The event logs start reporting memory pressure when it is over 75%.
  # There's two separate OIDs to obtain memory pressure value for SGOSV4 and SGOSV5;
  # SGOSV4:  memPressureValue - OIDs: 1.3.6.1.4.1.3417.2.8.2.3 (systemResourceMIB)
  # SGOSV5: sgProxyMemoryPressure - OIDs: 1.3.6.1.4.1.3417.2.11.2.3.4 (bluecoatSGProxyMIB)
  $self->get_snmp_objects('BLUECOAT-SG-PROXY-MIB', (qw(sgProxyMemPressure
      sgProxyMemAvailable sgProxyMemCacheUsage sgProxyMemSysUsage)));
}

sub check {
  my $self = shift;
  $self->add_info('checking memory');
  $self->add_info(sprintf 'memory usage is %.2f%%',
      $self->{sgProxyMemPressure});
  $self->set_thresholds(warning => 75, critical => 90);
  $self->add_message($self->check_thresholds($self->{sgProxyMemPressure}));
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{sgProxyMemPressure},
      uom => '%',
  );
}

package Classes::SGOS::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  my %params = @_;
  # With AVOS version 5.5.4.1, 5.4.6.1 and 6.1.2.1, the SNMP MIB has been extended to support multiple CPU cores.
  # The new OID is defined as a table 1.3.6.1.4.1.3417.2.11.2.4.1 in the BLUECOAT-SG-PROXY-MIB file with the following sub-OIDs.
  # https://kb.bluecoat.com/index?page=content&id=FAQ1244&actp=search&viewlocale=en_US&searchid=1360452047002
  $self->get_snmp_tables('BLUECOAT-SG-PROXY-MIB', [
      ['cpus', 'sgProxyCpuCoreTable', 'Classes::SGOS::Component::CpuSubsystem::Cpu'],
  ]);
  if (scalar (@{$self->{cpus}}) == 0) {
    $self->get_snmp_tables('USAGE-MIB', [
        ['cpus', 'deviceUsageTable', 'Classes::SGOS::Component::CpuSubsystem::DevCpu', sub { return shift->{deviceUsageName} =~ /CPU/ }],
    ]);
  }
}

package Classes::SGOS::Component::CpuSubsystem::Cpu;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'cpu %s usage is %.2f%%',
      $self->{flat_indices}, $self->{sgProxyCpuCoreBusyPerCent});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{sgProxyCpuCoreBusyPerCent}));
  $self->add_perfdata(
      label => 'cpu_'.$self->{flat_indices}.'_usage',
      value => $self->{sgProxyCpuCoreBusyPerCent},
      uom => '%',
  );
}


package Classes::SGOS::Component::CpuSubsystem::DevCpu;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'cpu %s usage is %.2f%%',
      $self->{flat_indices}, $self->{deviceUsagePercent});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{deviceUsagePercent}));
  $self->add_perfdata(
      label => 'cpu_'.$self->{flat_indices}.'_usage',
      value => $self->{deviceUsagePercent},
      uom => '%',
  );
}


package Classes::SGOS::Component::EnvironmentalSubsystem;
our @ISA = qw(Classes::SGOS);
use strict;

sub new {
  my $class = shift;
  my $self = {};
  bless $self, $class;
  $self->init();
  return $self;
}

sub init {
  my $self = shift;
  $self->{sensor_subsystem} =
      Classes::SGOS::Component::SensorSubsystem->new();
  $self->{disk_subsystem} =
      Classes::SGOS::Component::DiskSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{sensor_subsystem}->check();
  $self->{disk_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_ok("environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{sensor_subsystem}->dump();
  $self->{disk_subsystem}->dump();
}


package Classes::SGOS::Component::SensorSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('SENSOR-MIB', [
      ['sensors', 'deviceSensorValueTable', 'Classes::SGOS::Component::SensorSubsystem::Sensor'],
  ]);
}

sub check {
  my $self = shift;
  my $psus = {};
  foreach my $sensor (@{$self->{sensors}}) {
    if ($sensor->{deviceSensorName} =~ /^PSU\s+(\d+)\s+(.*)/) {
      $psus->{$1}->{sensors}->{$2}->{code} = $sensor->{deviceSensorCode};
      $psus->{$1}->{sensors}->{$2}->{status} = $sensor->{deviceSensorStatus};
    }
  }
  foreach my $psu (keys %{$psus}) {
    if ($psus->{$psu}->{sensors}->{'ambient temperature'}->{code} &&
        $psus->{$psu}->{sensors}->{'ambient temperature'}->{code} eq 'unknown' &&
        $psus->{$psu}->{sensors}->{'ambient temperature'}->{status} &&
        $psus->{$psu}->{sensors}->{'ambient temperature'}->{status} eq 'nonoperational' &&
        $psus->{$psu}->{sensors}->{'core temperature'}->{code} &&
        $psus->{$psu}->{sensors}->{'core temperature'}->{code} eq 'unknown' &&
        $psus->{$psu}->{sensors}->{'core temperature'}->{status} &&
        $psus->{$psu}->{sensors}->{'core temperature'}->{status} eq 'nonoperational' &&
        $psus->{$psu}->{sensors}->{'status'}->{code} &&
        $psus->{$psu}->{sensors}->{'status'}->{code} eq 'no-power' &&
        $psus->{$psu}->{sensors}->{'status'}->{status} &&
        $psus->{$psu}->{sensors}->{'status'}->{status} eq 'ok') {
      $psus->{$psu}->{'exists'} = 0;
      $self->add_info(sprintf 'psu %d probably doesn\'t exist', $psu);
    } else {
      $psus->{$psu}->{'exists'} = 1;
    }
  }
  foreach my $sensor (@{$self->{sensors}}) {
    if ($sensor->{deviceSensorName} =~ /^PSU\s+(\d+)\s+(.*)/) {
      if (! $psus->{$1}->{exists}) {
        $sensor->{deviceSensorCode} = sprintf 'not-installed (real code: %s)',
            $sensor->{deviceSensorCode};
        $sensor->blacklist();
      }
    }
  }
  foreach my $sensor (@{$self->{sensors}}) {
    $sensor->check();
  }
}


package Classes::SGOS::Component::SensorSubsystem::Sensor;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  if ($self->{deviceSensorScale}) {
    $self->{deviceSensorValue} *= 10 ** $self->{deviceSensorScale};
  }
  $self->add_info(sprintf 'sensor %s (%s %s) is %s',
      $self->{deviceSensorName},
      $self->{deviceSensorValue},
      $self->{deviceSensorUnits},
      $self->{deviceSensorCode});
  if ($self->{deviceSensorCode} =~ /^not-installed/) {
  } elsif ($self->{deviceSensorCode} eq "unknown") {
  } else {
    if ($self->{deviceSensorCode} ne "ok") {
      if ($self->{deviceSensorCode} =~ /warning/) {
        $self->add_warning();
      } else {
        $self->add_critical();
      }
    }
    $self->add_perfdata(
        label => sprintf('sensor_%s', $self->{deviceSensorName}),
        value => $self->{deviceSensorValue},
    ) if $self->{deviceSensorUnits} =~ /^(volts|celsius|rpm)/;
  }
}

package Classes::SGOS::Component::DiskSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('DISK-MIB', [
      ['disks', 'deviceDiskValueTable', 'Classes::SGOS::Component::DiskSubsystem::Disk'],
  ]);
  $self->get_snmp_tables('USAGE-MIB', [
      ['filesystems', 'deviceUsageTable', 'Classes::SGOS::Component::DiskSubsystem::FS', sub { return lc shift->{deviceUsageName} eq 'disk' }],
  ]);
  my $fs = 0;
  foreach (@{$self->{filesystems}}) {
    $_->{deviceUsageIndex} = $fs++;
  }
}


package Classes::SGOS::Component::DiskSubsystem::Disk;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'disk %s (%s %s) is %s',
      $self->{flat_indices},
      $self->{deviceDiskVendor},
      $self->{deviceDiskRevision},
      $self->{deviceDiskStatus});
  if ($self->{deviceDiskStatus} eq "bad") {
    $self->add_critical();
  }
}


package Classes::SGOS::Component::DiskSubsystem::FS;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'disk %s usage is %.2f%% (internal status is %s)',
      $self->{deviceUsageIndex},
      $self->{deviceUsagePercent},
      $self->{deviceUsageStatus}
  );
  $self->set_thresholds(
      metric => 'disk_'.$self->{deviceUsageIndex}.'_usage',
      warning => $self->{deviceUsageHigh},
      critical => $self->{deviceUsageHigh},
  );
  $self->add_message($self->check_thresholds(
      metric => 'disk_'.$self->{deviceUsageIndex}.'_usage',
      value => $self->{deviceUsagePercent},),
  );
  $self->add_perfdata(
      label => 'disk_'.$self->{deviceUsageIndex}.'_usage',
      value => $self->{deviceUsagePercent},
      uom => '%',
  );
}


package Classes::SGOS::Component::SecuritySubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('ATTACK-MIB', [
      ['attacks', 'deviceAttackTable', 'Classes::SGOS::Component::SecuritySubsystem::Attack' ],
  ]);
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking attacks');
  if (scalar (@{$self->{attacks}}) == 0) {
    $self->add_info('no security incidents');
  } else {
    foreach (@{$self->{attacks}}) {
      $_->check();
    }
    $self->add_info(sprintf '%d serious incidents (of %d)',
        scalar(grep { $_->{count_me} == 1 } @{$self->{attacks}}),
        scalar(@{$self->{attacks}}));
  }
  $self->add_ok();
}


package Classes::SGOS::Component::SecuritySubsystem::Attack;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->{deviceAttackTime} = $self->timeticks(
      $self->{deviceAttackTime});
  $self->{count_me} = 0;
  $self->add_info(sprintf '%s %s %s',
      scalar localtime (time - $self->uptime() + $self->{deviceAttackTime}),
      $self->{deviceAttackName}, $self->{deviceAttackStatus});
  my $lookback = $self->opts->lookback() ? 
      $self->opts->lookback() : 3600;
  if (($self->{deviceAttackStatus} eq 'under-attack') &&
      ($lookback - $self->uptime() + $self->{deviceAttackTime} > 0)) {
    $self->add_critical();
    $self->{count_me}++;
  }
}

package Classes::SGOS::Component::ConnectionSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub init {
  my $self = shift;
  $self->get_snmp_objects('BLUECOAT-SG-PROXY-MIB', (qw(sgProxyHttpResponseTimeAll
      sgProxyHttpResponseFirstByte
      sgProxyHttpResponseByteRate sgProxyHttpResponseSize
      sgProxyHttpClientConnections sgProxyHttpClientConnectionsActive
      sgProxyHttpClientConnectionsIdle
      sgProxyHttpServerConnections sgProxyHttpServerConnectionsActive
      sgProxyHttpServerConnectionsIdle)));
  $self->{sgProxyHttpResponseTimeAll} /= 1000;
}

sub check {
  my $self = shift;
  $self->add_info('checking connections');
  if ($self->mode =~ /device::connections::check/) {
    $self->add_info(sprintf 'average service time for http requests is %.5fs',
        $self->{sgProxyHttpResponseTimeAll});
    $self->set_thresholds(warning => 5, critical => 10);
    $self->add_message($self->check_thresholds($self->{sgProxyHttpResponseTimeAll}));
    $self->add_perfdata(
        label => 'http_response_time',
        value => $self->{sgProxyHttpResponseTimeAll},
        places => 5,
        uom => 's',
    );
  } elsif ($self->mode =~ /device::.*?::count/) {
    my $details = [
        ['client', 'total', 'sgProxyHttpClientConnections'],
        ['client', 'active', 'sgProxyHttpClientConnectionsActive'],
        ['client', 'idle', 'sgProxyHttpClientConnectionsIdle'],
        ['server', 'total', 'sgProxyHttpServerConnections'],
        ['server', 'active', 'sgProxyHttpServerConnectionsActive'],
        ['server', 'idle', 'sgProxyHttpServerConnectionsIdle'],
    ];
    my @selected;
    # --name client --name2 idle
    if (! $self->opts->name) {
      @selected = @{$details};
    } elsif (! $self->opts->name2) {
      @selected = grep { $_->[0] eq $self->opts->name } @{$details};
    } else {
      @selected = grep { $_->[0] eq $self->opts->name && $_->[1] eq $self->opts->name2 } @{$details};
    }
    foreach (@selected) {
      $self->add_info(sprintf '%d %s connections %s', $self->{$_->[2]}, $_->[0], $_->[1]);
      $self->set_thresholds(warning => 5000, critical => 10000);
      $self->add_message($self->check_thresholds($self->{$_->[2]}));
      $self->add_perfdata(
          label => $_->[0].'_connections_'.$_->[1],
          value => $self->{$_->[2]},
      );
    }
  }
}


package Classes::SGOS;
our @ISA = qw(Classes::Bluecoat);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::SGOS::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::SGOS::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::SGOS::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::security/) {
    $self->analyze_and_check_security_subsystem("Classes::SGOS::Component::SecuritySubsystem");
  } elsif ($self->mode =~ /device::(users|connections)::(count|check)/) {
    $self->analyze_and_check_connection_subsystem("Classes::SGOS::Component::ConnectionSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::AVOS::Component::KeySubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('BLUECOAT-AV-MIB', (qw(
      avLicenseDaysRemaining avVendorName)));
}

sub check {
  my $self = shift;
  $self->add_info(sprintf 'license %s expires in %d days',
      $self->{avVendorName},
      $self->{avLicenseDaysRemaining});
  $self->set_thresholds(warning => '14:', critical => '7:');
  $self->add_message($self->check_thresholds($self->{avLicenseDaysRemaining}));
  $self->add_perfdata(
      label => sprintf('lifetime_%s', $self->{avVendorName}),
      value => $self->{avLicenseDaysRemaining},
  );
}


package Classes::AVOS::Component::SecuritySubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('BLUECOAT-AV-MIB', (qw(
      avVirusesDetected)));
}

sub check {
  my $self = shift;
  $self->add_info(sprintf '%d viruses detected',
      $self->{avVirusesDetected});
  $self->set_thresholds(warning => 1500, critical => 1500);
  $self->add_message($self->check_thresholds($self->{avVirusesDetected}));
  $self->add_perfdata(
      label => 'viruses',
      value => $self->{avVirusesDetected},
  );
}

package Classes::AVOS::Component::ConnectionSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('BLUECOAT-AV-MIB', (qw(
      avSlowICAPConnections)));
}

sub check {
  my $self = shift;
  $self->add_info(sprintf '%d slow ICAP connections',
      $self->{avSlowICAPConnections});
  $self->set_thresholds(warning => 100, critical => 100);
  $self->add_message($self->check_thresholds($self->{avSlowICAPConnections}));
  $self->add_perfdata(
      label => 'slow_connections',
      value => $self->{avSlowICAPConnections},
  );
}

package Classes::AVOS::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  # https://kb.bluecoat.com/index?page=content&id=KB3069
  # Memory pressure simply is the percentage of physical memory less free and reclaimable memory, of total memory. So, for example, if there is no free or reclaimable memory in the system, then memory pressure is at 100%.
  # The event logs start reporting memory pressure when it is over 75%.
  # There's two separate OIDs to obtain memory pressure value for AVOSV4 and AVOSV5;
  # AVOSV4:  memPressureValue - OIDs: 1.3.6.1.4.1.3417.2.8.2.3 (systemResourceMIB)
  # AVOSV5: sgProxyMemoryPressure - OIDs: 1.3.6.1.4.1.3417.2.11.2.3.4 (bluecoatSGProxyMIB)
  my $self = shift;
  $self->get_snmp_objects('BLUECOAT-SG-PROXY-MIB', (qw(
      sgProxyMemPressure sgProxyMemAvailable sgProxyMemCacheUsage sgProxyMemSysUsage)));
  if (! defined $self->{sgProxyMemPressure}) {
  $self->get_snmp_objects('SYSTEM-RESOURCES-MIB', (qw(
      memPressureValue memWarningThreshold memCriticalThreshold memCurrentState)));
  }
  if (! defined $self->{memPressureValue}) {
    foreach ($self->get_snmp_table_objects(
        'USAGE-MIB', 'deviceUsageTable')) {
      next if $_->{deviceUsageName} !~ /Memory/;
      $self->{deviceUsageName} = $_->{deviceUsageName};
      $self->{deviceUsagePercent} = $_->{deviceUsagePercent};
      $self->{deviceUsageHigh} = $_->{deviceUsageHigh};
      $self->{deviceUsageStatus} = $_->{deviceUsageStatus};
      $self->{deviceUsageTime} = $_->{deviceUsageTime};
    }
    bless $self, 'Classes::AVOS::Component::MemSubsystem::AVOS3';
  }
}


package Classes::AVOS::Component::MemSubsystem::AVOS3;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking memory');
  $self->add_info(sprintf 'memory usage is %.2f%%',
      $self->{deviceUsagePercent});
  $self->set_thresholds(warning => $self->{deviceUsageHigh} - 10, critical => $self->{deviceUsageHigh});
  $self->add_message($self->check_thresholds($self->{deviceUsagePercent}));
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{deviceUsagePercent},
      uom => '%',
  );
}

package Classes::AVOS::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  my %params = @_;
  # With AVOS version 5.5.4.1, 5.4.6.1 and 6.1.2.1, the SNMP MIB has been extended to support multiple CPU cores.
  # The new OID is defined as a table 1.3.6.1.4.1.3417.2.11.2.4.1 in the BLUECOAT-SG-PROXY-MIB file with the following sub-OIDs.
  # https://kb.bluecoat.com/index?page=content&id=FAQ1244&actp=search&viewlocale=en_US&searchid=1360452047002
  $self->get_snmp_tables('BLUECOAT-SG-PROXY-MIB', [
      ['cpus', 'sgProxyCpuCoreTable', 'Classes::AVOS::Component::CpuSubsystem::Cpu'],
  ]);
  if (scalar (@{$self->{cpus}}) == 0) {
    $self->get_snmp_tables('USAGE-MIB', [
        ['cpus', 'deviceUsageTable', 'Classes::AVOS::Component::CpuSubsystem::DevCpu', sub { return shift->{deviceUsageName} =~ /CPU/ }],
    ]);
  }
}

package Classes::AVOS::Component::CpuSubsystem::Cpu;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'cpu %s usage is %.2f%%',
      $self->{sgProxyCpuCoreIndex}, $self->{sgProxyCpuCoreBusyPerCent});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{sgProxyCpuCoreBusyPerCent}));
  $self->add_perfdata(
      label => 'cpu_'.$self->{sgProxyCpuCoreIndex}.'_usage',
      value => $self->{sgProxyCpuCoreBusyPerCent},
      uom => '%',
  );
}


package Classes::AVOS::Component::CpuSubsystem::DevCpu;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'cpu %s usage is %.2f%%',
      $self->{deviceUsageIndex}, $self->{deviceUsagePercent});
  $self->set_thresholds(warning => $self->{deviceUsageHigh} - 10, critical => $self->{deviceUsageHigh});
  $self->add_message($self->check_thresholds($self->{deviceUsagePercent}));
  $self->add_perfdata(
      label => 'cpu_'.$self->{deviceUsageIndex}.'_usage',
      value => $self->{deviceUsagePercent},
      uom => '%',
  );
}


package Classes::AVOS;
our @ISA = qw(Classes::Bluecoat);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::AVOS::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::AVOS::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::licenses::/) {
    $self->analyze_and_check_key_subsystem("Classes::AVOS::Component::KeySubsystem");
  } elsif ($self->mode =~ /device::connections/) {
    $self->analyze_and_check_connection_subsystem("Classes::AVOS::Component::ConnectionSubsystem");
  } elsif ($self->mode =~ /device::security/) {
    $self->analyze_and_check_security_subsystem("Classes::AVOS::Component::SecuritySubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Alcatel::OmniAccess::Component::HaSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub init {
  my $self = shift;
  if ($self->mode =~ /device::ha::role/) {
    $self->get_snmp_objects('WLSX-SYSTEMEXT-MIB', (qw(wlsxSysExtSwitchRole)));
    if (! $self->opts->role()) {
      $self->opts->override_opt('role', 'master');
    }
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking ha');
  $self->add_info(sprintf 'ha role is %s', $self->{wlsxSysExtSwitchRole});
  if ($self->{wlsxSysExtSwitchRole} ne $self->opts->role()) {
    $self->add_warning();
    $self->add_warning(sprintf "expected role %s", $self->opts->role());
  } else {
    $self->add_ok();
  }
}

package Classes::Alcatel::OmniAccess::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('WLSX-SYSTEMEXT-MIB', [
      ['memories', 'wlsxSysExtMemoryTable', 'Classes::Alcatel::OmniAccess::Component::MemSubsystem::Memory'],
  ]);
}


package Classes::Alcatel::OmniAccess::Component::MemSubsystem::Memory;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{usage} = 100 * $self->{sysExtMemoryUsed} / $self->{sysExtMemorySize};
}

sub check {
  my $self = shift;
  my $label = sprintf 'memory_%s_usage', $self->{flat_indices};
  $self->add_info(sprintf 'memory %s usage is %.2f%%',
      $self->{flat_indices}, $self->{usage});
  $self->set_thresholds(metric => $label, warning => 80, critical => 90);
  $self->add_message($self->check_thresholds(
      metric => $label, value => $self->{usage}));
  $self->add_perfdata(
      label => $label,
      value => $self->{usage},
      uom => '%',
  );
}

package Classes::Alcatel::OmniAccess::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('WLSX-SYSTEMEXT-MIB', [
      ['memories', 'wlsxSysExtProcessorTable', 'Classes::Alcatel::OmniAccess::Component::CpuSubsystem::Cpu'],
  ]);
}


package Classes::Alcatel::OmniAccess::Component::CpuSubsystem::Cpu;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  my $label = sprintf '%s_usage', lc $self->{sysExtProcessorDescr};
  $label =~ s/\s+/_/g;
  $self->add_info(sprintf '%s usage is %.2f%%',
      $self->{sysExtProcessorDescr}, $self->{sysExtProcessorLoad});
  $self->set_thresholds(metric => $label, warning => 80, critical => 90);
  $self->add_message($self->check_thresholds(
      metric => $label, value => $self->{sysExtProcessorLoad}));
  $self->add_perfdata(
      label => $label,
      value => $self->{sysExtProcessorLoad},
      uom => '%',
  );
}

package Classes::Alcatel::OmniAccess::Component::PowersupplySubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('WLSX-SYSTEMEXT-MIB', [
      ['powersupplies', 'wlsxSysExtPowerSupplyTable', 'Classes::Alcatel::OmniAccess::Component::PowersupplySubsystem::Powersupply'],
  ]);
}

package Classes::Alcatel::OmniAccess::Component::PowersupplySubsystem::Powersupply;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'power supply %d status is %s',
      $self->{flat_indices},
      $self->{sysExtPowerSupplyStatus});
  if ($self->{sysExtPowerSupplyStatus} ne 'active') {
    $self->add_warning();
  }
}

package Classes::Alcatel::OmniAccess::Component::FanSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('WLSX-SYSTEMEXT-MIB', [
      ['fans', 'wlsxSysExtFanTable', 'Classes::Alcatel::OmniAccess::Component::FanSubsystem::Fan'],
  ]);
}

package Classes::Alcatel::OmniAccess::Component::FanSubsystem::Fan;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'fan %d status is %s',
      $self->{flat_indices},
      $self->{sysExtFanStatus});
  if ($self->{sysExtFanStatus} ne 'active') {
    $self->add_warning();
  }
}

package Classes::Alcatel::OmniAccess::Component::StorageSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('WLSX-SYSTEMEXT-MIB', [
      ['storage', 'wlsxSysExtStorageTable', 'Classes::Alcatel::OmniAccess::Component::StorageSubsystem::Storageory'],
  ]);
}


package Classes::Alcatel::OmniAccess::Component::StorageSubsystem::Storageory;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{usage} = 100 * $self->{sysExtStorageUsed} / $self->{sysExtStorageSize};
}

sub check {
  my $self = shift;
  my $label = sprintf 'storage_%s_usage', $self->{sysExtStorageName};
  $label =~ s/\s+/_/g;
  $self->add_info(sprintf 'storage %s usage is %.2f%%',
      $self->{sysExtStorageName}, $self->{usage});
  $self->set_thresholds(metric => $label, warning => 80, critical => 90);
  $self->add_message($self->check_thresholds(
      metric => $label, value => $self->{usage}));
  $self->add_perfdata(
      label => $label,
      value => $self->{usage},
      uom => '%',
  );
}

package Classes::Alcatel::OmniAccess::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{fan_subsystem} =
      Classes::Alcatel::OmniAccess::Component::FanSubsystem->new();
  $self->get_snmp_objects('WLSX-SYSTEMEXT-MIB', qw(
      wlsxSysExtInternalTemparature));
  $self->{powersupply_subsystem} = 
      Classes::Alcatel::OmniAccess::Component::PowersupplySubsystem->new();
  $self->{storage_subsystem} = 
      Classes::Alcatel::OmniAccess::Component::StorageSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{fan_subsystem}->check();
  $self->{powersupply_subsystem}->check();
  $self->{storage_subsystem}->check();
  $self->add_info(sprintf "temperature is %s", $self->{wlsxSysExtInternalTemparature});
  if ($self->{wlsxSysExtInternalTemparature} =~ /\(.*\)/ &&
      $self->{wlsxSysExtInternalTemparature} !~ /normal/i) {
    # -1.00 degrees Celsius (NORMAL)
    # wenn kein "(irgendwas)" enthalten ist, dann gibt's wahrsch. eh keinen
    # status, also ignorieren. und warum -1 grad normal sein sollen, muss
    # mir auch mal einer erklaeren.
    $self->add_warning();
  }
  $self->reduce_messages("environmental hardware working fine");
}

sub dump {
  my $self = shift;
  printf "[%s]\n%s\n", uc "wlsxSysExtInternalTemparature", 
      $self->{wlsxSysExtInternalTemparature};
  $self->{fan_subsystem}->dump();
  $self->{powersupply_subsystem}->dump();
  $self->{storage_subsystem}->dump();
}

package Classes::Alcatel::OmniAccess::Component::WlanSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('WLSX-WLAN-MIB', qw(wlsxWlanTotalNumAccessPoints));
  $self->get_snmp_tables('WLSX-WLAN-MIB', [
      ['aps', 'wlsxWlanAPTable', 'Classes::Alcatel::OmniAccess::Component::WlanSubsystem::AP', sub { return $self->filter_name(shift->{wlanAPName}) } ],
  ]);
}

sub check {
  my $self = shift;
  $self->add_info('checking access points');
  $self->{numOfAPs} = scalar (@{$self->{aps}});
  $self->{apNameList} = [map { $_->{wlanAPName} } @{$self->{aps}}];
  if (scalar (@{$self->{aps}}) == 0) {
    $self->add_unknown('no access points found');
  } else {
    foreach (@{$self->{aps}}) {
      $_->check();
    }
    if ($self->mode =~ /device::wlan::aps::watch/) {
      $self->opts->override_opt('lookback', 1800) if ! $self->opts->lookback;
      $self->valdiff({name => $self->{name}, lastarray => 1},
          qw(apNameList numOfAPs));
      if (scalar(@{$self->{delta_found_apNameList}}) > 0) {
      #if (scalar(@{$self->{delta_found_apNameList}}) > 0 &&
      #    $self->{delta_timestamp} > $self->opts->lookback) {
        $self->add_warning(sprintf '%d new access points (%s)',
            scalar(@{$self->{delta_found_apNameList}}),
            join(", ", @{$self->{delta_found_apNameList}}));
      }
      if (scalar(@{$self->{delta_lost_apNameList}}) > 0) {
        $self->add_critical(sprintf '%d access points missing (%s)',
            scalar(@{$self->{delta_lost_apNameList}}),
            join(", ", @{$self->{delta_lost_apNameList}}));
      }
      $self->add_ok(sprintf 'found %d access points', scalar (@{$self->{aps}}));
      $self->add_perfdata(
          label => 'num_aps',
          value => scalar (@{$self->{aps}}),
      );
    } elsif ($self->mode =~ /device::wlan::aps::count/) {
      $self->set_thresholds(warning => '10:', critical => '5:');
      $self->add_message($self->check_thresholds(
          scalar (@{$self->{aps}})), 
          sprintf 'found %d access points', scalar (@{$self->{aps}}));
      $self->add_perfdata(
          label => 'num_aps',
          value => scalar (@{$self->{aps}}),
      );
    } elsif ($self->mode =~ /device::wlan::aps::status/) {
      $self->reduce_messages('no problems');
      $self->add_perfdata(
          label => 'num_aps',
          value => scalar (@{$self->{aps}}),
      );
      $self->add_perfdata(
          label => 'num_up_aps',
          value => scalar (grep { $_->{wlanAPStatus} ne "down" } @{$self->{aps}}),
      );
      $self->add_perfdata(
          label => 'num_down_aps',
          value => scalar (grep { $_->{wlanAPStatus} eq "down" } @{$self->{aps}}),
      );
    } elsif ($self->mode =~ /device::wlan::aps::list/) {
      foreach (@{$self->{aps}}) {
        printf "%s\n", $_->{wlanAPName};
      }
    }
  }
}

package Classes::Alcatel::OmniAccess::Component::WlanSubsystem::AP;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  if ($self->{wlanAPMacAddress} && $self->{wlanAPMacAddress} =~ /0x(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})/) {
    $self->{wlanAPMacAddress} = join(".", map { hex($_) } ($1, $2, $3, $4, $5, $6));
  } elsif ($self->{wlanAPMacAddress} && unpack("H12", $self->{wlanAPMacAddress}) =~ /(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})/) {
    $self->{wlanAPMacAddress} = join(".", map { hex($_) } ($1, $2, $3, $4, $5, $6));
  }
}

sub check {
  my $self = shift;
  $self->add_info(sprintf 'access point %s is %s',
      $self->{wlanAPName}, $self->{wlanAPStatus});
  if ($self->mode =~ /device::wlan::aps::status/) {
    if ($self->{wlanAPStatus} eq 'down') {
      $self->add_critical();
    } else {
      $self->add_ok();
    }
  }
}

package Classes::Alcatel::OmniAccess;
our @ISA = qw(Classes::Alcatel);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Alcatel::OmniAccess::Component::EnvironmentalSubsystem");
    # waere praktischer, aber in diesem fall muss alarmdreck ausgeputzt werden
    #$self->analyze_and_check_alarm_subsystem("Classes::ALARMMIB::Component::AlarmSubsystem");
    $self->{components}->{alarm_subsystem} = Classes::ALARMMIB::Component::AlarmSubsystem->new();
    @{$self->{components}->{alarm_subsystem}->{alarms}} = grep {
      # accesspoint down und so interface-zeugs interessiert hier nicht, dafuer
      # gibt's die *accesspoint*- und *interface*-modes
      $_->{alarmActiveDescription} =~ /(Temperature is out of range)|(Out of range voltage)|(failed)/ ? 1 : undef;
    } @{$self->{components}->{alarm_subsystem}->{alarms}};
    $self->{components}->{alarm_subsystem}->{stats}->[0]->{alarmActiveStatsActiveCurrent} = scalar(@{$self->{components}->{alarm_subsystem}->{alarms}});
    $self->check_alarm_subsystem();
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Alcatel::OmniAccess::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Alcatel::OmniAccess::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::wlan/) {
    $self->analyze_and_check_wlan_subsystem("Classes::Alcatel::OmniAccess::Component::WlanSubsystem");
  } elsif ($self->mode =~ /device::ha::/) {
    $self->analyze_and_check_ha_subsystem("Classes::Alcatel::OmniAccess::Component::HaSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Alcatel;
our @ISA = qw(Classes::Device);
use strict;

sub init {
  my $self = shift;
  if ($self->{productname} =~ /AOS.*OAW/i) {
    bless $self, 'Classes::Alcatel::OmniAccess';
    $self->debug('using Classes::Alcatel::OmniAccess');
  }
  if (ref($self) ne "Classes::Alcatel") {
    $self->init();
  }
}

package Classes::ALARMMIB::Component::AlarmSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('ALARM-MIB', [
      #['models', 'alarmModelTable', 'Classes::ALARMMIB::Component::AlarmSubsystem::AlarmModel'],
      #['variables', 'alarmActiveVariableTable', 'Classes::ALARMMIB::Component::AlarmSubsystem::AlarmVariable'],
      ['alarms', 'alarmActiveTable', 'Classes::ALARMMIB::Component::AlarmSubsystem::Alarm'],
      ['stats', 'alarmActiveStatsTable', 'Classes::ALARMMIB::Component::AlarmSubsystem::AlarmStats'],
  ]);
}


package Classes::ALARMMIB::Component::AlarmSubsystem::Alarm;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

package Classes::ALARMMIB::Component::AlarmSubsystem::AlarmModel;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

package Classes::ALARMMIB::Component::AlarmSubsystem::AlarmVariable;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{ceAlarmTypes} = [];
  if ($self->{alarmActiveVariableValueType} eq 'octetString') {
    my $index = 0;
    $self->{alarmActiveVariableOctetStringVal2} = join("", map {
      chr(hex($_));
    } map {
      /0x(\w+)/ ? $1 : $_;
    } split(/\s+/, $self->{alarmActiveVariableOctetStringVal}));
  }
}


package Classes::ALARMMIB::Component::AlarmSubsystem::AlarmStats;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf "there are %d active alarms",
      $self->{alarmActiveStatsActiveCurrent});
  if ($self->{alarmActiveStatsActiveCurrent}) {
    $self->add_critical();
  } else {
    $self->add_ok();
  }
}

package Classes::Foundry::Component::SLBSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub update_caches {
  my $self = shift;
  my $force = shift;
  $self->update_entry_cache($force, 'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4BindTable', 'snL4BindVirtualServerName');
  $self->update_entry_cache($force, 'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4VirtualServerTable', 'snL4VirtualServerName');
  $self->update_entry_cache($force, 'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4VirtualServerPortTable', 'snL4VirtualServerPortServerName');
  $self->update_entry_cache($force, 'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4VirtualServerPortStatisticTable', 'snL4VirtualServerPortStatisticServerName');
  $self->update_entry_cache($force, 'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4RealServerPortStatusTable', 'snL4RealServerPortStatusServerName');
}

sub init {
  my $self = shift;
  # opt->name can be servername:serverport
  my $original_name = $self->opts->name;
  if ($self->mode =~ /device::lb::session::usage/) {
    $self->get_snmp_objects('FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', (qw(
        snL4MaxSessionLimit snL4FreeSessionCount)));
    $self->{session_usage} = 100 * ($self->{snL4MaxSessionLimit} - $self->{snL4FreeSessionCount}) / $self->{snL4MaxSessionLimit};
  } elsif ($self->mode =~ /device::lb::pool/) {
    if ($self->mode =~ /device::lb::pool::list/) {
      $self->update_caches(1);
    } else {
      $self->update_caches(0);
    }
    if ($self->opts->name) {
      # optimized, with a minimum of snmp operations
      foreach my $vs ($self->get_snmp_table_objects_with_cache(
          'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4VirtualServerTable', 'snL4VirtualServerName')) {
        $self->{vsdict}->{$vs->{snL4VirtualServerName}} = $vs;
        $self->opts->override_opt('name', $vs->{snL4VirtualServerName});
        foreach my $vsp ($self->get_snmp_table_objects_with_cache(
            'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4VirtualServerPortTable', 'snL4VirtualServerPortServerName')) {
          $self->{vspdict}->{$vsp->{snL4VirtualServerPortServerName}}->{$vsp->{snL4VirtualServerPortPort}} = $vsp;
        }
        foreach my $vspsc ($self->get_snmp_table_objects_with_cache(
            'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4VirtualServerPortStatisticTable', 'snL4VirtualServerPortStatisticServerName')) {
          $self->{vspscdict}->{$vspsc->{snL4VirtualServerPortStatisticServerName}}->{$vspsc->{snL4VirtualServerPortStatisticPort}} = $vspsc;
        }
        foreach my $binding ($self->get_snmp_table_objects_with_cache(
            'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4BindTable', 'snL4BindVirtualServerName')) {
          $self->{bindingdict}->{$binding->{snL4BindVirtualServerName}}->{$binding->{snL4BindVirtualPortNumber}}->{$binding->{snL4BindRealServerName}}->{$binding->{snL4BindRealPortNumber}} = 1;
          $self->opts->override_opt('name', $binding->{snL4BindRealServerName});
          if (! exists $self->{rsdict}->{$binding->{snL4BindRealServerName}}) {
            #foreach my $rs ($self->get_snmp_table_objects_with_cache(
            #    'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4RealServerTable', 'snL4RealServerName')) {
            #  $self->{rsdict}->{$rs->{snL4RealServerName}} = $rs;
            #}
            #foreach my $rsst ($self->get_snmp_table_objects_with_cache(
            #    'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4RealServerStatusTable', 'snL4RealServerStatusName')) {
            #  $self->{rsstdict}->{$rsst->{snL4RealServerStatusName}} = $rsst;
            #}
          }
          if (! exists $self->{rspstdict}->{$binding->{snL4BindRealServerName}}->{$binding->{snL4BindRealPortNumber}}) {
            # todo: profiler, dauert 30s pro aufruf
            foreach my $rspst ($self->get_snmp_table_objects_with_cache(
                'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4RealServerPortStatusTable', 'snL4RealServerPortStatusServerName')) {
              $self->{rspstdict}->{$rspst->{snL4RealServerPortStatusServerName}}->{$rspst->{snL4RealServerPortStatusPort}} = $rspst;
            }
          }
        }
      }
    } else {
      foreach my $vs ($self->get_snmp_table_objects(
          'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4VirtualServerTable')) {
        $self->{vsdict}->{$vs->{snL4VirtualServerName}} = $vs;
      }
      foreach my $vsp ($self->get_snmp_table_objects(
          'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4VirtualServerPortTable')) {
        $self->{vspdict}->{$vsp->{snL4VirtualServerPortServerName}}->{$vsp->{snL4VirtualServerPortPort}} = $vsp;
      }
      foreach my $vspsc ($self->get_snmp_table_objects(
          'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4VirtualServerPortStatisticTable')) {
        $self->{vspscdict}->{$vspsc->{snL4VirtualServerPortStatisticServerName}}->{$vspsc->{snL4VirtualServerPortStatisticPort}} = $vspsc;
      }
      #foreach my $rs ($self->get_snmp_table_objects(
      #    'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4RealServerTable')) {
      #  $self->{rsdict}->{$rs->{snL4RealServerName}} = $rs;
      #}
      #foreach my $rsst ($self->get_snmp_table_objects(
      #    'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4RealServerStatusTable')) {
      #  $self->{rsstdict}->{$rsst->{snL4RealServerStatusName}} = $rsst;
      #}
      foreach my $rspst ($self->get_snmp_table_objects(
          'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4RealServerPortStatusTable')) {
        $self->{rspstdict}->{$rspst->{snL4RealServerPortStatusServerName}}->{$rspst->{snL4RealServerPortStatusPort}} = $rspst;
      }
      foreach my $binding ($self->get_snmp_table_objects(
          'FOUNDRY-SN-SW-L4-SWITCH-GROUP-MIB', 'snL4BindTable')) {
        $self->{bindingdict}->{$binding->{snL4BindVirtualServerName}}->{$binding->{snL4BindVirtualPortNumber}}->{$binding->{snL4BindRealServerName}}->{$binding->{snL4BindRealPortNumber}} = 1;
      }
    }

    # snL4VirtualServerTable:                snL4VirtualServerAdminStatus
    # snL4VirtualServerStatisticTable:       allenfalls TxRx Bytes
    # snL4VirtualServerPortTable:            snL4VirtualServerPortAdminStatus*
    # snL4VirtualServerPortStatisticTable:   snL4VirtualServerPortStatisticCurrentConnection*
    # snL4RealServerTable:                   snL4RealServerAdminStatus
    # snL4RealServerPortStatusTable:         snL4RealServerPortStatusCurrentConnection snL4RealServerPortStatusState
    # 
    # summe snL4RealServerStatisticCurConnections = snL4VirtualServerPortStatisticCurrentConnection
    # vip , jeder vport gibt ein performancedatum, jeder port hat n. realports, jeder realport hat status
    #  aus realportstatus errechnet sich verfuegbarkeit des vport
    #  aus vports ergeben sich die session-output.zahlen
    # real ports eines vs, real servers
    # globaler mode snL4MaxSessionLimit : snL4FreeSessionCount


    #
    # virtual server
    #
    $self->opts->override_opt('name', $original_name);
    $self->{virtualservers} = [];
    foreach my $vs (grep { $self->filter_name($_) } keys %{$self->{vsdict}}) {
      $self->{vsdict}->{$vs} = Classes::Foundry::Component::SLBSubsystem::VirtualServer->new(%{$self->{vsdict}->{$vs}});
      next if ! exists $self->{vspdict}->{$vs};
      #
      # virtual server has ports
      #
      foreach my $vspp (keys %{$self->{vspdict}->{$vs}}) {
        next if $self->opts->name2 && $self->opts->name2 ne $vspp;
        #
        # virtual server port has bindings
        #
        $self->{vspdict}->{$vs}->{$vspp} = Classes::Foundry::Component::SLBSubsystem::VirtualServerPort->new(%{$self->{vspdict}->{$vs}->{$vspp}});
        #
        # merge virtual server port and virtual server port statistics
        #
        map { $self->{vspdict}->{$vs}->{$vspp}->{$_} = $self->{vspscdict}->{$vs}->{$vspp}->{$_} } keys %{$self->{vspscdict}->{$vs}->{$vspp}};
        #
        # add the virtual port to the virtual server object
        #
        $self->{vsdict}->{$vs}->add_port($self->{vspdict}->{$vs}->{$vspp});
        next if ! exists $self->{bindingdict}->{$vs} || ! exists $self->{bindingdict}->{$vs}->{$vspp};
        #
        # bound virtual server port has corresponding real server port(s)
        #
        foreach my $rs (keys %{$self->{bindingdict}->{$vs}->{$vspp}}) {
          foreach my $rsp (keys %{$self->{bindingdict}->{$vs}->{$vspp}->{$rs}}) {
            #
            # loop through real server / real server port
            #
            $self->{rspstdict}->{$rs}->{$rsp} = Classes::Foundry::Component::SLBSubsystem::RealServerPort->new(%{$self->{rspstdict}->{$rs}->{$rsp}}) if ref($self->{rspstdict}->{$rs}->{$rsp}) eq 'HASH';
            $self->{vspdict}->{$vs}->{$vspp}->add_port($self->{rspstdict}->{$rs}->{$rsp}); # add real port(s) to virtual port
          }
        }
      }
      push(@{$self->{virtualservers}}, $self->{vsdict}->{$vs});
    }
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking slb virtual servers');
  if ($self->mode =~ /device::lb::session::usage/) {
    $self->add_info('checking session usage');
    $self->add_info(sprintf 'session usage is %.2f%% (%d of %d)', $self->{session_usage},
        $self->{snL4MaxSessionLimit} - $self->{snL4FreeSessionCount}, $self->{snL4MaxSessionLimit});
    $self->set_thresholds(warning => 80, critical => 90);
    $self->add_message($self->check_thresholds($self->{session_usage}));
    $self->add_perfdata(
        label => 'session_usage',
        value => $self->{session_usage},
        uom => '%',
    );
  } elsif ($self->mode =~ /device::lb::pool/) {
    if (scalar(@{$self->{virtualservers}}) == 0) {
      $self->add_unknown('no vips');
      return;
    }
    if ($self->mode =~ /pool::list/) {
      foreach (@{$self->{virtualservers}}) {
        printf "%s\n", $_->{snL4VirtualServerName};
        #$_->list();
      }
    } else {
      foreach (@{$self->{virtualservers}}) {
        $_->check();
      }
      if (! $self->opts->name) {
        $self->clear_ok(); # too much noise
        if (! $self->check_messages()) {
          $self->add_ok("virtual servers working fine");
        }
      }
    }
  }
}


package Classes::Foundry::Component::SLBSubsystem::VirtualServer;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{ports} = [];
}

sub check {
  my $self = shift;
  my %params = @_;
  $self->add_info(sprintf "vis %s is %s", 
      $self->{snL4VirtualServerName},
      $self->{snL4VirtualServerAdminStatus});
  if ($self->{snL4VirtualServerAdminStatus} ne 'enabled') {
    $self->add_warning();
  } else {
    if (scalar (@{$self->{ports}}) == 0) {
      $self->add_warning();
      $self->add_warning("but has no configured ports");
    } else {
      foreach (@{$self->{ports}}) {
        $_->check();
      }
    }
  }
  if ($self->opts->report eq "html") {
    my ($code, $message) = $self->check_messages();
    printf "%s - %s%s\n", $self->status_code($code), $message, $self->perfdata_string() ? " | ".$self->perfdata_string() : "";
    $self->suppress_messages();
    print $self->html_string();
  }
}

sub add_port {
  my $self = shift;
  push(@{$self->{ports}}, shift);
}


package Classes::Foundry::Component::SLBSubsystem::VirtualServerPort;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub finish {
  my $self = shift;
  $self->{ports} = [];
}

sub check {
  my $self = shift;
  $self->add_info(sprintf "vpo %s:%d is %s (%d connections to %d real ports)",
      $self->{snL4VirtualServerPortServerName},
      $self->{snL4VirtualServerPortPort},
      $self->{snL4VirtualServerPortAdminStatus},
      $self->{snL4VirtualServerPortStatisticCurrentConnection},
      scalar(@{$self->{ports}}));
  my $num_ports = scalar(@{$self->{ports}});
  my $active_ports = scalar(grep { $_->{snL4RealServerPortStatusState} eq 'active' } @{$self->{ports}});
  # snL4RealServerPortStatusState: failed wird auch angezeigt durch snL4RealServerStatusFailedPortExists => 1
  # wobei snL4RealServerStatusState' => serveractive ist
  # zu klaeren, ob ein kaputter real server auch in snL4RealServerPortStatusState angezeigt wird
  $self->{completeness} = $num_ports ? 100 * $active_ports / $num_ports : 0;
  if ($num_ports == 0) {
    $self->set_thresholds(warning => "0:", critical => "0:");
    $self->add_warning(sprintf "%s:%d has no bindings", 
      $self->{snL4VirtualServerPortServerName},
      $self->{snL4VirtualServerPortPort});
  } elsif ($active_ports == 1) {
    # only one member left = no more redundancy!!
    $self->set_thresholds(warning => "100:", critical => "51:");
  } else {
    $self->set_thresholds(warning => "51:", critical => "26:");
  }
  $self->add_message($self->check_thresholds($self->{completeness}));
  foreach (@{$self->{ports}}) {
    $_->check();
  }
  $self->add_perfdata(
      label => sprintf('pool_%s:%d_completeness', $self->{snL4VirtualServerPortServerName}, $self->{snL4VirtualServerPortPort}),
      value => $self->{completeness},
      uom => '%',
  );
  $self->add_perfdata(
      label => sprintf('pool_%s:%d_servercurconns', $self->{snL4VirtualServerPortServerName}, $self->{snL4VirtualServerPortPort}),
      value => $self->{snL4VirtualServerPortStatisticCurrentConnection},
      thresholds => 0,
  );
  if ($self->opts->report eq "html") {
    # tabelle mit snL4VirtualServerPortServerName:snL4VirtualServerPortPort
    $self->add_html("<table style=\"border-collapse:collapse; border: 1px solid black;\">");
    $self->add_html("<tr>");
    foreach (qw(Name Port Status Real Port Status Conn)) {
      $self->add_html(sprintf "<th style=\"text-align: left; padding-left: 4px; padding-right: 6px;\">%s</th>", $_);
    }
    $self->add_html("</tr>");
    foreach (sort {$a->{snL4RealServerPortStatusServerName} cmp $b->{snL4RealServerPortStatusServerName}} @{$self->{ports}}) {
      $self->add_html("<tr style=\"border: 1px solid black;\">");
      foreach my $attr (qw(snL4VirtualServerPortServerName snL4VirtualServerPortPort snL4VirtualServerPortAdminStatus)) {
        my $bgcolor = "#33ff00"; #green
        if ($self->{snL4VirtualServerPortAdminStatus} ne "enabled") {
          $bgcolor = "#acacac";
        } elsif ($self->check_messages()) {
          $bgcolor = "#f83838";
        }
        $self->add_html(sprintf "<td style=\"text-align: left; padding-left: 4px; padding-right: 6px; background-color: %s;\">%s</td>", $bgcolor, $self->{$attr});
      }
      foreach my $attr (qw(snL4RealServerPortStatusServerName snL4RealServerPortStatusPort snL4RealServerPortStatusState snL4RealServerPortStatusCurrentConnection)) {
        my $bgcolor = "#33ff00"; #green
        if ($self->{snL4VirtualServerPortAdminStatus} ne "enabled") {
          $bgcolor = "#acacac";
        } elsif ($_->{snL4RealServerPortStatusState} ne "active") {
          $bgcolor = "#f83838";
        }
        $self->add_html(sprintf "<td style=\"text-align: left; padding-left: 4px; padding-right: 6px; background-color: %s;\">%s</td>", $bgcolor, $_->{$attr});
      }
      $self->add_html("</tr>");
    }
    $self->add_html("</table>\n");
    $self->add_html("<!--\nASCII_NOTIFICATION_START\n");
    foreach (qw(Name Port Status Real Port Status Conn)) {
      $self->add_html(sprintf "%25s", $_);
    }
    $self->add_html("\n");
    foreach (sort {$a->{snL4RealServerPortStatusServerName} cmp $b->{snL4RealServerPortStatusServerName}} @{$self->{ports}}) {
      foreach my $attr (qw(snL4VirtualServerPortServerName snL4VirtualServerPortPort snL4VirtualServerPortAdminStatus)) {
        $self->add_html(sprintf "%25s", $self->{$attr});
      }
      foreach my $attr (qw(snL4RealServerPortStatusServerName snL4RealServerPortStatusPort snL4RealServerPortStatusState snL4RealServerPortStatusCurrentConnection)) {
        $self->add_html(sprintf "%15s", $_->{$attr});
      }
      $self->add_html("\n");
    }
    $self->add_html("ASCII_NOTIFICATION_END\n-->\n");
  }
}

sub add_port {
  my $self = shift;
  push(@{$self->{ports}}, shift);
}


package Classes::Foundry::Component::SLBSubsystem::RealServer;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  if ($self->{slbPoolMbrStatusEnabledState} eq "enabled") {
    if ($self->{slbPoolMbrStatusAvailState} ne "green") {
      $self->add_critical(sprintf
          "member %s is %s/%s (%s)",
          $self->{slbPoolMemberNodeName},
          $self->{slbPoolMemberMonitorState},
          $self->{slbPoolMbrStatusAvailState},
          $self->{slbPoolMbrStatusDetailReason});
    }
  }
}


package Classes::Foundry::Component::SLBSubsystem::RealServerPort;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub check {
  my $self = shift;
  my %params = @_;
  $self->add_info(sprintf "rpo %s:%d is %s",
      $self->{snL4RealServerPortStatusServerName},
      $self->{snL4RealServerPortStatusPort},
      $self->{snL4RealServerPortStatusState});
  $self->add_message($self->{snL4RealServerPortStatusState} eq 'active' ? OK : CRITICAL);
  # snL4VirtualServerPortStatisticTable dazumischen
  # snL4VirtualServerPortStatisticTable:   snL4VirtualServerPortStatisticCurrentConnection*
  # realports connecten und den status ermitteln
}


package Classes::Foundry::Component::SLBSubsystem::Binding;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

package Classes::Foundry::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('FOUNDRY-SN-AGENT-MIB', (qw(
      snAgGblDynMemUtil snAgGblDynMemTotal snAgGblDynMemFree)));
}

sub check {
  my $self = shift;
  $self->add_info('checking memory');
  if (defined $self->{snAgGblDynMemUtil}) {
    $self->add_info(sprintf 'memory usage is %.2f%%',
        $self->{snAgGblDynMemUtil});
    $self->set_thresholds(warning => 80, critical => 99);
    $self->add_message($self->check_thresholds($self->{snAgGblDynMemUtil}));
    $self->add_perfdata(
        label => 'memory_usage',
        value => $self->{snAgGblDynMemUtil},
        uom => '%',
    );
  } else {
    $self->add_unknown('cannot aquire memory usage');
  }
}

package Classes::Foundry::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('FOUNDRY-SN-AGENT-MIB', [
      ['cpus', 'snAgentCpuUtilTable', 'Classes::Foundry::Component::CpuSubsystem::Cpu'],
  ]);
  $self->get_snmp_objects('FOUNDRY-SN-AGENT-MIB', (qw(
      snAgGblCpuUtil1SecAvg snAgGblCpuUtil5SecAvg snAgGblCpuUtil1MinAvg)));
}

sub check {
  my $self = shift;
  if (scalar (@{$self->{cpus}}) == 0) {
    $self->overall_check();
  } else {
    # snAgentCpuUtilInterval = 1, 5, 60, 300
    # --lookback can be one of these values, default is 300 (1,5 is a stupid choice)
    $self->opts->override_opt('lookback', 300) if ! $self->opts->lookback;
    foreach (grep { $_->{snAgentCpuUtilInterval} eq $self->opts->lookback} @{$self->{cpus}}) {
      $_->check();
    }
  }
}

sub dump {
  my $self = shift;
  $self->overall_dump();
  foreach (@{$self->{cpus}}) {
    $_->dump();
  }
}

sub overall_check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking cpus');
  $self->add_info(sprintf 'cpu usage is %.2f%%', $self->{snAgGblCpuUtil1MinAvg});
  $self->set_thresholds(warning => 50, critical => 90);
  $self->add_message($self->check_thresholds(
      $self->{snAgGblCpuUtil1MinAvg}));
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{snAgGblCpuUtil1MinAvg},
      uom => '%',
  );
}

sub overall_dump {
  my $self = shift;
  printf "[CPU]\n";
  foreach (qw(snAgGblCpuUtil1SecAvg snAgGblCpuUtil5SecAvg
      snAgGblCpuUtil1MinAvg)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "\n";
}

package Classes::Foundry::Component::CpuSubsystem::Cpu;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  # newer mibs have snAgentCpuUtilPercent and snAgentCpuUtil100thPercent
  # snAgentCpuUtilValue is deprecated
  $self->{snAgentCpuUtilValue} = $self->{snAgentCpuUtil100thPercent} / 100
      if defined $self->{snAgentCpuUtil100thPercent};
  # if it is an old mib, watch out. snAgentCpuUtilValue is 100th of a percent
  # but it seems that sometimes in reality it is percent
  $self->{snAgentCpuUtilValue} = $self->{snAgentCpuUtilValue} / 100
      if $self->{snAgentCpuUtilValue} > 100;
  $self->add_info(sprintf 'cpu %s usage is %.2f', $self->{snAgentCpuUtilSlotNum}, $self->{snAgentCpuUtilValue});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{snAgentCpuUtilValue}));
  $self->add_perfdata(
      label => 'cpu_'.$self->{snAgentCpuUtilSlotNum},
      value => $self->{snAgentCpuUtilValue},
      uom => '%',
  );
}

package Classes::Foundry::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{powersupply_subsystem} =
      Classes::Foundry::Component::PowersupplySubsystem->new();
  $self->{fan_subsystem} =
      Classes::Foundry::Component::FanSubsystem->new();
  $self->{temperature_subsystem} =
      Classes::Foundry::Component::TemperatureSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{powersupply_subsystem}->check();
  $self->{fan_subsystem}->check();
  $self->{temperature_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_ok("environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{powersupply_subsystem}->dump();
  $self->{fan_subsystem}->dump();
  $self->{temperature_subsystem}->dump();
}


package Classes::Foundry::Component::PowersupplySubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('FOUNDRY-SN-AGENT-MIB', [
      ['powersupplies', 'snChasPwrSupplyTable', 'Classes::Foundry::Component::PowersupplySubsystem::Powersupply'],
  ]);
}


package Classes::Foundry::Component::PowersupplySubsystem::Powersupply;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'powersupply %d is %s',
      $self->{snChasPwrSupplyIndex},
      $self->{snChasPwrSupplyOperStatus});
  if ($self->{snChasPwrSupplyOperStatus} eq 'failure') {
    $self->add_critical();
  }
}

package Classes::Foundry::Component::FanSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('FOUNDRY-SN-AGENT-MIB', [
      ['fans', 'snChasFanTable', 'Classes::Foundry::Component::FanSubsystem::Fan'],
  ]);
}


package Classes::Foundry::Component::FanSubsystem::Fan;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'fan %d is %s',
      $self->{snChasFanIndex},
      $self->{snChasFanOperStatus});
  if ($self->{snChasFanOperStatus} eq 'failure') {
    $self->add_critical();
  }
}

package Classes::Foundry::Component::TemperatureSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  my $temp = 0;
  $self->get_snmp_tables('FOUNDRY-SN-AGENT-MIB', [
      ['temperatures', 'snAgentTempTable', 'Classes::Foundry::Component::TemperatureSubsystem::Temperature'],
  ]);
  foreach(@{$self->{temperatures}}) {
    $_->{snAgentTempSlotNum} ||= $temp++;
    $_->{snAgentTempSensorId} ||= 1;
  }
}


package Classes::Foundry::Component::TemperatureSubsystem::Temperature;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->{snAgentTempValue} /= 2;
  $self->add_info(sprintf 'temperature %s is %.2fC', 
      $self->{snAgentTempSlotNum}, $self->{snAgentTempValue});
  $self->set_thresholds(warning => 60, critical => 70);
  $self->add_message($self->check_thresholds($self->{snAgentTempValue}));
  $self->add_perfdata(
      label => 'temperature_'.$self->{snAgentTempSlotNum},
      value => $self->{snAgentTempValue},
  );
}

package Classes::Foundry;
our @ISA = qw(Classes::Device);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Foundry::Component::EnvironmentalSubsystem");
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::Foundry::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::Foundry::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::lb/) {
    $self->analyze_and_check_slb_subsystem("Classes::Foundry::Component::SLBSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::RAPIDCITYMIB::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->{powersupply_subsystem} =
      Classes::RAPIDCITYMIB::Component::PowersupplySubsystem->new();
  $self->{fan_subsystem} =
      Classes::RAPIDCITYMIB::Component::FanSubsystem->new();
  $self->{temperature_subsystem} =
      Classes::RAPIDCITYMIB::Component::TemperatureSubsystem->new();
}

sub check {
  my $self = shift;
  $self->{powersupply_subsystem}->check();
  $self->{fan_subsystem}->check();
  $self->{temperature_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_ok("environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{powersupply_subsystem}->dump();
  $self->{fan_subsystem}->dump();
  $self->{temperature_subsystem}->dump();
}


package Classes::RAPIDCITYMIB::Component::PowersupplySubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('FOUNDRY-SN-AGENT-MIB', [
      ['powersupplies', 'snChasPwrSupplyTable', 'Classes::RAPIDCITYMIB::Component::PowersupplySubsystem::Powersupply'],
  ]);
}


package Classes::RAPIDCITYMIB::Component::PowersupplySubsystem::Powersupply;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'powersupply %d is %s',
      $self->{snChasPwrSupplyIndex},
      $self->{snChasPwrSupplyOperStatus});
  if ($self->{snChasPwrSupplyOperStatus} eq 'failure') {
    $self->add_critical();
  }
}

package Classes::RAPIDCITYMIB::Component::FanSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('FOUNDRY-SN-AGENT-MIB', [
      ['fans', 'snChasFanTable', 'Classes::RAPIDCITYMIB::Component::FanSubsystem::Fan'],
  ]);
}


package Classes::RAPIDCITYMIB::Component::FanSubsystem::Fan;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf 'fan %d is %s',
      $self->{snChasFanIndex},
      $self->{snChasFanOperStatus});
  if ($self->{snChasFanOperStatus} eq 'failure') {
    $self->add_critical();
  }
}

package Classes::RAPIDCITYMIB::Component::TemperatureSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  my $temp = 0;
  $self->get_snmp_tables('FOUNDRY-SN-AGENT-MIB', [
      ['temperatures', 'snAgentTempTable', 'Classes::RAPIDCITYMIB::Component::TemperatureSubsystem::Temperature'],
  ]);
  foreach(@{$self->{temperatures}}) {
    $_->{snAgentTempSlotNum} ||= $temp++;
    $_->{snAgentTempSensorId} ||= 1;
  }
}


package Classes::RAPIDCITYMIB::Component::TemperatureSubsystem::Temperature;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->{snAgentTempValue} /= 2;
  $self->add_info(sprintf 'temperature %s is %.2fC', 
      $self->{snAgentTempSlotNum}, $self->{snAgentTempValue});
  $self->set_thresholds(warning => 60, critical => 70);
  $self->add_message($self->check_thresholds($self->{snAgentTempValue}));
  $self->add_perfdata(
      label => 'temperature_'.$self->{snAgentTempSlotNum},
      value => $self->{snAgentTempValue},
  );
}

package Classes::RAPIDCITYMIB;
our @ISA = qw(Classes::Device);
use strict;

package Classes::PaloALto::Component::MemSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('NETSCREEN-RESOURCE-MIB', (qw(
      nsResMemAllocate nsResMemLeft nsResMemFrag)));
  my $mem_total = $self->{nsResMemAllocate} + $self->{nsResMemLeft};
  $self->{mem_usage} = $self->{nsResMemAllocate} / $mem_total * 100;
}

sub check {
  my $self = shift;
  $self->add_info('checking memory');
  if (defined $self->{mem_usage}) {
    $self->add_info(sprintf 'memory usage is %.2f%%', $self->{mem_usage});
    $self->set_thresholds(warning => 80,
        critical => 90);
    $self->add_message($self->check_thresholds($self->{mem_usage}));
    $self->add_perfdata(
        label => 'memory_usage',
        value => $self->{mem_usage},
        uom => '%',
    );
  } else {
    $self->add_unknown('cannot aquire memory usage');
  }
}

package Classes::PaloALto::Component::CpuSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('NETSCREEN-RESOURCE-MIB', (qw(
      nsResCpuAvg)));
}

sub check {
  my $self = shift;
  $self->add_info('checking cpus');
  $self->add_info(sprintf 'cpu usage is %.2f%%', $self->{nsResCpuAvg});
  $self->set_thresholds(warning => 50, critical => 90);
  $self->add_message($self->check_thresholds($self->{nsResCpuAvg}));
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{nsResCpuAvg},
      uom => '%',
  );
}
package Classes::PaloAlto::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
#######################
$self->no_such_mode();
die;
## entitymib, pan enhancement
  $self->get_snmp_objects("NETSCREEN-CHASSIS-MIB", (qw(
      sysBatteryStatus)));
  $self->get_snmp_tables("NETSCREEN-CHASSIS-MIB", [
      ['fans', 'nsFanTable', 'Classes::PaloAlto::Component::EnvironmentalSubsystem::Fan'],
      ['power', 'nsPowerTable', 'Classes::PaloAlto::Component::EnvironmentalSubsystem::Power'],
      ['slots', 'nsSlotTable', 'Classes::PaloAlto::Component::EnvironmentalSubsystem::Slot'],
      ['temperatures', 'nsTemperatureTable', 'Classes::PaloAlto::Component::EnvironmentalSubsystem::Temperature'],
  ]);
}

sub check {
  my $self = shift;
  foreach (@{$self->{fans}}, @{$self->{power}}, @{$self->{slots}}, @{$self->{temperatures}}) {
    $_->check();
  }
}


package Classes::PaloAlto::Component::EnvironmentalSubsystem::Fan;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf "fan %s (%s) is %s",
      $self->{nsFanId}, $self->{nsFanDesc}, $self->{nsFanStatus});
  if ($self->{nsFanStatus} eq "notInstalled") {
  } elsif ($self->{nsFanStatus} eq "good") {
    $self->add_ok();
  } elsif ($self->{nsFanStatus} eq "fail") {
    $self->add_warning();
  }
}


package Classes::PaloAlto::Component::EnvironmentalSubsystem::Power;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf "power supply %s (%s) is %s",
      $self->{nsPowerId}, $self->{nsPowerDesc}, $self->{nsPowerStatus});
  if ($self->{nsPowerStatus} eq "good") {
    $self->add_ok();
  } elsif ($self->{nsPowerStatus} eq "fail") {
    $self->add_warning();
  }
}


package Classes::PaloAlto::Component::EnvironmentalSubsystem::Slot;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf "%s slot %s (%s) is %s",
      $self->{nsSlotType}, $self->{nsSlotId}, $self->{nsSlotSN}, $self->{nsSlotStatus});
  if ($self->{nsSlotStatus} eq "good") {
    $self->add_ok();
  } elsif ($self->{nsSlotStatus} eq "fail") {
    $self->add_warning();
  }
}


package Classes::PaloAlto::Component::EnvironmentalSubsystem::Temperature;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;

sub check {
  my $self = shift;
  $self->add_info(sprintf "temperature %s is %sC",
      $self->{nsTemperatureId}, $self->{nsTemperatureDesc}, $self->{nsTemperatureCur});
  $self->add_ok();
  $self->add_perfdata(
      label => 'temp_'.$self->{nsTemperatureId},
      value => $self->{nsTemperatureCur},
  );
}

package Classes::PaloAlto::Component::HaSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub init {
  my $self = shift;
  if ($self->mode =~ /device::ha::role/) {
  $self->get_snmp_objects('PAN-COMMON-MIB', (qw(
      panSysHAMode panSysHAState panSysHAPeerState)));
    if (! $self->opts->role()) {
      $self->opts->override_opt('role', 'active');
    }
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking ha');
  $self->add_info(sprintf 'ha mode is %s, state is %s, peer state is %s', 
      $self->{panSysHAMode},
      $self->{panSysHAState},
      $self->{panSysHAPeerState},
  );
  if ($self->{panSysHAMode} eq 'disabled') {
    $self->add_message(
        defined $self->opts->mitigation() ? $self->opts->mitigation() : WARNING,
        'ha was not started');
  } else {
    if ($self->{panSysHAState} ne $self->opts->role()) {
      $self->add_message(
          defined $self->opts->mitigation() ? $self->opts->mitigation() : WARNING,
          $self->{info});
      $self->add_message(
          defined $self->opts->mitigation() ? $self->opts->mitigation() : WARNING,
          sprintf "expected role %s", $self->opts->role())
    } else {
      $self->add_ok();
    }
  }
}

package Classes::PaloAlto;
our @ISA = qw(Classes::Device);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::ENTITYSENSORMIB::Component::EnvironmentalSubsystem");
    $self->analyze_and_check_environmental_subsystem("Classes::HOSTRESOURCESMIB::Component::EnvironmentalSubsystem");
    # entity-state-mib gibts u.u. auch
    # The entStateTable will have entries for Line Cards, Fan Trays and Power supplies. Since these entities only apply to chassis systems, only PA-7000 series devices will support this MIB.
    # gibts aber erst, wenn einer die entwicklung zahlt. bis dahin ist es
    # mir scheissegal, wenn euch die firewalls abkacken, ihr freibiervisagen
  } elsif ($self->mode =~ /device::hardware::load/) {
    # CPU util on management plane
    # Utilization of CPUs on dataplane that are used for system functions
    $self->analyze_and_check_cpu_subsystem("Classes::HOSTRESOURCESMIB::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::HOSTRESOURCESMIB::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::ha::/) {
    $self->analyze_and_check_ha_subsystem("Classes::PaloAlto::Component::HaSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Bluecoat;
our @ISA = qw(Classes::Device);
use strict;


sub init {
  my $self = shift;
  if ($self->{productname} =~ /Blue.*Coat.*(SG\d+|SGOS)/i) {
    # product ProxySG  Blue Coat SG600
    # iso.3.6.1.4.1.3417.2.11.1.3.0 = STRING: "Version: SGOS 5.5.8.1, Release id: 78642 Proxy Edition"
    bless $self, 'Classes::SGOS';
    $self->debug('using Classes::SGOS');
  } elsif ($self->{productname} =~ /Blue.*Coat.*AV\d+/i) {
    # product Blue Coat AV510 Series, ProxyAV Version: 3.5.1.1, Release id: 111017
    bless $self, 'Classes::AVOS';
    $self->debug('using Classes::AVOS');
  }
  if (ref($self) ne "Classes::Bluecoat") {
    $self->init();
  } else {
    $self->no_such_mode();
  }
}

package Classes::Cumulus;
our @ISA = qw(Classes::Device);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    #$self->get_snmp_tables("UCD-DISKIO-MIB", [
    #    ['diskios', 'diskIOTable', 'Monitoring::GLPlugin::SNMP::TableItem'],
    #]);
    $self->override_opt('warningx', { 'temp_.*' => '68'});
    $self->analyze_and_check_environmental_subsystem("Classes::LMSENSORSMIB::Component::EnvironmentalSubsystem");
    $self->{components}->{environmental_subsystem} = Classes::HOSTRESOURCESMIB::Component::EnvironmentalSubsystem->new();
    @{$self->{components}->{environmental_subsystem}->{disk_subsystem}->{storages}} = grep {
      $_->{hrStorageDescr} ne '/mnt/root-ro';
    } @{$self->{components}->{environmental_subsystem}->{disk_subsystem}->{storages}} ;
    $self->{components}->{environmental_subsystem}->check();
    $self->{components}->{environmental_subsystem}->dump()
        if $self->opts->verbose >= 2;
  } elsif ($self->mode =~ /device::hardware::load/) {
    $self->analyze_and_check_cpu_subsystem("Classes::HOSTRESOURCESMIB::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::HOSTRESOURCESMIB::Component::MemSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Netgear;
our @ISA = qw(Classes::Device);
use strict;


sub init {
  my $self = shift;
  # netgear does not publish mibs
  $self->no_such_mode();
}

package Classes::Lantronix;
our @ISA = qw(Classes::Device);
use strict;
package Classes::Lantronix::SLS;
our @ISA = qw(Classes::Lantronix);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->analyze_and_check_environmental_subsystem("Classes::Lantronix::SLS::Component::EnvironmentalSubsystem");
  } else {
    $self->no_such_mode();
  }
}


package Classes::Lantronix::SLS::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_objects('LARA-MIB', qw(checkHostPower));
}

sub check {
  my $self = shift;
  $self->add_info(sprintf 'host power status is %s', $self->{checkHostPower});
  if ($self->{checkHostPower} eq 'hasPower') {
    $self->add_ok();
  } else {
    $self->add_critical();
  }
}

package Classes::Arista::Component::EnvironmentalSubsystem;
our @ISA = qw(Monitoring::GLPlugin::SNMP::Item);
use strict;

sub init {
  my $self = shift;
  $self->get_snmp_tables('ENTITY-MIB', [
    ['entities', 'entPhysicalTable',
      'Classes::Arista::Component::EnvironmentalSubsystem::Entity',
      undef,
      ['entPhysicalClass', 'entPhysicalDescr', 'entPhysicalName']
    ],
  ]);
  $self->get_snmp_tables('ENTITY-SENSOR-MIB', [
    ['sensorvalues', 'entPhySensorTable', 'Monitoring::GLPlugin::SNMP::TableItem'],
  ]);
  $self->get_snmp_tables('ENTITY-STATE-MIB', [
    ['sensorstates', 'entStateTable', 'Monitoring::GLPlugin::SNMP::TableItem'],
  ]);
  $self->get_snmp_tables('ARISTA-ENTITY-SENSOR-MIB', [
    ['sensorthresholds', 'aristaEntSensorThresholdTable', 'Monitoring::GLPlugin::SNMP::TableItem'],
  ]);
  $self->merge_tables("entities", "sensorvalues", "sensorstates", "sensorthresholds");
  foreach (@{$self->{entities}}) {
    $_->rebless();
    $_->finish() if $_->can('finish');
  }
  @{$self->{entities}} = grep {
    ! exists $_->{valid} || $_->{valid};
  } @{$self->{entities}};
}

package Classes::Arista::Component::EnvironmentalSubsystem::Entity;
our @ISA = qw(Monitoring::GLPlugin::SNMP::TableItem);
use strict;


sub rebless {
  my $self = shift;
  bless $self,
      'Classes::Arista::Component::EnvironmentalSubsystem::Chassis' if
      $self->{entPhysicalClass} eq 'chassis';
  bless $self,
      'Classes::Arista::Component::EnvironmentalSubsystem::Container' if
      $self->{entPhysicalClass} eq 'container';
  bless $self,
      'Classes::Arista::Component::EnvironmentalSubsystem::Fan' if
      $self->{entPhysicalClass} eq 'fan';
  bless $self,
      'Classes::Arista::Component::EnvironmentalSubsystem::Module' if
      $self->{entPhysicalClass} eq 'module';
  bless $self,
      'Classes::Arista::Component::EnvironmentalSubsystem::Port' if
      $self->{entPhysicalClass} eq 'port';
  bless $self,
      'Classes::Arista::Component::EnvironmentalSubsystem::Powersupply' if
      $self->{entPhysicalClass} eq 'powerSupply';
  bless $self,
      'Classes::Arista::Component::EnvironmentalSubsystem::Sensor' if
      $self->{entPhysicalClass} eq 'sensor';
}

sub check_state {
  my $self = shift;
  $self->add_info(sprintf "%s is %s (admin %s, oper %s)",
      $self->{entPhysicalDescr}, $self->{entStateUsage},
      $self->{entStateAdmin}, $self->{entStateOper});
  if ($self->{entStateAdmin} eq "unlocked") {
    if ($self->{entStateOper} eq "enabled") {
      if ($self->{entStateUsage} eq "idle") {
        $self->add_ok();
      } elsif ($self->{entStateUsage} eq "active") {
        $self->add_ok();
      } elsif ($self->{entStateUsage} eq "busy") {
        $self->add_warning();
      } else {
        $self->add_unknown();
      }
    } elsif ($self->{entStateOper} eq "disabled") {
      $self->add_critical();
    } else {
      $self->add_unknown();
    }
  } else {
    $self->add_ok(); # admin disabled, ignore
  }
}

package Classes::Arista::Component::EnvironmentalSubsystem::Chassis;
our @ISA = qw(Classes::Arista::Component::EnvironmentalSubsystem::Entity);
use strict;

package Classes::Arista::Component::EnvironmentalSubsystem::Container;
our @ISA = qw(Classes::Arista::Component::EnvironmentalSubsystem::Entity);
use strict;

package Classes::Arista::Component::EnvironmentalSubsystem::Fan;
our @ISA = qw(Classes::Arista::Component::EnvironmentalSubsystem::Entity);
use strict;

sub check {
  my $self = shift;
  $self->check_state();
}

package Classes::Arista::Component::EnvironmentalSubsystem::Module;
our @ISA = qw(Classes::Arista::Component::EnvironmentalSubsystem::Entity);
use strict;

package Classes::Arista::Component::EnvironmentalSubsystem::Port;
our @ISA = qw(Classes::Arista::Component::EnvironmentalSubsystem::Entity);
use strict;

package Classes::Arista::Component::EnvironmentalSubsystem::Powersupply;
our @ISA = qw(Classes::Arista::Component::EnvironmentalSubsystem::Entity);
use strict;

sub check {
  my $self = shift;
  $self->check_state();
}

package Classes::Arista::Component::EnvironmentalSubsystem::Sensor;
our @ISA = qw(Classes::Arista::Component::EnvironmentalSubsystem::Entity);
use strict;

sub finish {
  my $self = shift;
  
  $self->{valid} = ($self->{entPhySensorValue} == -1000000000 || $self->{entPhySensorValue} == 1000000000)
      ? 0 : 1;
  foreach (qw(entPhySensorValue
      aristaEntSensorThresholdLowWarning aristaEntSensorThresholdHighWarning
      aristaEntSensorThresholdLowCritical aristaEntSensorThresholdHighCritical)) {
    delete $self->{$_} if defined $self->{$_} && $_ ne 'entPhySensorValue' &&
        ($self->{$_} == -1000000000 || $self->{$_} == 1000000000);
    if ($self->{entPhySensorPrecision} && $self->{$_}) {
      $self->{$_} /= 10 ** $self->{entPhySensorPrecision};
    }
  }
}

sub check {
  my $self = shift;
  $self->check_state();
  my ($warn, $crit) = (undef, undef);
  if ($self->{aristaEntSensorStatusDescr} =~ /no thresholds/i) {
  } else {
    $warn =
        ($self->{aristaEntSensorThresholdLowWarning} ?
        $self->{aristaEntSensorThresholdLowWarning} : '').':'.
        ($self->{aristaEntSensorThresholdHighWarning} ?
        $self->{aristaEntSensorThresholdHighWarning} : '');
    $crit =
        ($self->{aristaEntSensorThresholdLowCritical} ?
        $self->{aristaEntSensorThresholdLowCritical} : '').':'.
        ($self->{aristaEntSensorThresholdHighCritical} ?
        $self->{aristaEntSensorThresholdHighCritical} : '');
  }
  $self->add_thresholds(metric => $self->{entPhysicalDescr}.'_'.$self->{entPhySensorUnitsDisplay},
      warning => $warn, critical => $crit);
  $self->add_perfdata(
      label => $self->{entPhysicalDescr}.'_'.$self->{entPhySensorUnitsDisplay},
      value => $self->{entPhySensorValue},
      warning => $warn, critical => $crit,
  );
}


package Classes::Arista;
our @ISA = qw(Classes::Device);
use strict;

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hardware::health/) {
    $self->mult_snmp_max_msg_size(10);
    $self->analyze_and_check_environmental_subsystem("Classes::Arista::Component::EnvironmentalSubsystem");
    if (! $self->check_messages()) {
      $self->clear_messages(0);
      $self->add_ok("environmental hardware working fine");
    }
  } elsif ($self->mode =~ /device::hardware::load/) {
    # CPU util on management plane
    # Utilization of CPUs on dataplane that are used for system functions
    $self->analyze_and_check_cpu_subsystem("Classes::HOSTRESOURCESMIB::Component::CpuSubsystem");
  } elsif ($self->mode =~ /device::hardware::memory/) {
    $self->analyze_and_check_mem_subsystem("Classes::HOSTRESOURCESMIB::Component::MemSubsystem");
  } elsif ($self->mode =~ /device::ha::/) {
    $self->analyze_and_check_ha_subsystem("Classes::Arista::Component::HaSubsystem");
  } else {
    $self->no_such_mode();
  }
}

package Classes::Device;
our @ISA = qw(Monitoring::GLPlugin::SNMP Monitoring::GLPlugin::UPNP);
use strict;

sub classify {
  my $self = shift;
  if (! ($self->opts->hostname || $self->opts->snmpwalk)) {
    $self->add_unknown('either specify a hostname or a snmpwalk file');
  } else {
    if ($self->opts->servertype && $self->opts->servertype eq 'linuxlocal') {
    } elsif ($self->opts->servertype && $self->opts->servertype eq 'windowslocal') {
      eval "require DBD::WMI";
      if ($@) {
        $self->add_unknown("module DBD::WMI is not installed");
      }
    } elsif ($self->opts->servertype && $self->opts->servertype eq 'solarislocal') {
      eval "require Sun::Solaris::Kstat";
      if ($@) {
        $self->add_unknown("module Sun::Solaris::Kstat is not installed");
      }
    } elsif ($self->opts->port && $self->opts->port == 49000) {
      $self->{productname} = 'upnp';
      $self->check_upnp_and_model();
    } else {
      $self->check_snmp_and_model();
    }
    if ($self->opts->servertype) {
      $self->{productname} = $self->opts->servertype;
      $self->{productname} = 'cisco' if $self->opts->servertype eq 'cisco';
      $self->{productname} = 'huawei' if $self->opts->servertype eq 'huawei';
      $self->{productname} = 'hh3c' if $self->opts->servertype eq 'hh3c';
      $self->{productname} = 'hp' if $self->opts->servertype eq 'hp';
      $self->{productname} = 'brocade' if $self->opts->servertype eq 'brocade';
      $self->{productname} = 'netscreen' if $self->opts->servertype eq 'netscreen';
      $self->{productname} = 'linuxlocal' if $self->opts->servertype eq 'linuxlocal';
      $self->{productname} = 'procurve' if $self->opts->servertype eq 'procurve';
      $self->{productname} = 'bluecoat' if $self->opts->servertype eq 'bluecoat';
      $self->{productname} = 'checkpoint' if $self->opts->servertype eq 'checkpoint';
      $self->{productname} = 'clavister' if $self->opts->servertype eq 'clavister';
      $self->{productname} = 'ifmib' if $self->opts->servertype eq 'ifmib';
    }
    if ($self->opts->mode eq "uptime") {
      return $self;
    } elsif (! $self->check_messages()) {
      if ($self->opts->verbose && $self->opts->verbose) {
        printf "I am a %s\n", $self->{productname};
      }
      if ($self->opts->mode =~ /^my-/) {
        $self->load_my_extension();
      } elsif ($self->{productname} =~ /upnp/i) {
        bless $self, 'Classes::UPNP';
        $self->debug('using Classes::UPNP');
      } elsif ($self->{productname} =~ /FRITZ/i) {
        bless $self, 'Classes::UPNP::AVM';
        $self->debug('using Classes::UPNP::AVM');
      } elsif ($self->{productname} =~ /linuxlocal/i) {
        bless $self, 'Server::LinuxLocal';
        $self->debug('using Server::LinuxLocal');
      } elsif ($self->{productname} =~ /windowslocal/i) {
        bless $self, 'Server::WindowsLocal';
        $self->debug('using Server::WindowsLocal');
      } elsif ($self->{productname} =~ /solarislocal/i) {
        bless $self, 'Server::SolarisLocal';
        $self->debug('using Server::SolarisLocal');
      } elsif ($self->{productname} =~ /Cisco/i) {
        bless $self, 'Classes::Cisco';
        $self->debug('using Classes::Cisco');
      } elsif ($self->{productname} =~ /fujitsu intelligent blade panel 30\/12/i) {
        bless $self, 'Classes::Cisco';
        $self->debug('using Classes::Cisco');
      } elsif ($self->{productname} =~ /UCOS /i) {
        bless $self, 'Classes::Cisco';
        $self->debug('using Classes::Cisco');
      } elsif ($self->{productname} =~ /Nortel/i) {
        bless $self, 'Classes::Nortel';
        $self->debug('using Classes::Nortel');
      } elsif ($self->implements_mib('SYNOPTICS-ROOT-MIB')) {
        bless $self, 'Classes::Nortel';
        $self->debug('using Classes::Nortel');
      } elsif ($self->{productname} =~ /AT-GS/i) {
        bless $self, 'Classes::AlliedTelesyn';
        $self->debug('using Classes::AlliedTelesyn');
      } elsif ($self->{productname} =~ /AT-\d+GB/i) {
        bless $self, 'Classes::AlliedTelesyn';
        $self->debug('using Classes::AlliedTelesyn');
      } elsif ($self->{productname} =~ /Allied Telesyn Ethernet Switch/i) {
        bless $self, 'Classes::AlliedTelesyn';
        $self->debug('using Classes::AlliedTelesyn');
      } elsif ($self->{productname} =~ /Linux cumulus/i) {
        bless $self, 'Classes::Cumulus';
        $self->debug('using Classes::Cumulus');
      } elsif ($self->{productname} =~ /DS_4100/i) {
        bless $self, 'Classes::Brocade';
        $self->debug('using Classes::Brocade');
      } elsif ($self->{productname} =~ /Connectrix DS_4900B/i) {
        bless $self, 'Classes::Brocade';
        $self->debug('using Classes::Brocade');
      } elsif ($self->{productname} =~ /EMC\s*DS.*4700M/i) {
        bless $self, 'Classes::Brocade';
        $self->debug('using Classes::Brocade');
      } elsif ($self->{productname} =~ /EMC\s*DS-24M2/i) {
        bless $self, 'Classes::Brocade';
        $self->debug('using Classes::Brocade');
      } elsif ($self->{productname} =~ /Brocade/i) {
        bless $self, 'Classes::Brocade';
        $self->debug('using Classes::Brocade');
      } elsif ($self->{productname} =~ /Fibre Channel Switch/i) {
        bless $self, 'Classes::Brocade';
        $self->debug('using Classes::Brocade');
      } elsif ($self->{productname} =~ /Juniper.*MAG\-\d+/i) {
        # Juniper Networks,Inc,MAG-4610,7.2R10
        bless $self, 'Classes::Juniper';
        $self->debug('using Classes::Juniper');
      } elsif ($self->{productname} =~ /Juniper.*MAG\-SM\d+/i) {
        # Juniper Networks,Inc,MAG-SMx60,7.4R8
        bless $self, 'Classes::Juniper::IVE';
        $self->debug('using Classes::Juniper::IVE');
      } elsif ($self->implements_mib('JUNIPER-MIB')) {
        bless $self, 'Classes::Juniper::SRX';
        $self->debug('using Classes::Juniper::SRX');
      } elsif ($self->{productname} =~ /NetScreen/i) {
        bless $self, 'Classes::Juniper';
        $self->debug('using Classes::Juniper');
      } elsif ($self->{productname} =~ /Pulse Secure.*LLC/i) {
        # Pulse Secure,LLC,Pulse Policy Secure,IC-6500,5.2R7.1 (build 37645)
        bless $self, 'Classes::Juniper::IVE';
        $self->debug('using Classes::Juniper::IVE');
      } elsif ($self->implements_mib('NETGEAR-MIB')) {
        $self->debug('using Classes::Netgear');
        bless $self, 'Classes::Netgear';
      } elsif ($self->{productname} =~ /^(GS|FS)/i) {
        bless $self, 'Classes::Juniper';
        $self->debug('using Classes::Juniper');
      } elsif ($self->implements_mib('NETSCREEN-PRODUCTS-MIB')) {
        $self->debug('using Classes::Juniper::NetScreen');
        bless $self, 'Classes::Juniper::NetScreen';
      } elsif ($self->implements_mib('PAN-PRODUCTS-MIB')) {
        $self->debug('using Classes::PaloAlto');
        bless $self, 'Classes::PaloAlto';
      } elsif ($self->{productname} =~ /SecureOS/i) {
        bless $self, 'Classes::SecureOS';
        $self->debug('using Classes::SecureOS');
      } elsif ($self->{productname} =~ /Linux.*((el6.f5.x86_64)|(el5.1.0.f5app)) .*/i) {
        bless $self, 'Classes::F5';
        $self->debug('using Classes::F5');
      } elsif ($self->{productname} =~ /(H?H3C|HP Comware)/i) {
        bless $self, 'Classes::HH3C';
        $self->debug('using Classes::HH3C');
      } elsif ($self->{productname} =~ /(Huawei)/i) {
        bless $self, 'Classes::Huawei';
        $self->debug('using Classes::Huawei');
      } elsif ($self->{productname} =~ /Procurve/i ||
          ($self->implements_mib('HP-ICF-CHASSIS-MIB') &&
          $self->implements_mib('NETSWITCH-MIB'))) {
        bless $self, 'Classes::HP::Procurve';
        $self->debug('using Classes::HP::Procurve');
      } elsif ($self->{productname} =~ /((cpx86_64)|(Check\s*Point)|(IPSO)|(Linux.*\dcp) )/i || $self->implements_mib('CHECKPOINT-MIB')) {
        bless $self, 'Classes::CheckPoint';
        $self->debug('using Classes::CheckPoint');
      } elsif ($self->{productname} =~ /Clavister/i) {
        bless $self, 'Classes::Clavister';
        $self->debug('using Classes::Clavister');
      } elsif ($self->{productname} =~ /Blue\s*Coat/i) {
        bless $self, 'Classes::Bluecoat';
        $self->debug('using Classes::Bluecoat');
      } elsif ($self->{productname} =~ /Foundry/i) {
        bless $self, 'Classes::Foundry';
        $self->debug('using Classes::Foundry');
      } elsif ($self->{productname} =~ /IronWare/i) {
        # although there can be a 
        # Brocade Communications Systems, Inc. FWS648, IronWare Version 07.1....
        bless $self, 'Classes::Foundry';
        $self->debug('using Classes::Foundry');
      } elsif ($self->{productname} =~ /Linux Stingray/i) {
        bless $self, 'Classes::HOSTRESOURCESMIB';
        $self->debug('using Classes::HOSTRESOURCESMIB');
      } elsif ($self->{productname} =~ /Fortinet|Fortigate/i) {
        bless $self, 'Classes::Fortigate';
        $self->debug('using Classes::Fortigate');
      } elsif ($self->implements_mib('ALCATEL-IND1-BASE-MIB')) {
        bless $self, 'Classes::Alcatel';
        $self->debug('using Classes::Alcatel');
      } elsif ($self->implements_mib('ONEACCESS-SYS-MIB')) {
        bless $self, 'Classes::OneOS';
        $self->debug('using Classes::OneOS');
      } elsif ($self->{productname} eq "ifmib") {
        bless $self, 'Classes::Generic';
        $self->debug('using Classes::Generic');
      } elsif ($self->implements_mib('SW-MIB')) {
        bless $self, 'Classes::Brocade';
        $self->debug('using Classes::Brocade');
      } elsif ($self->{sysobjectid} =~ /1\.3\.6\.1\.4\.1\.9\./) {
        bless $self, 'Classes::Cisco';
        $self->debug('using Classes::Cisco');
      } elsif ($self->{productname} =~ /Arista.*EOS.*/) {
        bless $self, 'Classes::Arista';
        $self->debug('using Classes::Arista');
      } elsif ($self->{sysobjectid} =~ /1\.3\.6\.1\.4\.1\.272\./) {
        bless $self, 'Classes::Bintec::Bibo';
        $self->debug('using Classes::Bintec::Bibo');
      } elsif ($self->{productname} =~ /^Linux/i) {
        bless $self, 'Classes::Server::Linux';
        $self->debug('using Classes::Server::Linux');
      } else {
        $self->map_oid_to_class('1.3.6.1.4.1.12532.252.5.1',
            'Classes::Juniper::IVE');
        $self->map_oid_to_class('1.3.6.1.4.1.9.1.1348',
            'Classes::CiscoCCM');
        $self->map_oid_to_class('1.3.6.1.4.1.9.1.746',
            'Classes::CiscoCCM');
        $self->map_oid_to_class('1.3.6.1.4.1.244.1.11',
            'Classes::Lantronix::SLS');
        if (my $class = $self->discover_suitable_class()) {
          bless $self, $class;
          $self->debug('using '.$class);
        } else {
          bless $self, 'Classes::Generic';
          $self->debug('using Classes::Generic');
        }
      }
    }
  }
  return $self;
}


package Classes::Generic;
our @ISA = qw(Classes::Device);
use strict;


sub init {
  my $self = shift;
  if ($self->mode =~ /device::interfaces::aggregation::availability/) {
    $self->analyze_and_check_aggregation_subsystem("Classes::IFMIB::Component::LinkAggregation");
  } elsif ($self->mode =~ /device::interfaces/) {
    $self->analyze_and_check_interface_subsystem("Classes::IFMIB::Component::InterfaceSubsystem");
  } elsif ($self->mode =~ /device::routes/) {
    if ($self->implements_mib('IP-FORWARD-MIB')) {
      $self->analyze_and_check_interface_subsystem("Classes::IPFORWARDMIB::Component::RoutingSubsystem");
    } else {
      $self->analyze_and_check_interface_subsystem("Classes::IPMIB::Component::RoutingSubsystem");
    }
  } elsif ($self->mode =~ /device::bgp/) {
    $self->analyze_and_check_bgp_subsystem("Classes::BGP::Component::PeerSubsystem");
  } elsif ($self->mode =~ /device::ospf/) {
    bless $self, "Classes::OSPF";
    #$self->analyze_and_check_ospf_subsystem("Classes::OSPF");
    $self->init();
  } elsif ($self->mode =~ /device::vrrp/) {
    $self->analyze_and_check_vrrp_subsystem("Classes::VRRPMIB::Component::VRRPSubsystem");
  } else {
    bless $self, 'Monitoring::GLPlugin::SNMP';
    $self->no_such_mode();
  }
}

package main;
# /usr/bin/perl -w

use strict;
no warnings qw(once);

if ( ! grep /BEGIN/, keys %Monitoring::GLPlugin::) {
  eval {
    require Monitoring::GLPlugin;
    require Monitoring::GLPlugin::SNMP;
    require Monitoring::GLPlugin::UPNP;
  };
  if ($@) {
    printf "UNKNOWN - module Monitoring::GLPlugin was not found. Either build a standalone version of this plugin or set PERL5LIB\n";
    printf "%s\n", $@;
    exit 3;
  }
}

my $plugin = Classes::Device->new(
    shortname => '',
    usage => 'Usage: %s [ -v|--verbose ] [ -t <timeout> ] '.
        '--mode <what-to-do> '.
        '--hostname <network-component> --community <snmp-community>'.
        '  ...]',
    version => '$Revision: 5.12 $',
    blurb => 'This plugin checks various parameters of network components ',
    url => 'http://labs.consol.de/nagios/check_nwc_health',
    timeout => 60,
    plugin => $Monitoring::GLPlugin::pluginname,
);
$plugin->add_mode(
    internal => 'device::hardware::health',
    spec => 'hardware-health',
    alias => undef,
    help => 'Check the status of environmental equipment (fans, temperatures, power)',
);
$plugin->add_mode(
    internal => 'device::hardware::load',
    spec => 'cpu-load',
    alias => ['cpu-usage'],
    help => 'Check the CPU load of the device',
);
$plugin->add_mode(
    internal => 'device::hardware::memory',
    spec => 'memory-usage',
    alias => undef,
    help => 'Check the memory usage of the device',
);
$plugin->add_mode(
    internal => 'device::disk::usage',
    spec => 'disk-usage',
    alias => undef,
    help => 'Check the disk usage of the device',
);
$plugin->add_mode(
    internal => 'device::interfaces::usage',
    spec => 'interface-usage',
    alias => undef,
    help => 'Check the utilization of interfaces',
);
$plugin->add_mode(
    internal => 'device::interfaces::errors',
    spec => 'interface-errors',
    alias => undef,
    help => 'Check the error-rate of interfaces (without discards)',
);
$plugin->add_mode(
    internal => 'device::interfaces::discards',
    spec => 'interface-discards',
    alias => undef,
    help => 'Check the discard-rate of interfaces',
);
$plugin->add_mode(
    internal => 'device::interfaces::operstatus',
    spec => 'interface-status',
    alias => undef,
    help => 'Check the status of interfaces (oper/admin)',
);
$plugin->add_mode(
    internal => 'device::interfaces::complete',
    spec => 'interface-health',
    alias => undef,
    help => 'Check everything interface',
);
$plugin->add_mode(
    internal => 'device::interfaces::nat::sessions::count',
    spec => 'interface-nat-count-sessions',
    alias => undef,
    help => 'Count the number of nat sessions',
);
$plugin->add_mode(
    internal => 'device::interfaces::nat::rejects',
    spec => 'interface-nat-rejects',
    alias => undef,
    help => 'Count the number of nat sessions rejected due to lack of resources',
);
$plugin->add_mode(
    internal => 'device::interfaces::list',
    spec => 'list-interfaces',
    alias => undef,
    help => 'Show the interfaces of the device and update the name cache',
);
$plugin->add_mode(
    internal => 'device::interfaces::listdetail',
    spec => 'list-interfaces-detail',
    alias => undef,
    help => 'Show the interfaces of the device and some details',
);
$plugin->add_mode(
    internal => 'device::interfaces::availability',
    spec => 'interface-availability',
    alias => undef,
    help => 'Show the availability (oper != up) of interfaces',
);
$plugin->add_mode(
    internal => 'device::interfaces::aggregation::availability',
    spec => 'link-aggregation-availability',
    alias => undef,
    help => 'Check the percentage of up interfaces in a link aggregation',
);
$plugin->add_mode(
    internal => 'device::interfaces::etherstats',
    spec => 'interface-etherstats',
    alias => undef,
    help => 'Check the ethernet statistics of interfaces',
);
$plugin->add_mode(
    internal => 'device::routes::list',
    spec => 'list-routes',
    alias => undef,
    help => 'Show the configured routes',
    help => 'Check the percentage of up interfaces in a link aggregation',
);
$plugin->add_mode(
    internal => 'device::routes::exists',
    spec => 'route-exists',
    alias => undef,
    help => 'Check if a route exists. (--name is the dest, --name2 check also the next hop)',
);
$plugin->add_mode(
    internal => 'device::routes::count',
    spec => 'count-routes',
    alias => undef,
    help => 'Count the routes. (--name is the dest, --name2 is the hop)',
);
$plugin->add_mode(
    internal => 'device::vpn::status',
    spec => 'vpn-status',
    alias => undef,
    help => 'Check the status of vpns (up/down)',
);
$plugin->add_mode(
    internal => 'device::shinken::interface',
    spec => 'create-shinken-service',
    alias => undef,
    help => 'Create a Shinken service definition',
);
$plugin->add_mode(
    internal => 'device::hsrp::state',
    spec => 'hsrp-state',
    alias => undef,
    help => 'Check the state in a HSRP group',
);
$plugin->add_mode(
    internal => 'device::hsrp::failover',
    spec => 'hsrp-failover',
    alias => undef,
    help => 'Check if a HSRP group\'s nodes have changed their roles',
);
$plugin->add_mode(
    internal => 'device::hsrp::list',
    spec => 'list-hsrp-groups',
    alias => undef,
    help => 'Show the HSRP groups configured on this device',
);
$plugin->add_mode(
    internal => 'device::vrrp::state',
    spec => 'vrrp-state',
    alias => undef,
    help => 'Check the state in a VRRP group',
);
$plugin->add_mode(
    internal => 'device::vrrp::failover',
    spec => 'vrrp-failover',
    alias => undef,
    help => 'Check if a VRRP group\'s nodes have changed their roles',
);
$plugin->add_mode(
    internal => 'device::vrrp::list',
    spec => 'list-vrrp-groups',
    alias => undef,
    help => 'Show the VRRP groups configured on this device',
);
$plugin->add_mode(
    internal => 'device::bgp::peer::status',
    spec => 'bgp-peer-status',
    alias => undef,
    help => 'Check status of BGP peers',
);
$plugin->add_mode(
    internal => 'device::bgp::peer::count',
    spec => 'count-bgp-peers',
    alias => undef,
    help => 'Count the number of BGP peers',
);
$plugin->add_mode(
    internal => 'device::bgp::peer::watch',
    spec => 'watch-bgp-peers',
    alias => undef,
    help => 'Watch BGP peers appear and disappear',
);
$plugin->add_mode(
    internal => 'device::bgp::peer::list',
    spec => 'list-bgp-peers',
    alias => undef,
    help => 'Show BGP peers known to this device',
);
$plugin->add_mode(
    internal => 'device::bgp::prefix::count',
    spec => 'count-bgp-prefixes',
    alias => undef,
    help => 'Count the number of BGP prefixes (for specific peer with --name)',
);
$plugin->add_mode(
    internal => 'device::ospf::neighbor::status',
    spec => 'ospf-neighbor-status',
    alias => undef,
    help => 'Check status of OSPF neighbors',
);
$plugin->add_mode(
    internal => 'device::ospf::neighbor::list',
    spec => 'list-ospf-neighbors',
    alias => undef,
    help => 'Show OSPF neighbors',
);
$plugin->add_mode(
    internal => 'device::ha::role',
    spec => 'ha-role',
    alias => undef,
    help => 'Check the role in a ha group',
);
$plugin->add_mode(
    internal => 'device::svn::status',
    spec => 'svn-status',
    alias => undef,
    help => 'Check the status of the svn subsystem',
);
$plugin->add_mode(
    internal => 'device::mngmt::status',
    spec => 'mngmt-status',
    alias => undef,
    help => 'Check the status of the management subsystem',
);
$plugin->add_mode(
    internal => 'device::process::status',
    spec => 'process-status',
    alias => undef,
    help => 'Check the status of the running processes'
);
$plugin->add_mode(
    internal => 'device::fw::policy::installed',
    spec => 'fw-policy',
    alias => undef,
    help => 'Check the installed firewall policy',
);
$plugin->add_mode(
    internal => 'device::fw::policy::connections',
    spec => 'fw-connections',
    alias => undef,
    help => 'Check the number of firewall policy connections',
);
$plugin->add_mode(
    internal => 'device::lb::session::usage',
    spec => 'session-usage',
    alias => undef,
    help => 'Check the session limits of a load balancer',
);
$plugin->add_mode(
    internal => 'device::security',
    spec => 'security-status',
    alias => undef,
    help => 'Check if there are security-relevant incidents',
);
$plugin->add_mode(
    internal => 'device::lb::pool::completeness',
    spec => 'pool-completeness',
    alias => undef,
    help => 'Check the members of a load balancer pool',
);
$plugin->add_mode(
    internal => 'device::lb::pool::connections',
    spec => 'pool-connections',
    alias => undef,
    help => 'Check the number of connections of a load balancer pool',
);
$plugin->add_mode(
    internal => 'device::lb::pool::complections',
    spec => 'pool-complections',
    alias => undef,
    help => 'Check the members and connections of a load balancer pool',
);
$plugin->add_mode(
    internal => 'device::lb::pool::list',
    spec => 'list-pools',
    alias => undef,
    help => 'List load balancer pools',
);
$plugin->add_mode(
    internal => 'device::licenses::validate',
    spec => 'check-licenses',
    alias => undef,
    help => 'Check the installed licences/keys',
);
$plugin->add_mode(
    internal => 'device::users::count',
    spec => 'count-users',
    alias => ['count-sessions', 'count-connections'],
    help => 'Count the (connected) users/sessions',
);
$plugin->add_mode(
    internal => 'device::config::status',
    spec => 'check-config',
    alias => undef,
    help => 'Check the status of configs (cisco, unsaved config changes)',
);
$plugin->add_mode(
    internal => 'device::connections::check',
    spec => 'check-connections',
    alias => undef,
    help => 'Check the quality of connections',
);
$plugin->add_mode(
    internal => 'device::connections::count',
    spec => 'count-connections',
    alias => ['count-connections-client', 'count-connections-server'],
    help => 'Check the number of connections (-client, -server is possible)',
);
$plugin->add_mode(
    internal => 'device::cisco::fex::watch',
    spec => 'watch-fexes',
    alias => undef,
    help => 'Check if FEXes appear and disappear (use --lookup)',
);
$plugin->add_mode(
    internal => 'device::hardware::chassis::health',
    spec => 'chassis-hardware-health',
    alias => undef,
    help => 'Check the status of stacked switches and chassis, count modules and ports',
);
$plugin->add_mode(
    internal => 'device::wlan::aps::status',
    spec => 'accesspoint-status',
    alias => undef,
    help => 'Check the status of access points',
);
$plugin->add_mode(
    internal => 'device::wlan::aps::count',
    spec => 'count-accesspoints',
    alias => undef,
    help => 'Check if the number of access points is within a certain range',
);
$plugin->add_mode(
    internal => 'device::wlan::aps::watch',
    spec => 'watch-accesspoints',
    alias => undef,
    help => 'Check if access points appear and disappear (use --lookup)',
);
$plugin->add_mode(
    internal => 'device::wlan::aps::clients',
    spec => 'count-accesspoint-clients',
    alias => undef,
    help => 'Check if the number of access point clients is within a certain range',
);
$plugin->add_mode(
    internal => 'device::wlan::aps::list',
    spec => 'list-accesspoints',
    alias => undef,
    help => 'List access points managed by this device',
);
$plugin->add_mode(
    internal => 'device::phone::cmstatus',
    spec => 'phone-cm-status',
    alias => undef,
    help => 'Check if the callmanager is up',
);
$plugin->add_mode(
    internal => 'device::phone::status',
    spec => 'phone-status',
    alias => undef,
    help => 'Check the number of registered/unregistered/rejected phones',
);
$plugin->add_mode(
    internal => 'device::smarthome::device::list',
    spec => 'list-smart-home-devices',
    alias => undef,
    help => 'List Fritz!DECT 200 plugs managed by this device',
);
$plugin->add_mode(
    internal => 'device::smarthome::device::status',
    spec => 'smart-home-device-status',
    alias => undef,
    help => 'Check if a Fritz!DECT 200 plug is on (or Comet DECT)',
);
$plugin->add_mode(
    internal => 'device::smarthome::device::energy',
    spec => 'smart-home-device-energy',
    alias => undef,
    help => 'Show the current power consumption of a Fritz!DECT 200 plug',
);
$plugin->add_mode(
    internal => 'device::smarthome::device::consumption',
    spec => 'smart-home-device-consumption',
    alias => undef,
    help => 'Show the cumulated power consumption of a Fritz!DECT 200 plug',
);
$plugin->add_mode(
    internal => 'device::smarthome::device::temperature',
    spec => 'smart-home-device-temperature',
    alias => undef,
    help => 'Show the temperature measured by a Fritz! compatible device',
);
$plugin->add_snmp_modes();
$plugin->add_snmp_args();
$plugin->add_default_args();
$plugin->mod_arg("name",
    help => "--name
   The name of an interface (ifDescr) or pool or ...",
);
$plugin->add_arg(
    spec => 'alias=s',
    help => "--alias
   The alias name of a 64bit-interface (ifAlias)",
    required => 0,
);
$plugin->add_arg(
    spec => 'ifspeedin=i',
    help => "--ifspeedin
   Override the ifspeed oid of an interface (only inbound)",
    required => 0,
);
$plugin->add_arg(
    spec => 'ifspeedout=i',
    help => "--ifspeedout
   Override the ifspeed oid of an interface (only outbound)",
    required => 0,
);
$plugin->add_arg(
    spec => 'ifspeed=i',
    help => "--ifspeed
   Override the ifspeed oid of an interface",
    required => 0,
);
$plugin->add_arg(
    spec => 'role=s',
    help => "--role
   The role of this device in a hsrp group (active/standby/listen)",
    required => 0,
);

$plugin->getopts();
$plugin->classify();
$plugin->validate_args();

if (! $plugin->check_messages()) {
  $plugin->init();
  if (! $plugin->check_messages()) {
    $plugin->add_ok($plugin->get_summary())
        if $plugin->get_summary();
    $plugin->add_ok($plugin->get_extendedinfo(" "))
        if $plugin->get_extendedinfo();
  }
} elsif ($plugin->opts->snmpwalk && $plugin->opts->offline) {
  ;
} else {
  $plugin->add_critical('wrong device');
}
my ($code, $message) = $plugin->opts->multiline ?
    $plugin->check_messages(join => "\n", join_all => ', ') :
    $plugin->check_messages(join => ', ', join_all => ', ');
$message .= sprintf "\n%s\n", $plugin->get_info("\n")
    if $plugin->opts->verbose >= 1;

$plugin->nagios_exit($code, $message);
